<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>nltk.sem.logic &mdash; NLTK 3.0 documentation</title>
    
    <link rel="stylesheet" href="../../../_static/agogo.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '3.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <link rel="top" title="NLTK 3.0 documentation" href="../../../index.html" />
    <link rel="up" title="Module code" href="../../index.html" /> 
  </head>
  <body>
    <div class="header-wrapper">
      <div class="header">
        <div class="headertitle"><a
          href="../../../index.html">NLTK 3.0 documentation</a></div>
        <div class="rel">
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a>
        </div>
       </div>
    </div>

    <div class="content-wrapper">
      <div class="content">
        <div class="document">
            
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for nltk.sem.logic</h1><div class="highlight"><pre>
<span class="c"># Natural Language Toolkit: Logic</span>
<span class="c">#</span>
<span class="c"># Author: Dan Garrette &lt;dhgarrette@gmail.com&gt;</span>
<span class="c">#</span>
<span class="c"># Copyright (C) 2001-2014 NLTK Project</span>
<span class="c"># URL: &lt;http://nltk.org&gt;</span>
<span class="c"># For license information, see LICENSE.TXT</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">A version of first order predicate logic, built on</span>
<span class="sd">top of the typed lambda calculus.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">unicode_literals</span>

<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">operator</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="nb">reduce</span>

<span class="kn">from</span> <span class="nn">nltk.internals</span> <span class="kn">import</span> <span class="n">Counter</span>
<span class="kn">from</span> <span class="nn">nltk.compat</span> <span class="kn">import</span> <span class="p">(</span><span class="n">total_ordering</span><span class="p">,</span> <span class="n">string_types</span><span class="p">,</span>
                         <span class="n">python_2_unicode_compatible</span><span class="p">)</span>

<span class="n">APP</span> <span class="o">=</span> <span class="s">&#39;APP&#39;</span>

<span class="n">_counter</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">()</span>

<div class="viewcode-block" id="Tokens"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.Tokens">[docs]</a><span class="k">class</span> <span class="nc">Tokens</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="n">LAMBDA</span> <span class="o">=</span> <span class="s">&#39;</span><span class="se">\\</span><span class="s">&#39;</span><span class="p">;</span>     <span class="n">LAMBDA_LIST</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;</span><span class="se">\\</span><span class="s">&#39;</span><span class="p">]</span>

    <span class="c">#Quantifiers</span>
    <span class="n">EXISTS</span> <span class="o">=</span> <span class="s">&#39;exists&#39;</span><span class="p">;</span> <span class="n">EXISTS_LIST</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;some&#39;</span><span class="p">,</span> <span class="s">&#39;exists&#39;</span><span class="p">,</span> <span class="s">&#39;exist&#39;</span><span class="p">]</span>
    <span class="n">ALL</span> <span class="o">=</span> <span class="s">&#39;all&#39;</span><span class="p">;</span>       <span class="n">ALL_LIST</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;all&#39;</span><span class="p">,</span> <span class="s">&#39;forall&#39;</span><span class="p">]</span>

    <span class="c">#Punctuation</span>
    <span class="n">DOT</span> <span class="o">=</span> <span class="s">&#39;.&#39;</span>
    <span class="n">OPEN</span> <span class="o">=</span> <span class="s">&#39;(&#39;</span>
    <span class="n">CLOSE</span> <span class="o">=</span> <span class="s">&#39;)&#39;</span>
    <span class="n">COMMA</span> <span class="o">=</span> <span class="s">&#39;,&#39;</span>

    <span class="c">#Operations</span>
    <span class="n">NOT</span> <span class="o">=</span> <span class="s">&#39;-&#39;</span><span class="p">;</span>         <span class="n">NOT_LIST</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;not&#39;</span><span class="p">,</span> <span class="s">&#39;-&#39;</span><span class="p">,</span> <span class="s">&#39;!&#39;</span><span class="p">]</span>
    <span class="n">AND</span> <span class="o">=</span> <span class="s">&#39;&amp;&#39;</span><span class="p">;</span>         <span class="n">AND_LIST</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;and&#39;</span><span class="p">,</span> <span class="s">&#39;&amp;&#39;</span><span class="p">,</span> <span class="s">&#39;^&#39;</span><span class="p">]</span>
    <span class="n">OR</span> <span class="o">=</span> <span class="s">&#39;|&#39;</span><span class="p">;</span>          <span class="n">OR_LIST</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;or&#39;</span><span class="p">,</span> <span class="s">&#39;|&#39;</span><span class="p">]</span>
    <span class="n">IMP</span> <span class="o">=</span> <span class="s">&#39;-&gt;&#39;</span><span class="p">;</span>        <span class="n">IMP_LIST</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;implies&#39;</span><span class="p">,</span> <span class="s">&#39;-&gt;&#39;</span><span class="p">,</span> <span class="s">&#39;=&gt;&#39;</span><span class="p">]</span>
    <span class="n">IFF</span> <span class="o">=</span> <span class="s">&#39;&lt;-&gt;&#39;</span><span class="p">;</span>       <span class="n">IFF_LIST</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;iff&#39;</span><span class="p">,</span> <span class="s">&#39;&lt;-&gt;&#39;</span><span class="p">,</span> <span class="s">&#39;&lt;=&gt;&#39;</span><span class="p">]</span>
    <span class="n">EQ</span> <span class="o">=</span> <span class="s">&#39;=&#39;</span><span class="p">;</span>          <span class="n">EQ_LIST</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;=&#39;</span><span class="p">,</span> <span class="s">&#39;==&#39;</span><span class="p">]</span>
    <span class="n">NEQ</span> <span class="o">=</span> <span class="s">&#39;!=&#39;</span><span class="p">;</span>        <span class="n">NEQ_LIST</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;!=&#39;</span><span class="p">]</span>

    <span class="c">#Collections of tokens</span>
    <span class="n">BINOPS</span> <span class="o">=</span> <span class="n">AND_LIST</span> <span class="o">+</span> <span class="n">OR_LIST</span> <span class="o">+</span> <span class="n">IMP_LIST</span> <span class="o">+</span> <span class="n">IFF_LIST</span>
    <span class="n">QUANTS</span> <span class="o">=</span> <span class="n">EXISTS_LIST</span> <span class="o">+</span> <span class="n">ALL_LIST</span>
    <span class="n">PUNCT</span> <span class="o">=</span> <span class="p">[</span><span class="n">DOT</span><span class="p">,</span> <span class="n">OPEN</span><span class="p">,</span> <span class="n">CLOSE</span><span class="p">,</span> <span class="n">COMMA</span><span class="p">]</span>

    <span class="n">TOKENS</span> <span class="o">=</span> <span class="n">BINOPS</span> <span class="o">+</span> <span class="n">EQ_LIST</span> <span class="o">+</span> <span class="n">NEQ_LIST</span> <span class="o">+</span> <span class="n">QUANTS</span> <span class="o">+</span> <span class="n">LAMBDA_LIST</span> <span class="o">+</span> <span class="n">PUNCT</span> <span class="o">+</span> <span class="n">NOT_LIST</span>

    <span class="c">#Special</span>
    <span class="n">SYMBOLS</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">TOKENS</span> <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s">r&#39;^[-</span><span class="se">\\</span><span class="s">.(),!&amp;^|&gt;=&lt;]*$&#39;</span><span class="p">,</span> <span class="n">x</span><span class="p">)]</span>

</div>
<div class="viewcode-block" id="boolean_ops"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.boolean_ops">[docs]</a><span class="k">def</span> <span class="nf">boolean_ops</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Boolean operators</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">names</span> <span class="o">=</span>  <span class="p">[</span><span class="s">&quot;negation&quot;</span><span class="p">,</span> <span class="s">&quot;conjunction&quot;</span><span class="p">,</span> <span class="s">&quot;disjunction&quot;</span><span class="p">,</span> <span class="s">&quot;implication&quot;</span><span class="p">,</span> <span class="s">&quot;equivalence&quot;</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="p">[</span><span class="n">Tokens</span><span class="o">.</span><span class="n">NOT</span><span class="p">,</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">AND</span><span class="p">,</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">OR</span><span class="p">,</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">IMP</span><span class="p">,</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">IFF</span><span class="p">]):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%-15s</span><span class="se">\t</span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span>  <span class="n">pair</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="equality_preds"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.equality_preds">[docs]</a><span class="k">def</span> <span class="nf">equality_preds</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Equality predicates</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">names</span> <span class="o">=</span>  <span class="p">[</span><span class="s">&quot;equality&quot;</span><span class="p">,</span> <span class="s">&quot;inequality&quot;</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="p">[</span><span class="n">Tokens</span><span class="o">.</span><span class="n">EQ</span><span class="p">,</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">NEQ</span><span class="p">]):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%-15s</span><span class="se">\t</span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span>  <span class="n">pair</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="binding_ops"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.binding_ops">[docs]</a><span class="k">def</span> <span class="nf">binding_ops</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Binding operators</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">names</span> <span class="o">=</span>  <span class="p">[</span><span class="s">&quot;existential&quot;</span><span class="p">,</span> <span class="s">&quot;universal&quot;</span><span class="p">,</span> <span class="s">&quot;lambda&quot;</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="p">[</span><span class="n">Tokens</span><span class="o">.</span><span class="n">EXISTS</span><span class="p">,</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">ALL</span><span class="p">,</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">LAMBDA</span><span class="p">]):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%-15s</span><span class="se">\t</span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span>  <span class="n">pair</span><span class="p">)</span>

</div>
<span class="nd">@python_2_unicode_compatible</span>
<span class="k">class</span> <span class="nc">_LogicParser</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A lambda calculus expression parser.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">type_check</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param type_check: bool should type checking be performed?</span>
<span class="sd">        to their types.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">type_check</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_currentIndex</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_buffer</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type_check</span> <span class="o">=</span> <span class="n">type_check</span>

        <span class="sd">&quot;&quot;&quot;A list of tuples of quote characters.  The 4-tuple is comprised</span>
<span class="sd">        of the start character, the end character, the escape character, and</span>
<span class="sd">        a boolean indicating whether the quotes should be included in the</span>
<span class="sd">        result. Quotes are used to signify that a token should be treated as</span>
<span class="sd">        atomic, ignoring any special characters within the token.  The escape</span>
<span class="sd">        character allows the quote end character to be used within the quote.</span>
<span class="sd">        If True, the boolean indicates that the final token should contain the</span>
<span class="sd">        quote and escape characters.</span>
<span class="sd">        This method exists to be overridden&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">quote_chars</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">operator_precedence</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
                           <span class="p">[(</span><span class="n">x</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">LAMBDA_LIST</span><span class="p">]</span>             <span class="o">+</span> \
                           <span class="p">[(</span><span class="n">x</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">NOT_LIST</span><span class="p">]</span>                <span class="o">+</span> \
                           <span class="p">[(</span><span class="n">APP</span><span class="p">,</span><span class="mi">3</span><span class="p">)]</span>                                       <span class="o">+</span> \
                           <span class="p">[(</span><span class="n">x</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">EQ_LIST</span><span class="o">+</span><span class="n">Tokens</span><span class="o">.</span><span class="n">NEQ_LIST</span><span class="p">]</span> <span class="o">+</span> \
                           <span class="p">[(</span><span class="n">x</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">QUANTS</span><span class="p">]</span>                  <span class="o">+</span> \
                           <span class="p">[(</span><span class="n">x</span><span class="p">,</span><span class="mi">6</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">AND_LIST</span><span class="p">]</span>                <span class="o">+</span> \
                           <span class="p">[(</span><span class="n">x</span><span class="p">,</span><span class="mi">7</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">OR_LIST</span><span class="p">]</span>                 <span class="o">+</span> \
                           <span class="p">[(</span><span class="n">x</span><span class="p">,</span><span class="mi">8</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">IMP_LIST</span><span class="p">]</span>                <span class="o">+</span> \
                           <span class="p">[(</span><span class="n">x</span><span class="p">,</span><span class="mi">9</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">IFF_LIST</span><span class="p">]</span>                <span class="o">+</span> \
                           <span class="p">[(</span><span class="bp">None</span><span class="p">,</span><span class="mi">10</span><span class="p">)])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">right_associated_operations</span> <span class="o">=</span> <span class="p">[</span><span class="n">APP</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">signature</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parse the expression.</span>

<span class="sd">        :param data: str for the input to be parsed</span>
<span class="sd">        :param signature: ``dict&lt;str, str&gt;`` that maps variable names to type</span>
<span class="sd">        strings</span>
<span class="sd">        :returns: a parsed Expression</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_currentIndex</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_buffer</span><span class="p">,</span> <span class="n">mapping</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_Expression</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">inRange</span><span class="p">(</span><span class="mi">0</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">UnexpectedTokenException</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_currentIndex</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
        <span class="k">except</span> <span class="n">LogicalExpressionException</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s">&#39;</span><span class="si">%s</span><span class="se">\n</span><span class="si">%s</span><span class="se">\n</span><span class="si">%s</span><span class="s">^&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="s">&#39; &#39;</span><span class="o">*</span><span class="n">mapping</span><span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">index</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">raise</span> <span class="n">LogicalExpressionException</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">type_check</span><span class="p">:</span>
            <span class="n">result</span><span class="o">.</span><span class="n">typecheck</span><span class="p">(</span><span class="n">signature</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Split the data into tokens&quot;&quot;&quot;</span>
        <span class="n">out</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">mapping</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">tokenTrie</span> <span class="o">=</span> <span class="n">StringTrie</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_all_symbols</span><span class="p">())</span>
        <span class="n">token</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
        <span class="n">data_idx</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">token_start_idx</span> <span class="o">=</span> <span class="n">data_idx</span>
        <span class="k">while</span> <span class="n">data_idx</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
            <span class="n">cur_data_idx</span> <span class="o">=</span> <span class="n">data_idx</span>
            <span class="n">quoted_token</span><span class="p">,</span> <span class="n">data_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_quoted_token</span><span class="p">(</span><span class="n">data_idx</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">quoted_token</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">token</span><span class="p">:</span>
                    <span class="n">token_start_idx</span> <span class="o">=</span> <span class="n">cur_data_idx</span>
                <span class="n">token</span> <span class="o">+=</span> <span class="n">quoted_token</span>
                <span class="k">continue</span>

            <span class="n">st</span> <span class="o">=</span> <span class="n">tokenTrie</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">data_idx</span><span class="p">]</span>
            <span class="n">symbol</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
            <span class="k">while</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">st</span><span class="p">:</span>
                <span class="n">symbol</span> <span class="o">+=</span> <span class="n">c</span>
                <span class="n">st</span> <span class="o">=</span> <span class="n">st</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">-</span><span class="n">data_idx</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">symbol</span><span class="p">):</span>
                    <span class="n">c</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">data_idx</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="n">symbol</span><span class="p">)]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">break</span>
            <span class="k">if</span> <span class="n">StringTrie</span><span class="o">.</span><span class="n">LEAF</span> <span class="ow">in</span> <span class="n">st</span><span class="p">:</span>
                <span class="c">#token is a complete symbol</span>
                <span class="k">if</span> <span class="n">token</span><span class="p">:</span>
                    <span class="n">mapping</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">out</span><span class="p">)]</span> <span class="o">=</span> <span class="n">token_start_idx</span>
                    <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">token</span><span class="p">)</span>
                    <span class="n">token</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
                <span class="n">mapping</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">out</span><span class="p">)]</span> <span class="o">=</span> <span class="n">data_idx</span>
                <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">symbol</span><span class="p">)</span>
                <span class="n">data_idx</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">symbol</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="n">data_idx</span><span class="p">]</span> <span class="ow">in</span> <span class="s">&#39; </span><span class="se">\t\n</span><span class="s">&#39;</span><span class="p">:</span> <span class="c">#any whitespace</span>
                    <span class="k">if</span> <span class="n">token</span><span class="p">:</span>
                        <span class="n">mapping</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">out</span><span class="p">)]</span> <span class="o">=</span> <span class="n">token_start_idx</span>
                        <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">token</span><span class="p">)</span>
                        <span class="n">token</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">token</span><span class="p">:</span>
                        <span class="n">token_start_idx</span> <span class="o">=</span> <span class="n">data_idx</span>
                    <span class="n">token</span> <span class="o">+=</span> <span class="n">data</span><span class="p">[</span><span class="n">data_idx</span><span class="p">]</span>
                <span class="n">data_idx</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">token</span><span class="p">:</span>
            <span class="n">mapping</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">out</span><span class="p">)]</span> <span class="o">=</span> <span class="n">token_start_idx</span>
            <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">token</span><span class="p">)</span>
        <span class="n">mapping</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">out</span><span class="p">)]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">mapping</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">out</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span>
        <span class="k">return</span> <span class="n">out</span><span class="p">,</span> <span class="n">mapping</span>

    <span class="k">def</span> <span class="nf">process_quoted_token</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_idx</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="n">token</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">data_idx</span><span class="p">]</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">data_idx</span>
        <span class="k">for</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">escape</span><span class="p">,</span> <span class="n">incl_quotes</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">quote_chars</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">c</span> <span class="o">==</span> <span class="n">start</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">incl_quotes</span><span class="p">:</span>
                    <span class="n">token</span> <span class="o">+=</span> <span class="n">c</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">while</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">end</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">escape</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">incl_quotes</span><span class="p">:</span>
                            <span class="n">token</span> <span class="o">+=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">==</span> <span class="n">i</span><span class="p">:</span> <span class="c">#if there are no more chars</span>
                            <span class="k">raise</span> <span class="n">LogicalExpressionException</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="s">&quot;End of input reached.  &quot;</span>
                                    <span class="s">&quot;Escape character [</span><span class="si">%s</span><span class="s">] found at end.&quot;</span>
                                    <span class="o">%</span> <span class="n">escape</span><span class="p">)</span>
                        <span class="n">token</span> <span class="o">+=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">token</span> <span class="o">+=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">==</span> <span class="n">i</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="n">LogicalExpressionException</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="s">&quot;End of input reached.  &quot;</span>
                                             <span class="s">&quot;Expected: [</span><span class="si">%s</span><span class="s">]&quot;</span> <span class="o">%</span> <span class="n">end</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">incl_quotes</span><span class="p">:</span>
                    <span class="n">token</span> <span class="o">+=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">token</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">LogicalExpressionException</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="s">&#39;Empty quoted token found&#39;</span><span class="p">)</span>
                <span class="k">break</span>
        <span class="k">return</span> <span class="n">token</span><span class="p">,</span> <span class="n">i</span>

    <span class="k">def</span> <span class="nf">get_all_symbols</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This method exists to be overridden&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">SYMBOLS</span>

    <span class="k">def</span> <span class="nf">inRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">location</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return TRUE if the given location is within the buffer&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_currentIndex</span><span class="o">+</span><span class="n">location</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_buffer</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">token</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">location</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the next waiting token.  If a location is given, then</span>
<span class="sd">        return the token at currentIndex+location without advancing</span>
<span class="sd">        currentIndex; setting it gives lookahead/lookback capability.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">location</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">tok</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_buffer</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_currentIndex</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_currentIndex</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">tok</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_buffer</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_currentIndex</span><span class="o">+</span><span class="n">location</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">tok</span>
        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ExpectedMoreTokensException</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_currentIndex</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">isvariable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tok</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">tok</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">TOKENS</span>

    <span class="k">def</span> <span class="nf">parse_Expression</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Parse the next complete expression from the stream and return it.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">tok</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span><span class="p">()</span>
        <span class="k">except</span> <span class="n">ExpectedMoreTokensException</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ExpectedMoreTokensException</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_currentIndex</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="s">&#39;Expression expected.&#39;</span><span class="p">)</span>

        <span class="n">accum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">handle</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="n">context</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">accum</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">UnexpectedTokenException</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_currentIndex</span><span class="p">,</span> <span class="n">tok</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="s">&#39;Expression expected.&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">attempt_adjuncts</span><span class="p">(</span><span class="n">accum</span><span class="p">,</span> <span class="n">context</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">handle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tok</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This method is intended to be overridden for logics that</span>
<span class="sd">        use different operators or expressions&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">isvariable</span><span class="p">(</span><span class="n">tok</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">handle_variable</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="n">context</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">tok</span> <span class="ow">in</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">NOT_LIST</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">handle_negation</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="n">context</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">tok</span> <span class="ow">in</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">LAMBDA_LIST</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">handle_lambda</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="n">context</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">tok</span> <span class="ow">in</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">QUANTS</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">handle_quant</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="n">context</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">tok</span> <span class="o">==</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">OPEN</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">handle_open</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="n">context</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">attempt_adjuncts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expression</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
        <span class="n">cur_idx</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">while</span> <span class="n">cur_idx</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_currentIndex</span><span class="p">:</span> <span class="c">#while adjuncts are added</span>
            <span class="n">cur_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_currentIndex</span>
            <span class="n">expression</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">attempt_EqualityExpression</span><span class="p">(</span><span class="n">expression</span><span class="p">,</span> <span class="n">context</span><span class="p">)</span>
            <span class="n">expression</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">attempt_ApplicationExpression</span><span class="p">(</span><span class="n">expression</span><span class="p">,</span> <span class="n">context</span><span class="p">)</span>
            <span class="n">expression</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">attempt_BooleanExpression</span><span class="p">(</span><span class="n">expression</span><span class="p">,</span> <span class="n">context</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">expression</span>

    <span class="k">def</span> <span class="nf">handle_negation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tok</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_NegatedExpression</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parse_Expression</span><span class="p">(</span><span class="n">Tokens</span><span class="o">.</span><span class="n">NOT</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">make_NegatedExpression</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expression</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">NegatedExpression</span><span class="p">(</span><span class="n">expression</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">handle_variable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tok</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
        <span class="c">#It&#39;s either: 1) a predicate expression: sees(x,y)</span>
        <span class="c">#             2) an application expression: P(x)</span>
        <span class="c">#             3) a solo variable: john OR x</span>
        <span class="n">accum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_VariableExpression</span><span class="p">(</span><span class="n">tok</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">inRange</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">OPEN</span><span class="p">:</span>
            <span class="c">#The predicate has arguments</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">accum</span><span class="p">,</span> <span class="n">FunctionVariableExpression</span><span class="p">)</span> <span class="ow">and</span> \
               <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">accum</span><span class="p">,</span> <span class="n">ConstantExpression</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">LogicalExpressionException</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_currentIndex</span><span class="p">,</span>
                                     <span class="s">&quot;&#39;</span><span class="si">%s</span><span class="s">&#39; is an illegal predicate name.  &quot;</span>
                                     <span class="s">&quot;Individual variables may not be used as &quot;</span>
                                     <span class="s">&quot;predicates.&quot;</span> <span class="o">%</span> <span class="n">tok</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">token</span><span class="p">()</span> <span class="c">#swallow the Open Paren</span>

            <span class="c">#curry the arguments</span>
            <span class="n">accum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_ApplicationExpression</span><span class="p">(</span><span class="n">accum</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_Expression</span><span class="p">(</span><span class="n">APP</span><span class="p">))</span>
            <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">inRange</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">COMMA</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">token</span><span class="p">()</span> <span class="c">#swallow the comma</span>
                <span class="n">accum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_ApplicationExpression</span><span class="p">(</span><span class="n">accum</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_Expression</span><span class="p">(</span><span class="n">APP</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">assertNextToken</span><span class="p">(</span><span class="n">Tokens</span><span class="o">.</span><span class="n">CLOSE</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">accum</span>

    <span class="k">def</span> <span class="nf">get_next_token_variable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">description</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">tok</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span><span class="p">()</span>
        <span class="k">except</span> <span class="n">ExpectedMoreTokensException</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ExpectedMoreTokensException</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="s">&#39;Variable expected.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">make_VariableExpression</span><span class="p">(</span><span class="n">tok</span><span class="p">),</span> <span class="n">ConstantExpression</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">LogicalExpressionException</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_currentIndex</span><span class="p">,</span>
                                 <span class="s">&quot;&#39;</span><span class="si">%s</span><span class="s">&#39; is an illegal variable name.  &quot;</span>
                                 <span class="s">&quot;Constants may not be </span><span class="si">%s</span><span class="s">.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="n">description</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">Variable</span><span class="p">(</span><span class="n">tok</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">handle_lambda</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tok</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
        <span class="c"># Expression is a lambda expression</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">inRange</span><span class="p">(</span><span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">ExpectedMoreTokensException</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_currentIndex</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span>
                                              <span class="n">message</span><span class="o">=</span><span class="s">&quot;Variable and Expression expected following lambda operator.&quot;</span><span class="p">)</span>
        <span class="nb">vars</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">get_next_token_variable</span><span class="p">(</span><span class="s">&#39;abstracted&#39;</span><span class="p">)]</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">inRange</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">token</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">DOT</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">inRange</span><span class="p">(</span><span class="mi">1</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="n">ExpectedMoreTokensException</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_currentIndex</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="s">&quot;Expression expected.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">isvariable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">token</span><span class="p">(</span><span class="mi">0</span><span class="p">)):</span>
                <span class="k">break</span>
            <span class="c"># Support expressions like: \x y.M == \x.\y.M</span>
            <span class="nb">vars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_next_token_variable</span><span class="p">(</span><span class="s">&#39;abstracted&#39;</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">inRange</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">DOT</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">token</span><span class="p">()</span> <span class="c">#swallow the dot</span>

        <span class="n">accum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_Expression</span><span class="p">(</span><span class="n">tok</span><span class="p">)</span>
        <span class="k">while</span> <span class="nb">vars</span><span class="p">:</span>
            <span class="n">accum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_LambdaExpression</span><span class="p">(</span><span class="nb">vars</span><span class="o">.</span><span class="n">pop</span><span class="p">(),</span> <span class="n">accum</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">accum</span>

    <span class="k">def</span> <span class="nf">handle_quant</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tok</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
        <span class="c"># Expression is a quantified expression: some x.M</span>
        <span class="n">factory</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_QuantifiedExpression_factory</span><span class="p">(</span><span class="n">tok</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">inRange</span><span class="p">(</span><span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">ExpectedMoreTokensException</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_currentIndex</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span>
                                              <span class="n">message</span><span class="o">=</span><span class="s">&quot;Variable and Expression expected following quantifier &#39;</span><span class="si">%s</span><span class="s">&#39;.&quot;</span> <span class="o">%</span> <span class="n">tok</span><span class="p">)</span>
        <span class="nb">vars</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">get_next_token_variable</span><span class="p">(</span><span class="s">&#39;quantified&#39;</span><span class="p">)]</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">inRange</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">token</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">DOT</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">inRange</span><span class="p">(</span><span class="mi">1</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="n">ExpectedMoreTokensException</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_currentIndex</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="s">&quot;Expression expected.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">isvariable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">token</span><span class="p">(</span><span class="mi">0</span><span class="p">)):</span>
                <span class="k">break</span>
            <span class="c"># Support expressions like: some x y.M == some x.some y.M</span>
            <span class="nb">vars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_next_token_variable</span><span class="p">(</span><span class="s">&#39;quantified&#39;</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">inRange</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">DOT</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">token</span><span class="p">()</span> <span class="c">#swallow the dot</span>

        <span class="n">accum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_Expression</span><span class="p">(</span><span class="n">tok</span><span class="p">)</span>
        <span class="k">while</span> <span class="nb">vars</span><span class="p">:</span>
            <span class="n">accum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_QuanifiedExpression</span><span class="p">(</span><span class="n">factory</span><span class="p">,</span> <span class="nb">vars</span><span class="o">.</span><span class="n">pop</span><span class="p">(),</span> <span class="n">accum</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">accum</span>

    <span class="k">def</span> <span class="nf">get_QuantifiedExpression_factory</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tok</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This method serves as a hook for other logic parsers that</span>
<span class="sd">        have different quantifiers&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">tok</span> <span class="ow">in</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">EXISTS_LIST</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ExistsExpression</span>
        <span class="k">elif</span> <span class="n">tok</span> <span class="ow">in</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">ALL_LIST</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">AllExpression</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">assertToken</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">QUANTS</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">make_QuanifiedExpression</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">factory</span><span class="p">,</span> <span class="n">variable</span><span class="p">,</span> <span class="n">term</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">factory</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">term</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">handle_open</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tok</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
        <span class="c">#Expression is in parens</span>
        <span class="n">accum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_Expression</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertNextToken</span><span class="p">(</span><span class="n">Tokens</span><span class="o">.</span><span class="n">CLOSE</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">accum</span>

    <span class="k">def</span> <span class="nf">attempt_EqualityExpression</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expression</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Attempt to make an equality expression.  If the next token is an</span>
<span class="sd">        equality operator, then an EqualityExpression will be returned.</span>
<span class="sd">        Otherwise, the parameter will be returned.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">inRange</span><span class="p">(</span><span class="mi">0</span><span class="p">):</span>
            <span class="n">tok</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">tok</span> <span class="ow">in</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">EQ_LIST</span> <span class="o">+</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">NEQ_LIST</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_priority</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">token</span><span class="p">()</span> <span class="c">#swallow the &quot;=&quot; or &quot;!=&quot;</span>
                <span class="n">expression</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_EqualityExpression</span><span class="p">(</span><span class="n">expression</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_Expression</span><span class="p">(</span><span class="n">tok</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">tok</span> <span class="ow">in</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">NEQ_LIST</span><span class="p">:</span>
                    <span class="n">expression</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_NegatedExpression</span><span class="p">(</span><span class="n">expression</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">expression</span>

    <span class="k">def</span> <span class="nf">make_EqualityExpression</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">first</span><span class="p">,</span> <span class="n">second</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This method serves as a hook for other logic parsers that</span>
<span class="sd">        have different equality expression classes&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">EqualityExpression</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">second</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">attempt_BooleanExpression</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expression</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Attempt to make a boolean expression.  If the next token is a boolean</span>
<span class="sd">        operator, then a BooleanExpression will be returned.  Otherwise, the</span>
<span class="sd">        parameter will be returned.&quot;&quot;&quot;</span>
        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">inRange</span><span class="p">(</span><span class="mi">0</span><span class="p">):</span>
            <span class="n">tok</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">factory</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_BooleanExpression_factory</span><span class="p">(</span><span class="n">tok</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">factory</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_priority</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">token</span><span class="p">()</span> <span class="c">#swallow the operator</span>
                <span class="n">expression</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_BooleanExpression</span><span class="p">(</span><span class="n">factory</span><span class="p">,</span> <span class="n">expression</span><span class="p">,</span>
                                                         <span class="bp">self</span><span class="o">.</span><span class="n">parse_Expression</span><span class="p">(</span><span class="n">tok</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="k">return</span> <span class="n">expression</span>

    <span class="k">def</span> <span class="nf">get_BooleanExpression_factory</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tok</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This method serves as a hook for other logic parsers that</span>
<span class="sd">        have different boolean operators&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">tok</span> <span class="ow">in</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">AND_LIST</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">AndExpression</span>
        <span class="k">elif</span> <span class="n">tok</span> <span class="ow">in</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">OR_LIST</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">OrExpression</span>
        <span class="k">elif</span> <span class="n">tok</span> <span class="ow">in</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">IMP_LIST</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ImpExpression</span>
        <span class="k">elif</span> <span class="n">tok</span> <span class="ow">in</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">IFF_LIST</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">IffExpression</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">make_BooleanExpression</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">factory</span><span class="p">,</span> <span class="n">first</span><span class="p">,</span> <span class="n">second</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">factory</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">second</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">attempt_ApplicationExpression</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expression</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Attempt to make an application expression.  The next tokens are</span>
<span class="sd">        a list of arguments in parens, then the argument expression is a</span>
<span class="sd">        function being applied to the arguments.  Otherwise, return the</span>
<span class="sd">        argument expression.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_priority</span><span class="p">(</span><span class="n">APP</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">inRange</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">OPEN</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expression</span><span class="p">,</span> <span class="n">LambdaExpression</span><span class="p">)</span> <span class="ow">and</span> \
                   <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expression</span><span class="p">,</span> <span class="n">ApplicationExpression</span><span class="p">)</span> <span class="ow">and</span> \
                   <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expression</span><span class="p">,</span> <span class="n">FunctionVariableExpression</span><span class="p">)</span> <span class="ow">and</span> \
                   <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expression</span><span class="p">,</span> <span class="n">ConstantExpression</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="n">LogicalExpressionException</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_currentIndex</span><span class="p">,</span>
                                         <span class="p">(</span><span class="s">&quot;The function &#39;</span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">expression</span><span class="p">)</span> <span class="o">+</span>
                                         <span class="s">&quot;&#39; is not a Lambda Expression, an &quot;</span>
                                         <span class="s">&quot;Application Expression, or a &quot;</span>
                                         <span class="s">&quot;functional predicate, so it may &quot;</span>
                                         <span class="s">&quot;not take arguments.&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">token</span><span class="p">()</span> <span class="c">#swallow then open paren</span>
                <span class="c">#curry the arguments</span>
                <span class="n">accum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_ApplicationExpression</span><span class="p">(</span><span class="n">expression</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_Expression</span><span class="p">(</span><span class="n">APP</span><span class="p">))</span>
                <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">inRange</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">COMMA</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">token</span><span class="p">()</span> <span class="c">#swallow the comma</span>
                    <span class="n">accum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_ApplicationExpression</span><span class="p">(</span><span class="n">accum</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_Expression</span><span class="p">(</span><span class="n">APP</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">assertNextToken</span><span class="p">(</span><span class="n">Tokens</span><span class="o">.</span><span class="n">CLOSE</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">accum</span>
        <span class="k">return</span> <span class="n">expression</span>

    <span class="k">def</span> <span class="nf">make_ApplicationExpression</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">argument</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">ApplicationExpression</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="n">argument</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">make_VariableExpression</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">VariableExpression</span><span class="p">(</span><span class="n">Variable</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">make_LambdaExpression</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variable</span><span class="p">,</span> <span class="n">term</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">LambdaExpression</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">term</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">has_priority</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">operation</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">operator_precedence</span><span class="p">[</span><span class="n">operation</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">operator_precedence</span><span class="p">[</span><span class="n">context</span><span class="p">]</span> <span class="ow">or</span> \
               <span class="p">(</span><span class="n">operation</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">right_associated_operations</span> <span class="ow">and</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">operator_precedence</span><span class="p">[</span><span class="n">operation</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">operator_precedence</span><span class="p">[</span><span class="n">context</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">assertNextToken</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expected</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">tok</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span><span class="p">()</span>
        <span class="k">except</span> <span class="n">ExpectedMoreTokensException</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ExpectedMoreTokensException</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="s">&quot;Expected token &#39;</span><span class="si">%s</span><span class="s">&#39;.&quot;</span> <span class="o">%</span> <span class="n">expected</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expected</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">tok</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">expected</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">UnexpectedTokenException</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_currentIndex</span><span class="p">,</span> <span class="n">tok</span><span class="p">,</span> <span class="n">expected</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">tok</span> <span class="o">!=</span> <span class="n">expected</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">UnexpectedTokenException</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_currentIndex</span><span class="p">,</span> <span class="n">tok</span><span class="p">,</span> <span class="n">expected</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">assertToken</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tok</span><span class="p">,</span> <span class="n">expected</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expected</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">tok</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">expected</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">UnexpectedTokenException</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_currentIndex</span><span class="p">,</span> <span class="n">tok</span><span class="p">,</span> <span class="n">expected</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">tok</span> <span class="o">!=</span> <span class="n">expected</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">UnexpectedTokenException</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_currentIndex</span><span class="p">,</span> <span class="n">tok</span><span class="p">,</span> <span class="n">expected</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">inRange</span><span class="p">(</span><span class="mi">0</span><span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s">&#39;Next token: &#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s">&#39;No more tokens&#39;</span>
        <span class="k">return</span> <span class="s">&#39;&lt;&#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span> <span class="o">+</span> <span class="s">&#39;: &#39;</span> <span class="o">+</span> <span class="n">msg</span> <span class="o">+</span> <span class="s">&#39;&gt;&#39;</span>


<div class="viewcode-block" id="parse_logic"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.parse_logic">[docs]</a><span class="k">def</span> <span class="nf">parse_logic</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">logic_parser</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert a file of First Order Formulas into a list of {Expression}s.</span>

<span class="sd">    :param s: the contents of the file</span>
<span class="sd">    :type s: str</span>
<span class="sd">    :param logic_parser: The parser to be used to parse the logical expression</span>
<span class="sd">    :type logic_parser: _LogicParser</span>
<span class="sd">    :param encoding: the encoding of the input string, if it is binary</span>
<span class="sd">    :type encoding: str</span>
<span class="sd">    :return: a list of parsed formulas.</span>
<span class="sd">    :rtype: list(Expression)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">encoding</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="n">encoding</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">logic_parser</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">logic_parser</span> <span class="o">=</span> <span class="n">_LogicParser</span><span class="p">()</span>

    <span class="n">statements</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">linenum</span><span class="p">,</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">splitlines</span><span class="p">()):</span>
        <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">line</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&#39;#&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">line</span><span class="o">==</span><span class="s">&#39;&#39;</span><span class="p">:</span> <span class="k">continue</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">statements</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">logic_parser</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">line</span><span class="p">))</span>
        <span class="k">except</span> <span class="n">LogicalExpressionException</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Unable to parse line </span><span class="si">%s</span><span class="s">: </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">linenum</span><span class="p">,</span> <span class="n">line</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">statements</span>

</div>
<span class="nd">@total_ordering</span>
<span class="nd">@python_2_unicode_compatible</span>
<div class="viewcode-block" id="Variable"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.Variable">[docs]</a><span class="k">class</span> <span class="nc">Variable</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param name: the name of the variable</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">string_types</span><span class="p">),</span> <span class="s">&quot;</span><span class="si">%s</span><span class="s"> is not a string&quot;</span> <span class="o">%</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Variable</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">name</span>

    <span class="k">def</span> <span class="nf">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span>

    <span class="k">def</span> <span class="nf">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Variable</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="n">name</span>

<div class="viewcode-block" id="Variable.substitute_bindings"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.Variable.substitute_bindings">[docs]</a>    <span class="k">def</span> <span class="nf">substitute_bindings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bindings</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">bindings</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;Variable(&#39;</span><span class="si">%s</span><span class="s">&#39;)&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>

</div>
<div class="viewcode-block" id="unique_variable"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.unique_variable">[docs]</a><span class="k">def</span> <span class="nf">unique_variable</span><span class="p">(</span><span class="n">pattern</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">ignore</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a new, unique variable.</span>

<span class="sd">    :param pattern: ``Variable`` that is being replaced.  The new variable must</span>
<span class="sd">        be the same type.</span>
<span class="sd">    :param term: a set of ``Variable`` objects that should not be returned from</span>
<span class="sd">        this function.</span>
<span class="sd">    :rtype: Variable</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">pattern</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">is_indvar</span><span class="p">(</span><span class="n">pattern</span><span class="o">.</span><span class="n">name</span><span class="p">):</span>
            <span class="n">prefix</span> <span class="o">=</span> <span class="s">&#39;z&#39;</span>
        <span class="k">elif</span> <span class="n">is_funcvar</span><span class="p">(</span><span class="n">pattern</span><span class="o">.</span><span class="n">name</span><span class="p">):</span>
            <span class="n">prefix</span> <span class="o">=</span> <span class="s">&#39;F&#39;</span>
        <span class="k">elif</span> <span class="n">is_eventvar</span><span class="p">(</span><span class="n">pattern</span><span class="o">.</span><span class="n">name</span><span class="p">):</span>
            <span class="n">prefix</span> <span class="o">=</span> <span class="s">&#39;e0&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="bp">False</span><span class="p">,</span> <span class="s">&quot;Cannot generate a unique constant&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">prefix</span> <span class="o">=</span> <span class="s">&#39;z&#39;</span>

    <span class="n">v</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%s%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">prefix</span><span class="p">,</span> <span class="n">_counter</span><span class="o">.</span><span class="n">get</span><span class="p">()))</span>
    <span class="k">while</span> <span class="n">ignore</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">ignore</span><span class="p">:</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%s%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">prefix</span><span class="p">,</span> <span class="n">_counter</span><span class="o">.</span><span class="n">get</span><span class="p">()))</span>
    <span class="k">return</span> <span class="n">v</span>
</div>
<div class="viewcode-block" id="skolem_function"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.skolem_function">[docs]</a><span class="k">def</span> <span class="nf">skolem_function</span><span class="p">(</span><span class="n">univ_scope</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a skolem function over the variables in univ_scope</span>
<span class="sd">    param univ_scope</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">skolem</span> <span class="o">=</span> <span class="n">VariableExpression</span><span class="p">(</span><span class="n">Variable</span><span class="p">(</span><span class="s">&#39;F</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">_counter</span><span class="o">.</span><span class="n">get</span><span class="p">()))</span>
    <span class="k">if</span> <span class="n">univ_scope</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">univ_scope</span><span class="p">):</span>
            <span class="n">skolem</span> <span class="o">=</span> <span class="n">skolem</span><span class="p">(</span><span class="n">VariableExpression</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">skolem</span>

</div>
<span class="nd">@python_2_unicode_compatible</span>
<div class="viewcode-block" id="Type"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.Type">[docs]</a><span class="k">class</span> <span class="nc">Type</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;</span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="p">)</span>
</div>
<span class="nd">@python_2_unicode_compatible</span>
<div class="viewcode-block" id="ComplexType"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.ComplexType">[docs]</a><span class="k">class</span> <span class="nc">ComplexType</span><span class="p">(</span><span class="n">Type</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">first</span><span class="p">,</span> <span class="n">second</span><span class="p">):</span>
        <span class="k">assert</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">Type</span><span class="p">)),</span> <span class="s">&quot;</span><span class="si">%s</span><span class="s"> is not a Type&quot;</span> <span class="o">%</span> <span class="n">first</span>
        <span class="k">assert</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">second</span><span class="p">,</span> <span class="n">Type</span><span class="p">)),</span> <span class="s">&quot;</span><span class="si">%s</span><span class="s"> is not a Type&quot;</span> <span class="o">%</span> <span class="n">second</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">first</span> <span class="o">=</span> <span class="n">first</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">second</span> <span class="o">=</span> <span class="n">second</span>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ComplexType</span><span class="p">)</span> <span class="ow">and</span> \
               <span class="bp">self</span><span class="o">.</span><span class="n">first</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">first</span> <span class="ow">and</span> \
               <span class="bp">self</span><span class="o">.</span><span class="n">second</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">second</span>

    <span class="k">def</span> <span class="nf">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span>

    <span class="n">__hash__</span> <span class="o">=</span> <span class="n">Type</span><span class="o">.</span><span class="n">__hash__</span>

<div class="viewcode-block" id="ComplexType.matches"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.ComplexType.matches">[docs]</a>    <span class="k">def</span> <span class="nf">matches</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ComplexType</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">first</span><span class="o">.</span><span class="n">matches</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">first</span><span class="p">)</span> <span class="ow">and</span> \
                   <span class="bp">self</span><span class="o">.</span><span class="n">second</span><span class="o">.</span><span class="n">matches</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">second</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">ANY_TYPE</span>
</div>
<div class="viewcode-block" id="ComplexType.resolve"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.ComplexType.resolve">[docs]</a>    <span class="k">def</span> <span class="nf">resolve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">other</span> <span class="o">==</span> <span class="n">ANY_TYPE</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ComplexType</span><span class="p">):</span>
            <span class="n">f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">first</span><span class="o">.</span><span class="n">resolve</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">first</span><span class="p">)</span>
            <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">second</span><span class="o">.</span><span class="n">resolve</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">second</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">f</span> <span class="ow">and</span> <span class="n">s</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">ComplexType</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="n">s</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">None</span>
        <span class="k">elif</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">ANY_TYPE</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">other</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>
</div>
    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">ANY_TYPE</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">&quot;</span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">ANY_TYPE</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">&#39;&lt;</span><span class="si">%s</span><span class="s">,</span><span class="si">%s</span><span class="s">&gt;&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">first</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">second</span><span class="p">)</span>

<div class="viewcode-block" id="ComplexType.str"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.ComplexType.str">[docs]</a>    <span class="k">def</span> <span class="nf">str</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">ANY_TYPE</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ANY_TYPE</span><span class="o">.</span><span class="n">str</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">&#39;(</span><span class="si">%s</span><span class="s"> -&gt; </span><span class="si">%s</span><span class="s">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">first</span><span class="o">.</span><span class="n">str</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">second</span><span class="o">.</span><span class="n">str</span><span class="p">())</span>
</div></div>
<div class="viewcode-block" id="BasicType"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.BasicType">[docs]</a><span class="k">class</span> <span class="nc">BasicType</span><span class="p">(</span><span class="n">Type</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">BasicType</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="s">&quot;</span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="s">&quot;</span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span>

    <span class="n">__hash__</span> <span class="o">=</span> <span class="n">Type</span><span class="o">.</span><span class="n">__hash__</span>

<div class="viewcode-block" id="BasicType.matches"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.BasicType.matches">[docs]</a>    <span class="k">def</span> <span class="nf">matches</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">other</span> <span class="o">==</span> <span class="n">ANY_TYPE</span> <span class="ow">or</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span>
</div>
<div class="viewcode-block" id="BasicType.resolve"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.BasicType.resolve">[docs]</a>    <span class="k">def</span> <span class="nf">resolve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">matches</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>
</div></div>
<span class="nd">@python_2_unicode_compatible</span>
<div class="viewcode-block" id="EntityType"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.EntityType">[docs]</a><span class="k">class</span> <span class="nc">EntityType</span><span class="p">(</span><span class="n">BasicType</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&#39;e&#39;</span>

<div class="viewcode-block" id="EntityType.str"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.EntityType.str">[docs]</a>    <span class="k">def</span> <span class="nf">str</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&#39;IND&#39;</span>
</div></div>
<span class="nd">@python_2_unicode_compatible</span>
<div class="viewcode-block" id="TruthValueType"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.TruthValueType">[docs]</a><span class="k">class</span> <span class="nc">TruthValueType</span><span class="p">(</span><span class="n">BasicType</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&#39;t&#39;</span>

<div class="viewcode-block" id="TruthValueType.str"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.TruthValueType.str">[docs]</a>    <span class="k">def</span> <span class="nf">str</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&#39;BOOL&#39;</span>
</div></div>
<span class="nd">@python_2_unicode_compatible</span>
<div class="viewcode-block" id="EventType"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.EventType">[docs]</a><span class="k">class</span> <span class="nc">EventType</span><span class="p">(</span><span class="n">BasicType</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&#39;v&#39;</span>

<div class="viewcode-block" id="EventType.str"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.EventType.str">[docs]</a>    <span class="k">def</span> <span class="nf">str</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&#39;EVENT&#39;</span>
</div></div>
<span class="nd">@python_2_unicode_compatible</span>
<div class="viewcode-block" id="AnyType"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.AnyType">[docs]</a><span class="k">class</span> <span class="nc">AnyType</span><span class="p">(</span><span class="n">BasicType</span><span class="p">,</span> <span class="n">ComplexType</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="nd">@property</span>
<div class="viewcode-block" id="AnyType.first"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.AnyType.first">[docs]</a>    <span class="k">def</span> <span class="nf">first</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="AnyType.second"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.AnyType.second">[docs]</a>    <span class="k">def</span> <span class="nf">second</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span>
</div>
    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">AnyType</span><span class="p">)</span> <span class="ow">or</span> <span class="n">other</span><span class="o">.</span><span class="n">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span>

    <span class="n">__hash__</span> <span class="o">=</span> <span class="n">Type</span><span class="o">.</span><span class="n">__hash__</span>

<div class="viewcode-block" id="AnyType.matches"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.AnyType.matches">[docs]</a>    <span class="k">def</span> <span class="nf">matches</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">True</span>
</div>
<div class="viewcode-block" id="AnyType.resolve"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.AnyType.resolve">[docs]</a>    <span class="k">def</span> <span class="nf">resolve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">other</span>
</div>
    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&#39;?&#39;</span>

<div class="viewcode-block" id="AnyType.str"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.AnyType.str">[docs]</a>    <span class="k">def</span> <span class="nf">str</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&#39;ANY&#39;</span>

</div></div>
<span class="n">TRUTH_TYPE</span> <span class="o">=</span> <span class="n">TruthValueType</span><span class="p">()</span>
<span class="n">ENTITY_TYPE</span> <span class="o">=</span> <span class="n">EntityType</span><span class="p">()</span>
<span class="n">EVENT_TYPE</span> <span class="o">=</span> <span class="n">EventType</span><span class="p">()</span>
<span class="n">ANY_TYPE</span> <span class="o">=</span> <span class="n">AnyType</span><span class="p">()</span>


<div class="viewcode-block" id="parse_type"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.parse_type">[docs]</a><span class="k">def</span> <span class="nf">parse_type</span><span class="p">(</span><span class="n">type_string</span><span class="p">):</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">type_string</span><span class="p">,</span> <span class="n">string_types</span><span class="p">)</span>
    <span class="n">type_string</span> <span class="o">=</span> <span class="n">type_string</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&#39; &#39;</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="p">)</span> <span class="c">#remove spaces</span>

    <span class="k">if</span> <span class="n">type_string</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;&lt;&#39;</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">type_string</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;&gt;&#39;</span>
        <span class="n">paren_count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">char</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">type_string</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">char</span> <span class="o">==</span> <span class="s">&#39;&lt;&#39;</span><span class="p">:</span>
                <span class="n">paren_count</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">char</span> <span class="o">==</span> <span class="s">&#39;&gt;&#39;</span><span class="p">:</span>
                <span class="n">paren_count</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="k">assert</span> <span class="n">paren_count</span> <span class="o">&gt;</span> <span class="mi">0</span>
            <span class="k">elif</span> <span class="n">char</span> <span class="o">==</span> <span class="s">&#39;,&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">paren_count</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">break</span>
        <span class="k">return</span> <span class="n">ComplexType</span><span class="p">(</span><span class="n">parse_type</span><span class="p">(</span><span class="n">type_string</span><span class="p">[</span><span class="mi">1</span>  <span class="p">:</span><span class="n">i</span> <span class="p">]),</span>
                           <span class="n">parse_type</span><span class="p">(</span><span class="n">type_string</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
    <span class="k">elif</span> <span class="n">type_string</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s">&quot;</span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">ENTITY_TYPE</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ENTITY_TYPE</span>
    <span class="k">elif</span> <span class="n">type_string</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s">&quot;</span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">TRUTH_TYPE</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">TRUTH_TYPE</span>
    <span class="k">elif</span> <span class="n">type_string</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s">&quot;</span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">ANY_TYPE</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ANY_TYPE</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">LogicalExpressionException</span><span class="p">(</span><span class="s">&quot;Unexpected character: &#39;</span><span class="si">%s</span><span class="s">&#39;.&quot;</span> <span class="o">%</span> <span class="n">type_string</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

</div>
<div class="viewcode-block" id="TypeException"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.TypeException">[docs]</a><span class="k">class</span> <span class="nc">TypeException</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">msg</span><span class="p">):</span>
        <span class="ne">Exception</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="InconsistentTypeHierarchyException"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.InconsistentTypeHierarchyException">[docs]</a><span class="k">class</span> <span class="nc">InconsistentTypeHierarchyException</span><span class="p">(</span><span class="n">TypeException</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variable</span><span class="p">,</span> <span class="n">expression</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">expression</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s">&quot;The variable &#39;</span><span class="si">%s</span><span class="s">&#39; was found in multiple places with different&quot;</span>\
                <span class="s">&quot; types in &#39;</span><span class="si">%s</span><span class="s">&#39;.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">expression</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s">&quot;The variable &#39;</span><span class="si">%s</span><span class="s">&#39; was found in multiple places with different&quot;</span>\
                <span class="s">&quot; types.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">variable</span><span class="p">)</span>
        <span class="ne">Exception</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="TypeResolutionException"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.TypeResolutionException">[docs]</a><span class="k">class</span> <span class="nc">TypeResolutionException</span><span class="p">(</span><span class="n">TypeException</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expression</span><span class="p">,</span> <span class="n">other_type</span><span class="p">):</span>
        <span class="ne">Exception</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&quot;The type of &#39;</span><span class="si">%s</span><span class="s">&#39;, &#39;</span><span class="si">%s</span><span class="s">&#39;, cannot be &quot;</span>
                           <span class="s">&quot;resolved with type &#39;</span><span class="si">%s</span><span class="s">&#39;&quot;</span> <span class="o">%</span> \
                           <span class="p">(</span><span class="n">expression</span><span class="p">,</span> <span class="n">expression</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">other_type</span><span class="p">))</span>
</div>
<div class="viewcode-block" id="IllegalTypeException"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.IllegalTypeException">[docs]</a><span class="k">class</span> <span class="nc">IllegalTypeException</span><span class="p">(</span><span class="n">TypeException</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expression</span><span class="p">,</span> <span class="n">other_type</span><span class="p">,</span> <span class="n">allowed_type</span><span class="p">):</span>
        <span class="ne">Exception</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&quot;Cannot set type of </span><span class="si">%s</span><span class="s"> &#39;</span><span class="si">%s</span><span class="s">&#39; to &#39;</span><span class="si">%s</span><span class="s">&#39;; &quot;</span>
                           <span class="s">&quot;must match type &#39;</span><span class="si">%s</span><span class="s">&#39;.&quot;</span> <span class="o">%</span>
                           <span class="p">(</span><span class="n">expression</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span> <span class="n">expression</span><span class="p">,</span>
                            <span class="n">other_type</span><span class="p">,</span> <span class="n">allowed_type</span><span class="p">))</span>

</div>
<div class="viewcode-block" id="typecheck"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.typecheck">[docs]</a><span class="k">def</span> <span class="nf">typecheck</span><span class="p">(</span><span class="n">expressions</span><span class="p">,</span> <span class="n">signature</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Ensure correct typing across a collection of ``Expression`` objects.</span>
<span class="sd">    :param expressions: a collection of expressions</span>
<span class="sd">    :param signature: dict that maps variable names to types (or string</span>
<span class="sd">    representations of types)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c">#typecheck and create master signature</span>
    <span class="k">for</span> <span class="n">expression</span> <span class="ow">in</span> <span class="n">expressions</span><span class="p">:</span>
        <span class="n">signature</span> <span class="o">=</span> <span class="n">expression</span><span class="o">.</span><span class="n">typecheck</span><span class="p">(</span><span class="n">signature</span><span class="p">)</span>
    <span class="c">#apply master signature to all expressions</span>
    <span class="k">for</span> <span class="n">expression</span> <span class="ow">in</span> <span class="n">expressions</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="n">expression</span><span class="o">.</span><span class="n">typecheck</span><span class="p">(</span><span class="n">signature</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">signature</span>

</div>
<div class="viewcode-block" id="SubstituteBindingsI"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.SubstituteBindingsI">[docs]</a><span class="k">class</span> <span class="nc">SubstituteBindingsI</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An interface for classes that can perform substitutions for</span>
<span class="sd">    variables.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="SubstituteBindingsI.substitute_bindings"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.SubstituteBindingsI.substitute_bindings">[docs]</a>    <span class="k">def</span> <span class="nf">substitute_bindings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bindings</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :return: The object that is obtained by replacing</span>
<span class="sd">            each variable bound by ``bindings`` with its values.</span>
<span class="sd">            Aliases are already resolved. (maybe?)</span>
<span class="sd">        :rtype: (any)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="SubstituteBindingsI.variables"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.SubstituteBindingsI.variables">[docs]</a>    <span class="k">def</span> <span class="nf">variables</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :return: A list of all variables in this object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>

</div></div>
<span class="nd">@python_2_unicode_compatible</span>
<div class="viewcode-block" id="Expression"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.Expression">[docs]</a><span class="k">class</span> <span class="nc">Expression</span><span class="p">(</span><span class="n">SubstituteBindingsI</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This is the base abstract object for all logical expressions&quot;&quot;&quot;</span>

    <span class="n">_logic_parser</span> <span class="o">=</span> <span class="n">_LogicParser</span><span class="p">()</span>

    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="Expression.fromstring"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.Expression.fromstring">[docs]</a>    <span class="k">def</span> <span class="nf">fromstring</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">cls</span><span class="o">.</span><span class="n">_logic_parser</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="o">*</span><span class="n">additional</span><span class="p">):</span>
        <span class="n">accum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">applyto</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">additional</span><span class="p">:</span>
            <span class="n">accum</span> <span class="o">=</span> <span class="n">accum</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">accum</span>

<div class="viewcode-block" id="Expression.applyto"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.Expression.applyto">[docs]</a>    <span class="k">def</span> <span class="nf">applyto</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Expression</span><span class="p">),</span> <span class="s">&quot;</span><span class="si">%s</span><span class="s"> is not an Expression&quot;</span> <span class="o">%</span> <span class="n">other</span>
        <span class="k">return</span> <span class="n">ApplicationExpression</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">__neg__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">NegatedExpression</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

<div class="viewcode-block" id="Expression.negate"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.Expression.negate">[docs]</a>    <span class="k">def</span> <span class="nf">negate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;If this is a negated expression, remove the negation.</span>
<span class="sd">        Otherwise add a negation.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="o">-</span><span class="bp">self</span>
</div>
    <span class="k">def</span> <span class="nf">__and__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Expression</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%s</span><span class="s"> is not an Expression&quot;</span> <span class="o">%</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">AndExpression</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__or__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Expression</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%s</span><span class="s"> is not an Expression&quot;</span> <span class="o">%</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">OrExpression</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__gt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Expression</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%s</span><span class="s"> is not an Expression&quot;</span> <span class="o">%</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ImpExpression</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Expression</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%s</span><span class="s"> is not an Expression&quot;</span> <span class="o">%</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">IffExpression</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span>

<div class="viewcode-block" id="Expression.equiv"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.Expression.equiv">[docs]</a>    <span class="k">def</span> <span class="nf">equiv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">prover</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check for logical equivalence.</span>
<span class="sd">        Pass the expression (self &lt;-&gt; other) to the theorem prover.</span>
<span class="sd">        If the prover says it is valid, then the self and other are equal.</span>

<span class="sd">        :param other: an ``Expression`` to check equality against</span>
<span class="sd">        :param prover: a ``nltk.inference.api.Prover``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Expression</span><span class="p">),</span> <span class="s">&quot;</span><span class="si">%s</span><span class="s"> is not an Expression&quot;</span> <span class="o">%</span> <span class="n">other</span>

        <span class="k">if</span> <span class="n">prover</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">nltk.inference</span> <span class="kn">import</span> <span class="n">Prover9</span>
            <span class="n">prover</span> <span class="o">=</span> <span class="n">Prover9</span><span class="p">()</span>
        <span class="n">bicond</span> <span class="o">=</span> <span class="n">IffExpression</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">simplify</span><span class="p">(),</span> <span class="n">other</span><span class="o">.</span><span class="n">simplify</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">prover</span><span class="o">.</span><span class="n">prove</span><span class="p">(</span><span class="n">bicond</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

<div class="viewcode-block" id="Expression.substitute_bindings"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.Expression.substitute_bindings">[docs]</a>    <span class="k">def</span> <span class="nf">substitute_bindings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bindings</span><span class="p">):</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">variables</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">bindings</span><span class="p">:</span>
                <span class="n">val</span> <span class="o">=</span> <span class="n">bindings</span><span class="p">[</span><span class="n">var</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">Variable</span><span class="p">):</span>
                    <span class="n">val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_VariableExpression</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
                <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">Expression</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Can not substitute a non-expression &#39;</span>
                                     <span class="s">&#39;value into an expression: </span><span class="si">%r</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">val</span><span class="p">,))</span>
                <span class="c"># Substitute bindings in the target value.</span>
                <span class="n">val</span> <span class="o">=</span> <span class="n">val</span><span class="o">.</span><span class="n">substitute_bindings</span><span class="p">(</span><span class="n">bindings</span><span class="p">)</span>
                <span class="c"># Replace var w/ the target value.</span>
                <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">expr</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Expression.typecheck"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.Expression.typecheck">[docs]</a>    <span class="k">def</span> <span class="nf">typecheck</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">signature</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Infer and check types.  Raise exceptions if necessary.</span>

<span class="sd">        :param signature: dict that maps variable names to types (or string</span>
<span class="sd">            representations of types)</span>
<span class="sd">        :return: the signature, plus any additional type mappings</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sig</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">signature</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">signature</span><span class="p">:</span>
                <span class="n">val</span> <span class="o">=</span> <span class="n">signature</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
                <span class="n">varEx</span> <span class="o">=</span> <span class="n">VariableExpression</span><span class="p">(</span><span class="n">Variable</span><span class="p">(</span><span class="n">key</span><span class="p">))</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">Type</span><span class="p">):</span>
                    <span class="n">varEx</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">val</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">varEx</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">parse_type</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
                <span class="n">sig</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">varEx</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_set_type</span><span class="p">(</span><span class="n">signature</span><span class="o">=</span><span class="n">sig</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">dict</span><span class="p">((</span><span class="n">key</span><span class="p">,</span> <span class="n">sig</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">type</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">sig</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Expression.findtype"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.Expression.findtype">[docs]</a>    <span class="k">def</span> <span class="nf">findtype</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variable</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find the type of the given variable as it is used in this expression.</span>
<span class="sd">        For example, finding the type of &quot;P&quot; in &quot;P(x) &amp; Q(x,y)&quot; yields &quot;&lt;e,t&gt;&quot;</span>

<span class="sd">        :param variable: Variable</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
    <span class="k">def</span> <span class="nf">_set_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_type</span><span class="o">=</span><span class="n">ANY_TYPE</span><span class="p">,</span> <span class="n">signature</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the type of this expression to be the given type.  Raise type</span>
<span class="sd">        exceptions where applicable.</span>

<span class="sd">        :param other_type: Type</span>
<span class="sd">        :param signature: dict(str -&gt; list(AbstractVariableExpression))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>

<div class="viewcode-block" id="Expression.replace"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.Expression.replace">[docs]</a>    <span class="k">def</span> <span class="nf">replace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variable</span><span class="p">,</span> <span class="n">expression</span><span class="p">,</span> <span class="n">replace_bound</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">alpha_convert</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Replace every instance of &#39;variable&#39; with &#39;expression&#39;</span>
<span class="sd">        :param variable: ``Variable`` The variable to replace</span>
<span class="sd">        :param expression: ``Expression`` The expression with which to replace it</span>
<span class="sd">        :param replace_bound: bool Should bound variables be replaced?</span>
<span class="sd">        :param alpha_convert: bool Alpha convert automatically to avoid name clashes?</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">Variable</span><span class="p">),</span> <span class="s">&quot;</span><span class="si">%s</span><span class="s"> is not a Variable&quot;</span> <span class="o">%</span> <span class="n">variable</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expression</span><span class="p">,</span> <span class="n">Expression</span><span class="p">),</span> <span class="s">&quot;</span><span class="si">%s</span><span class="s"> is not an Expression&quot;</span> <span class="o">%</span> <span class="n">expression</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit_structured</span><span class="p">(</span><span class="k">lambda</span> <span class="n">e</span><span class="p">:</span> <span class="n">e</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">expression</span><span class="p">,</span>
                                                         <span class="n">replace_bound</span><span class="p">,</span> <span class="n">alpha_convert</span><span class="p">),</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Expression.normalize"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.Expression.normalize">[docs]</a>    <span class="k">def</span> <span class="nf">normalize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">newvars</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Rename auto-generated unique variables&quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">get_indiv_vars</span><span class="p">(</span><span class="n">e</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">IndividualVariableExpression</span><span class="p">):</span>
                <span class="k">return</span> <span class="nb">set</span><span class="p">([</span><span class="n">e</span><span class="p">])</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">AbstractVariableExpression</span><span class="p">):</span>
                <span class="k">return</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">e</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">get_indiv_vars</span><span class="p">,</span>
                               <span class="k">lambda</span> <span class="n">parts</span><span class="p">:</span> <span class="nb">reduce</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">or_</span><span class="p">,</span> <span class="n">parts</span><span class="p">,</span> <span class="nb">set</span><span class="p">()))</span>

        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">get_indiv_vars</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">e</span><span class="p">:</span> <span class="n">e</span><span class="o">.</span><span class="n">variable</span><span class="p">)):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span><span class="n">EventVariableExpression</span><span class="p">):</span>
                <span class="n">newVar</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span><span class="n">Variable</span><span class="p">(</span><span class="s">&#39;e0</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)))</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span><span class="n">IndividualVariableExpression</span><span class="p">):</span>
                <span class="n">newVar</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span><span class="n">Variable</span><span class="p">(</span><span class="s">&#39;z</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">newVar</span> <span class="o">=</span> <span class="n">e</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">variable</span><span class="p">,</span> <span class="n">newVar</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>
</div>
<div class="viewcode-block" id="Expression.visit"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.Expression.visit">[docs]</a>    <span class="k">def</span> <span class="nf">visit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">combinator</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Recursively visit subexpressions.  Apply &#39;function&#39; to each</span>
<span class="sd">        subexpression and pass the result of each function application</span>
<span class="sd">        to the &#39;combinator&#39; for aggregation:</span>

<span class="sd">            return combinator(map(function, self.subexpressions))</span>

<span class="sd">        Bound variables are neither applied upon by the function nor given to</span>
<span class="sd">        the combinator.</span>
<span class="sd">        :param function: ``Function&lt;Expression,T&gt;`` to call on each subexpression</span>
<span class="sd">        :param combinator: ``Function&lt;list&lt;T&gt;,R&gt;`` to combine the results of the</span>
<span class="sd">        function calls</span>
<span class="sd">        :return: result of combination ``R``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Expression.visit_structured"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.Expression.visit_structured">[docs]</a>    <span class="k">def</span> <span class="nf">visit_structured</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">combinator</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Recursively visit subexpressions.  Apply &#39;function&#39; to each</span>
<span class="sd">        subexpression and pass the result of each function application</span>
<span class="sd">        to the &#39;combinator&#39; for aggregation.  The combinator must have</span>
<span class="sd">        the same signature as the constructor.  The function is not</span>
<span class="sd">        applied to bound variables, but they are passed to the</span>
<span class="sd">        combinator.</span>
<span class="sd">        :param function: ``Function`` to call on each subexpression</span>
<span class="sd">        :param combinator: ``Function`` with the same signature as the</span>
<span class="sd">        constructor, to combine the results of the function calls</span>
<span class="sd">        :return: result of combination</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">parts</span><span class="p">:</span> <span class="n">combinator</span><span class="p">(</span><span class="o">*</span><span class="n">parts</span><span class="p">))</span>
</div>
    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&#39;&lt;</span><span class="si">%s</span><span class="s"> </span><span class="si">%s</span><span class="s">&gt;&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">str</span><span class="p">()</span>

<div class="viewcode-block" id="Expression.variables"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.Expression.variables">[docs]</a>    <span class="k">def</span> <span class="nf">variables</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a set of all the variables for binding substitution.</span>
<span class="sd">        The variables returned include all free (non-bound) individual</span>
<span class="sd">        variables and any variable starting with &#39;?&#39; or &#39;@&#39;.</span>
<span class="sd">        :return: set of ``Variable`` objects</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">free</span><span class="p">()</span> <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">predicates</span><span class="p">()</span><span class="o">|</span><span class="bp">self</span><span class="o">.</span><span class="n">constants</span><span class="p">()</span>
                                 <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s">&#39;^[?@]&#39;</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
</div>
<div class="viewcode-block" id="Expression.free"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.Expression.free">[docs]</a>    <span class="k">def</span> <span class="nf">free</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a set of all the free (non-bound) variables.  This includes</span>
<span class="sd">        both individual and predicate variables, but not constants.</span>
<span class="sd">        :return: set of ``Variable`` objects</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="k">lambda</span> <span class="n">e</span><span class="p">:</span> <span class="n">e</span><span class="o">.</span><span class="n">free</span><span class="p">(),</span>
                          <span class="k">lambda</span> <span class="n">parts</span><span class="p">:</span> <span class="nb">reduce</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">or_</span><span class="p">,</span> <span class="n">parts</span><span class="p">,</span> <span class="nb">set</span><span class="p">()))</span>
</div>
<div class="viewcode-block" id="Expression.constants"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.Expression.constants">[docs]</a>    <span class="k">def</span> <span class="nf">constants</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a set of individual constants (non-predicates).</span>
<span class="sd">        :return: set of ``Variable`` objects</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="k">lambda</span> <span class="n">e</span><span class="p">:</span> <span class="n">e</span><span class="o">.</span><span class="n">constants</span><span class="p">(),</span>
                          <span class="k">lambda</span> <span class="n">parts</span><span class="p">:</span> <span class="nb">reduce</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">or_</span><span class="p">,</span> <span class="n">parts</span><span class="p">,</span> <span class="nb">set</span><span class="p">()))</span>
</div>
<div class="viewcode-block" id="Expression.predicates"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.Expression.predicates">[docs]</a>    <span class="k">def</span> <span class="nf">predicates</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a set of predicates (constants, not variables).</span>
<span class="sd">        :return: set of ``Variable`` objects</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="k">lambda</span> <span class="n">e</span><span class="p">:</span> <span class="n">e</span><span class="o">.</span><span class="n">predicates</span><span class="p">(),</span>
                          <span class="k">lambda</span> <span class="n">parts</span><span class="p">:</span> <span class="nb">reduce</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">or_</span><span class="p">,</span> <span class="n">parts</span><span class="p">,</span> <span class="nb">set</span><span class="p">()))</span>
</div>
<div class="viewcode-block" id="Expression.simplify"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.Expression.simplify">[docs]</a>    <span class="k">def</span> <span class="nf">simplify</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :return: beta-converted version of this expression</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit_structured</span><span class="p">(</span><span class="k">lambda</span> <span class="n">e</span><span class="p">:</span> <span class="n">e</span><span class="o">.</span><span class="n">simplify</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Expression.make_VariableExpression"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.Expression.make_VariableExpression">[docs]</a>    <span class="k">def</span> <span class="nf">make_VariableExpression</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variable</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">VariableExpression</span><span class="p">(</span><span class="n">variable</span><span class="p">)</span>

</div></div>
<span class="nd">@python_2_unicode_compatible</span>
<div class="viewcode-block" id="ApplicationExpression"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.ApplicationExpression">[docs]</a><span class="k">class</span> <span class="nc">ApplicationExpression</span><span class="p">(</span><span class="n">Expression</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    This class is used to represent two related types of logical expressions.</span>

<span class="sd">    The first is a Predicate Expression, such as &quot;P(x,y)&quot;.  A predicate</span>
<span class="sd">    expression is comprised of a ``FunctionVariableExpression`` or</span>
<span class="sd">    ``ConstantExpression`` as the predicate and a list of Expressions as the</span>
<span class="sd">    arguments.</span>

<span class="sd">    The second is a an application of one expression to another, such as</span>
<span class="sd">    &quot;(\x.dog(x))(fido)&quot;.</span>

<span class="sd">    The reason Predicate Expressions are treated as Application Expressions is</span>
<span class="sd">    that the Variable Expression predicate of the expression may be replaced</span>
<span class="sd">    with another Expression, such as a LambdaExpression, which would mean that</span>
<span class="sd">    the Predicate should be thought of as being applied to the arguments.</span>

<span class="sd">    The logical expression parser will always curry arguments in a application expression.</span>
<span class="sd">    So, &quot;\x y.see(x,y)(john,mary)&quot; will be represented internally as</span>
<span class="sd">    &quot;((\x y.(see(x))(y))(john))(mary)&quot;.  This simplifies the internals since</span>
<span class="sd">    there will always be exactly one argument in an application.</span>

<span class="sd">    The str() method will usually print the curried forms of application</span>
<span class="sd">    expressions.  The one exception is when the the application expression is</span>
<span class="sd">    really a predicate expression (ie, underlying function is an</span>
<span class="sd">    ``AbstractVariableExpression``).  This means that the example from above</span>
<span class="sd">    will be returned as &quot;(\x y.see(x,y)(john))(mary)&quot;.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">argument</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param function: ``Expression``, for the function expression</span>
<span class="sd">        :param argument: ``Expression``, for the argument</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="n">Expression</span><span class="p">),</span> <span class="s">&quot;</span><span class="si">%s</span><span class="s"> is not an Expression&quot;</span> <span class="o">%</span> <span class="n">function</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">argument</span><span class="p">,</span> <span class="n">Expression</span><span class="p">),</span> <span class="s">&quot;</span><span class="si">%s</span><span class="s"> is not an Expression&quot;</span> <span class="o">%</span> <span class="n">argument</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">function</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">argument</span> <span class="o">=</span> <span class="n">argument</span>

<div class="viewcode-block" id="ApplicationExpression.simplify"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.ApplicationExpression.simplify">[docs]</a>    <span class="k">def</span> <span class="nf">simplify</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">function</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">function</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span>
        <span class="n">argument</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">argument</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="n">LambdaExpression</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">function</span><span class="o">.</span><span class="n">term</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">function</span><span class="o">.</span><span class="n">variable</span><span class="p">,</span> <span class="n">argument</span><span class="p">)</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="n">argument</span><span class="p">)</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="ApplicationExpression.type"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.ApplicationExpression.type">[docs]</a>    <span class="k">def</span> <span class="nf">type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">function</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">ComplexType</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">function</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">second</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ANY_TYPE</span>
</div>
    <span class="k">def</span> <span class="nf">_set_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_type</span><span class="o">=</span><span class="n">ANY_TYPE</span><span class="p">,</span> <span class="n">signature</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;:see Expression._set_type()&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other_type</span><span class="p">,</span> <span class="n">Type</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">signature</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">signature</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">argument</span><span class="o">.</span><span class="n">_set_type</span><span class="p">(</span><span class="n">ANY_TYPE</span><span class="p">,</span> <span class="n">signature</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">function</span><span class="o">.</span><span class="n">_set_type</span><span class="p">(</span><span class="n">ComplexType</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">argument</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">other_type</span><span class="p">),</span> <span class="n">signature</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">TypeResolutionException</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">TypeException</span><span class="p">(</span>
                    <span class="s">&quot;The function &#39;</span><span class="si">%s</span><span class="s">&#39; is of type &#39;</span><span class="si">%s</span><span class="s">&#39; and cannot be applied &quot;</span>
                    <span class="s">&quot;to &#39;</span><span class="si">%s</span><span class="s">&#39; of type &#39;</span><span class="si">%s</span><span class="s">&#39;.  Its argument must match type &#39;</span><span class="si">%s</span><span class="s">&#39;.&quot;</span>
                    <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">function</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">function</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">argument</span><span class="p">,</span>
                       <span class="bp">self</span><span class="o">.</span><span class="n">argument</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">function</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">first</span><span class="p">))</span>

<div class="viewcode-block" id="ApplicationExpression.findtype"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.ApplicationExpression.findtype">[docs]</a>    <span class="k">def</span> <span class="nf">findtype</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variable</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;:see Expression.findtype()&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">Variable</span><span class="p">),</span> <span class="s">&quot;</span><span class="si">%s</span><span class="s"> is not a Variable&quot;</span> <span class="o">%</span> <span class="n">variable</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_atom</span><span class="p">():</span>
            <span class="n">function</span><span class="p">,</span> <span class="n">args</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">uncurry</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c">#It&#39;s not a predicate expression (&quot;P(x,y)&quot;), so leave args curried</span>
            <span class="n">function</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">function</span>
            <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">argument</span><span class="p">]</span>

        <span class="n">found</span> <span class="o">=</span> <span class="p">[</span><span class="n">arg</span><span class="o">.</span><span class="n">findtype</span><span class="p">(</span><span class="n">variable</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="p">[</span><span class="n">function</span><span class="p">]</span><span class="o">+</span><span class="n">args</span><span class="p">]</span>

        <span class="n">unique</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">found</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">f</span> <span class="o">!=</span> <span class="n">ANY_TYPE</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">unique</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">unique</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">matches</span><span class="p">(</span><span class="n">u</span><span class="p">):</span>
                            <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">unique</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">unique</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ANY_TYPE</span>
</div>
<div class="viewcode-block" id="ApplicationExpression.constants"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.ApplicationExpression.constants">[docs]</a>    <span class="k">def</span> <span class="nf">constants</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;:see: Expression.constants()&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">function</span><span class="p">,</span> <span class="n">AbstractVariableExpression</span><span class="p">):</span>
            <span class="n">function_constants</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">function_constants</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">function</span><span class="o">.</span><span class="n">constants</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">function_constants</span> <span class="o">|</span> <span class="bp">self</span><span class="o">.</span><span class="n">argument</span><span class="o">.</span><span class="n">constants</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="ApplicationExpression.predicates"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.ApplicationExpression.predicates">[docs]</a>    <span class="k">def</span> <span class="nf">predicates</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;:see: Expression.predicates()&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">function</span><span class="p">,</span> <span class="n">ConstantExpression</span><span class="p">):</span>
            <span class="n">function_preds</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">function</span><span class="o">.</span><span class="n">variable</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">function_preds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">function</span><span class="o">.</span><span class="n">predicates</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">function_preds</span> <span class="o">|</span> <span class="bp">self</span><span class="o">.</span><span class="n">argument</span><span class="o">.</span><span class="n">predicates</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="ApplicationExpression.visit"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.ApplicationExpression.visit">[docs]</a>    <span class="k">def</span> <span class="nf">visit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">combinator</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;:see: Expression.visit()&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">combinator</span><span class="p">([</span><span class="n">function</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">function</span><span class="p">),</span> <span class="n">function</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">argument</span><span class="p">)])</span>
</div>
    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ApplicationExpression</span><span class="p">)</span> <span class="ow">and</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">function</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">function</span> <span class="ow">and</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">argument</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">argument</span>

    <span class="k">def</span> <span class="nf">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span>

    <span class="n">__hash__</span> <span class="o">=</span> <span class="n">Expression</span><span class="o">.</span><span class="n">__hash__</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># uncurry the arguments and find the base function</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_atom</span><span class="p">():</span>
            <span class="n">function</span><span class="p">,</span> <span class="n">args</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">uncurry</span><span class="p">()</span>
            <span class="n">arg_str</span> <span class="o">=</span> <span class="s">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">arg</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c">#Leave arguments curried</span>
            <span class="n">function</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">function</span>
            <span class="n">arg_str</span> <span class="o">=</span> <span class="s">&quot;</span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">argument</span>

        <span class="n">function_str</span> <span class="o">=</span> <span class="s">&quot;</span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">function</span>
        <span class="n">parenthesize_function</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="n">LambdaExpression</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">function</span><span class="o">.</span><span class="n">term</span><span class="p">,</span> <span class="n">ApplicationExpression</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">function</span><span class="o">.</span><span class="n">term</span><span class="o">.</span><span class="n">function</span><span class="p">,</span>
                                  <span class="n">AbstractVariableExpression</span><span class="p">):</span>
                    <span class="n">parenthesize_function</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">function</span><span class="o">.</span><span class="n">term</span><span class="p">,</span> <span class="n">BooleanExpression</span><span class="p">):</span>
                <span class="n">parenthesize_function</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="n">ApplicationExpression</span><span class="p">):</span>
            <span class="n">parenthesize_function</span> <span class="o">=</span> <span class="bp">True</span>

        <span class="k">if</span> <span class="n">parenthesize_function</span><span class="p">:</span>
            <span class="n">function_str</span> <span class="o">=</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">OPEN</span> <span class="o">+</span> <span class="n">function_str</span> <span class="o">+</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">CLOSE</span>

        <span class="k">return</span> <span class="n">function_str</span> <span class="o">+</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">OPEN</span> <span class="o">+</span> <span class="n">arg_str</span> <span class="o">+</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">CLOSE</span>

<div class="viewcode-block" id="ApplicationExpression.uncurry"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.ApplicationExpression.uncurry">[docs]</a>    <span class="k">def</span> <span class="nf">uncurry</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Uncurry this application expression</span>

<span class="sd">        return: A tuple (base-function, arg-list)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">function</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">function</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">argument</span><span class="p">]</span>
        <span class="k">while</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="n">ApplicationExpression</span><span class="p">):</span>
            <span class="c">#(\x.\y.sees(x,y)(john))(mary)</span>
            <span class="n">args</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">function</span><span class="o">.</span><span class="n">argument</span><span class="p">)</span>
            <span class="n">function</span> <span class="o">=</span> <span class="n">function</span><span class="o">.</span><span class="n">function</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="ApplicationExpression.pred"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.ApplicationExpression.pred">[docs]</a>    <span class="k">def</span> <span class="nf">pred</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return uncurried base-function.</span>
<span class="sd">        If this is an atom, then the result will be a variable expression.</span>
<span class="sd">        Otherwise, it will be a lambda expression.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">uncurry</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="ApplicationExpression.args"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.ApplicationExpression.args">[docs]</a>    <span class="k">def</span> <span class="nf">args</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return uncurried arg-list</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">uncurry</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span>
</div>
<div class="viewcode-block" id="ApplicationExpression.is_atom"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.ApplicationExpression.is_atom">[docs]</a>    <span class="k">def</span> <span class="nf">is_atom</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Is this expression an atom (as opposed to a lambda expression applied</span>
<span class="sd">        to a term)?</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pred</span><span class="p">,</span> <span class="n">AbstractVariableExpression</span><span class="p">)</span>

</div></div>
<span class="nd">@total_ordering</span>
<span class="nd">@python_2_unicode_compatible</span>
<div class="viewcode-block" id="AbstractVariableExpression"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.AbstractVariableExpression">[docs]</a><span class="k">class</span> <span class="nc">AbstractVariableExpression</span><span class="p">(</span><span class="n">Expression</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This class represents a variable to be used as a predicate or entity&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variable</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param variable: ``Variable``, for the variable</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">Variable</span><span class="p">),</span> <span class="s">&quot;</span><span class="si">%s</span><span class="s"> is not a Variable&quot;</span> <span class="o">%</span> <span class="n">variable</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">variable</span> <span class="o">=</span> <span class="n">variable</span>

<div class="viewcode-block" id="AbstractVariableExpression.simplify"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.AbstractVariableExpression.simplify">[docs]</a>    <span class="k">def</span> <span class="nf">simplify</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>
</div>
<div class="viewcode-block" id="AbstractVariableExpression.replace"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.AbstractVariableExpression.replace">[docs]</a>    <span class="k">def</span> <span class="nf">replace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variable</span><span class="p">,</span> <span class="n">expression</span><span class="p">,</span> <span class="n">replace_bound</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">alpha_convert</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;:see: Expression.replace()&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">Variable</span><span class="p">),</span> <span class="s">&quot;</span><span class="si">%s</span><span class="s"> is not an Variable&quot;</span> <span class="o">%</span> <span class="n">variable</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expression</span><span class="p">,</span> <span class="n">Expression</span><span class="p">),</span> <span class="s">&quot;</span><span class="si">%s</span><span class="s"> is not an Expression&quot;</span> <span class="o">%</span> <span class="n">expression</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable</span> <span class="o">==</span> <span class="n">variable</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">expression</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
</div>
    <span class="k">def</span> <span class="nf">_set_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_type</span><span class="o">=</span><span class="n">ANY_TYPE</span><span class="p">,</span> <span class="n">signature</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;:see Expression._set_type()&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other_type</span><span class="p">,</span> <span class="n">Type</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">signature</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">signature</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

        <span class="n">resolution</span> <span class="o">=</span> <span class="n">other_type</span>
        <span class="k">for</span> <span class="n">varEx</span> <span class="ow">in</span> <span class="n">signature</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">variable</span><span class="o">.</span><span class="n">name</span><span class="p">]:</span>
            <span class="n">resolution</span> <span class="o">=</span> <span class="n">varEx</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">resolve</span><span class="p">(</span><span class="n">resolution</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">resolution</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">InconsistentTypeHierarchyException</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="n">signature</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">variable</span><span class="o">.</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">varEx</span> <span class="ow">in</span> <span class="n">signature</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">variable</span><span class="o">.</span><span class="n">name</span><span class="p">]:</span>
            <span class="n">varEx</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">resolution</span>

<div class="viewcode-block" id="AbstractVariableExpression.findtype"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.AbstractVariableExpression.findtype">[docs]</a>    <span class="k">def</span> <span class="nf">findtype</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variable</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;:see Expression.findtype()&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">Variable</span><span class="p">),</span> <span class="s">&quot;</span><span class="si">%s</span><span class="s"> is not a Variable&quot;</span> <span class="o">%</span> <span class="n">variable</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable</span> <span class="o">==</span> <span class="n">variable</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ANY_TYPE</span>
</div>
<div class="viewcode-block" id="AbstractVariableExpression.predicates"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.AbstractVariableExpression.predicates">[docs]</a>    <span class="k">def</span> <span class="nf">predicates</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;:see: Expression.predicates()&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">set</span><span class="p">()</span>
</div>
    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Allow equality between instances of ``AbstractVariableExpression``</span>
<span class="sd">        subtypes.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">AbstractVariableExpression</span><span class="p">)</span> <span class="ow">and</span> \
               <span class="bp">self</span><span class="o">.</span><span class="n">variable</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">variable</span>

    <span class="k">def</span> <span class="nf">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span>

    <span class="k">def</span> <span class="nf">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">AbstractVariableExpression</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="n">variable</span>

    <span class="n">__hash__</span> <span class="o">=</span> <span class="n">Expression</span><span class="o">.</span><span class="n">__hash__</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;</span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable</span>
</div>
<div class="viewcode-block" id="IndividualVariableExpression"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.IndividualVariableExpression">[docs]</a><span class="k">class</span> <span class="nc">IndividualVariableExpression</span><span class="p">(</span><span class="n">AbstractVariableExpression</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This class represents variables that take the form of a single lowercase</span>
<span class="sd">    character (other than &#39;e&#39;) followed by zero or more digits.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">_set_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_type</span><span class="o">=</span><span class="n">ANY_TYPE</span><span class="p">,</span> <span class="n">signature</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;:see Expression._set_type()&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other_type</span><span class="p">,</span> <span class="n">Type</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">signature</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">signature</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">other_type</span><span class="o">.</span><span class="n">matches</span><span class="p">(</span><span class="n">ENTITY_TYPE</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">IllegalTypeException</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_type</span><span class="p">,</span> <span class="n">ENTITY_TYPE</span><span class="p">)</span>

        <span class="n">signature</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">variable</span><span class="o">.</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="n">ENTITY_TYPE</span>
    <span class="nb">type</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_type</span><span class="p">,</span> <span class="n">_set_type</span><span class="p">)</span>

<div class="viewcode-block" id="IndividualVariableExpression.free"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.IndividualVariableExpression.free">[docs]</a>    <span class="k">def</span> <span class="nf">free</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;:see: Expression.free()&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">set</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">variable</span><span class="p">])</span>
</div>
<div class="viewcode-block" id="IndividualVariableExpression.constants"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.IndividualVariableExpression.constants">[docs]</a>    <span class="k">def</span> <span class="nf">constants</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;:see: Expression.constants()&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">set</span><span class="p">()</span>
</div></div>
<div class="viewcode-block" id="FunctionVariableExpression"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.FunctionVariableExpression">[docs]</a><span class="k">class</span> <span class="nc">FunctionVariableExpression</span><span class="p">(</span><span class="n">AbstractVariableExpression</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This class represents variables that take the form of a single uppercase</span>
<span class="sd">    character followed by zero or more digits.&quot;&quot;&quot;</span>
    <span class="nb">type</span> <span class="o">=</span> <span class="n">ANY_TYPE</span>

<div class="viewcode-block" id="FunctionVariableExpression.free"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.FunctionVariableExpression.free">[docs]</a>    <span class="k">def</span> <span class="nf">free</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;:see: Expression.free()&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">set</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">variable</span><span class="p">])</span>
</div>
<div class="viewcode-block" id="FunctionVariableExpression.constants"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.FunctionVariableExpression.constants">[docs]</a>    <span class="k">def</span> <span class="nf">constants</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;:see: Expression.constants()&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">set</span><span class="p">()</span>
</div></div>
<div class="viewcode-block" id="EventVariableExpression"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.EventVariableExpression">[docs]</a><span class="k">class</span> <span class="nc">EventVariableExpression</span><span class="p">(</span><span class="n">IndividualVariableExpression</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This class represents variables that take the form of a single lowercase</span>
<span class="sd">    &#39;e&#39; character followed by zero or more digits.&quot;&quot;&quot;</span>
    <span class="nb">type</span> <span class="o">=</span> <span class="n">EVENT_TYPE</span>
</div>
<div class="viewcode-block" id="ConstantExpression"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.ConstantExpression">[docs]</a><span class="k">class</span> <span class="nc">ConstantExpression</span><span class="p">(</span><span class="n">AbstractVariableExpression</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This class represents variables that do not take the form of a single</span>
<span class="sd">    character followed by zero or more digits.&quot;&quot;&quot;</span>
    <span class="nb">type</span> <span class="o">=</span> <span class="n">ENTITY_TYPE</span>

    <span class="k">def</span> <span class="nf">_set_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_type</span><span class="o">=</span><span class="n">ANY_TYPE</span><span class="p">,</span> <span class="n">signature</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;:see Expression._set_type()&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other_type</span><span class="p">,</span> <span class="n">Type</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">signature</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">signature</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">other_type</span> <span class="o">==</span> <span class="n">ANY_TYPE</span><span class="p">:</span>
            <span class="c">#entity type by default, for individuals</span>
            <span class="n">resolution</span> <span class="o">=</span> <span class="n">ENTITY_TYPE</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">resolution</span> <span class="o">=</span> <span class="n">other_type</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">ENTITY_TYPE</span><span class="p">:</span>
                <span class="n">resolution</span> <span class="o">=</span> <span class="n">resolution</span><span class="o">.</span><span class="n">resolve</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">varEx</span> <span class="ow">in</span> <span class="n">signature</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">variable</span><span class="o">.</span><span class="n">name</span><span class="p">]:</span>
            <span class="n">resolution</span> <span class="o">=</span> <span class="n">varEx</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">resolve</span><span class="p">(</span><span class="n">resolution</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">resolution</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">InconsistentTypeHierarchyException</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="n">signature</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">variable</span><span class="o">.</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">varEx</span> <span class="ow">in</span> <span class="n">signature</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">variable</span><span class="o">.</span><span class="n">name</span><span class="p">]:</span>
            <span class="n">varEx</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">resolution</span>

<div class="viewcode-block" id="ConstantExpression.free"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.ConstantExpression.free">[docs]</a>    <span class="k">def</span> <span class="nf">free</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;:see: Expression.free()&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">set</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="ConstantExpression.constants"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.ConstantExpression.constants">[docs]</a>    <span class="k">def</span> <span class="nf">constants</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;:see: Expression.constants()&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">set</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">variable</span><span class="p">])</span>

</div></div>
<div class="viewcode-block" id="VariableExpression"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.VariableExpression">[docs]</a><span class="k">def</span> <span class="nf">VariableExpression</span><span class="p">(</span><span class="n">variable</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This is a factory method that instantiates and returns a subtype of</span>
<span class="sd">    ``AbstractVariableExpression`` appropriate for the given variable.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">Variable</span><span class="p">),</span> <span class="s">&quot;</span><span class="si">%s</span><span class="s"> is not a Variable&quot;</span> <span class="o">%</span> <span class="n">variable</span>
    <span class="k">if</span> <span class="n">is_indvar</span><span class="p">(</span><span class="n">variable</span><span class="o">.</span><span class="n">name</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">IndividualVariableExpression</span><span class="p">(</span><span class="n">variable</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">is_funcvar</span><span class="p">(</span><span class="n">variable</span><span class="o">.</span><span class="n">name</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">FunctionVariableExpression</span><span class="p">(</span><span class="n">variable</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">is_eventvar</span><span class="p">(</span><span class="n">variable</span><span class="o">.</span><span class="n">name</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">EventVariableExpression</span><span class="p">(</span><span class="n">variable</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ConstantExpression</span><span class="p">(</span><span class="n">variable</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="VariableBinderExpression"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.VariableBinderExpression">[docs]</a><span class="k">class</span> <span class="nc">VariableBinderExpression</span><span class="p">(</span><span class="n">Expression</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This an abstract class for any Expression that binds a variable in an</span>
<span class="sd">    Expression.  This includes LambdaExpressions and Quantified Expressions&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variable</span><span class="p">,</span> <span class="n">term</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param variable: ``Variable``, for the variable</span>
<span class="sd">        :param term: ``Expression``, for the term</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">Variable</span><span class="p">),</span> <span class="s">&quot;</span><span class="si">%s</span><span class="s"> is not a Variable&quot;</span> <span class="o">%</span> <span class="n">variable</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">term</span><span class="p">,</span> <span class="n">Expression</span><span class="p">),</span> <span class="s">&quot;</span><span class="si">%s</span><span class="s"> is not an Expression&quot;</span> <span class="o">%</span> <span class="n">term</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">variable</span> <span class="o">=</span> <span class="n">variable</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">term</span> <span class="o">=</span> <span class="n">term</span>

<div class="viewcode-block" id="VariableBinderExpression.replace"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.VariableBinderExpression.replace">[docs]</a>    <span class="k">def</span> <span class="nf">replace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variable</span><span class="p">,</span> <span class="n">expression</span><span class="p">,</span> <span class="n">replace_bound</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">alpha_convert</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;:see: Expression.replace()&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">Variable</span><span class="p">),</span> <span class="s">&quot;</span><span class="si">%s</span><span class="s"> is not a Variable&quot;</span> <span class="o">%</span> <span class="n">variable</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expression</span><span class="p">,</span> <span class="n">Expression</span><span class="p">),</span> <span class="s">&quot;</span><span class="si">%s</span><span class="s"> is not an Expression&quot;</span> <span class="o">%</span> <span class="n">expression</span>
        <span class="c">#if the bound variable is the thing being replaced</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable</span> <span class="o">==</span> <span class="n">variable</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">replace_bound</span><span class="p">:</span>
                <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expression</span><span class="p">,</span> <span class="n">AbstractVariableExpression</span><span class="p">),</span>\
                       <span class="s">&quot;</span><span class="si">%s</span><span class="s"> is not a AbstractVariableExpression&quot;</span> <span class="o">%</span> <span class="n">expression</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span><span class="n">expression</span><span class="o">.</span><span class="n">variable</span><span class="p">,</span>
                                      <span class="bp">self</span><span class="o">.</span><span class="n">term</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">expression</span><span class="p">,</span> <span class="bp">True</span><span class="p">,</span> <span class="n">alpha_convert</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># if the bound variable appears in the expression, then it must</span>
            <span class="c"># be alpha converted to avoid a conflict</span>
            <span class="k">if</span> <span class="n">alpha_convert</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable</span> <span class="ow">in</span> <span class="n">expression</span><span class="o">.</span><span class="n">free</span><span class="p">():</span>
                <span class="bp">self</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha_convert</span><span class="p">(</span><span class="n">unique_variable</span><span class="p">(</span><span class="n">pattern</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">variable</span><span class="p">))</span>

            <span class="c">#replace in the term</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variable</span><span class="p">,</span>
                                  <span class="bp">self</span><span class="o">.</span><span class="n">term</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">expression</span><span class="p">,</span> <span class="n">replace_bound</span><span class="p">,</span> <span class="n">alpha_convert</span><span class="p">))</span>
</div>
<div class="viewcode-block" id="VariableBinderExpression.alpha_convert"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.VariableBinderExpression.alpha_convert">[docs]</a>    <span class="k">def</span> <span class="nf">alpha_convert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">newvar</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Rename all occurrences of the variable introduced by this variable</span>
<span class="sd">        binder in the expression to ``newvar``.</span>
<span class="sd">        :param newvar: ``Variable``, for the new variable</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">newvar</span><span class="p">,</span> <span class="n">Variable</span><span class="p">),</span> <span class="s">&quot;</span><span class="si">%s</span><span class="s"> is not a Variable&quot;</span> <span class="o">%</span> <span class="n">newvar</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span><span class="n">newvar</span><span class="p">,</span>
                              <span class="bp">self</span><span class="o">.</span><span class="n">term</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variable</span><span class="p">,</span>
                                                <span class="n">VariableExpression</span><span class="p">(</span><span class="n">newvar</span><span class="p">),</span>
                                                <span class="bp">True</span><span class="p">))</span>
</div>
<div class="viewcode-block" id="VariableBinderExpression.free"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.VariableBinderExpression.free">[docs]</a>    <span class="k">def</span> <span class="nf">free</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;:see: Expression.free()&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">term</span><span class="o">.</span><span class="n">free</span><span class="p">()</span> <span class="o">-</span> <span class="nb">set</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">variable</span><span class="p">])</span>
</div>
<div class="viewcode-block" id="VariableBinderExpression.findtype"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.VariableBinderExpression.findtype">[docs]</a>    <span class="k">def</span> <span class="nf">findtype</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variable</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;:see Expression.findtype()&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">Variable</span><span class="p">),</span> <span class="s">&quot;</span><span class="si">%s</span><span class="s"> is not a Variable&quot;</span> <span class="o">%</span> <span class="n">variable</span>
        <span class="k">if</span> <span class="n">variable</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ANY_TYPE</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">term</span><span class="o">.</span><span class="n">findtype</span><span class="p">(</span><span class="n">variable</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="VariableBinderExpression.visit"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.VariableBinderExpression.visit">[docs]</a>    <span class="k">def</span> <span class="nf">visit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">combinator</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;:see: Expression.visit()&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">combinator</span><span class="p">([</span><span class="n">function</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">term</span><span class="p">)])</span>
</div>
<div class="viewcode-block" id="VariableBinderExpression.visit_structured"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.VariableBinderExpression.visit_structured">[docs]</a>    <span class="k">def</span> <span class="nf">visit_structured</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">combinator</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;:see: Expression.visit_structured()&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">combinator</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variable</span><span class="p">,</span> <span class="n">function</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">term</span><span class="p">))</span>
</div>
    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;Defines equality modulo alphabetic variance.  If we are comparing</span>
<span class="sd">        \x.M  and \y.N, then check equality of M and N[x/y].&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">__class__</span><span class="p">)</span> <span class="ow">or</span> \
           <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">variable</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">term</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">term</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c"># Comparing \x.M  and \y.N.  Relabel y in N with x and continue.</span>
                <span class="n">varex</span> <span class="o">=</span> <span class="n">VariableExpression</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variable</span><span class="p">)</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">term</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">term</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">variable</span><span class="p">,</span> <span class="n">varex</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>

    <span class="k">def</span> <span class="nf">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span>

    <span class="n">__hash__</span> <span class="o">=</span> <span class="n">Expression</span><span class="o">.</span><span class="n">__hash__</span>

</div>
<span class="nd">@python_2_unicode_compatible</span>
<div class="viewcode-block" id="LambdaExpression"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.LambdaExpression">[docs]</a><span class="k">class</span> <span class="nc">LambdaExpression</span><span class="p">(</span><span class="n">VariableBinderExpression</span><span class="p">):</span>
    <span class="nd">@property</span>
<div class="viewcode-block" id="LambdaExpression.type"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.LambdaExpression.type">[docs]</a>    <span class="k">def</span> <span class="nf">type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">ComplexType</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">term</span><span class="o">.</span><span class="n">findtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variable</span><span class="p">),</span>
                           <span class="bp">self</span><span class="o">.</span><span class="n">term</span><span class="o">.</span><span class="n">type</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">_set_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_type</span><span class="o">=</span><span class="n">ANY_TYPE</span><span class="p">,</span> <span class="n">signature</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;:see Expression._set_type()&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other_type</span><span class="p">,</span> <span class="n">Type</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">signature</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">signature</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">term</span><span class="o">.</span><span class="n">_set_type</span><span class="p">(</span><span class="n">other_type</span><span class="o">.</span><span class="n">second</span><span class="p">,</span> <span class="n">signature</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">resolve</span><span class="p">(</span><span class="n">other_type</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">TypeResolutionException</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_type</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">variables</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">variable</span><span class="p">]</span>
        <span class="n">term</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">term</span>
        <span class="k">while</span> <span class="n">term</span><span class="o">.</span><span class="n">__class__</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">:</span>
            <span class="n">variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">term</span><span class="o">.</span><span class="n">variable</span><span class="p">)</span>
            <span class="n">term</span> <span class="o">=</span> <span class="n">term</span><span class="o">.</span><span class="n">term</span>
        <span class="k">return</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">LAMBDA</span> <span class="o">+</span> <span class="s">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">)</span> <span class="o">+</span> \
               <span class="n">Tokens</span><span class="o">.</span><span class="n">DOT</span> <span class="o">+</span> <span class="s">&quot;</span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">term</span>

</div>
<span class="nd">@python_2_unicode_compatible</span>
<div class="viewcode-block" id="QuantifiedExpression"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.QuantifiedExpression">[docs]</a><span class="k">class</span> <span class="nc">QuantifiedExpression</span><span class="p">(</span><span class="n">VariableBinderExpression</span><span class="p">):</span>
    <span class="nd">@property</span>
<div class="viewcode-block" id="QuantifiedExpression.type"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.QuantifiedExpression.type">[docs]</a>    <span class="k">def</span> <span class="nf">type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="n">TRUTH_TYPE</span>
</div>
    <span class="k">def</span> <span class="nf">_set_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_type</span><span class="o">=</span><span class="n">ANY_TYPE</span><span class="p">,</span> <span class="n">signature</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;:see Expression._set_type()&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other_type</span><span class="p">,</span> <span class="n">Type</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">signature</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">signature</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">other_type</span><span class="o">.</span><span class="n">matches</span><span class="p">(</span><span class="n">TRUTH_TYPE</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">IllegalTypeException</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_type</span><span class="p">,</span> <span class="n">TRUTH_TYPE</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">term</span><span class="o">.</span><span class="n">_set_type</span><span class="p">(</span><span class="n">TRUTH_TYPE</span><span class="p">,</span> <span class="n">signature</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">variables</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">variable</span><span class="p">]</span>
        <span class="n">term</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">term</span>
        <span class="k">while</span> <span class="n">term</span><span class="o">.</span><span class="n">__class__</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">:</span>
            <span class="n">variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">term</span><span class="o">.</span><span class="n">variable</span><span class="p">)</span>
            <span class="n">term</span> <span class="o">=</span> <span class="n">term</span><span class="o">.</span><span class="n">term</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">getQuantifier</span><span class="p">()</span> <span class="o">+</span> <span class="s">&#39; &#39;</span> <span class="o">+</span> <span class="s">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">)</span> <span class="o">+</span> \
               <span class="n">Tokens</span><span class="o">.</span><span class="n">DOT</span> <span class="o">+</span> <span class="s">&quot;</span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">term</span>
</div>
<div class="viewcode-block" id="ExistsExpression"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.ExistsExpression">[docs]</a><span class="k">class</span> <span class="nc">ExistsExpression</span><span class="p">(</span><span class="n">QuantifiedExpression</span><span class="p">):</span>
<div class="viewcode-block" id="ExistsExpression.getQuantifier"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.ExistsExpression.getQuantifier">[docs]</a>    <span class="k">def</span> <span class="nf">getQuantifier</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">EXISTS</span>
</div></div>
<div class="viewcode-block" id="AllExpression"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.AllExpression">[docs]</a><span class="k">class</span> <span class="nc">AllExpression</span><span class="p">(</span><span class="n">QuantifiedExpression</span><span class="p">):</span>
<div class="viewcode-block" id="AllExpression.getQuantifier"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.AllExpression.getQuantifier">[docs]</a>    <span class="k">def</span> <span class="nf">getQuantifier</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">ALL</span>

</div></div>
<span class="nd">@python_2_unicode_compatible</span>
<div class="viewcode-block" id="NegatedExpression"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.NegatedExpression">[docs]</a><span class="k">class</span> <span class="nc">NegatedExpression</span><span class="p">(</span><span class="n">Expression</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">term</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">term</span><span class="p">,</span> <span class="n">Expression</span><span class="p">),</span> <span class="s">&quot;</span><span class="si">%s</span><span class="s"> is not an Expression&quot;</span> <span class="o">%</span> <span class="n">term</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">term</span> <span class="o">=</span> <span class="n">term</span>

    <span class="nd">@property</span>
<div class="viewcode-block" id="NegatedExpression.type"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.NegatedExpression.type">[docs]</a>    <span class="k">def</span> <span class="nf">type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="n">TRUTH_TYPE</span>
</div>
    <span class="k">def</span> <span class="nf">_set_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_type</span><span class="o">=</span><span class="n">ANY_TYPE</span><span class="p">,</span> <span class="n">signature</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;:see Expression._set_type()&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other_type</span><span class="p">,</span> <span class="n">Type</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">signature</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">signature</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">other_type</span><span class="o">.</span><span class="n">matches</span><span class="p">(</span><span class="n">TRUTH_TYPE</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">IllegalTypeException</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_type</span><span class="p">,</span> <span class="n">TRUTH_TYPE</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">term</span><span class="o">.</span><span class="n">_set_type</span><span class="p">(</span><span class="n">TRUTH_TYPE</span><span class="p">,</span> <span class="n">signature</span><span class="p">)</span>

<div class="viewcode-block" id="NegatedExpression.findtype"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.NegatedExpression.findtype">[docs]</a>    <span class="k">def</span> <span class="nf">findtype</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variable</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">Variable</span><span class="p">),</span> <span class="s">&quot;</span><span class="si">%s</span><span class="s"> is not a Variable&quot;</span> <span class="o">%</span> <span class="n">variable</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">term</span><span class="o">.</span><span class="n">findtype</span><span class="p">(</span><span class="n">variable</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="NegatedExpression.visit"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.NegatedExpression.visit">[docs]</a>    <span class="k">def</span> <span class="nf">visit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">combinator</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;:see: Expression.visit()&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">combinator</span><span class="p">([</span><span class="n">function</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">term</span><span class="p">)])</span>
</div>
<div class="viewcode-block" id="NegatedExpression.negate"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.NegatedExpression.negate">[docs]</a>    <span class="k">def</span> <span class="nf">negate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;:see: Expression.negate()&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">term</span>
</div>
    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">NegatedExpression</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">term</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">term</span>

    <span class="k">def</span> <span class="nf">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span>

    <span class="n">__hash__</span> <span class="o">=</span> <span class="n">Expression</span><span class="o">.</span><span class="n">__hash__</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">NOT</span> <span class="o">+</span> <span class="s">&quot;</span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">term</span>

</div>
<span class="nd">@python_2_unicode_compatible</span>
<div class="viewcode-block" id="BinaryExpression"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.BinaryExpression">[docs]</a><span class="k">class</span> <span class="nc">BinaryExpression</span><span class="p">(</span><span class="n">Expression</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">first</span><span class="p">,</span> <span class="n">second</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">Expression</span><span class="p">),</span> <span class="s">&quot;</span><span class="si">%s</span><span class="s"> is not an Expression&quot;</span> <span class="o">%</span> <span class="n">first</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">second</span><span class="p">,</span> <span class="n">Expression</span><span class="p">),</span> <span class="s">&quot;</span><span class="si">%s</span><span class="s"> is not an Expression&quot;</span> <span class="o">%</span> <span class="n">second</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">first</span> <span class="o">=</span> <span class="n">first</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">second</span> <span class="o">=</span> <span class="n">second</span>

    <span class="nd">@property</span>
<div class="viewcode-block" id="BinaryExpression.type"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.BinaryExpression.type">[docs]</a>    <span class="k">def</span> <span class="nf">type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="n">TRUTH_TYPE</span>
</div>
<div class="viewcode-block" id="BinaryExpression.findtype"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.BinaryExpression.findtype">[docs]</a>    <span class="k">def</span> <span class="nf">findtype</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variable</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;:see Expression.findtype()&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">Variable</span><span class="p">),</span> <span class="s">&quot;</span><span class="si">%s</span><span class="s"> is not a Variable&quot;</span> <span class="o">%</span> <span class="n">variable</span>
        <span class="n">f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">first</span><span class="o">.</span><span class="n">findtype</span><span class="p">(</span><span class="n">variable</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">second</span><span class="o">.</span><span class="n">findtype</span><span class="p">(</span><span class="n">variable</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">f</span> <span class="o">==</span> <span class="n">s</span> <span class="ow">or</span> <span class="n">s</span> <span class="o">==</span> <span class="n">ANY_TYPE</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">f</span>
        <span class="k">elif</span> <span class="n">f</span> <span class="o">==</span> <span class="n">ANY_TYPE</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">s</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ANY_TYPE</span>
</div>
<div class="viewcode-block" id="BinaryExpression.visit"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.BinaryExpression.visit">[docs]</a>    <span class="k">def</span> <span class="nf">visit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">combinator</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;:see: Expression.visit()&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">combinator</span><span class="p">([</span><span class="n">function</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">first</span><span class="p">),</span> <span class="n">function</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">second</span><span class="p">)])</span>
</div>
    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">__class__</span><span class="p">)</span> <span class="ow">or</span> \
                <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">))</span> <span class="ow">and</span> \
               <span class="bp">self</span><span class="o">.</span><span class="n">first</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">first</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">second</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">second</span>

    <span class="k">def</span> <span class="nf">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span>

    <span class="n">__hash__</span> <span class="o">=</span> <span class="n">Expression</span><span class="o">.</span><span class="n">__hash__</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">first</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_str_subex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">first</span><span class="p">)</span>
        <span class="n">second</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_str_subex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">second</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">OPEN</span> <span class="o">+</span> <span class="n">first</span> <span class="o">+</span> <span class="s">&#39; &#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">getOp</span><span class="p">()</span> \
                <span class="o">+</span> <span class="s">&#39; &#39;</span> <span class="o">+</span> <span class="n">second</span> <span class="o">+</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">CLOSE</span>

    <span class="k">def</span> <span class="nf">_str_subex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">subex</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;</span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">subex</span>

</div>
<div class="viewcode-block" id="BooleanExpression"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.BooleanExpression">[docs]</a><span class="k">class</span> <span class="nc">BooleanExpression</span><span class="p">(</span><span class="n">BinaryExpression</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">_set_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_type</span><span class="o">=</span><span class="n">ANY_TYPE</span><span class="p">,</span> <span class="n">signature</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;:see Expression._set_type()&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other_type</span><span class="p">,</span> <span class="n">Type</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">signature</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">signature</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">other_type</span><span class="o">.</span><span class="n">matches</span><span class="p">(</span><span class="n">TRUTH_TYPE</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">IllegalTypeException</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_type</span><span class="p">,</span> <span class="n">TRUTH_TYPE</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">first</span><span class="o">.</span><span class="n">_set_type</span><span class="p">(</span><span class="n">TRUTH_TYPE</span><span class="p">,</span> <span class="n">signature</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">second</span><span class="o">.</span><span class="n">_set_type</span><span class="p">(</span><span class="n">TRUTH_TYPE</span><span class="p">,</span> <span class="n">signature</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="AndExpression"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.AndExpression">[docs]</a><span class="k">class</span> <span class="nc">AndExpression</span><span class="p">(</span><span class="n">BooleanExpression</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This class represents conjunctions&quot;&quot;&quot;</span>
<div class="viewcode-block" id="AndExpression.getOp"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.AndExpression.getOp">[docs]</a>    <span class="k">def</span> <span class="nf">getOp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">AND</span>
</div>
    <span class="k">def</span> <span class="nf">_str_subex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">subex</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="s">&quot;</span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">subex</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">subex</span><span class="p">,</span> <span class="n">AndExpression</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">s</span>
</div>
<div class="viewcode-block" id="OrExpression"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.OrExpression">[docs]</a><span class="k">class</span> <span class="nc">OrExpression</span><span class="p">(</span><span class="n">BooleanExpression</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This class represents disjunctions&quot;&quot;&quot;</span>
<div class="viewcode-block" id="OrExpression.getOp"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.OrExpression.getOp">[docs]</a>    <span class="k">def</span> <span class="nf">getOp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">OR</span>
</div>
    <span class="k">def</span> <span class="nf">_str_subex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">subex</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="s">&quot;</span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">subex</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">subex</span><span class="p">,</span> <span class="n">OrExpression</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">s</span>
</div>
<div class="viewcode-block" id="ImpExpression"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.ImpExpression">[docs]</a><span class="k">class</span> <span class="nc">ImpExpression</span><span class="p">(</span><span class="n">BooleanExpression</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This class represents implications&quot;&quot;&quot;</span>
<div class="viewcode-block" id="ImpExpression.getOp"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.ImpExpression.getOp">[docs]</a>    <span class="k">def</span> <span class="nf">getOp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">IMP</span>
</div></div>
<div class="viewcode-block" id="IffExpression"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.IffExpression">[docs]</a><span class="k">class</span> <span class="nc">IffExpression</span><span class="p">(</span><span class="n">BooleanExpression</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This class represents biconditionals&quot;&quot;&quot;</span>
<div class="viewcode-block" id="IffExpression.getOp"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.IffExpression.getOp">[docs]</a>    <span class="k">def</span> <span class="nf">getOp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">IFF</span>

</div></div>
<div class="viewcode-block" id="EqualityExpression"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.EqualityExpression">[docs]</a><span class="k">class</span> <span class="nc">EqualityExpression</span><span class="p">(</span><span class="n">BinaryExpression</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This class represents equality expressions like &quot;(x = y)&quot;.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">_set_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_type</span><span class="o">=</span><span class="n">ANY_TYPE</span><span class="p">,</span> <span class="n">signature</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;:see Expression._set_type()&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other_type</span><span class="p">,</span> <span class="n">Type</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">signature</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">signature</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">other_type</span><span class="o">.</span><span class="n">matches</span><span class="p">(</span><span class="n">TRUTH_TYPE</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">IllegalTypeException</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_type</span><span class="p">,</span> <span class="n">TRUTH_TYPE</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">first</span><span class="o">.</span><span class="n">_set_type</span><span class="p">(</span><span class="n">ENTITY_TYPE</span><span class="p">,</span> <span class="n">signature</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">second</span><span class="o">.</span><span class="n">_set_type</span><span class="p">(</span><span class="n">ENTITY_TYPE</span><span class="p">,</span> <span class="n">signature</span><span class="p">)</span>

<div class="viewcode-block" id="EqualityExpression.getOp"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.EqualityExpression.getOp">[docs]</a>    <span class="k">def</span> <span class="nf">getOp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">EQ</span>


<span class="c">### Utilities</span>
</div></div>
<div class="viewcode-block" id="StringTrie"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.StringTrie">[docs]</a><span class="k">class</span> <span class="nc">StringTrie</span><span class="p">(</span><span class="n">defaultdict</span><span class="p">):</span>
    <span class="n">LEAF</span> <span class="o">=</span> <span class="s">&quot;&lt;leaf&gt;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">strings</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="n">defaultdict</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">StringTrie</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">strings</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">string</span> <span class="ow">in</span> <span class="n">strings</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>

<div class="viewcode-block" id="StringTrie.insert"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.StringTrie.insert">[docs]</a>    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">string</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">string</span><span class="p">):</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">string</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">string</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c">#mark the string is complete</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">StringTrie</span><span class="o">.</span><span class="n">LEAF</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span>

</div></div>
<div class="viewcode-block" id="LogicalExpressionException"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.LogicalExpressionException">[docs]</a><span class="k">class</span> <span class="nc">LogicalExpressionException</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">message</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">index</span>
        <span class="ne">Exception</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="UnexpectedTokenException"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.UnexpectedTokenException">[docs]</a><span class="k">class</span> <span class="nc">UnexpectedTokenException</span><span class="p">(</span><span class="n">LogicalExpressionException</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">unexpected</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">expected</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">unexpected</span> <span class="ow">and</span> <span class="n">expected</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s">&quot;Unexpected token: &#39;</span><span class="si">%s</span><span class="s">&#39;.  &quot;</span> \
                  <span class="s">&quot;Expected token &#39;</span><span class="si">%s</span><span class="s">&#39;.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">unexpected</span><span class="p">,</span> <span class="n">expected</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">unexpected</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s">&quot;Unexpected token: &#39;</span><span class="si">%s</span><span class="s">&#39;.&quot;</span> <span class="o">%</span> <span class="n">unexpected</span>
            <span class="k">if</span> <span class="n">message</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">+=</span> <span class="s">&#39;  &#39;</span><span class="o">+</span><span class="n">message</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s">&quot;Expected token &#39;</span><span class="si">%s</span><span class="s">&#39;.&quot;</span> <span class="o">%</span> <span class="n">expected</span>
        <span class="n">LogicalExpressionException</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="ExpectedMoreTokensException"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.ExpectedMoreTokensException">[docs]</a><span class="k">class</span> <span class="nc">ExpectedMoreTokensException</span><span class="p">(</span><span class="n">LogicalExpressionException</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">message</span><span class="p">:</span>
            <span class="n">message</span> <span class="o">=</span> <span class="s">&#39;More tokens expected.&#39;</span>
        <span class="n">LogicalExpressionException</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="s">&#39;End of input found.  &#39;</span> <span class="o">+</span> <span class="n">message</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="is_indvar"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.is_indvar">[docs]</a><span class="k">def</span> <span class="nf">is_indvar</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An individual variable must be a single lowercase character other than &#39;e&#39;,</span>
<span class="sd">    followed by zero or more digits.</span>

<span class="sd">    :param expr: str</span>
<span class="sd">    :return: bool True if expr is of the correct form</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">string_types</span><span class="p">),</span> <span class="s">&quot;</span><span class="si">%s</span><span class="s"> is not a string&quot;</span> <span class="o">%</span> <span class="n">expr</span>
    <span class="k">return</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s">r&#39;^[a-df-z]\d*$&#39;</span><span class="p">,</span> <span class="n">expr</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span>
</div>
<div class="viewcode-block" id="is_funcvar"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.is_funcvar">[docs]</a><span class="k">def</span> <span class="nf">is_funcvar</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A function variable must be a single uppercase character followed by</span>
<span class="sd">    zero or more digits.</span>

<span class="sd">    :param expr: str</span>
<span class="sd">    :return: bool True if expr is of the correct form</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">string_types</span><span class="p">),</span> <span class="s">&quot;</span><span class="si">%s</span><span class="s"> is not a string&quot;</span> <span class="o">%</span> <span class="n">expr</span>
    <span class="k">return</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s">r&#39;^[A-Z]\d*$&#39;</span><span class="p">,</span> <span class="n">expr</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span>
</div>
<div class="viewcode-block" id="is_eventvar"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.is_eventvar">[docs]</a><span class="k">def</span> <span class="nf">is_eventvar</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An event variable must be a single lowercase &#39;e&#39; character followed by</span>
<span class="sd">    zero or more digits.</span>

<span class="sd">    :param expr: str</span>
<span class="sd">    :return: bool True if expr is of the correct form</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">string_types</span><span class="p">),</span> <span class="s">&quot;</span><span class="si">%s</span><span class="s"> is not a string&quot;</span> <span class="o">%</span> <span class="n">expr</span>
    <span class="k">return</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s">r&#39;^e\d*$&#39;</span><span class="p">,</span> <span class="n">expr</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span>

</div>
<div class="viewcode-block" id="demo"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.demo">[docs]</a><span class="k">def</span> <span class="nf">demo</span><span class="p">():</span>
    <span class="n">lexpr</span> <span class="o">=</span> <span class="n">Expression</span><span class="o">.</span><span class="n">fromstring</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;=&#39;</span><span class="o">*</span><span class="mi">20</span> <span class="o">+</span> <span class="s">&#39;Test parser&#39;</span> <span class="o">+</span> <span class="s">&#39;=&#39;</span><span class="o">*</span><span class="mi">20</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">lexpr</span><span class="p">(</span><span class="s">r&#39;john&#39;</span><span class="p">))</span>
    <span class="k">print</span><span class="p">(</span><span class="n">lexpr</span><span class="p">(</span><span class="s">r&#39;man(x)&#39;</span><span class="p">))</span>
    <span class="k">print</span><span class="p">(</span><span class="n">lexpr</span><span class="p">(</span><span class="s">r&#39;-man(x)&#39;</span><span class="p">))</span>
    <span class="k">print</span><span class="p">(</span><span class="n">lexpr</span><span class="p">(</span><span class="s">r&#39;(man(x) &amp; tall(x) &amp; walks(x))&#39;</span><span class="p">))</span>
    <span class="k">print</span><span class="p">(</span><span class="n">lexpr</span><span class="p">(</span><span class="s">r&#39;exists x.(man(x) &amp; tall(x) &amp; walks(x))&#39;</span><span class="p">))</span>
    <span class="k">print</span><span class="p">(</span><span class="n">lexpr</span><span class="p">(</span><span class="s">r&#39;\x.man(x)&#39;</span><span class="p">))</span>
    <span class="k">print</span><span class="p">(</span><span class="n">lexpr</span><span class="p">(</span><span class="s">r&#39;\x.man(x)(john)&#39;</span><span class="p">))</span>
    <span class="k">print</span><span class="p">(</span><span class="n">lexpr</span><span class="p">(</span><span class="s">r&#39;\x y.sees(x,y)&#39;</span><span class="p">))</span>
    <span class="k">print</span><span class="p">(</span><span class="n">lexpr</span><span class="p">(</span><span class="s">r&#39;\x y.sees(x,y)(a,b)&#39;</span><span class="p">))</span>
    <span class="k">print</span><span class="p">(</span><span class="n">lexpr</span><span class="p">(</span><span class="s">r&#39;(\x.exists y.walks(x,y))(x)&#39;</span><span class="p">))</span>
    <span class="k">print</span><span class="p">(</span><span class="n">lexpr</span><span class="p">(</span><span class="s">r&#39;exists x.x = y&#39;</span><span class="p">))</span>
    <span class="k">print</span><span class="p">(</span><span class="n">lexpr</span><span class="p">(</span><span class="s">r&#39;exists x.(x = y)&#39;</span><span class="p">))</span>
    <span class="k">print</span><span class="p">(</span><span class="n">lexpr</span><span class="p">(</span><span class="s">&#39;P(x) &amp; x=y &amp; P(y)&#39;</span><span class="p">))</span>
    <span class="k">print</span><span class="p">(</span><span class="n">lexpr</span><span class="p">(</span><span class="s">r&#39;\P Q.exists x.(P(x) &amp; Q(x))&#39;</span><span class="p">))</span>
    <span class="k">print</span><span class="p">(</span><span class="n">lexpr</span><span class="p">(</span><span class="s">r&#39;man(x) &lt;-&gt; tall(x)&#39;</span><span class="p">))</span>

    <span class="k">print</span><span class="p">(</span><span class="s">&#39;=&#39;</span><span class="o">*</span><span class="mi">20</span> <span class="o">+</span> <span class="s">&#39;Test simplify&#39;</span> <span class="o">+</span> <span class="s">&#39;=&#39;</span><span class="o">*</span><span class="mi">20</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">lexpr</span><span class="p">(</span><span class="s">r&#39;\x.\y.sees(x,y)(john)(mary)&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">simplify</span><span class="p">())</span>
    <span class="k">print</span><span class="p">(</span><span class="n">lexpr</span><span class="p">(</span><span class="s">r&#39;\x.\y.sees(x,y)(john, mary)&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">simplify</span><span class="p">())</span>
    <span class="k">print</span><span class="p">(</span><span class="n">lexpr</span><span class="p">(</span><span class="s">r&#39;all x.(man(x) &amp; (\x.exists y.walks(x,y))(x))&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">simplify</span><span class="p">())</span>
    <span class="k">print</span><span class="p">(</span><span class="n">lexpr</span><span class="p">(</span><span class="s">r&#39;(\P.\Q.exists x.(P(x) &amp; Q(x)))(\x.dog(x))(\x.bark(x))&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">simplify</span><span class="p">())</span>

    <span class="k">print</span><span class="p">(</span><span class="s">&#39;=&#39;</span><span class="o">*</span><span class="mi">20</span> <span class="o">+</span> <span class="s">&#39;Test alpha conversion and binder expression equality&#39;</span> <span class="o">+</span> <span class="s">&#39;=&#39;</span><span class="o">*</span><span class="mi">20</span><span class="p">)</span>
    <span class="n">e1</span> <span class="o">=</span> <span class="n">p</span><span class="p">(</span><span class="s">&#39;exists x.P(x)&#39;</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">e1</span><span class="p">)</span>
    <span class="n">e2</span> <span class="o">=</span> <span class="n">e1</span><span class="o">.</span><span class="n">alpha_convert</span><span class="p">(</span><span class="n">Variable</span><span class="p">(</span><span class="s">&#39;z&#39;</span><span class="p">))</span>
    <span class="k">print</span><span class="p">(</span><span class="n">e2</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">e1</span> <span class="o">==</span> <span class="n">e2</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="demo_errors"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.demo_errors">[docs]</a><span class="k">def</span> <span class="nf">demo_errors</span><span class="p">():</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;=&#39;</span><span class="o">*</span><span class="mi">20</span> <span class="o">+</span> <span class="s">&#39;Test parser errors&#39;</span> <span class="o">+</span> <span class="s">&#39;=&#39;</span><span class="o">*</span><span class="mi">20</span><span class="p">)</span>
    <span class="n">demoException</span><span class="p">(</span><span class="s">&#39;(P(x) &amp; Q(x)&#39;</span><span class="p">)</span>
    <span class="n">demoException</span><span class="p">(</span><span class="s">&#39;((P(x) &amp;) &amp; Q(x))&#39;</span><span class="p">)</span>
    <span class="n">demoException</span><span class="p">(</span><span class="s">&#39;P(x) -&gt; &#39;</span><span class="p">)</span>
    <span class="n">demoException</span><span class="p">(</span><span class="s">&#39;P(x&#39;</span><span class="p">)</span>
    <span class="n">demoException</span><span class="p">(</span><span class="s">&#39;P(x,&#39;</span><span class="p">)</span>
    <span class="n">demoException</span><span class="p">(</span><span class="s">&#39;P(x,)&#39;</span><span class="p">)</span>
    <span class="n">demoException</span><span class="p">(</span><span class="s">&#39;exists&#39;</span><span class="p">)</span>
    <span class="n">demoException</span><span class="p">(</span><span class="s">&#39;exists x.&#39;</span><span class="p">)</span>
    <span class="n">demoException</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\\</span><span class="s">&#39;</span><span class="p">)</span>
    <span class="n">demoException</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\\</span><span class="s"> x y.&#39;</span><span class="p">)</span>
    <span class="n">demoException</span><span class="p">(</span><span class="s">&#39;P(x)Q(x)&#39;</span><span class="p">)</span>
    <span class="n">demoException</span><span class="p">(</span><span class="s">&#39;(P(x)Q(x)&#39;</span><span class="p">)</span>
    <span class="n">demoException</span><span class="p">(</span><span class="s">&#39;exists x -&gt; y&#39;</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="demoException"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.demoException">[docs]</a><span class="k">def</span> <span class="nf">demoException</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">Expression</span><span class="o">.</span><span class="n">fromstring</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    <span class="k">except</span> <span class="n">LogicalExpressionException</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%s</span><span class="s">: </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span> <span class="n">e</span><span class="p">))</span>
</div>
<div class="viewcode-block" id="printtype"><a class="viewcode-back" href="../../../api/nltk.sem.html#nltk.sem.logic.printtype">[docs]</a><span class="k">def</span> <span class="nf">printtype</span><span class="p">(</span><span class="n">ex</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%s</span><span class="s"> : </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">ex</span><span class="o">.</span><span class="n">str</span><span class="p">(),</span> <span class="n">ex</span><span class="o">.</span><span class="n">type</span><span class="p">))</span>
</div>
<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">demo</span><span class="p">()</span>
    <span class="n">demo_errors</span><span class="p">()</span>
</pre></div>

          </div>
        </div>
      </div>
        </div>
        <div class="sidebar">
          <h3>Table Of Contents</h3>
          <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../news.html">NLTK News</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../install.html">Installing NLTK</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../data.html">Installing NLTK Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../contribute.html">Contribute to NLTK</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/nltk/nltk/wiki/FAQ">FAQ</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/nltk/nltk/wiki">Wiki</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/nltk.html">API</a></li>
<li class="toctree-l1"><a class="reference external" href="http://www.nltk.org/howto">HOWTO</a></li>
</ul>

          <h3 style="margin-top: 1.5em;">Search</h3>
          <form class="search" action="../../../search.html" method="get">
            <input type="text" name="q" />
            <input type="submit" value="Go" />
            <input type="hidden" name="check_keywords" value="yes" />
            <input type="hidden" name="area" value="default" />
          </form>
          <p class="searchtip" style="font-size: 90%">
            Enter search terms or a module, class or function name.
          </p>
        </div>
        <div class="clearer"></div>
      </div>
    </div>

    <div class="footer-wrapper">
      <div class="footer">
        <div class="left">
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |
          <a href="../../../genindex.html" title="General Index"
             >index</a>
        </div>

        <div class="right">
          
    <div class="footer">
        &copy; Copyright 2013, NLTK Project.
      Last updated on Jul 09, 2014.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
        </div>
        <div class="clearer"></div>
      </div>
    </div>

  </body>
</html>