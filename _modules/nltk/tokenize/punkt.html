

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>nltk.tokenize.punkt &mdash; NLTK 2.0 documentation</title>
    
    <link rel="stylesheet" href="../../../_static/agogo.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '2.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <link rel="top" title="NLTK 2.0 documentation" href="../../../index.html" />
    <link rel="up" title="nltk.tokenize" href="../tokenize.html" /> 
  </head>
  <body>
    <div class="header-wrapper">
      <div class="header">
        <div class="headertitle"><a
          href="../../../index.html">NLTK 2.0 documentation</a></div>
        <div class="rel">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a>
        </div>
       </div>
    </div>

    <div class="content-wrapper">
      <div class="content">
        <div class="document">
            
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for nltk.tokenize.punkt</h1><div class="highlight"><pre>
<span class="c"># Natural Language Toolkit: Punkt sentence tokenizer</span>
<span class="c">#</span>
<span class="c"># Copyright (C) 2001-2012 NLTK Project</span>
<span class="c"># Algorithm: Kiss &amp; Strunk (2006)</span>
<span class="c"># Author: Willy &lt;willy@csse.unimelb.edu.au&gt; (original Python port)</span>
<span class="c">#         Steven Bird &lt;sb@csse.unimelb.edu.au&gt; (additions)</span>
<span class="c">#         Edward Loper &lt;edloper@gradient.cis.upenn.edu&gt; (rewrite)</span>
<span class="c">#         Joel Nothman &lt;jnothman@student.usyd.edu.au&gt; (almost rewrite)</span>
<span class="c"># URL: &lt;http://www.nltk.org/&gt;</span>
<span class="c"># For license information, see LICENSE.TXT</span>
<span class="c">#</span>
<span class="c"># $Id: probability.py 4865 2007-07-11 22:6:07Z edloper $</span>

<span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">Punkt Sentence Tokenizer</span>

<span class="sd">This tokenizer divides a text into a list of sentences,</span>
<span class="sd">by using an unsupervised algorithm to build a model for abbreviation</span>
<span class="sd">words, collocations, and words that start sentences.  It must be</span>
<span class="sd">trained on a large collection of plaintext in the taret language</span>
<span class="sd">before it can be used.</span>

<span class="sd">The NLTK data package includes a pre-trained Punkt tokenizer for</span>
<span class="sd">English.</span>

<span class="sd">    &gt;&gt;&gt; import nltk.data</span>
<span class="sd">    &gt;&gt;&gt; text = &#39;&#39;&#39;</span>
<span class="sd">    ... Punkt knows that the periods in Mr. Smith and Johann S. Bach</span>
<span class="sd">    ... do not mark sentence boundaries.  And sometimes sentences </span>
<span class="sd">    ... can start with non-capitalized words.  i is a good variable</span>
<span class="sd">    ... name.</span>
<span class="sd">    ... &#39;&#39;&#39;</span>
<span class="sd">    &gt;&gt;&gt; sent_detector = nltk.data.load(&#39;tokenizers/punkt/english.pickle&#39;)</span>
<span class="sd">    &gt;&gt;&gt; print &#39;\n-----\n&#39;.join(sent_detector.tokenize(text.strip()))</span>
<span class="sd">    Punkt knows that the periods in Mr. Smith and Johann S. Bach</span>
<span class="sd">    do not mark sentence boundaries.</span>
<span class="sd">    -----</span>
<span class="sd">    And sometimes sentences </span>
<span class="sd">    can start with non-capitalized words.</span>
<span class="sd">    -----</span>
<span class="sd">    i is a good variable</span>
<span class="sd">    name.</span>

<span class="sd">(Note that whitespace from the original text, including newlines, is</span>
<span class="sd">retained in the output.)</span>

<span class="sd">Punctuation following sentences can be included with the realign_boundaries</span>
<span class="sd">flag:</span>
<span class="sd">   </span>
<span class="sd">    &gt;&gt;&gt; text = &#39;&#39;&#39;</span>
<span class="sd">    ... (How does it deal with this parenthesis?)  &quot;It should be part of the</span>
<span class="sd">    ... previous sentence.&quot;</span>
<span class="sd">    ... &#39;&#39;&#39;</span>
<span class="sd">    &gt;&gt;&gt; print &#39;\n-----\n&#39;.join(</span>
<span class="sd">    ...     sent_detector.tokenize(text.strip(), realign_boundaries=True))</span>
<span class="sd">    (How does it deal with this parenthesis?)</span>
<span class="sd">    -----</span>
<span class="sd">    &quot;It should be part of the</span>
<span class="sd">    previous sentence.&quot;</span>

<span class="sd">:class:`.PunktWordTokenizer` uses a regular expression to divide a text into tokens,</span>
<span class="sd">leaving all periods attached to words, but separating off other punctuation:</span>

<span class="sd">    &gt;&gt;&gt; s = &quot;Good muffins cost $3.88\nin New York.  Please buy me\ntwo of them.\n\nThanks.&quot;</span>
<span class="sd">    &gt;&gt;&gt; PunktWordTokenizer().tokenize(s)</span>
<span class="sd">    [&#39;Good&#39;, &#39;muffins&#39;, &#39;cost&#39;, &#39;$3.88&#39;, &#39;in&#39;, &#39;New&#39;, &#39;York.&#39;, &#39;Please&#39;,</span>
<span class="sd">    &#39;buy&#39;, &#39;me&#39;, &#39;two&#39;, &#39;of&#39;, &#39;them.&#39;, &#39;Thanks.&#39;]</span>

<span class="sd">The algorithm for this tokenizer is described in::</span>

<span class="sd">  Kiss, Tibor and Strunk, Jan (2006): Unsupervised Multilingual Sentence</span>
<span class="sd">    Boundary Detection.  Computational Linguistics 32: 485-525.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c"># TODO: Make orthographic heuristic less susceptible to overtraining</span>
<span class="c"># TODO: Frequent sentence starters optionally exclude always-capitalised words</span>
<span class="c"># FIXME: Problem with ending string with e.g. &#39;!!!&#39; -&gt; &#39;!! !&#39;</span>

<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>

<span class="kn">from</span> <span class="nn">nltk.probability</span> <span class="kn">import</span> <span class="n">FreqDist</span>
<span class="kn">from</span> <span class="nn">nltk.tokenize.api</span> <span class="kn">import</span> <span class="n">TokenizerI</span>

<span class="c">######################################################################</span>
<span class="c">#{ Orthographic Context Constants</span>
<span class="c">######################################################################</span>
<span class="c"># The following constants are used to describe the orthographic</span>
<span class="c"># contexts in which a word can occur.  BEG=beginning, MID=middle,</span>
<span class="c"># UNK=unknown, UC=uppercase, LC=lowercase, NC=no case.</span>

<span class="n">_ORTHO_BEG_UC</span>    <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span>
<span class="sd">&quot;&quot;&quot;Orthographic context: beginning of a sentence with upper case.&quot;&quot;&quot;</span>

<span class="n">_ORTHO_MID_UC</span>    <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span>
<span class="sd">&quot;&quot;&quot;Orthographic context: middle of a sentence with upper case.&quot;&quot;&quot;</span>

<span class="n">_ORTHO_UNK_UC</span>    <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span>
<span class="sd">&quot;&quot;&quot;Orthographic context: unknown position in a sentence with upper case.&quot;&quot;&quot;</span>

<span class="n">_ORTHO_BEG_LC</span>    <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span>
<span class="sd">&quot;&quot;&quot;Orthographic context: beginning of a sentence with lower case.&quot;&quot;&quot;</span>

<span class="n">_ORTHO_MID_LC</span>    <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span>
<span class="sd">&quot;&quot;&quot;Orthographic context: middle of a sentence with lower case.&quot;&quot;&quot;</span>

<span class="n">_ORTHO_UNK_LC</span>    <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span>
<span class="sd">&quot;&quot;&quot;Orthographic context: unknown position in a sentence with lower case.&quot;&quot;&quot;</span>

<span class="n">_ORTHO_UC</span> <span class="o">=</span> <span class="n">_ORTHO_BEG_UC</span> <span class="o">+</span> <span class="n">_ORTHO_MID_UC</span> <span class="o">+</span> <span class="n">_ORTHO_UNK_UC</span>
<span class="sd">&quot;&quot;&quot;Orthographic context: occurs with upper case.&quot;&quot;&quot;</span>

<span class="n">_ORTHO_LC</span> <span class="o">=</span> <span class="n">_ORTHO_BEG_LC</span> <span class="o">+</span> <span class="n">_ORTHO_MID_LC</span> <span class="o">+</span> <span class="n">_ORTHO_UNK_LC</span>
<span class="sd">&quot;&quot;&quot;Orthographic context: occurs with lower case.&quot;&quot;&quot;</span>

<span class="n">_ORTHO_MAP</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">(</span><span class="s">&#39;initial&#39;</span><span class="p">,</span>  <span class="s">&#39;upper&#39;</span><span class="p">):</span> <span class="n">_ORTHO_BEG_UC</span><span class="p">,</span>
        <span class="p">(</span><span class="s">&#39;internal&#39;</span><span class="p">,</span> <span class="s">&#39;upper&#39;</span><span class="p">):</span> <span class="n">_ORTHO_MID_UC</span><span class="p">,</span>
        <span class="p">(</span><span class="s">&#39;unknown&#39;</span><span class="p">,</span>  <span class="s">&#39;upper&#39;</span><span class="p">):</span> <span class="n">_ORTHO_UNK_UC</span><span class="p">,</span>
        <span class="p">(</span><span class="s">&#39;initial&#39;</span><span class="p">,</span>  <span class="s">&#39;lower&#39;</span><span class="p">):</span> <span class="n">_ORTHO_BEG_LC</span><span class="p">,</span>
        <span class="p">(</span><span class="s">&#39;internal&#39;</span><span class="p">,</span> <span class="s">&#39;lower&#39;</span><span class="p">):</span> <span class="n">_ORTHO_MID_LC</span><span class="p">,</span>
        <span class="p">(</span><span class="s">&#39;unknown&#39;</span><span class="p">,</span>  <span class="s">&#39;lower&#39;</span><span class="p">):</span> <span class="n">_ORTHO_UNK_LC</span><span class="p">,</span>
<span class="p">}</span>
<span class="sd">&quot;&quot;&quot;A map from context position and first-letter case to the</span>
<span class="sd">appropriate orthographic context flag.&quot;&quot;&quot;</span>

<span class="c">#} (end orthographic context constants)</span>
<span class="c">######################################################################</span>
        
<span class="c">######################################################################</span>
<span class="c">#{ Language-dependent variables</span>
<span class="c">######################################################################</span>

<div class="viewcode-block" id="PunktLanguageVars"><a class="viewcode-back" href="../../../api/nltk.tokenize.html#nltk.tokenize.punkt.PunktLanguageVars">[docs]</a><span class="k">class</span> <span class="nc">PunktLanguageVars</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Stores variables, mostly regular expressions, which may be</span>
<span class="sd">    language-dependent for correct application of the algorithm.</span>
<span class="sd">    An extension of this class may modify its properties to suit</span>
<span class="sd">    a language other than English; an instance can then be passed</span>
<span class="sd">    as an argument to PunktSentenceTokenizer and PunktTrainer</span>
<span class="sd">    constructors.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s">&#39;_re_period_context&#39;</span><span class="p">,</span> <span class="s">&#39;_re_word_tokenizer&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># All modifications to the class are performed by inheritance.</span>
        <span class="c"># Non-default parameters to be pickled must be defined in the inherited</span>
        <span class="c"># class.</span>
        <span class="k">return</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">1</span>

    <span class="n">sent_end_chars</span> <span class="o">=</span> <span class="p">(</span><span class="s">&#39;.&#39;</span><span class="p">,</span> <span class="s">&#39;?&#39;</span><span class="p">,</span> <span class="s">&#39;!&#39;</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;Characters which are candidates for sentence boundaries&quot;&quot;&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_re_sent_end_chars</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&#39;[</span><span class="si">%s</span><span class="s">]&#39;</span> <span class="o">%</span> <span class="n">re</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="s">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sent_end_chars</span><span class="p">))</span>

    <span class="n">internal_punctuation</span> <span class="o">=</span> <span class="s">&#39;,:;&#39;</span> <span class="c"># might want to extend this..</span>
    <span class="sd">&quot;&quot;&quot;sentence internal punctuation, which indicates an abbreviation if</span>
<span class="sd">    preceded by a period-final token.&quot;&quot;&quot;</span>

    <span class="n">re_boundary_realignment</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s">r&#39;[&quot;</span><span class="se">\&#39;</span><span class="s">)\]}]+?(?:\s+|(?=--)|$)&#39;</span><span class="p">,</span>
            <span class="n">re</span><span class="o">.</span><span class="n">MULTILINE</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;Used to realign punctuation that should be included in a sentence</span>
<span class="sd">    although it follows the period (or ?, !).&quot;&quot;&quot;</span>

    <span class="n">_re_word_start</span>    <span class="o">=</span> <span class="s">r&quot;[^\(</span><span class="se">\&quot;</span><span class="s">\`{\[:;&amp;\#\*@\)}\]\-,]&quot;</span>
    <span class="sd">&quot;&quot;&quot;Excludes some characters from starting word tokens&quot;&quot;&quot;</span>

    <span class="n">_re_non_word_chars</span>   <span class="o">=</span> <span class="s">r&quot;(?:[?!)</span><span class="se">\&quot;</span><span class="s">;}\]\*:@\&#39;\({\[])&quot;</span>
    <span class="sd">&quot;&quot;&quot;Characters that cannot appear within words&quot;&quot;&quot;</span>

    <span class="n">_re_multi_char_punct</span> <span class="o">=</span> <span class="s">r&quot;(?:\-{2,}|\.{2,}|(?:\.\s){2,}\.)&quot;</span>
    <span class="sd">&quot;&quot;&quot;Hyphen and ellipsis are multi-character punctuation&quot;&quot;&quot;</span>

    <span class="n">_word_tokenize_fmt</span> <span class="o">=</span> <span class="s">r&#39;&#39;&#39;(</span>
<span class="s">        </span><span class="si">%(MultiChar)s</span><span class="s"></span>
<span class="s">        |</span>
<span class="s">        (?=</span><span class="si">%(WordStart)s</span><span class="s">)\S+?  # Accept word characters until end is found</span>
<span class="s">        (?= # Sequences marking a word&#39;s end</span>
<span class="s">            \s|                                 # White-space</span>
<span class="s">            $|                                  # End-of-string</span>
<span class="s">            </span><span class="si">%(NonWord)s</span><span class="s">|</span><span class="si">%(MultiChar)s</span><span class="s">|          # Punctuation</span>
<span class="s">            ,(?=$|\s|</span><span class="si">%(NonWord)s</span><span class="s">|</span><span class="si">%(MultiChar)s</span><span class="s">) # Comma if at end of word</span>
<span class="s">        )</span>
<span class="s">        |</span>
<span class="s">        \S</span>
<span class="s">    )&#39;&#39;&#39;</span>
    <span class="sd">&quot;&quot;&quot;Format of a regular expression to split punctuation from words,</span>
<span class="sd">    excluding period.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_word_tokenizer_re</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compiles and returns a regular expression for word tokenization&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_re_word_tokenizer</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_re_word_tokenizer</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_word_tokenize_fmt</span> <span class="o">%</span>
                <span class="p">{</span>
                    <span class="s">&#39;NonWord&#39;</span><span class="p">:</span>   <span class="bp">self</span><span class="o">.</span><span class="n">_re_non_word_chars</span><span class="p">,</span>
                    <span class="s">&#39;MultiChar&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_re_multi_char_punct</span><span class="p">,</span>
                    <span class="s">&#39;WordStart&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_re_word_start</span><span class="p">,</span>
                <span class="p">},</span>
                <span class="n">re</span><span class="o">.</span><span class="n">UNICODE</span> <span class="o">|</span> <span class="n">re</span><span class="o">.</span><span class="n">VERBOSE</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_re_word_tokenizer</span>

<div class="viewcode-block" id="PunktLanguageVars.word_tokenize"><a class="viewcode-back" href="../../../api/nltk.tokenize.html#nltk.tokenize.punkt.PunktLanguageVars.word_tokenize">[docs]</a>    <span class="k">def</span> <span class="nf">word_tokenize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Tokenize a string to split off punctuation other than periods&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_word_tokenizer_re</span><span class="p">()</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
</div>
    <span class="n">_period_context_fmt</span> <span class="o">=</span> <span class="s">r&quot;&quot;&quot;</span>
<span class="s">        \S*                          # some word material</span>
<span class="s">        </span><span class="si">%(SentEndChars)s</span><span class="s">             # a potential sentence ending</span>
<span class="s">        (?=(?P&lt;after_tok&gt;</span>
<span class="s">            </span><span class="si">%(NonWord)s</span><span class="s">              # either other punctuation</span>
<span class="s">            |</span>
<span class="s">            \s+(?P&lt;next_tok&gt;\S+)     # or whitespace and some other token</span>
<span class="s">        ))&quot;&quot;&quot;</span>
    <span class="sd">&quot;&quot;&quot;Format of a regular expression to find contexts including possible</span>
<span class="sd">    sentence boundaries. Matches token which the possible sentence boundary</span>
<span class="sd">    ends, and matches the following token within a lookahead expression.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="PunktLanguageVars.period_context_re"><a class="viewcode-back" href="../../../api/nltk.tokenize.html#nltk.tokenize.punkt.PunktLanguageVars.period_context_re">[docs]</a>    <span class="k">def</span> <span class="nf">period_context_re</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compiles and returns a regular expression to find contexts</span>
<span class="sd">        including possible sentence boundaries.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_re_period_context</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_re_period_context</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_period_context_fmt</span> <span class="o">%</span>
                <span class="p">{</span>
                    <span class="s">&#39;NonWord&#39;</span><span class="p">:</span>      <span class="bp">self</span><span class="o">.</span><span class="n">_re_non_word_chars</span><span class="p">,</span>
                    <span class="s">&#39;SentEndChars&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_re_sent_end_chars</span><span class="p">,</span>
                <span class="p">},</span>
                <span class="n">re</span><span class="o">.</span><span class="n">UNICODE</span> <span class="o">|</span> <span class="n">re</span><span class="o">.</span><span class="n">VERBOSE</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_re_period_context</span>

</div></div>
<span class="n">_re_non_punct</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s">r&#39;[^\W\d]&#39;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">UNICODE</span><span class="p">)</span>
<span class="sd">&quot;&quot;&quot;Matches token types that are not merely punctuation. (Types for</span>
<span class="sd">numeric tokens are changed to ##number## and hence contain alpha.)&quot;&quot;&quot;</span>

<span class="c">#}</span>
<span class="c">######################################################################</span>
        

<span class="c">######################################################################</span>
<span class="c">#{ Punkt Word Tokenizer</span>
<span class="c">######################################################################</span>

<div class="viewcode-block" id="PunktWordTokenizer"><a class="viewcode-back" href="../../../api/nltk.tokenize.html#nltk.tokenize.punkt.PunktWordTokenizer">[docs]</a><span class="k">class</span> <span class="nc">PunktWordTokenizer</span><span class="p">(</span><span class="n">TokenizerI</span><span class="p">):</span>
    <span class="c"># Retained for backward compatibility</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lang_vars</span><span class="o">=</span><span class="n">PunktLanguageVars</span><span class="p">()):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lang_vars</span> <span class="o">=</span> <span class="n">lang_vars</span>

<div class="viewcode-block" id="PunktWordTokenizer.tokenize"><a class="viewcode-back" href="../../../api/nltk.tokenize.html#nltk.tokenize.punkt.PunktWordTokenizer.tokenize">[docs]</a>    <span class="k">def</span> <span class="nf">tokenize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lang_vars</span><span class="o">.</span><span class="n">word_tokenize</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>

<span class="c">#}</span>
<span class="c">######################################################################</span>


<span class="c">#////////////////////////////////////////////////////////////</span>
<span class="c">#{ Helper Functions</span>
<span class="c">#////////////////////////////////////////////////////////////</span>
</div></div>
<span class="k">def</span> <span class="nf">_pair_iter</span><span class="p">(</span><span class="n">it</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Yields pairs of tokens from the given iterator such that each input</span>
<span class="sd">    token will appear as the first element in a yielded tuple. The last</span>
<span class="sd">    pair will have None as its second element.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">it</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
    <span class="n">prev</span> <span class="o">=</span> <span class="n">it</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">it</span><span class="p">:</span>
        <span class="k">yield</span> <span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">el</span><span class="p">)</span>
        <span class="n">prev</span> <span class="o">=</span> <span class="n">el</span>
    <span class="k">yield</span> <span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>

<span class="c">######################################################################</span>
<span class="c">#{ Punkt Parameters</span>
<span class="c">######################################################################</span>

<div class="viewcode-block" id="PunktParameters"><a class="viewcode-back" href="../../../api/nltk.tokenize.html#nltk.tokenize.punkt.PunktParameters">[docs]</a><span class="k">class</span> <span class="nc">PunktParameters</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Stores data used to perform sentence boundary detection with Punkt.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">abbrev_types</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="sd">&quot;&quot;&quot;A set of word types for known abbreviations.&quot;&quot;&quot;</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">collocations</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="sd">&quot;&quot;&quot;A set of word type tuples for known common collocations</span>
<span class="sd">        where the first word ends in a period.  E.g., (&#39;S.&#39;, &#39;Bach&#39;)</span>
<span class="sd">        is a common collocation in a text that discusses &#39;Johann</span>
<span class="sd">        S. Bach&#39;.  These count as negative evidence for sentence</span>
<span class="sd">        boundaries.&quot;&quot;&quot;</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">sent_starters</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="sd">&quot;&quot;&quot;A set of word types for words that often appear at the</span>
<span class="sd">        beginning of sentences.&quot;&quot;&quot;</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">ortho_context</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot;A dictionary mapping word types to the set of orthographic</span>
<span class="sd">        contexts that word type appears in.  Contexts are represented</span>
<span class="sd">        by adding orthographic context flags: ...&quot;&quot;&quot;</span>

<div class="viewcode-block" id="PunktParameters.clear_abbrevs"><a class="viewcode-back" href="../../../api/nltk.tokenize.html#nltk.tokenize.punkt.PunktParameters.clear_abbrevs">[docs]</a>    <span class="k">def</span> <span class="nf">clear_abbrevs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">abbrev_types</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="PunktParameters.clear_collocations"><a class="viewcode-back" href="../../../api/nltk.tokenize.html#nltk.tokenize.punkt.PunktParameters.clear_collocations">[docs]</a>    <span class="k">def</span> <span class="nf">clear_collocations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">collocations</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="PunktParameters.clear_sent_starters"><a class="viewcode-back" href="../../../api/nltk.tokenize.html#nltk.tokenize.punkt.PunktParameters.clear_sent_starters">[docs]</a>    <span class="k">def</span> <span class="nf">clear_sent_starters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sent_starters</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="PunktParameters.clear_ortho_context"><a class="viewcode-back" href="../../../api/nltk.tokenize.html#nltk.tokenize.punkt.PunktParameters.clear_ortho_context">[docs]</a>    <span class="k">def</span> <span class="nf">clear_ortho_context</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ortho_context</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="PunktParameters.add_ortho_context"><a class="viewcode-back" href="../../../api/nltk.tokenize.html#nltk.tokenize.punkt.PunktParameters.add_ortho_context">[docs]</a>    <span class="k">def</span> <span class="nf">add_ortho_context</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">typ</span><span class="p">,</span> <span class="n">flag</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ortho_context</span><span class="p">[</span><span class="n">typ</span><span class="p">]</span> <span class="o">|=</span> <span class="n">flag</span>

<span class="c">######################################################################</span>
<span class="c">#{ PunktToken</span>
<span class="c">######################################################################</span>
</div></div>
<div class="viewcode-block" id="PunktToken"><a class="viewcode-back" href="../../../api/nltk.tokenize.html#nltk.tokenize.punkt.PunktToken">[docs]</a><span class="k">class</span> <span class="nc">PunktToken</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Stores a token of text with annotations produced during</span>
<span class="sd">    sentence boundary detection.&quot;&quot;&quot;</span>

    <span class="n">_properties</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s">&#39;parastart&#39;</span><span class="p">,</span> <span class="s">&#39;linestart&#39;</span><span class="p">,</span>
        <span class="s">&#39;sentbreak&#39;</span><span class="p">,</span> <span class="s">&#39;abbr&#39;</span><span class="p">,</span> <span class="s">&#39;ellipsis&#39;</span>
    <span class="p">]</span>
    <span class="n">__slots__</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;tok&#39;</span><span class="p">,</span> <span class="s">&#39;type&#39;</span><span class="p">,</span> <span class="s">&#39;period_final&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">_properties</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tok</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tok</span> <span class="o">=</span> <span class="n">tok</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_type</span><span class="p">(</span><span class="n">tok</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">period_final</span> <span class="o">=</span> <span class="n">tok</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s">&#39;.&#39;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_properties</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">params</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

    <span class="c">#////////////////////////////////////////////////////////////</span>
    <span class="c">#{ Regular expressions for properties</span>
    <span class="c">#////////////////////////////////////////////////////////////</span>
    <span class="c"># Note: [A-Za-z] is approximated by [^\W\d] in the general case.</span>
    <span class="n">_RE_ELLIPSIS</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s">r&#39;\.\.+$&#39;</span><span class="p">)</span>
    <span class="n">_RE_NUMERIC</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s">r&#39;^-?[\.,]?\d[\d,\.-]*\.?$&#39;</span><span class="p">)</span>
    <span class="n">_RE_INITIAL</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s">r&#39;[^\W\d]\.$&#39;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">UNICODE</span><span class="p">)</span>
    <span class="n">_RE_ALPHA</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s">r&#39;[^\W\d]+$&#39;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">UNICODE</span><span class="p">)</span>

    <span class="c">#////////////////////////////////////////////////////////////</span>
    <span class="c">#{ Derived properties</span>
    <span class="c">#////////////////////////////////////////////////////////////</span>

    <span class="k">def</span> <span class="nf">_get_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tok</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a case-normalized representation of the token.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_RE_NUMERIC</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s">&#39;##number##&#39;</span><span class="p">,</span> <span class="n">tok</span><span class="o">.</span><span class="n">lower</span><span class="p">())</span>

    <span class="nd">@property</span>
<div class="viewcode-block" id="PunktToken.type_no_period"><a class="viewcode-back" href="../../../api/nltk.tokenize.html#nltk.tokenize.punkt.PunktToken.type_no_period">[docs]</a>    <span class="k">def</span> <span class="nf">type_no_period</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The type with its final period removed if it has one.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;.&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="PunktToken.type_no_sentperiod"><a class="viewcode-back" href="../../../api/nltk.tokenize.html#nltk.tokenize.punkt.PunktToken.type_no_sentperiod">[docs]</a>    <span class="k">def</span> <span class="nf">type_no_sentperiod</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The type with its final period removed if it is marked as a</span>
<span class="sd">        sentence break.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sentbreak</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">type_no_period</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="PunktToken.first_upper"><a class="viewcode-back" href="../../../api/nltk.tokenize.html#nltk.tokenize.punkt.PunktToken.first_upper">[docs]</a>    <span class="k">def</span> <span class="nf">first_upper</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if the token&#39;s first character is uppercase.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tok</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">isupper</span><span class="p">()</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="PunktToken.first_lower"><a class="viewcode-back" href="../../../api/nltk.tokenize.html#nltk.tokenize.punkt.PunktToken.first_lower">[docs]</a>    <span class="k">def</span> <span class="nf">first_lower</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if the token&#39;s first character is lowercase.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tok</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">islower</span><span class="p">()</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="PunktToken.first_case"><a class="viewcode-back" href="../../../api/nltk.tokenize.html#nltk.tokenize.punkt.PunktToken.first_case">[docs]</a>    <span class="k">def</span> <span class="nf">first_case</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">first_lower</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">&#39;lower&#39;</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">first_upper</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">&#39;upper&#39;</span>
        <span class="k">return</span> <span class="s">&#39;none&#39;</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="PunktToken.is_ellipsis"><a class="viewcode-back" href="../../../api/nltk.tokenize.html#nltk.tokenize.punkt.PunktToken.is_ellipsis">[docs]</a>    <span class="k">def</span> <span class="nf">is_ellipsis</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if the token text is that of an ellipsis.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_RE_ELLIPSIS</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tok</span><span class="p">)</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="PunktToken.is_number"><a class="viewcode-back" href="../../../api/nltk.tokenize.html#nltk.tokenize.punkt.PunktToken.is_number">[docs]</a>    <span class="k">def</span> <span class="nf">is_number</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if the token text is that of a number.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&#39;##number##&#39;</span><span class="p">)</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="PunktToken.is_initial"><a class="viewcode-back" href="../../../api/nltk.tokenize.html#nltk.tokenize.punkt.PunktToken.is_initial">[docs]</a>    <span class="k">def</span> <span class="nf">is_initial</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if the token text is that of an initial.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_RE_INITIAL</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tok</span><span class="p">)</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="PunktToken.is_alpha"><a class="viewcode-back" href="../../../api/nltk.tokenize.html#nltk.tokenize.punkt.PunktToken.is_alpha">[docs]</a>    <span class="k">def</span> <span class="nf">is_alpha</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if the token text is all alphabetic.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_RE_ALPHA</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tok</span><span class="p">)</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="PunktToken.is_non_punct"><a class="viewcode-back" href="../../../api/nltk.tokenize.html#nltk.tokenize.punkt.PunktToken.is_non_punct">[docs]</a>    <span class="k">def</span> <span class="nf">is_non_punct</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if the token is either a number or is alphabetic.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_re_non_punct</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">)</span>
    
    <span class="c">#////////////////////////////////////////////////////////////</span>
    <span class="c">#{ String representation</span>
    <span class="c">#////////////////////////////////////////////////////////////</span>
</div>
    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A string representation of the token that can reproduce it</span>
<span class="sd">        with eval(), which lists all the token&#39;s non-default</span>
<span class="sd">        annotations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tok</span><span class="p">:</span>
            <span class="n">typestr</span> <span class="o">=</span> <span class="s">&#39; type=</span><span class="si">%s</span><span class="s">,&#39;</span> <span class="o">%</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">typestr</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>

        <span class="n">propvals</span> <span class="o">=</span> <span class="s">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="s">&#39;</span><span class="si">%s</span><span class="s">=</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="nb">repr</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">)))</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_properties</span>
            <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="s">&#39;</span><span class="si">%s</span><span class="s">(</span><span class="si">%s</span><span class="s">,</span><span class="si">%s</span><span class="s"> </span><span class="si">%s</span><span class="s">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span>
            <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tok</span><span class="p">),</span> <span class="n">typestr</span><span class="p">,</span> <span class="n">propvals</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A string representation akin to that used by Kiss and Strunk.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tok</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">abbr</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">+=</span> <span class="s">&#39;&lt;A&gt;&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ellipsis</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">+=</span> <span class="s">&#39;&lt;E&gt;&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sentbreak</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">+=</span> <span class="s">&#39;&lt;S&gt;&#39;</span>
        <span class="k">return</span> <span class="n">res</span>

<span class="c">######################################################################</span>
<span class="c">#{ Punkt base class</span>
<span class="c">######################################################################</span>
</div>
<div class="viewcode-block" id="PunktBaseClass"><a class="viewcode-back" href="../../../api/nltk.tokenize.html#nltk.tokenize.punkt.PunktBaseClass">[docs]</a><span class="k">class</span> <span class="nc">PunktBaseClass</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Includes common components of PunktTrainer and PunktSentenceTokenizer.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lang_vars</span><span class="o">=</span><span class="n">PunktLanguageVars</span><span class="p">(),</span> <span class="n">token_cls</span><span class="o">=</span><span class="n">PunktToken</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="n">PunktParameters</span><span class="p">()):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_params</span> <span class="o">=</span> <span class="n">params</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lang_vars</span> <span class="o">=</span> <span class="n">lang_vars</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_Token</span> <span class="o">=</span> <span class="n">token_cls</span>
        <span class="sd">&quot;&quot;&quot;The collection of parameters that determines the behavior</span>
<span class="sd">        of the punkt tokenizer.&quot;&quot;&quot;</span>

    <span class="c">#////////////////////////////////////////////////////////////</span>
    <span class="c">#{ Word tokenization</span>
    <span class="c">#////////////////////////////////////////////////////////////</span>

    <span class="k">def</span> <span class="nf">_tokenize_words</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">plaintext</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Divide the given text into tokens, using the punkt word</span>
<span class="sd">        segmentation regular expression, and generate the resulting list</span>
<span class="sd">        of tokens augmented as three-tuples with two boolean values for whether</span>
<span class="sd">        the given token occurs at the start of a paragraph or a new line,</span>
<span class="sd">        respectively.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">parastart</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">plaintext</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">():</span>
                <span class="n">line_toks</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lang_vars</span><span class="o">.</span><span class="n">word_tokenize</span><span class="p">(</span><span class="n">line</span><span class="p">))</span>

                <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Token</span><span class="p">(</span><span class="n">line_toks</span><span class="o">.</span><span class="n">next</span><span class="p">(),</span>
                        <span class="n">parastart</span><span class="o">=</span><span class="n">parastart</span><span class="p">,</span> <span class="n">linestart</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
                <span class="n">parastart</span> <span class="o">=</span> <span class="bp">False</span>

                <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">line_toks</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Token</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">parastart</span> <span class="o">=</span> <span class="bp">True</span>


    <span class="c">#////////////////////////////////////////////////////////////</span>
    <span class="c">#{ Annotation Procedures</span>
    <span class="c">#////////////////////////////////////////////////////////////</span>

    <span class="k">def</span> <span class="nf">_annotate_first_pass</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tokens</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform the first pass of annotation, which makes decisions</span>
<span class="sd">        based purely based on the word type of each word:</span>
<span class="sd">        </span>
<span class="sd">          - &#39;?&#39;, &#39;!&#39;, and &#39;.&#39; are marked as sentence breaks.</span>
<span class="sd">          - sequences of two or more periods are marked as ellipsis.</span>
<span class="sd">          - any word ending in &#39;.&#39; that&#39;s a known abbreviation is</span>
<span class="sd">            marked as an abbreviation.</span>
<span class="sd">          - any other word ending in &#39;.&#39; is marked as a sentence break.</span>

<span class="sd">        Return these annotations as a tuple of three sets:</span>
<span class="sd">        </span>
<span class="sd">          - sentbreak_toks: The indices of all sentence breaks.</span>
<span class="sd">          - abbrev_toks: The indices of all abbreviations.</span>
<span class="sd">          - ellipsis_toks: The indices of all ellipsis marks.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">aug_tok</span> <span class="ow">in</span> <span class="n">tokens</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_first_pass_annotation</span><span class="p">(</span><span class="n">aug_tok</span><span class="p">)</span>
            <span class="k">yield</span> <span class="n">aug_tok</span>

    <span class="k">def</span> <span class="nf">_first_pass_annotation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">aug_tok</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs type-based annotation on a single token.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">tok</span> <span class="o">=</span> <span class="n">aug_tok</span><span class="o">.</span><span class="n">tok</span>

        <span class="k">if</span> <span class="n">tok</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lang_vars</span><span class="o">.</span><span class="n">sent_end_chars</span><span class="p">:</span>
            <span class="n">aug_tok</span><span class="o">.</span><span class="n">sentbreak</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">elif</span> <span class="n">aug_tok</span><span class="o">.</span><span class="n">is_ellipsis</span><span class="p">:</span>
            <span class="n">aug_tok</span><span class="o">.</span><span class="n">ellipsis</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">elif</span> <span class="n">aug_tok</span><span class="o">.</span><span class="n">period_final</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">tok</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s">&#39;..&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">tok</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="o">.</span><span class="n">abbrev_types</span> <span class="ow">or</span>
                <span class="n">tok</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;-&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="o">.</span><span class="n">abbrev_types</span><span class="p">):</span>

                <span class="n">aug_tok</span><span class="o">.</span><span class="n">abbr</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">aug_tok</span><span class="o">.</span><span class="n">sentbreak</span> <span class="o">=</span> <span class="bp">True</span>

        <span class="k">return</span>

<span class="c">######################################################################</span>
<span class="c">#{ Punkt Trainer</span>
<span class="c">######################################################################</span>

</div>
<div class="viewcode-block" id="PunktTrainer"><a class="viewcode-back" href="../../../api/nltk.tokenize.html#nltk.tokenize.punkt.PunktTrainer">[docs]</a><span class="k">class</span> <span class="nc">PunktTrainer</span><span class="p">(</span><span class="n">PunktBaseClass</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Learns parameters used in Punkt sentence boundary detection.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">train_text</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
            <span class="n">lang_vars</span><span class="o">=</span><span class="n">PunktLanguageVars</span><span class="p">(),</span> <span class="n">token_cls</span><span class="o">=</span><span class="n">PunktToken</span><span class="p">):</span>

        <span class="n">PunktBaseClass</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lang_vars</span><span class="o">=</span><span class="n">lang_vars</span><span class="p">,</span>
                <span class="n">token_cls</span><span class="o">=</span><span class="n">token_cls</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_type_fdist</span> <span class="o">=</span> <span class="n">FreqDist</span><span class="p">()</span>
        <span class="sd">&quot;&quot;&quot;A frequency distribution giving the frequency of each</span>
<span class="sd">        case-normalized token type in the training data.&quot;&quot;&quot;</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">_num_period_toks</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="sd">&quot;&quot;&quot;The number of words ending in period in the training data.&quot;&quot;&quot;</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">_collocation_fdist</span> <span class="o">=</span> <span class="n">FreqDist</span><span class="p">()</span>
        <span class="sd">&quot;&quot;&quot;A frequency distribution giving the frequency of all</span>
<span class="sd">        bigrams in the training data where the first word ends in a</span>
<span class="sd">        period.  Bigrams are encoded as tuples of word types.</span>
<span class="sd">        Especially common collocations are extracted from this</span>
<span class="sd">        frequency distribution, and stored in</span>
<span class="sd">        L{_params}.L{collocations &lt;PunktParameters.collocations&gt;}.&quot;&quot;&quot;</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">_sent_starter_fdist</span> <span class="o">=</span> <span class="n">FreqDist</span><span class="p">()</span>
        <span class="sd">&quot;&quot;&quot;A frequency distribution giving the frequency of all words</span>
<span class="sd">        that occur at the training data at the beginning of a sentence</span>
<span class="sd">        (after the first pass of annotation).  Especially common</span>
<span class="sd">        sentence starters are extracted from this frequency</span>
<span class="sd">        distribution, and stored in L{_params}.L{sent_starters</span>
<span class="sd">        &lt;PunktParameters.sent_starters&gt;}.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_sentbreak_count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="sd">&quot;&quot;&quot;The total number of sentence breaks identified in training, used for</span>
<span class="sd">        calculating the frequent sentence starter heuristic.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_finalized</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="sd">&quot;&quot;&quot;A flag as to whether the training has been finalized by finding</span>
<span class="sd">        collocations and sentence starters, or whether finalize_training()</span>
<span class="sd">        still needs to be called.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">train_text</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">train</span><span class="p">(</span><span class="n">train_text</span><span class="p">,</span> <span class="n">verbose</span><span class="p">,</span> <span class="n">finalize</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

<div class="viewcode-block" id="PunktTrainer.get_params"><a class="viewcode-back" href="../../../api/nltk.tokenize.html#nltk.tokenize.punkt.PunktTrainer.get_params">[docs]</a>    <span class="k">def</span> <span class="nf">get_params</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates and returns parameters for sentence boundary detection as</span>
<span class="sd">        derived from training.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_finalized</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">finalize_training</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_params</span>

    <span class="c">#////////////////////////////////////////////////////////////</span>
    <span class="c">#{ Customization Variables</span>
    <span class="c">#////////////////////////////////////////////////////////////</span>
</div>
    <span class="n">ABBREV</span> <span class="o">=</span> <span class="mf">0.3</span>
    <span class="sd">&quot;&quot;&quot;cut-off value whether a &#39;token&#39; is an abbreviation&quot;&quot;&quot;</span>

    <span class="n">IGNORE_ABBREV_PENALTY</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="sd">&quot;&quot;&quot;allows the disabling of the abbreviation penalty heuristic, which</span>
<span class="sd">    exponentially disadvantages words that are found at times without a</span>
<span class="sd">    final period.&quot;&quot;&quot;</span>

    <span class="n">ABBREV_BACKOFF</span> <span class="o">=</span> <span class="mi">5</span>
    <span class="sd">&quot;&quot;&quot;upper cut-off for Mikheev&#39;s(2002) abbreviation detection algorithm&quot;&quot;&quot;</span>

    <span class="n">COLLOCATION</span> <span class="o">=</span> <span class="mf">7.88</span>
    <span class="sd">&quot;&quot;&quot;minimal log-likelihood value that two tokens need to be considered</span>
<span class="sd">    as a collocation&quot;&quot;&quot;</span>

    <span class="n">SENT_STARTER</span> <span class="o">=</span> <span class="mi">30</span>
    <span class="sd">&quot;&quot;&quot;minimal log-likelihood value that a token requires to be considered</span>
<span class="sd">    as a frequent sentence starter&quot;&quot;&quot;</span>

    <span class="n">INCLUDE_ALL_COLLOCS</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="sd">&quot;&quot;&quot;this includes as potential collocations all word pairs where the first</span>
<span class="sd">    word ends in a period. It may be useful in corpora where there is a lot</span>
<span class="sd">    of variation that makes abbreviations like Mr difficult to identify.&quot;&quot;&quot;</span>
    
    <span class="n">INCLUDE_ABBREV_COLLOCS</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="sd">&quot;&quot;&quot;this includes as potential collocations all word pairs where the first</span>
<span class="sd">    word is an abbreviation. Such collocations override the orthographic</span>
<span class="sd">    heuristic, but not the sentence starter heuristic. This is overridden by</span>
<span class="sd">    INCLUDE_ALL_COLLOCS, and if both are false, only collocations with initials</span>
<span class="sd">    and ordinals are considered.&quot;&quot;&quot;</span>
    <span class="sd">&quot;&quot;&quot;&quot;&quot;&quot;</span>

    <span class="n">MIN_COLLOC_FREQ</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="sd">&quot;&quot;&quot;this sets a minimum bound on the number of times a bigram needs to</span>
<span class="sd">    appear before it can be considered a collocation, in addition to log</span>
<span class="sd">    likelihood statistics. This is useful when INCLUDE_ALL_COLLOCS is True.&quot;&quot;&quot;</span>

    <span class="c">#////////////////////////////////////////////////////////////</span>
    <span class="c">#{ Training..</span>
    <span class="c">#////////////////////////////////////////////////////////////</span>

<div class="viewcode-block" id="PunktTrainer.train"><a class="viewcode-back" href="../../../api/nltk.tokenize.html#nltk.tokenize.punkt.PunktTrainer.train">[docs]</a>    <span class="k">def</span> <span class="nf">train</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">finalize</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Collects training data from a given text. If finalize is True, it</span>
<span class="sd">        will determine all the parameters for sentence boundary detection. If</span>
<span class="sd">        not, this will be delayed until get_params() or finalize_training() is</span>
<span class="sd">        called. If verbose is True, abbreviations found will be listed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Break the text into tokens; record which token indices correspond to</span>
        <span class="c"># line starts and paragraph starts; and determine their types.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_train_tokens</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tokenize_words</span><span class="p">(</span><span class="n">text</span><span class="p">),</span> <span class="n">verbose</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">finalize</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">finalize_training</span><span class="p">(</span><span class="n">verbose</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="PunktTrainer.train_tokens"><a class="viewcode-back" href="../../../api/nltk.tokenize.html#nltk.tokenize.punkt.PunktTrainer.train_tokens">[docs]</a>    <span class="k">def</span> <span class="nf">train_tokens</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tokens</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">finalize</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Collects training data from a given list of tokens.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_train_tokens</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_Token</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tokens</span><span class="p">),</span> <span class="n">verbose</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">finalize</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">finalize_training</span><span class="p">(</span><span class="n">verbose</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">_train_tokens</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tokens</span><span class="p">,</span> <span class="n">verbose</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_finalized</span> <span class="o">=</span> <span class="bp">False</span>

        <span class="c"># Ensure tokens are a list</span>
        <span class="n">tokens</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span>

        <span class="c"># Find the frequency of each case-normalized type.  (Don&#39;t</span>
        <span class="c"># strip off final periods.)  Also keep track of the number of</span>
        <span class="c"># tokens that end in periods.</span>
        <span class="k">for</span> <span class="n">aug_tok</span> <span class="ow">in</span> <span class="n">tokens</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_type_fdist</span><span class="o">.</span><span class="n">inc</span><span class="p">(</span><span class="n">aug_tok</span><span class="o">.</span><span class="n">type</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">aug_tok</span><span class="o">.</span><span class="n">period_final</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_num_period_toks</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c"># Look for new abbreviations, and for types that no longer are</span>
        <span class="n">unique_types</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_unique_types</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">abbr</span><span class="p">,</span> <span class="n">score</span><span class="p">,</span> <span class="n">is_add</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reclassify_abbrev_types</span><span class="p">(</span><span class="n">unique_types</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">score</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ABBREV</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">is_add</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="o">.</span><span class="n">abbrev_types</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">abbr</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                        <span class="k">print</span> <span class="p">(</span><span class="s">&#39;  Abbreviation: [</span><span class="si">%6.4f</span><span class="s">] </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span>
                               <span class="p">(</span><span class="n">score</span><span class="p">,</span> <span class="n">abbr</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">is_add</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="o">.</span><span class="n">abbrev_types</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">abbr</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                        <span class="k">print</span> <span class="p">(</span><span class="s">&#39;  Removed abbreviation: [</span><span class="si">%6.4f</span><span class="s">] </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span>
                               <span class="p">(</span><span class="n">score</span><span class="p">,</span> <span class="n">abbr</span><span class="p">))</span>

        <span class="c"># Make a preliminary pass through the document, marking likely</span>
        <span class="c"># sentence breaks, abbreviations, and ellipsis tokens.</span>
        <span class="n">tokens</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_annotate_first_pass</span><span class="p">(</span><span class="n">tokens</span><span class="p">))</span>

        <span class="c"># Check what contexts each word type can appear in, given the</span>
        <span class="c"># case of its first letter.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_get_orthography_data</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span>

        <span class="c"># We need total number of sentence breaks to find sentence starters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sentbreak_count</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_sentbreak_count</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span>

        <span class="c"># The remaining heuristics relate to pairs of tokens where the first</span>
        <span class="c"># ends in a period.</span>
        <span class="k">for</span> <span class="n">aug_tok1</span><span class="p">,</span> <span class="n">aug_tok2</span> <span class="ow">in</span> <span class="n">_pair_iter</span><span class="p">(</span><span class="n">tokens</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">aug_tok1</span><span class="o">.</span><span class="n">period_final</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">aug_tok2</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c"># Is the first token a rare abbreviation?</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_rare_abbrev_type</span><span class="p">(</span><span class="n">aug_tok1</span><span class="p">,</span> <span class="n">aug_tok2</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="o">.</span><span class="n">abbrev_types</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">aug_tok1</span><span class="o">.</span><span class="n">type_no_period</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="k">print</span> <span class="p">(</span><span class="s">&#39;  Rare Abbrev: </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">aug_tok1</span><span class="o">.</span><span class="n">type</span><span class="p">)</span>

            <span class="c"># Does second token have a high likelihood of starting a sentence?</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_potential_sent_starter</span><span class="p">(</span><span class="n">aug_tok2</span><span class="p">,</span> <span class="n">aug_tok1</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_sent_starter_fdist</span><span class="o">.</span><span class="n">inc</span><span class="p">(</span><span class="n">aug_tok2</span><span class="o">.</span><span class="n">type</span><span class="p">)</span>

            <span class="c"># Is this bigram a potential collocation?</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_potential_collocation</span><span class="p">(</span><span class="n">aug_tok1</span><span class="p">,</span> <span class="n">aug_tok2</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_collocation_fdist</span><span class="o">.</span><span class="n">inc</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">aug_tok1</span><span class="o">.</span><span class="n">type_no_period</span><span class="p">,</span> <span class="n">aug_tok2</span><span class="o">.</span><span class="n">type_no_sentperiod</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_unique_types</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tokens</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="n">aug_tok</span><span class="o">.</span><span class="n">type</span> <span class="k">for</span> <span class="n">aug_tok</span> <span class="ow">in</span> <span class="n">tokens</span><span class="p">)</span>
        
<div class="viewcode-block" id="PunktTrainer.finalize_training"><a class="viewcode-back" href="../../../api/nltk.tokenize.html#nltk.tokenize.punkt.PunktTrainer.finalize_training">[docs]</a>    <span class="k">def</span> <span class="nf">finalize_training</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Uses data that has been gathered in training to determine likely</span>
<span class="sd">        collocations and sentence starters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="o">.</span><span class="n">clear_sent_starters</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">typ</span><span class="p">,</span> <span class="n">ll</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_sent_starters</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="o">.</span><span class="n">sent_starters</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">typ</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="k">print</span> <span class="p">(</span><span class="s">&#39;  Sent Starter: [</span><span class="si">%6.4f</span><span class="s">] </span><span class="si">%r</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">ll</span><span class="p">,</span> <span class="n">typ</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="o">.</span><span class="n">clear_collocations</span><span class="p">()</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">typ1</span><span class="p">,</span> <span class="n">typ2</span><span class="p">),</span> <span class="n">ll</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_collocations</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="o">.</span><span class="n">collocations</span><span class="o">.</span><span class="n">add</span><span class="p">(</span> <span class="p">(</span><span class="n">typ1</span><span class="p">,</span><span class="n">typ2</span><span class="p">)</span> <span class="p">)</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="k">print</span> <span class="p">(</span><span class="s">&#39;  Collocation: [</span><span class="si">%6.4f</span><span class="s">] </span><span class="si">%r</span><span class="s">+</span><span class="si">%r</span><span class="s">&#39;</span> <span class="o">%</span>
                       <span class="p">(</span><span class="n">ll</span><span class="p">,</span> <span class="n">typ1</span><span class="p">,</span> <span class="n">typ2</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_finalized</span> <span class="o">=</span> <span class="bp">True</span>

    <span class="c">#////////////////////////////////////////////////////////////</span>
    <span class="c">#{ Overhead reduction</span>
    <span class="c">#////////////////////////////////////////////////////////////</span>
</div>
<div class="viewcode-block" id="PunktTrainer.freq_threshold"><a class="viewcode-back" href="../../../api/nltk.tokenize.html#nltk.tokenize.punkt.PunktTrainer.freq_threshold">[docs]</a>    <span class="k">def</span> <span class="nf">freq_threshold</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ortho_thresh</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">type_thresh</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">colloc_thres</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="n">sentstart_thresh</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Allows memory use to be reduced after much training by removing data</span>
<span class="sd">        about rare tokens that are unlikely to have a statistical effect with</span>
<span class="sd">        further training. Entries occurring above the given thresholds will be</span>
<span class="sd">        retained.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ortho_thresh</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">old_oc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="o">.</span><span class="n">ortho_context</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="o">.</span><span class="n">clear_ortho_context</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">tok</span><span class="p">,</span> <span class="n">count</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_type_fdist</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">count</span> <span class="o">&gt;=</span> <span class="n">ortho_thresh</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="o">.</span><span class="n">ortho_context</span><span class="p">[</span><span class="n">tok</span><span class="p">]</span> <span class="o">=</span> <span class="n">old_oc</span><span class="p">[</span><span class="n">tok</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_type_fdist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_freq_threshold</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_type_fdist</span><span class="p">,</span> <span class="n">type_thresh</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_collocation_fdist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_freq_threshold</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_collocation_fdist</span><span class="p">,</span> <span class="n">colloc_thres</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sent_starter_fdist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_freq_threshold</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_sent_starter_fdist</span><span class="p">,</span> <span class="n">sentstart_thresh</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">_freq_threshold</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fdist</span><span class="p">,</span> <span class="n">threshold</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a FreqDist containing only data with counts below a given</span>
<span class="sd">        threshold, as well as a mapping (None -&gt; count_removed).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># We assume that there is more data below the threshold than above it</span>
        <span class="c"># and so create a new FreqDist rather than working in place.</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">FreqDist</span><span class="p">()</span>
        <span class="n">num_removed</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">tok</span><span class="p">,</span> <span class="n">count</span> <span class="ow">in</span> <span class="n">fdist</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">count</span> <span class="o">&lt;</span> <span class="n">threshold</span><span class="p">:</span>
                <span class="n">num_removed</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">res</span><span class="o">.</span><span class="n">inc</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="n">count</span><span class="p">)</span>
        <span class="n">res</span><span class="o">.</span><span class="n">inc</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="n">num_removed</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span>

    <span class="c">#////////////////////////////////////////////////////////////</span>
    <span class="c">#{ Orthographic data</span>
    <span class="c">#////////////////////////////////////////////////////////////</span>

    <span class="k">def</span> <span class="nf">_get_orthography_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tokens</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Collect information about whether each token type occurs</span>
<span class="sd">        with different case patterns (i) overall, (ii) at</span>
<span class="sd">        sentence-initial positions, and (iii) at sentence-internal</span>
<span class="sd">        positions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># &#39;initial&#39; or &#39;internal&#39; or &#39;unknown&#39;</span>
        <span class="n">context</span> <span class="o">=</span> <span class="s">&#39;internal&#39;</span>
        <span class="n">tokens</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span>
        
        <span class="k">for</span> <span class="n">aug_tok</span> <span class="ow">in</span> <span class="n">tokens</span><span class="p">:</span>
            <span class="c"># If we encounter a paragraph break, then it&#39;s a good sign</span>
            <span class="c"># that it&#39;s a sentence break.  But err on the side of</span>
            <span class="c"># caution (by not positing a sentence break) if we just</span>
            <span class="c"># saw an abbreviation.</span>
            <span class="k">if</span> <span class="n">aug_tok</span><span class="o">.</span><span class="n">parastart</span> <span class="ow">and</span> <span class="n">context</span> <span class="o">!=</span> <span class="s">&#39;unknown&#39;</span><span class="p">:</span>
                <span class="n">context</span> <span class="o">=</span> <span class="s">&#39;initial&#39;</span>

            <span class="c"># If we&#39;re at the beginning of a line, then err on the</span>
            <span class="c"># side of calling our context &#39;initial&#39;.</span>
            <span class="k">if</span> <span class="n">aug_tok</span><span class="o">.</span><span class="n">linestart</span> <span class="ow">and</span> <span class="n">context</span> <span class="o">==</span> <span class="s">&#39;internal&#39;</span><span class="p">:</span>
                <span class="n">context</span> <span class="o">=</span> <span class="s">&#39;unknown&#39;</span>

            <span class="c"># Find the case-normalized type of the token.  If it&#39;s a</span>
            <span class="c"># sentence-final token, strip off the period.</span>
            <span class="n">typ</span> <span class="o">=</span> <span class="n">aug_tok</span><span class="o">.</span><span class="n">type_no_sentperiod</span>

            <span class="c"># Update the orthographic context table.</span>
            <span class="n">flag</span> <span class="o">=</span> <span class="n">_ORTHO_MAP</span><span class="o">.</span><span class="n">get</span><span class="p">((</span><span class="n">context</span><span class="p">,</span> <span class="n">aug_tok</span><span class="o">.</span><span class="n">first_case</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">flag</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="o">.</span><span class="n">add_ortho_context</span><span class="p">(</span><span class="n">typ</span><span class="p">,</span> <span class="n">flag</span><span class="p">)</span>

            <span class="c"># Decide whether the next word is at a sentence boundary.</span>
            <span class="k">if</span> <span class="n">aug_tok</span><span class="o">.</span><span class="n">sentbreak</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">aug_tok</span><span class="o">.</span><span class="n">is_number</span> <span class="ow">or</span> <span class="n">aug_tok</span><span class="o">.</span><span class="n">is_initial</span><span class="p">):</span>
                    <span class="n">context</span> <span class="o">=</span> <span class="s">&#39;initial&#39;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">context</span> <span class="o">=</span> <span class="s">&#39;unknown&#39;</span>
            <span class="k">elif</span> <span class="n">aug_tok</span><span class="o">.</span><span class="n">ellipsis</span> <span class="ow">or</span> <span class="n">aug_tok</span><span class="o">.</span><span class="n">abbr</span><span class="p">:</span>
                <span class="n">context</span> <span class="o">=</span> <span class="s">&#39;unknown&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">context</span> <span class="o">=</span> <span class="s">&#39;internal&#39;</span>
        
    <span class="c">#////////////////////////////////////////////////////////////</span>
    <span class="c">#{ Abbreviations</span>
    <span class="c">#////////////////////////////////////////////////////////////</span>

    <span class="k">def</span> <span class="nf">_reclassify_abbrev_types</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">types</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (Re)classifies each given token if</span>
<span class="sd">          - it is period-final and not a known abbreviation; or</span>
<span class="sd">          - it is not period-final and is otherwise a known abbreviation</span>
<span class="sd">        by checking whether its previous classification still holds according</span>
<span class="sd">        to the heuristics of section 3.</span>
<span class="sd">        Yields triples (abbr, score, is_add) where abbr is the type in question,</span>
<span class="sd">        score is its log-likelihood with penalties applied, and is_add specifies</span>
<span class="sd">        whether the present type is a candidate for inclusion or exclusion as an</span>
<span class="sd">        abbreviation, such that:</span>
<span class="sd">          - (is_add and score &gt;= 0.3)    suggests a new abbreviation; and</span>
<span class="sd">          - (not is_add and score &lt; 0.3) suggests excluding an abbreviation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># (While one could recalculate abbreviations from all .-final tokens at</span>
        <span class="c"># every iteration, in cases requiring efficiency, the number of tokens</span>
        <span class="c"># in the present training document will be much less.)</span>

        <span class="k">for</span> <span class="n">typ</span> <span class="ow">in</span> <span class="n">types</span><span class="p">:</span>
            <span class="c"># Check some basic conditions, to rule out words that are</span>
            <span class="c"># clearly not abbrev_types.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">_re_non_punct</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">typ</span><span class="p">)</span> <span class="ow">or</span> <span class="n">typ</span> <span class="o">==</span> <span class="s">&#39;##number##&#39;</span><span class="p">:</span>
                <span class="k">continue</span>
            
            <span class="k">if</span> <span class="n">typ</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s">&#39;.&#39;</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">typ</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="o">.</span><span class="n">abbrev_types</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">typ</span> <span class="o">=</span> <span class="n">typ</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">is_add</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">typ</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="o">.</span><span class="n">abbrev_types</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">is_add</span> <span class="o">=</span> <span class="bp">False</span>

            <span class="c"># Count how many periods &amp; nonperiods are in the</span>
            <span class="c"># candidate.</span>
            <span class="n">num_periods</span> <span class="o">=</span> <span class="n">typ</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s">&#39;.&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">num_nonperiods</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">typ</span><span class="p">)</span> <span class="o">-</span> <span class="n">num_periods</span> <span class="o">+</span> <span class="mi">1</span>
            
            <span class="c"># Let &lt;a&gt; be the candidate without the period, and &lt;b&gt;</span>
            <span class="c"># be the period.  Find a log likelihood ratio that</span>
            <span class="c"># indicates whether &lt;ab&gt; occurs as a single unit (high</span>
            <span class="c"># value of ll), or as two independent units &lt;a&gt; and</span>
            <span class="c"># &lt;b&gt; (low value of ll).</span>
            <span class="n">count_with_period</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_type_fdist</span><span class="p">[</span><span class="n">typ</span> <span class="o">+</span> <span class="s">&#39;.&#39;</span><span class="p">]</span>
            <span class="n">count_without_period</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_type_fdist</span><span class="p">[</span><span class="n">typ</span><span class="p">]</span>
            <span class="n">ll</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dunning_log_likelihood</span><span class="p">(</span>
                <span class="n">count_with_period</span> <span class="o">+</span> <span class="n">count_without_period</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_num_period_toks</span><span class="p">,</span> <span class="n">count_with_period</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_type_fdist</span><span class="o">.</span><span class="n">N</span><span class="p">())</span>

            <span class="c"># Apply three scaling factors to &#39;tweak&#39; the basic log</span>
            <span class="c"># likelihood ratio:</span>
            <span class="c">#   F_length: long word -&gt; less likely to be an abbrev</span>
            <span class="c">#   F_periods: more periods -&gt; more likely to be an abbrev</span>
            <span class="c">#   F_penalty: penalize occurances w/o a period</span>
            <span class="n">f_length</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">num_nonperiods</span><span class="p">)</span>
            <span class="n">f_periods</span> <span class="o">=</span> <span class="n">num_periods</span>
            <span class="n">f_penalty</span> <span class="o">=</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">IGNORE_ABBREV_PENALTY</span><span class="p">)</span>
                    <span class="ow">or</span> <span class="n">math</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="n">num_nonperiods</span><span class="p">,</span> <span class="o">-</span><span class="n">count_without_period</span><span class="p">))</span>
            <span class="n">score</span> <span class="o">=</span> <span class="n">ll</span> <span class="o">*</span> <span class="n">f_length</span> <span class="o">*</span> <span class="n">f_periods</span> <span class="o">*</span> <span class="n">f_penalty</span>

            <span class="k">yield</span> <span class="n">typ</span><span class="p">,</span> <span class="n">score</span><span class="p">,</span> <span class="n">is_add</span>

<div class="viewcode-block" id="PunktTrainer.find_abbrev_types"><a class="viewcode-back" href="../../../api/nltk.tokenize.html#nltk.tokenize.punkt.PunktTrainer.find_abbrev_types">[docs]</a>    <span class="k">def</span> <span class="nf">find_abbrev_types</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Recalculates abbreviations given type frequencies, despite no prior</span>
<span class="sd">        determination of abbreviations.</span>
<span class="sd">        This fails to include abbreviations otherwise found as &quot;rare&quot;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="o">.</span><span class="n">clear_abbrevs</span><span class="p">()</span>
        <span class="n">tokens</span> <span class="o">=</span> <span class="p">(</span><span class="n">typ</span> <span class="k">for</span> <span class="n">typ</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_type_fdist</span> <span class="k">if</span> <span class="n">typ</span> <span class="ow">and</span> <span class="n">typ</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s">&#39;.&#39;</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">abbr</span><span class="p">,</span> <span class="n">score</span><span class="p">,</span> <span class="n">is_add</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reclassify_abbrev_types</span><span class="p">(</span><span class="n">tokens</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">score</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ABBREV</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="o">.</span><span class="n">abbrev_types</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">abbr</span><span class="p">)</span>

    <span class="c"># This function combines the work done by the original code&#39;s</span>
    <span class="c"># functions `count_orthography_context`, `get_orthography_count`,</span>
    <span class="c"># and `get_rare_abbreviations`.</span></div>
    <span class="k">def</span> <span class="nf">_is_rare_abbrev_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cur_tok</span><span class="p">,</span> <span class="n">next_tok</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A word type is counted as a rare abbreviation if...</span>
<span class="sd">          - it&#39;s not already marked as an abbreviation</span>
<span class="sd">          - it occurs fewer than ABBREV_BACKOFF times</span>
<span class="sd">          - either it is followed by a sentence-internal punctuation</span>
<span class="sd">            mark, *or* it is followed by a lower-case word that</span>
<span class="sd">            sometimes appears with upper case, but never occurs with</span>
<span class="sd">            lower case at the beginning of sentences.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">cur_tok</span><span class="o">.</span><span class="n">abbr</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">cur_tok</span><span class="o">.</span><span class="n">sentbreak</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>

        <span class="c"># Find the case-normalized type of the token.  If it&#39;s</span>
        <span class="c"># a sentence-final token, strip off the period.</span>
        <span class="n">typ</span> <span class="o">=</span> <span class="n">cur_tok</span><span class="o">.</span><span class="n">type_no_sentperiod</span>
        
        <span class="c"># Proceed only if the type hasn&#39;t been categorized as an</span>
        <span class="c"># abbreviation already, and is sufficiently rare...</span>
        <span class="n">count</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_type_fdist</span><span class="p">[</span><span class="n">typ</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_type_fdist</span><span class="p">[</span><span class="n">typ</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">typ</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="o">.</span><span class="n">abbrev_types</span> <span class="ow">or</span> <span class="n">count</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ABBREV_BACKOFF</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">False</span>

        <span class="c"># Record this token as an abbreviation if the next</span>
        <span class="c"># token is a sentence-internal punctuation mark.</span>
        <span class="c"># [XX] :1 or check the whole thing??</span>
        <span class="k">if</span> <span class="n">next_tok</span><span class="o">.</span><span class="n">tok</span><span class="p">[:</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lang_vars</span><span class="o">.</span><span class="n">internal_punctuation</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>

        <span class="c"># Record this type as an abbreviation if the next</span>
        <span class="c"># token...  (i) starts with a lower case letter,</span>
        <span class="c"># (ii) sometimes occurs with an uppercase letter,</span>
        <span class="c"># and (iii) never occus with an uppercase letter</span>
        <span class="c"># sentence-internally.</span>
        <span class="c"># [xx] should the check for (ii) be modified??</span>
        <span class="k">elif</span> <span class="n">next_tok</span><span class="o">.</span><span class="n">first_lower</span><span class="p">:</span>
            <span class="n">typ2</span> <span class="o">=</span> <span class="n">next_tok</span><span class="o">.</span><span class="n">type_no_sentperiod</span>
            <span class="n">typ2ortho_context</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="o">.</span><span class="n">ortho_context</span><span class="p">[</span><span class="n">typ2</span><span class="p">]</span>
            <span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">typ2ortho_context</span> <span class="o">&amp;</span> <span class="n">_ORTHO_BEG_UC</span><span class="p">)</span> <span class="ow">and</span>
                 <span class="ow">not</span> <span class="p">(</span><span class="n">typ2ortho_context</span> <span class="o">&amp;</span> <span class="n">_ORTHO_MID_UC</span><span class="p">)</span> <span class="p">):</span>
                <span class="k">return</span> <span class="bp">True</span>

    <span class="c">#////////////////////////////////////////////////////////////</span>
    <span class="c">#{ Log Likelihoods</span>
    <span class="c">#////////////////////////////////////////////////////////////</span>

    <span class="c"># helper for _reclassify_abbrev_types:</span>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_dunning_log_likelihood</span><span class="p">(</span><span class="n">count_a</span><span class="p">,</span> <span class="n">count_b</span><span class="p">,</span> <span class="n">count_ab</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A function that calculates the modified Dunning log-likelihood</span>
<span class="sd">        ratio scores for abbreviation candidates.  The details of how</span>
<span class="sd">        this works is available in the paper.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">p1</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">count_b</span><span class="p">)</span> <span class="o">/</span> <span class="n">N</span>
        <span class="n">p2</span> <span class="o">=</span> <span class="mf">0.99</span>
        
        <span class="n">null_hypo</span> <span class="o">=</span> <span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">count_ab</span><span class="p">)</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">p1</span><span class="p">)</span> <span class="o">+</span>
                     <span class="p">(</span><span class="n">count_a</span> <span class="o">-</span> <span class="n">count_ab</span><span class="p">)</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">p1</span><span class="p">))</span>
        <span class="n">alt_hypo</span>  <span class="o">=</span> <span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">count_ab</span><span class="p">)</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">p2</span><span class="p">)</span> <span class="o">+</span>
                     <span class="p">(</span><span class="n">count_a</span> <span class="o">-</span> <span class="n">count_ab</span><span class="p">)</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">p2</span><span class="p">))</span>
        
        <span class="n">likelihood</span> <span class="o">=</span> <span class="n">null_hypo</span> <span class="o">-</span> <span class="n">alt_hypo</span>
        
        <span class="k">return</span> <span class="p">(</span><span class="o">-</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">likelihood</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_col_log_likelihood</span><span class="p">(</span><span class="n">count_a</span><span class="p">,</span> <span class="n">count_b</span><span class="p">,</span> <span class="n">count_ab</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A function that will just compute log-likelihood estimate, in</span>
<span class="sd">        the original paper it&#39;s decribed in algorithm 6 and 7.</span>

<span class="sd">        This *should* be the original Dunning log-likelihood values,</span>
<span class="sd">        unlike the previous log_l function where it used modified</span>
<span class="sd">        Dunning log-likelihood values</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">math</span>
        
        <span class="n">p</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">*</span> <span class="n">count_b</span> <span class="o">/</span> <span class="n">N</span>
        <span class="n">p1</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">*</span> <span class="n">count_ab</span> <span class="o">/</span> <span class="n">count_a</span>
        <span class="n">p2</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">count_b</span> <span class="o">-</span> <span class="n">count_ab</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="n">count_a</span><span class="p">)</span>

        <span class="n">summand1</span> <span class="o">=</span> <span class="p">(</span><span class="n">count_ab</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">+</span>
                    <span class="p">(</span><span class="n">count_a</span> <span class="o">-</span> <span class="n">count_ab</span><span class="p">)</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">p</span><span class="p">))</span>

        <span class="n">summand2</span> <span class="o">=</span> <span class="p">((</span><span class="n">count_b</span> <span class="o">-</span> <span class="n">count_ab</span><span class="p">)</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">+</span>
                    <span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="n">count_a</span> <span class="o">-</span> <span class="n">count_b</span> <span class="o">+</span> <span class="n">count_ab</span><span class="p">)</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">p</span><span class="p">))</span>
    
        <span class="k">if</span> <span class="n">count_a</span> <span class="o">==</span> <span class="n">count_ab</span><span class="p">:</span>
            <span class="n">summand3</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">summand3</span> <span class="o">=</span> <span class="p">(</span><span class="n">count_ab</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">p1</span><span class="p">)</span> <span class="o">+</span>
                        <span class="p">(</span><span class="n">count_a</span> <span class="o">-</span> <span class="n">count_ab</span><span class="p">)</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">p1</span><span class="p">))</span>
    
        <span class="k">if</span> <span class="n">count_b</span> <span class="o">==</span> <span class="n">count_ab</span><span class="p">:</span>
            <span class="n">summand4</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">summand4</span> <span class="o">=</span> <span class="p">((</span><span class="n">count_b</span> <span class="o">-</span> <span class="n">count_ab</span><span class="p">)</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">p2</span><span class="p">)</span> <span class="o">+</span>
                        <span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="n">count_a</span> <span class="o">-</span> <span class="n">count_b</span> <span class="o">+</span> <span class="n">count_ab</span><span class="p">)</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">p2</span><span class="p">))</span>
    
        <span class="n">likelihood</span> <span class="o">=</span> <span class="n">summand1</span> <span class="o">+</span> <span class="n">summand2</span> <span class="o">-</span> <span class="n">summand3</span> <span class="o">-</span> <span class="n">summand4</span>
    
        <span class="k">return</span> <span class="p">(</span><span class="o">-</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">likelihood</span><span class="p">)</span>
    
    <span class="c">#////////////////////////////////////////////////////////////</span>
    <span class="c">#{ Collocation Finder</span>
    <span class="c">#////////////////////////////////////////////////////////////</span>

    <span class="k">def</span> <span class="nf">_is_potential_collocation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">aug_tok1</span><span class="p">,</span> <span class="n">aug_tok2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns True if the pair of tokens may form a collocation given</span>
<span class="sd">        log-likelihood statistics.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">INCLUDE_ALL_COLLOCS</span> <span class="ow">or</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">INCLUDE_ABBREV_COLLOCS</span> <span class="ow">and</span> <span class="n">aug_tok1</span><span class="o">.</span><span class="n">abbr</span><span class="p">)</span> <span class="ow">or</span>
                <span class="p">(</span><span class="n">aug_tok1</span><span class="o">.</span><span class="n">sentbreak</span> <span class="ow">and</span>
                    <span class="p">(</span><span class="n">aug_tok1</span><span class="o">.</span><span class="n">is_number</span> <span class="ow">or</span> <span class="n">aug_tok1</span><span class="o">.</span><span class="n">is_initial</span><span class="p">)))</span>
                <span class="ow">and</span> <span class="n">aug_tok1</span><span class="o">.</span><span class="n">is_non_punct</span>
                <span class="ow">and</span> <span class="n">aug_tok2</span><span class="o">.</span><span class="n">is_non_punct</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_find_collocations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates likely collocations and their log-likelihood.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">types</span><span class="p">,</span> <span class="n">col_count</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_collocation_fdist</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">typ1</span><span class="p">,</span> <span class="n">typ2</span> <span class="o">=</span> <span class="n">types</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="c"># types may be None after calling freq_threshold()</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">typ2</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="o">.</span><span class="n">sent_starters</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">typ1_count</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_type_fdist</span><span class="p">[</span><span class="n">typ1</span><span class="p">]</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">_type_fdist</span><span class="p">[</span><span class="n">typ1</span><span class="o">+</span><span class="s">&#39;.&#39;</span><span class="p">]</span>
            <span class="n">typ2_count</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_type_fdist</span><span class="p">[</span><span class="n">typ2</span><span class="p">]</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">_type_fdist</span><span class="p">[</span><span class="n">typ2</span><span class="o">+</span><span class="s">&#39;.&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">typ1_count</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">typ2_count</span> <span class="o">&gt;</span> <span class="mi">1</span>
                    <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">MIN_COLLOC_FREQ</span> <span class="o">&lt;</span>
                        <span class="n">col_count</span> <span class="o">&lt;=</span> <span class="nb">min</span><span class="p">(</span><span class="n">typ1_count</span><span class="p">,</span> <span class="n">typ2_count</span><span class="p">)):</span>

                <span class="n">ll</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_col_log_likelihood</span><span class="p">(</span><span class="n">typ1_count</span><span class="p">,</span> <span class="n">typ2_count</span><span class="p">,</span>
                                              <span class="n">col_count</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_type_fdist</span><span class="o">.</span><span class="n">N</span><span class="p">())</span>
                <span class="c"># Filter out the not-so-collocative</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">ll</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">COLLOCATION</span> <span class="ow">and</span> 
                    <span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_type_fdist</span><span class="o">.</span><span class="n">N</span><span class="p">())</span><span class="o">/</span><span class="n">typ1_count</span> <span class="o">&gt;</span>
                     <span class="nb">float</span><span class="p">(</span><span class="n">typ2_count</span><span class="p">)</span><span class="o">/</span><span class="n">col_count</span><span class="p">)):</span>
                    <span class="k">yield</span> <span class="p">(</span><span class="n">typ1</span><span class="p">,</span> <span class="n">typ2</span><span class="p">),</span> <span class="n">ll</span>

    <span class="c">#////////////////////////////////////////////////////////////</span>
    <span class="c">#{ Sentence-Starter Finder</span>
    <span class="c">#////////////////////////////////////////////////////////////</span>

    <span class="k">def</span> <span class="nf">_is_potential_sent_starter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cur_tok</span><span class="p">,</span> <span class="n">prev_tok</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns True given a token and the token that preceds it if it</span>
<span class="sd">        seems clear that the token is beginning a sentence.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># If a token (i) is preceeded by a sentece break that is</span>
        <span class="c"># not a potential ordinal number or initial, and (ii) is</span>
        <span class="c"># alphabetic, then it is a a sentence-starter.</span>
        <span class="k">return</span> <span class="p">(</span> <span class="n">prev_tok</span><span class="o">.</span><span class="n">sentbreak</span> <span class="ow">and</span> 
             <span class="ow">not</span> <span class="p">(</span><span class="n">prev_tok</span><span class="o">.</span><span class="n">is_number</span> <span class="ow">or</span> <span class="n">prev_tok</span><span class="o">.</span><span class="n">is_initial</span><span class="p">)</span> <span class="ow">and</span>
             <span class="n">cur_tok</span><span class="o">.</span><span class="n">is_alpha</span> <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_find_sent_starters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Uses collocation heuristics for each candidate token to</span>
<span class="sd">        determine if it frequently starts sentences.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">typ</span><span class="p">,</span> <span class="n">typ_at_break_count</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sent_starter_fdist</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">typ</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">typ_count</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_type_fdist</span><span class="p">[</span><span class="n">typ</span><span class="p">]</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">_type_fdist</span><span class="p">[</span><span class="n">typ</span><span class="o">+</span><span class="s">&#39;.&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">typ_count</span> <span class="o">&lt;</span> <span class="n">typ_at_break_count</span><span class="p">:</span>
                <span class="c"># needed after freq_threshold</span>
                <span class="k">continue</span>

            <span class="n">ll</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_col_log_likelihood</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sentbreak_count</span><span class="p">,</span> <span class="n">typ_count</span><span class="p">,</span>
                                         <span class="n">typ_at_break_count</span><span class="p">,</span>
                                          <span class="bp">self</span><span class="o">.</span><span class="n">_type_fdist</span><span class="o">.</span><span class="n">N</span><span class="p">())</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">ll</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SENT_STARTER</span> <span class="ow">and</span>
                <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_type_fdist</span><span class="o">.</span><span class="n">N</span><span class="p">())</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">_sentbreak_count</span> <span class="o">&gt;</span>
                <span class="nb">float</span><span class="p">(</span><span class="n">typ_count</span><span class="p">)</span><span class="o">/</span><span class="n">typ_at_break_count</span><span class="p">):</span>

                <span class="k">yield</span> <span class="n">typ</span><span class="p">,</span> <span class="n">ll</span>

    <span class="k">def</span> <span class="nf">_get_sentbreak_count</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tokens</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of sentence breaks marked in a given set of</span>
<span class="sd">        augmented tokens.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">aug_tok</span> <span class="ow">in</span> <span class="n">tokens</span> <span class="k">if</span> <span class="n">aug_tok</span><span class="o">.</span><span class="n">sentbreak</span><span class="p">)</span>


<span class="c">######################################################################</span>
<span class="c">#{ Punkt Sentence Tokenizer</span>
<span class="c">######################################################################</span>

</div>
<div class="viewcode-block" id="PunktSentenceTokenizer"><a class="viewcode-back" href="../../../api/nltk.tokenize.html#nltk.tokenize.punkt.PunktSentenceTokenizer">[docs]</a><span class="k">class</span> <span class="nc">PunktSentenceTokenizer</span><span class="p">(</span><span class="n">PunktBaseClass</span><span class="p">,</span><span class="n">TokenizerI</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A sentence tokenizer which uses an unsupervised algorithm to build</span>
<span class="sd">    a model for abbreviation words, collocations, and words that start</span>
<span class="sd">    sentences; and then uses that model to find sentence boundaries.</span>
<span class="sd">    This approach has been shown to work well for many European</span>
<span class="sd">    languages.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">train_text</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
            <span class="n">lang_vars</span><span class="o">=</span><span class="n">PunktLanguageVars</span><span class="p">(),</span> <span class="n">token_cls</span><span class="o">=</span><span class="n">PunktToken</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        train_text can either be the sole training text for this sentence</span>
<span class="sd">        boundary detector, or can be a PunktParameters object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">PunktBaseClass</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lang_vars</span><span class="o">=</span><span class="n">lang_vars</span><span class="p">,</span>
                <span class="n">token_cls</span><span class="o">=</span><span class="n">token_cls</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">train_text</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">train</span><span class="p">(</span><span class="n">train_text</span><span class="p">,</span> <span class="n">verbose</span><span class="p">)</span>

<div class="viewcode-block" id="PunktSentenceTokenizer.train"><a class="viewcode-back" href="../../../api/nltk.tokenize.html#nltk.tokenize.punkt.PunktSentenceTokenizer.train">[docs]</a>    <span class="k">def</span> <span class="nf">train</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">train_text</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Derives parameters from a given training text, or uses the parameters</span>
<span class="sd">        given. Repeated calls to this method destroy previous parameters. For</span>
<span class="sd">        incremental training, instantiate a separate PunktTrainer instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">train_text</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="s">&#39;&#39;</span><span class="p">),</span> <span class="nb">type</span><span class="p">(</span><span class="s">u&#39;&#39;</span><span class="p">)):</span>
            <span class="k">return</span> <span class="n">train_text</span>
        <span class="k">return</span> <span class="n">PunktTrainer</span><span class="p">(</span><span class="n">train_text</span><span class="p">,</span> <span class="n">lang_vars</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_lang_vars</span><span class="p">,</span>
                <span class="n">token_cls</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_Token</span><span class="p">)</span><span class="o">.</span><span class="n">get_params</span><span class="p">()</span>
    
    <span class="c">#////////////////////////////////////////////////////////////</span>
    <span class="c">#{ Tokenization</span>
    <span class="c">#////////////////////////////////////////////////////////////</span>
</div>
<div class="viewcode-block" id="PunktSentenceTokenizer.tokenize"><a class="viewcode-back" href="../../../api/nltk.tokenize.html#nltk.tokenize.punkt.PunktSentenceTokenizer.tokenize">[docs]</a>    <span class="k">def</span> <span class="nf">tokenize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">realign_boundaries</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a text, returns a list of the sentences in that text.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sentences_from_text</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">realign_boundaries</span><span class="p">))</span>
</div>
<div class="viewcode-block" id="PunktSentenceTokenizer.span_tokenize"><a class="viewcode-back" href="../../../api/nltk.tokenize.html#nltk.tokenize.punkt.PunktSentenceTokenizer.span_tokenize">[docs]</a>    <span class="k">def</span> <span class="nf">span_tokenize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a text, returns a list of the (start, end) spans of sentences</span>
<span class="sd">        in the text.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[(</span><span class="n">sl</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">sl</span><span class="o">.</span><span class="n">stop</span><span class="p">)</span> <span class="k">for</span> <span class="n">sl</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_slices_from_text</span><span class="p">(</span><span class="n">text</span><span class="p">)]</span>
</div>
<div class="viewcode-block" id="PunktSentenceTokenizer.sentences_from_text"><a class="viewcode-back" href="../../../api/nltk.tokenize.html#nltk.tokenize.punkt.PunktSentenceTokenizer.sentences_from_text">[docs]</a>    <span class="k">def</span> <span class="nf">sentences_from_text</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">realign_boundaries</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a text, generates the sentences in that text by only</span>
<span class="sd">        testing candidate sentence breaks. If realign_boundaries is</span>
<span class="sd">        True, includes in the sentence closing punctuation that</span>
<span class="sd">        follows the period.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sents</span> <span class="o">=</span> <span class="p">[</span><span class="n">text</span><span class="p">[</span><span class="n">sl</span><span class="p">]</span> <span class="k">for</span> <span class="n">sl</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_slices_from_text</span><span class="p">(</span><span class="n">text</span><span class="p">)]</span>
        <span class="k">if</span> <span class="n">realign_boundaries</span><span class="p">:</span>
            <span class="n">sents</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_realign_boundaries</span><span class="p">(</span><span class="n">sents</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sents</span>
</div>
    <span class="k">def</span> <span class="nf">_slices_from_text</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">):</span>
        <span class="n">last_break</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">match</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lang_vars</span><span class="o">.</span><span class="n">period_context_re</span><span class="p">()</span><span class="o">.</span><span class="n">finditer</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
            <span class="n">context</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">()</span> <span class="o">+</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s">&#39;after_tok&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">text_contains_sentbreak</span><span class="p">(</span><span class="n">context</span><span class="p">):</span>
                <span class="k">yield</span> <span class="nb">slice</span><span class="p">(</span><span class="n">last_break</span><span class="p">,</span> <span class="n">match</span><span class="o">.</span><span class="n">end</span><span class="p">())</span>
                <span class="k">if</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s">&#39;next_tok&#39;</span><span class="p">):</span>
                    <span class="c"># next sentence starts after whitespace</span>
                    <span class="n">last_break</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="s">&#39;next_tok&#39;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c"># next sentence starts at following punctuation</span>
                    <span class="n">last_break</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>
        <span class="k">yield</span> <span class="nb">slice</span><span class="p">(</span><span class="n">last_break</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">text</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_realign_boundaries</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sents</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Attempts to realign punctuation that falls after the period but</span>
<span class="sd">        should otherwise be included in the same sentence.</span>

<span class="sd">        For example: &quot;(Sent1.) Sent2.&quot; will otherwise be split as::</span>
<span class="sd">        </span>
<span class="sd">            [&quot;(Sent1.&quot;, &quot;) Sent1.&quot;].</span>
<span class="sd">            </span>
<span class="sd">        This method will produce::</span>
<span class="sd">        </span>
<span class="sd">            [&quot;(Sent1.)&quot;, &quot;Sent2.&quot;].</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">realign</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span> <span class="ow">in</span> <span class="n">_pair_iter</span><span class="p">(</span><span class="n">sents</span><span class="p">):</span>
            <span class="n">s1</span> <span class="o">=</span> <span class="n">s1</span><span class="p">[</span><span class="n">realign</span><span class="p">:]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">s2</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">s1</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="n">s1</span>
                <span class="k">continue</span>

            <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lang_vars</span><span class="o">.</span><span class="n">re_boundary_realignment</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s2</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">m</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">s1</span> <span class="o">+</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
                <span class="n">realign</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">realign</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">if</span> <span class="n">s1</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="n">s1</span>

<div class="viewcode-block" id="PunktSentenceTokenizer.text_contains_sentbreak"><a class="viewcode-back" href="../../../api/nltk.tokenize.html#nltk.tokenize.punkt.PunktSentenceTokenizer.text_contains_sentbreak">[docs]</a>    <span class="k">def</span> <span class="nf">text_contains_sentbreak</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns True if the given text includes a sentence break.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">found</span> <span class="o">=</span> <span class="bp">False</span> <span class="c"># used to ignore last token</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_annotate_tokens</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tokenize_words</span><span class="p">(</span><span class="n">text</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">found</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">True</span>
            <span class="k">if</span> <span class="n">t</span><span class="o">.</span><span class="n">sentbreak</span><span class="p">:</span>
                <span class="n">found</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">return</span> <span class="bp">False</span>
   </div>
<div class="viewcode-block" id="PunktSentenceTokenizer.sentences_from_text_legacy"><a class="viewcode-back" href="../../../api/nltk.tokenize.html#nltk.tokenize.punkt.PunktSentenceTokenizer.sentences_from_text_legacy">[docs]</a>    <span class="k">def</span> <span class="nf">sentences_from_text_legacy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a text, generates the sentences in that text. Annotates all</span>
<span class="sd">        tokens, rather than just those with possible sentence breaks. Should</span>
<span class="sd">        produce the same results as L{sentences_from_text}.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tokens</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_annotate_tokens</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tokenize_words</span><span class="p">(</span><span class="n">text</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_build_sentence_list</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">tokens</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="PunktSentenceTokenizer.sentences_from_tokens"><a class="viewcode-back" href="../../../api/nltk.tokenize.html#nltk.tokenize.punkt.PunktSentenceTokenizer.sentences_from_tokens">[docs]</a>    <span class="k">def</span> <span class="nf">sentences_from_tokens</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tokens</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a sequence of tokens, generates lists of tokens, each list</span>
<span class="sd">        corresponding to a sentence.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tokens</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_annotate_tokens</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_Token</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tokens</span><span class="p">))</span>
        <span class="n">sentence</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">aug_tok</span> <span class="ow">in</span> <span class="n">tokens</span><span class="p">:</span>
            <span class="n">sentence</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">aug_tok</span><span class="o">.</span><span class="n">tok</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">aug_tok</span><span class="o">.</span><span class="n">sentbreak</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">sentence</span>
                <span class="n">sentence</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">sentence</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">sentence</span>
            </div>
    <span class="k">def</span> <span class="nf">_annotate_tokens</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tokens</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a set of tokens augmented with markers for line-start and</span>
<span class="sd">        paragraph-start, returns an iterator through those tokens with full</span>
<span class="sd">        annotation including predicted sentence breaks.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Make a preliminary pass through the document, marking likely</span>
        <span class="c"># sentence breaks, abbreviations, and ellipsis tokens.</span>
        <span class="n">tokens</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_annotate_first_pass</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span>

        <span class="c"># Make a second pass through the document, using token context</span>
        <span class="c"># information to change our preliminary decisions about where</span>
        <span class="c"># sentence breaks, abbreviations, and ellipsis occurs.</span>
        <span class="n">tokens</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_annotate_second_pass</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span>

        <span class="c">## [XX] TESTING</span>
        <span class="c">#tokens = list(tokens)</span>
        <span class="c">#self.dump(tokens)</span>

        <span class="k">return</span> <span class="n">tokens</span>

    <span class="k">def</span> <span class="nf">_build_sentence_list</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">tokens</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given the original text and the list of augmented word tokens,</span>
<span class="sd">        construct and return a tokenized list of sentence strings.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Most of the work here is making sure that we put the right</span>
        <span class="c"># pieces of whitespace back in all the right places.</span>

        <span class="c"># Our position in the source text, used to keep track of which</span>
        <span class="c"># whitespace to add:</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c"># A regular expression that finds pieces of whitespace:</span>
        <span class="n">WS_REGEXP</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s">r&#39;\s*&#39;</span><span class="p">)</span>
        
        <span class="n">sentence</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
        <span class="k">for</span> <span class="n">aug_tok</span> <span class="ow">in</span> <span class="n">tokens</span><span class="p">:</span>
            <span class="n">tok</span> <span class="o">=</span> <span class="n">aug_tok</span><span class="o">.</span><span class="n">tok</span>

            <span class="c"># Find the whitespace before this token, and update pos.</span>
            <span class="n">ws</span> <span class="o">=</span> <span class="n">WS_REGEXP</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span><span class="o">.</span><span class="n">group</span><span class="p">()</span>
            <span class="n">pos</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ws</span><span class="p">)</span>

            <span class="c"># Some of the rules used by the punkt word tokenizer</span>
            <span class="c"># strip whitespace out of the text, resulting in tokens</span>
            <span class="c"># that contain whitespace in the source text.  If our</span>
            <span class="c"># token doesn&#39;t match, see if adding whitespace helps.</span>
            <span class="c"># If so, then use the version with whitespace.</span>
            <span class="k">if</span> <span class="n">text</span><span class="p">[</span><span class="n">pos</span><span class="p">:</span><span class="n">pos</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="n">tok</span><span class="p">)]</span> <span class="o">!=</span> <span class="n">tok</span><span class="p">:</span>
                <span class="n">pat</span> <span class="o">=</span> <span class="s">&#39;\s*&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">tok</span><span class="p">)</span>
                <span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">pat</span><span class="p">)</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">text</span><span class="p">,</span><span class="n">pos</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">m</span><span class="p">:</span> <span class="n">tok</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">()</span>

            <span class="c"># Move our position pointer to the end of the token.</span>
            <span class="k">assert</span> <span class="n">text</span><span class="p">[</span><span class="n">pos</span><span class="p">:</span><span class="n">pos</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="n">tok</span><span class="p">)]</span> <span class="o">==</span> <span class="n">tok</span>
            <span class="n">pos</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">tok</span><span class="p">)</span>

            <span class="c"># Add this token.  If it&#39;s not at the beginning of the</span>
            <span class="c"># sentence, then include any whitespace that separated it</span>
            <span class="c"># from the previous token.</span>
            <span class="k">if</span> <span class="n">sentence</span><span class="p">:</span>
                <span class="n">sentence</span> <span class="o">+=</span> <span class="n">ws</span> <span class="o">+</span> <span class="n">tok</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sentence</span> <span class="o">+=</span> <span class="n">tok</span>

            <span class="c"># If we&#39;re at a sentence break, then start a new sentence.</span>
            <span class="k">if</span> <span class="n">aug_tok</span><span class="o">.</span><span class="n">sentbreak</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">sentence</span>
                <span class="n">sentence</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>

        <span class="c"># If the last sentence is emtpy, discard it.</span>
        <span class="k">if</span> <span class="n">sentence</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">sentence</span>

    <span class="c"># [XX] TESTING</span>
<div class="viewcode-block" id="PunktSentenceTokenizer.dump"><a class="viewcode-back" href="../../../api/nltk.tokenize.html#nltk.tokenize.punkt.PunktSentenceTokenizer.dump">[docs]</a>    <span class="k">def</span> <span class="nf">dump</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tokens</span><span class="p">):</span>
        <span class="k">print</span> <span class="s">&#39;writing to /tmp/punkt.new...&#39;</span>
        <span class="n">out</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s">&#39;/tmp/punkt.new&#39;</span><span class="p">,</span> <span class="s">&#39;w&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">aug_tok</span> <span class="ow">in</span> <span class="n">tokens</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">aug_tok</span><span class="o">.</span><span class="n">parastart</span><span class="p">:</span>
                <span class="n">out</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\n\n</span><span class="s">&#39;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">aug_tok</span><span class="o">.</span><span class="n">linestart</span><span class="p">:</span>
                <span class="n">out</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">out</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39; &#39;</span><span class="p">)</span>

            <span class="n">out</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">aug_tok</span><span class="p">))</span>
        <span class="n">out</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="c">#////////////////////////////////////////////////////////////</span>
    <span class="c">#{ Customization Variables</span>
    <span class="c">#////////////////////////////////////////////////////////////</span>
</div>
    <span class="n">PUNCTUATION</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="s">&#39;;:,.!?&#39;</span><span class="p">)</span>

    <span class="c">#////////////////////////////////////////////////////////////</span>
    <span class="c">#{ Annotation Procedures</span>
    <span class="c">#////////////////////////////////////////////////////////////</span>

    <span class="k">def</span> <span class="nf">_annotate_second_pass</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tokens</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs a token-based classification (section 4) over the given</span>
<span class="sd">        tokens, making use of the orthographic heuristic (4.1.1), collocation</span>
<span class="sd">        heuristic (4.1.2) and frequent sentence starter heuristic (4.1.3).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">t1</span><span class="p">,</span> <span class="n">t2</span> <span class="ow">in</span> <span class="n">_pair_iter</span><span class="p">(</span><span class="n">tokens</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_second_pass_annotation</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">)</span>
            <span class="k">yield</span> <span class="n">t1</span>

    <span class="k">def</span> <span class="nf">_second_pass_annotation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">aug_tok1</span><span class="p">,</span> <span class="n">aug_tok2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs token-based classification over a pair of contiguous tokens</span>
<span class="sd">        returning an updated augmented token for the first of them.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Is it the last token? We can&#39;t do anything then.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">aug_tok2</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">tok</span> <span class="o">=</span> <span class="n">aug_tok1</span><span class="o">.</span><span class="n">tok</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">aug_tok1</span><span class="o">.</span><span class="n">period_final</span><span class="p">:</span>
            <span class="c"># We only care about words ending in periods.</span>
            <span class="k">return</span>

        <span class="n">typ</span> <span class="o">=</span> <span class="n">aug_tok1</span><span class="o">.</span><span class="n">type_no_period</span>
        <span class="n">next_tok</span> <span class="o">=</span> <span class="n">aug_tok2</span><span class="o">.</span><span class="n">tok</span>
        <span class="n">next_typ</span> <span class="o">=</span> <span class="n">aug_tok2</span><span class="o">.</span><span class="n">type_no_sentperiod</span>
        <span class="n">tok_is_initial</span> <span class="o">=</span> <span class="n">aug_tok1</span><span class="o">.</span><span class="n">is_initial</span>

        <span class="c"># [4.1.2. Collocational Heuristic] If there&#39;s a</span>
        <span class="c"># collocation between the word before and after the</span>
        <span class="c"># period, then label tok as an abbreviation and NOT</span>
        <span class="c"># a sentence break. Note that collocations with</span>
        <span class="c"># frequent sentence starters as their second word are</span>
        <span class="c"># excluded in training.</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">typ</span><span class="p">,</span> <span class="n">next_typ</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="o">.</span><span class="n">collocations</span><span class="p">:</span>
            <span class="n">aug_tok1</span><span class="o">.</span><span class="n">sentbreak</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="n">aug_tok1</span><span class="o">.</span><span class="n">abbr</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">return</span>

        <span class="c"># [4.2. Token-Based Reclassification of Abbreviations] If</span>
        <span class="c"># the token is an abbreviation or an ellipsis, then decide</span>
        <span class="c"># whether we should *also* classify it as a sentbreak.</span>
        <span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">aug_tok1</span><span class="o">.</span><span class="n">abbr</span> <span class="ow">or</span> <span class="n">aug_tok1</span><span class="o">.</span><span class="n">ellipsis</span><span class="p">)</span> <span class="ow">and</span>
             <span class="p">(</span><span class="ow">not</span> <span class="n">tok_is_initial</span><span class="p">)</span> <span class="p">):</span>
            <span class="c"># [4.1.1. Orthographic Heuristic] Check if there&#39;s</span>
            <span class="c"># orthogrpahic evidence about whether the next word</span>
            <span class="c"># starts a sentence or not.</span>
            <span class="n">is_sent_starter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ortho_heuristic</span><span class="p">(</span><span class="n">aug_tok2</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">is_sent_starter</span> <span class="o">==</span> <span class="bp">True</span><span class="p">:</span>
                <span class="n">aug_tok1</span><span class="o">.</span><span class="n">sentbreak</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="k">return</span>

            <span class="c"># [4.1.3. Frequent Sentence Starter Heruistic] If the</span>
            <span class="c"># next word is capitalized, and is a member of the</span>
            <span class="c"># frequent-sentence-starters list, then label tok as a</span>
            <span class="c"># sentence break.</span>
            <span class="k">if</span> <span class="p">(</span> <span class="n">aug_tok2</span><span class="o">.</span><span class="n">first_upper</span> <span class="ow">and</span>
                 <span class="n">next_typ</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="o">.</span><span class="n">sent_starters</span><span class="p">):</span>
                <span class="n">aug_tok1</span><span class="o">.</span><span class="n">sentbreak</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="k">return</span>

        <span class="c"># [4.3. Token-Based Detection of Initials and Ordinals]</span>
        <span class="c"># Check if any initials or ordinals tokens that are marked</span>
        <span class="c"># as sentbreaks should be reclassified as abbreviations.</span>
        <span class="k">if</span> <span class="n">tok_is_initial</span> <span class="ow">or</span> <span class="n">typ</span> <span class="o">==</span> <span class="s">&#39;##number##&#39;</span><span class="p">:</span>

            <span class="c"># [4.1.1. Orthographic Heuristic] Check if there&#39;s</span>
            <span class="c"># orthogrpahic evidence about whether the next word</span>
            <span class="c"># starts a sentence or not.</span>
            <span class="n">is_sent_starter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ortho_heuristic</span><span class="p">(</span><span class="n">aug_tok2</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">is_sent_starter</span> <span class="o">==</span> <span class="bp">False</span><span class="p">:</span>
                <span class="n">aug_tok1</span><span class="o">.</span><span class="n">sentbreak</span> <span class="o">=</span> <span class="bp">False</span>
                <span class="n">aug_tok1</span><span class="o">.</span><span class="n">abbr</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="k">return</span>

            <span class="c"># Special heuristic for initials: if orthogrpahic</span>
            <span class="c"># heuristc is unknown, and next word is always</span>
            <span class="c"># capitalized, then mark as abbrev (eg: J. Bach).</span>
            <span class="k">if</span> <span class="p">(</span> <span class="n">is_sent_starter</span> <span class="o">==</span> <span class="s">&#39;unknown&#39;</span> <span class="ow">and</span> <span class="n">tok_is_initial</span> <span class="ow">and</span>
                 <span class="n">aug_tok2</span><span class="o">.</span><span class="n">first_upper</span> <span class="ow">and</span>
                 <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="o">.</span><span class="n">ortho_context</span><span class="p">[</span><span class="n">next_typ</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">_ORTHO_LC</span><span class="p">)</span> <span class="p">):</span>
                <span class="n">aug_tok1</span><span class="o">.</span><span class="n">sentbreak</span> <span class="o">=</span> <span class="bp">False</span>
                <span class="n">aug_tok1</span><span class="o">.</span><span class="n">abbr</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="k">return</span>

        <span class="k">return</span>

    <span class="k">def</span> <span class="nf">_ortho_heuristic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">aug_tok</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Decide whether the given token is the first token in a sentence.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Sentences don&#39;t start with punctuation marks:</span>
        <span class="k">if</span> <span class="n">aug_tok</span><span class="o">.</span><span class="n">tok</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">PUNCTUATION</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>

        <span class="n">ortho_context</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="o">.</span><span class="n">ortho_context</span><span class="p">[</span><span class="n">aug_tok</span><span class="o">.</span><span class="n">type_no_sentperiod</span><span class="p">]</span>

        <span class="c"># If the word is capitalized, occurs at least once with a</span>
        <span class="c"># lower case first letter, and never occurs with an upper case</span>
        <span class="c"># first letter sentence-internally, then it&#39;s a sentence starter.</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">aug_tok</span><span class="o">.</span><span class="n">first_upper</span> <span class="ow">and</span>
             <span class="p">(</span><span class="n">ortho_context</span> <span class="o">&amp;</span> <span class="n">_ORTHO_LC</span><span class="p">)</span> <span class="ow">and</span>
             <span class="ow">not</span> <span class="p">(</span><span class="n">ortho_context</span> <span class="o">&amp;</span> <span class="n">_ORTHO_MID_UC</span><span class="p">)</span> <span class="p">):</span>
            <span class="k">return</span> <span class="bp">True</span>

        <span class="c"># If the word is lower case, and either (a) we&#39;ve seen it used</span>
        <span class="c"># with upper case, or (b) we&#39;ve never seen it used</span>
        <span class="c"># sentence-initially with lower case, then it&#39;s not a sentence</span>
        <span class="c"># starter.</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">aug_tok</span><span class="o">.</span><span class="n">first_lower</span> <span class="ow">and</span>
             <span class="p">((</span><span class="n">ortho_context</span> <span class="o">&amp;</span> <span class="n">_ORTHO_UC</span><span class="p">)</span> <span class="ow">or</span>
              <span class="ow">not</span> <span class="p">(</span><span class="n">ortho_context</span> <span class="o">&amp;</span> <span class="n">_ORTHO_BEG_LC</span><span class="p">))</span> <span class="p">):</span>
            <span class="k">return</span> <span class="bp">False</span>

        <span class="c"># Otherwise, we&#39;re not sure.</span>
        <span class="k">return</span> <span class="s">&#39;unknown&#39;</span>

</div>
<div class="viewcode-block" id="demo"><a class="viewcode-back" href="../../../api/nltk.tokenize.html#nltk.tokenize.punkt.demo">[docs]</a><span class="k">def</span> <span class="nf">demo</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">tok_cls</span><span class="o">=</span><span class="n">PunktSentenceTokenizer</span><span class="p">,</span> <span class="n">train_cls</span><span class="o">=</span><span class="n">PunktTrainer</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Builds a punkt model and applies it to the same text&quot;&quot;&quot;</span>
    <span class="n">cleanup</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s">r&#39;(?:\r|^\s+)&#39;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">MULTILINE</span><span class="p">)</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s">&#39;&#39;</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">,</span> <span class="s">&#39; &#39;</span><span class="p">)</span>
    <span class="n">trainer</span> <span class="o">=</span> <span class="n">train_cls</span><span class="p">()</span>
    <span class="n">trainer</span><span class="o">.</span><span class="n">INCLUDE_ALL_COLLOCS</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="n">trainer</span><span class="o">.</span><span class="n">train</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
    <span class="n">sbd</span> <span class="o">=</span> <span class="n">tok_cls</span><span class="p">(</span><span class="n">trainer</span><span class="o">.</span><span class="n">get_params</span><span class="p">())</span>
    <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">sbd</span><span class="o">.</span><span class="n">sentences_from_text</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">realign_boundaries</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="k">print</span> <span class="n">cleanup</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>

</div>
<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">doctest</span>
    <span class="n">doctest</span><span class="o">.</span><span class="n">testmod</span><span class="p">(</span><span class="n">optionflags</span><span class="o">=</span><span class="n">doctest</span><span class="o">.</span><span class="n">NORMALIZE_WHITESPACE</span><span class="p">)</span>
</pre></div>

          </div>
        </div>
      </div>
        </div>
        <div class="sidebar">
          <h3>Table Of Contents</h3>
          <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../news.html">NLTK News</a></li>
</ul>

          <h3 style="margin-top: 1.5em;">Search</h3>
          <form class="search" action="../../../search.html" method="get">
            <input type="text" name="q" />
            <input type="submit" value="Go" />
            <input type="hidden" name="check_keywords" value="yes" />
            <input type="hidden" name="area" value="default" />
          </form>
          <p class="searchtip" style="font-size: 90%">
            Enter search terms or a module, class or function name.
          </p>
        </div>
        <div class="clearer"></div>
      </div>
    </div>

    <div class="footer-wrapper">
      <div class="footer">
        <div class="left">
          <a href="../../../genindex.html" title="General Index"
             >index</a>
        </div>

        <div class="right">
          
    <div class="footer">
        &copy; Copyright 2011, Steven Bird.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.2.
    </div>
        </div>
        <div class="clearer"></div>
      </div>
    </div>

  </body>
</html>