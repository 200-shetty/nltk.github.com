

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>nltk.corpus.reader.wordnet &mdash; NLTK 2.0 documentation</title>
    
    <link rel="stylesheet" href="../../../../_static/agogo.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../../',
        VERSION:     '2.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../../_static/doctools.js"></script>
    <link rel="top" title="NLTK 2.0 documentation" href="../../../../index.html" />
    <link rel="up" title="nltk.corpus.reader" href="../reader.html" /> 
  </head>
  <body>
    <div class="header-wrapper">
      <div class="header">
        <div class="headertitle"><a
          href="../../../../index.html">NLTK 2.0 documentation</a></div>
        <div class="rel">
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |
          <a href="../../../../genindex.html" title="General Index"
             accesskey="I">index</a>
        </div>
       </div>
    </div>

    <div class="content-wrapper">
      <div class="content">
        <div class="document">
            
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for nltk.corpus.reader.wordnet</h1><div class="highlight"><pre>
<span class="c"># Natural Language Toolkit: WordNet</span>
<span class="c">#</span>
<span class="c"># Copyright (C) 2001-2011 NLTK Project</span>
<span class="c"># Author: Steven Bethard &lt;Steven.Bethard@colorado.edu&gt;</span>
<span class="c">#         Steven Bird &lt;sb@csse.unimelb.edu.au&gt;</span>
<span class="c">#         Edward Loper &lt;edloper@gradient.cis.upenn.edu&gt;</span>
<span class="c">#         Nitin Madnani &lt;nmadnani@ets.org&gt;</span>
<span class="c"># URL: &lt;http://www.nltk.org/&gt;</span>
<span class="c"># For license information, see LICENSE.TXT</span>

<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">islice</span><span class="p">,</span> <span class="n">chain</span>
<span class="kn">from</span> <span class="nn">operator</span> <span class="kn">import</span> <span class="n">itemgetter</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>

<span class="kn">from</span> <span class="nn">nltk.corpus.reader</span> <span class="kn">import</span> <span class="n">CorpusReader</span>
<span class="kn">from</span> <span class="nn">nltk.util</span> <span class="kn">import</span> <span class="n">binary_search_file</span> <span class="k">as</span> <span class="n">_binary_search_file</span>
<span class="kn">from</span> <span class="nn">nltk.probability</span> <span class="kn">import</span> <span class="n">FreqDist</span>

<span class="c">######################################################################</span>
<span class="c">## Table of Contents</span>
<span class="c">######################################################################</span>
<span class="c">## - Constants</span>
<span class="c">## - Data Classes</span>
<span class="c">##   - WordNetError</span>
<span class="c">##   - Lemma</span>
<span class="c">##   - Synset</span>
<span class="c">## - WordNet Corpus Reader</span>
<span class="c">## - WordNet Information Content Corpus Reader</span>
<span class="c">## - Similarity Metrics</span>
<span class="c">## - Demo</span>

<span class="c">######################################################################</span>
<span class="c">## Constants</span>
<span class="c">######################################################################</span>

<span class="c">#: Positive infinity (for similarity functions)</span>
<span class="n">_INF</span> <span class="o">=</span> <span class="mf">1e300</span>

<span class="c">#{ Part-of-speech constants</span>
<span class="n">ADJ</span><span class="p">,</span> <span class="n">ADJ_SAT</span><span class="p">,</span> <span class="n">ADV</span><span class="p">,</span> <span class="n">NOUN</span><span class="p">,</span> <span class="n">VERB</span> <span class="o">=</span> <span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="s">&#39;s&#39;</span><span class="p">,</span> <span class="s">&#39;r&#39;</span><span class="p">,</span> <span class="s">&#39;n&#39;</span><span class="p">,</span> <span class="s">&#39;v&#39;</span>
<span class="c">#}</span>

<span class="n">POS_LIST</span> <span class="o">=</span> <span class="p">[</span><span class="n">NOUN</span><span class="p">,</span> <span class="n">VERB</span><span class="p">,</span> <span class="n">ADJ</span><span class="p">,</span> <span class="n">ADV</span><span class="p">]</span>

<span class="c">#: A table of strings that are used to express verb frames.</span>
<span class="n">VERB_FRAME_STRINGS</span> <span class="o">=</span> <span class="p">(</span>
    <span class="bp">None</span><span class="p">,</span>
    <span class="s">&quot;Something </span><span class="si">%s</span><span class="s">&quot;</span><span class="p">,</span>
    <span class="s">&quot;Somebody </span><span class="si">%s</span><span class="s">&quot;</span><span class="p">,</span>
    <span class="s">&quot;It is </span><span class="si">%s</span><span class="s">ing&quot;</span><span class="p">,</span>
    <span class="s">&quot;Something is </span><span class="si">%s</span><span class="s">ing PP&quot;</span><span class="p">,</span>
    <span class="s">&quot;Something </span><span class="si">%s</span><span class="s"> something Adjective/Noun&quot;</span><span class="p">,</span>
    <span class="s">&quot;Something </span><span class="si">%s</span><span class="s"> Adjective/Noun&quot;</span><span class="p">,</span>
    <span class="s">&quot;Somebody </span><span class="si">%s</span><span class="s"> Adjective&quot;</span><span class="p">,</span>
    <span class="s">&quot;Somebody </span><span class="si">%s</span><span class="s"> something&quot;</span><span class="p">,</span>
    <span class="s">&quot;Somebody </span><span class="si">%s</span><span class="s"> somebody&quot;</span><span class="p">,</span>
    <span class="s">&quot;Something </span><span class="si">%s</span><span class="s"> somebody&quot;</span><span class="p">,</span>
    <span class="s">&quot;Something </span><span class="si">%s</span><span class="s"> something&quot;</span><span class="p">,</span>
    <span class="s">&quot;Something </span><span class="si">%s</span><span class="s"> to somebody&quot;</span><span class="p">,</span>
    <span class="s">&quot;Somebody </span><span class="si">%s</span><span class="s"> on something&quot;</span><span class="p">,</span>
    <span class="s">&quot;Somebody </span><span class="si">%s</span><span class="s"> somebody something&quot;</span><span class="p">,</span>
    <span class="s">&quot;Somebody </span><span class="si">%s</span><span class="s"> something to somebody&quot;</span><span class="p">,</span>
    <span class="s">&quot;Somebody </span><span class="si">%s</span><span class="s"> something from somebody&quot;</span><span class="p">,</span>
    <span class="s">&quot;Somebody </span><span class="si">%s</span><span class="s"> somebody with something&quot;</span><span class="p">,</span>
    <span class="s">&quot;Somebody </span><span class="si">%s</span><span class="s"> somebody of something&quot;</span><span class="p">,</span>
    <span class="s">&quot;Somebody </span><span class="si">%s</span><span class="s"> something on somebody&quot;</span><span class="p">,</span>
    <span class="s">&quot;Somebody </span><span class="si">%s</span><span class="s"> somebody PP&quot;</span><span class="p">,</span>
    <span class="s">&quot;Somebody </span><span class="si">%s</span><span class="s"> something PP&quot;</span><span class="p">,</span>
    <span class="s">&quot;Somebody </span><span class="si">%s</span><span class="s"> PP&quot;</span><span class="p">,</span>
    <span class="s">&quot;Somebody&#39;s (body part) </span><span class="si">%s</span><span class="s">&quot;</span><span class="p">,</span>
    <span class="s">&quot;Somebody </span><span class="si">%s</span><span class="s"> somebody to INFINITIVE&quot;</span><span class="p">,</span>
    <span class="s">&quot;Somebody </span><span class="si">%s</span><span class="s"> somebody INFINITIVE&quot;</span><span class="p">,</span>
    <span class="s">&quot;Somebody </span><span class="si">%s</span><span class="s"> that CLAUSE&quot;</span><span class="p">,</span>
    <span class="s">&quot;Somebody </span><span class="si">%s</span><span class="s"> to somebody&quot;</span><span class="p">,</span>
    <span class="s">&quot;Somebody </span><span class="si">%s</span><span class="s"> to INFINITIVE&quot;</span><span class="p">,</span>
    <span class="s">&quot;Somebody </span><span class="si">%s</span><span class="s"> whether INFINITIVE&quot;</span><span class="p">,</span>
    <span class="s">&quot;Somebody </span><span class="si">%s</span><span class="s"> somebody into V-ing something&quot;</span><span class="p">,</span>
    <span class="s">&quot;Somebody </span><span class="si">%s</span><span class="s"> something with something&quot;</span><span class="p">,</span>
    <span class="s">&quot;Somebody </span><span class="si">%s</span><span class="s"> INFINITIVE&quot;</span><span class="p">,</span>
    <span class="s">&quot;Somebody </span><span class="si">%s</span><span class="s"> VERB-ing&quot;</span><span class="p">,</span>
    <span class="s">&quot;It </span><span class="si">%s</span><span class="s"> that CLAUSE&quot;</span><span class="p">,</span>
    <span class="s">&quot;Something </span><span class="si">%s</span><span class="s"> INFINITIVE&quot;</span><span class="p">)</span>

<span class="c">######################################################################</span>
<span class="c">## Data Classes</span>
<span class="c">######################################################################</span>

<div class="viewcode-block" id="WordNetError"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.WordNetError">[docs]</a><span class="k">class</span> <span class="nc">WordNetError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;An exception class for wordnet-related errors.&quot;&quot;&quot;</span>

</div>
<span class="k">class</span> <span class="nc">_WordNetObject</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A common base class for lemmas and synsets.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">hypernyms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_related</span><span class="p">(</span><span class="s">&#39;@&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">instance_hypernyms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_related</span><span class="p">(</span><span class="s">&#39;@i&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">hyponyms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_related</span><span class="p">(</span><span class="s">&#39;~&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">instance_hyponyms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_related</span><span class="p">(</span><span class="s">&#39;~i&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">member_holonyms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_related</span><span class="p">(</span><span class="s">&#39;#m&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">substance_holonyms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_related</span><span class="p">(</span><span class="s">&#39;#s&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">part_holonyms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_related</span><span class="p">(</span><span class="s">&#39;#p&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">member_meronyms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_related</span><span class="p">(</span><span class="s">&#39;%m&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">substance_meronyms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_related</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%s</span><span class="s">&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">part_meronyms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_related</span><span class="p">(</span><span class="s">&#39;%p&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">topic_domains</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_related</span><span class="p">(</span><span class="s">&#39;;c&#39;</span><span class="p">)</span>
        
    <span class="k">def</span> <span class="nf">region_domains</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_related</span><span class="p">(</span><span class="s">&#39;;r&#39;</span><span class="p">)</span>
        
    <span class="k">def</span> <span class="nf">usage_domains</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_related</span><span class="p">(</span><span class="s">&#39;;u&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">attributes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_related</span><span class="p">(</span><span class="s">&#39;=&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">entailments</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_related</span><span class="p">(</span><span class="s">&#39;*&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">causes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_related</span><span class="p">(</span><span class="s">&#39;&gt;&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">also_sees</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_related</span><span class="p">(</span><span class="s">&#39;^&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">verb_groups</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_related</span><span class="p">(</span><span class="s">&#39;$&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">similar_tos</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_related</span><span class="p">(</span><span class="s">&#39;&amp;&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">name</span>

    <span class="k">def</span> <span class="nf">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">name</span>

<div class="viewcode-block" id="Lemma"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.Lemma">[docs]</a><span class="k">class</span> <span class="nc">Lemma</span><span class="p">(</span><span class="n">_WordNetObject</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The lexical entry for a single morphological form of a</span>
<span class="sd">    sense-disambiguated word.</span>

<span class="sd">    Create a Lemma from a &quot;&lt;word&gt;.&lt;pos&gt;.&lt;number&gt;.&lt;lemma&gt;&quot; string where:</span>
<span class="sd">    &lt;word&gt; is the morphological stem identifying the synset</span>
<span class="sd">    &lt;pos&gt; is one of the module attributes ADJ, ADJ_SAT, ADV, NOUN or VERB</span>
<span class="sd">    &lt;number&gt; is the sense number, counting from 0.</span>
<span class="sd">    &lt;lemma&gt; is the morphological form of interest</span>

<span class="sd">    Note that &lt;word&gt; and &lt;lemma&gt; can be different, e.g. the Synset</span>
<span class="sd">    &#39;salt.n.03&#39; has the Lemmas &#39;salt.n.03.salt&#39;, &#39;salt.n.03.saltiness&#39; and</span>
<span class="sd">    &#39;salt.n.03.salinity&#39;.</span>

<span class="sd">    Lemma attributes</span>
<span class="sd">    ----------------</span>
<span class="sd">    name - The canonical name of this lemma.</span>
<span class="sd">    synset - The synset that this lemma belongs to.</span>
<span class="sd">    syntactic_marker - For adjectives, the WordNet string identifying the</span>
<span class="sd">        syntactic position relative modified noun. See:</span>
<span class="sd">            http://wordnet.princeton.edu/man/wninput.5WN.html#sect10</span>
<span class="sd">        For all other parts of speech, this attribute is None.</span>

<span class="sd">    Lemma methods</span>
<span class="sd">    -------------</span>
<span class="sd">    Lemmas have the following methods for retrieving related Lemmas. They</span>
<span class="sd">    correspond to the names for the pointer symbols defined here:</span>
<span class="sd">        http://wordnet.princeton.edu/man/wninput.5WN.html#sect3</span>
<span class="sd">    These methods all return lists of Lemmas.</span>

<span class="sd">    antonyms</span>
<span class="sd">    hypernyms</span>
<span class="sd">    instance_hypernyms</span>
<span class="sd">    hyponyms</span>
<span class="sd">    instance_hyponyms</span>
<span class="sd">    member_holonyms</span>
<span class="sd">    substance_holonyms</span>
<span class="sd">    part_holonyms</span>
<span class="sd">    member_meronyms</span>
<span class="sd">    substance_meronyms</span>
<span class="sd">    part_meronyms</span>
<span class="sd">    topic_domains</span>
<span class="sd">    region_domains</span>
<span class="sd">    usage_domains</span>
<span class="sd">    attributes</span>
<span class="sd">    derivationally_related_forms</span>
<span class="sd">    entailments</span>
<span class="sd">    causes</span>
<span class="sd">    also_sees</span>
<span class="sd">    verb_groups</span>
<span class="sd">    similar_tos</span>
<span class="sd">    pertainyms</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c"># formerly _from_synset_info</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wordnet_corpus_reader</span><span class="p">,</span> <span class="n">synset</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span>
                 <span class="n">lexname_index</span><span class="p">,</span> <span class="n">lex_id</span><span class="p">,</span> <span class="n">syntactic_marker</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_wordnet_corpus_reader</span> <span class="o">=</span> <span class="n">wordnet_corpus_reader</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">syntactic_marker</span> <span class="o">=</span> <span class="n">syntactic_marker</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">synset</span> <span class="o">=</span> <span class="n">synset</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">frame_strings</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">frame_ids</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lexname_index</span> <span class="o">=</span> <span class="n">lexname_index</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lex_id</span> <span class="o">=</span> <span class="n">lex_id</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">key</span> <span class="o">=</span> <span class="bp">None</span> <span class="c"># gets set later.</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">tup</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">synset</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="k">return</span> <span class="s">&quot;</span><span class="si">%s</span><span class="s">(&#39;</span><span class="si">%s</span><span class="s">.</span><span class="si">%s</span><span class="s">&#39;)&quot;</span> <span class="o">%</span> <span class="n">tup</span>

    <span class="k">def</span> <span class="nf">_related</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">relation_symbol</span><span class="p">):</span>
        <span class="n">get_synset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wordnet_corpus_reader</span><span class="o">.</span><span class="n">_synset_from_pos_and_offset</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">get_synset</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">offset</span><span class="p">)</span><span class="o">.</span><span class="n">lemmas</span><span class="p">[</span><span class="n">lemma_index</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">pos</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">lemma_index</span>
                <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">synset</span><span class="o">.</span><span class="n">_lemma_pointers</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">relation_symbol</span><span class="p">]]</span>

<div class="viewcode-block" id="Lemma.count"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.Lemma.count">[docs]</a>    <span class="k">def</span> <span class="nf">count</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the frequency count for this Lemma&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wordnet_corpus_reader</span><span class="o">.</span><span class="n">lemma_count</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Lemma.antonyms"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.Lemma.antonyms">[docs]</a>    <span class="k">def</span> <span class="nf">antonyms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_related</span><span class="p">(</span><span class="s">&#39;!&#39;</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Lemma.derivationally_related_forms"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.Lemma.derivationally_related_forms">[docs]</a>    <span class="k">def</span> <span class="nf">derivationally_related_forms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_related</span><span class="p">(</span><span class="s">&#39;+&#39;</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Lemma.pertainyms"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.Lemma.pertainyms">[docs]</a>    <span class="k">def</span> <span class="nf">pertainyms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_related</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\\</span><span class="s">&#39;</span><span class="p">)</span>

</div></div>
<div class="viewcode-block" id="Synset"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.Synset">[docs]</a><span class="k">class</span> <span class="nc">Synset</span><span class="p">(</span><span class="n">_WordNetObject</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Create a Synset from a &quot;&lt;lemma&gt;.&lt;pos&gt;.&lt;number&gt;&quot; string where:</span>
<span class="sd">    &lt;lemma&gt; is the word&#39;s morphological stem</span>
<span class="sd">    &lt;pos&gt; is one of the module attributes ADJ, ADJ_SAT, ADV, NOUN or VERB</span>
<span class="sd">    &lt;number&gt; is the sense number, counting from 0.</span>

<span class="sd">    Synset attributes</span>
<span class="sd">    -----------------</span>
<span class="sd">    name - The canonical name of this synset, formed using the first lemma</span>
<span class="sd">        of this synset. Note that this may be different from the name</span>
<span class="sd">        passed to the constructor if that string used a different lemma to</span>
<span class="sd">        identify the synset.</span>
<span class="sd">    pos - The synset&#39;s part of speech, matching one of the module level</span>
<span class="sd">        attributes ADJ, ADJ_SAT, ADV, NOUN or VERB.</span>
<span class="sd">    lemmas - A list of the Lemma objects for this synset.</span>
<span class="sd">    definition - The definition for this synset.</span>
<span class="sd">    examples - A list of example strings for this synset.</span>
<span class="sd">    offset - The offset in the WordNet dict file of this synset.</span>
<span class="sd">    #lexname - The name of the lexicographer file containing this synset.</span>

<span class="sd">    Synset methods</span>
<span class="sd">    --------------</span>
<span class="sd">    Synsets have the following methods for retrieving related Synsets.</span>
<span class="sd">    They correspond to the names for the pointer symbols defined here:</span>
<span class="sd">        http://wordnet.princeton.edu/man/wninput.5WN.html#sect3</span>
<span class="sd">    These methods all return lists of Synsets.</span>

<span class="sd">    hypernyms</span>
<span class="sd">    instance_hypernyms</span>
<span class="sd">    hyponyms</span>
<span class="sd">    instance_hyponyms</span>
<span class="sd">    member_holonyms</span>
<span class="sd">    substance_holonyms</span>
<span class="sd">    part_holonyms</span>
<span class="sd">    member_meronyms</span>
<span class="sd">    substance_meronyms</span>
<span class="sd">    part_meronyms</span>
<span class="sd">    attributes</span>
<span class="sd">    entailments</span>
<span class="sd">    causes</span>
<span class="sd">    also_sees</span>
<span class="sd">    verb_groups</span>
<span class="sd">    similar_tos</span>

<span class="sd">    Additionally, Synsets support the following methods specific to the</span>
<span class="sd">    hypernym relation:</span>

<span class="sd">    root_hypernyms</span>
<span class="sd">    common_hypernyms</span>
<span class="sd">    lowest_common_hypernyms</span>

<span class="sd">    Note that Synsets do not support the following relations because</span>
<span class="sd">    these are defined by WordNet as lexical relations:</span>

<span class="sd">    antonyms</span>
<span class="sd">    derivationally_related_forms</span>
<span class="sd">    pertainyms</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wordnet_corpus_reader</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_wordnet_corpus_reader</span> <span class="o">=</span> <span class="n">wordnet_corpus_reader</span>
        <span class="c"># All of these attributes get initialized by</span>
        <span class="c"># WordNetCorpusReader._synset_from_pos_and_line()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">offset</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">frame_ids</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lemmas</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lemma_names</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lemma_infos</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c"># never used?</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">definition</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">examples</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lexname</span> <span class="o">=</span> <span class="bp">None</span> <span class="c"># lexicographer name</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_pointers</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">set</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lemma_pointers</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">set</span><span class="p">)</span>        

    <span class="k">def</span> <span class="nf">_needs_root</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos</span> <span class="o">==</span> <span class="n">NOUN</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wordnet_corpus_reader</span><span class="o">.</span><span class="n">get_version</span><span class="p">()</span> <span class="o">==</span> <span class="s">&#39;1.6&#39;</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">False</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos</span> <span class="o">==</span> <span class="n">VERB</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
        
<div class="viewcode-block" id="Synset.root_hypernyms"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.Synset.root_hypernyms">[docs]</a>    <span class="k">def</span> <span class="nf">root_hypernyms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the topmost hypernyms of this synset in WordNet.&quot;&quot;&quot;</span>

        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">seen</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">todo</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="p">]</span>
        <span class="k">while</span> <span class="n">todo</span><span class="p">:</span>
            <span class="n">next_synset</span> <span class="o">=</span> <span class="n">todo</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">next_synset</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">seen</span><span class="p">:</span>
                <span class="n">seen</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">next_synset</span><span class="p">)</span>
                <span class="n">next_hypernyms</span> <span class="o">=</span> <span class="n">next_synset</span><span class="o">.</span><span class="n">hypernyms</span><span class="p">()</span> <span class="o">+</span> \
                    <span class="n">next_synset</span><span class="o">.</span><span class="n">instance_hypernyms</span><span class="p">()</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">next_hypernyms</span><span class="p">:</span>
                    <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">next_synset</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">todo</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">next_hypernyms</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

<span class="c"># Simpler implementation which makes incorrect assumption that</span>
<span class="c"># hypernym hierarcy is acyclic:</span>
<span class="c">#</span>
<span class="c">#        if not self.hypernyms():</span>
<span class="c">#            return [self]</span>
<span class="c">#        else:</span>
<span class="c">#            return list(set(root for h in self.hypernyms()</span>
<span class="c">#                            for root in h.root_hypernyms()))</span></div>
<div class="viewcode-block" id="Synset.max_depth"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.Synset.max_depth">[docs]</a>    <span class="k">def</span> <span class="nf">max_depth</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        @return: The length of the longest hypernym path from this</span>
<span class="sd">        synset to the root.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="s">&quot;_max_depth&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="p">:</span>
            <span class="n">hypernyms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hypernyms</span><span class="p">()</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">instance_hypernyms</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">hypernyms</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_max_depth</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_max_depth</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">max</span><span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">max_depth</span><span class="p">()</span> <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">hypernyms</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_max_depth</span>
</div>
<div class="viewcode-block" id="Synset.min_depth"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.Synset.min_depth">[docs]</a>    <span class="k">def</span> <span class="nf">min_depth</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        @return: The length of the shortest hypernym path from this</span>
<span class="sd">        synset to the root.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="s">&quot;_min_depth&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="p">:</span>
            <span class="n">hypernyms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hypernyms</span><span class="p">()</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">instance_hypernyms</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">hypernyms</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_min_depth</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_min_depth</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">min</span><span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">min_depth</span><span class="p">()</span> <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">hypernyms</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_min_depth</span>
</div>
<div class="viewcode-block" id="Synset.closure"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.Synset.closure">[docs]</a>    <span class="k">def</span> <span class="nf">closure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rel</span><span class="p">,</span> <span class="n">depth</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the transitive closure of source under the rel</span>
<span class="sd">        relationship, breadth-first</span>

<span class="sd">            &gt;&gt;&gt; from nltk.corpus import wordnet as wn</span>
<span class="sd">            &gt;&gt;&gt; dog = wn.synset(&#39;dog.n.01&#39;)</span>
<span class="sd">            &gt;&gt;&gt; hyp = lambda s:s.hypernyms()</span>
<span class="sd">            &gt;&gt;&gt; list(dog.closure(hyp))</span>
<span class="sd">            [Synset(&#39;domestic_animal.n.01&#39;), Synset(&#39;canine.n.02&#39;), Synset(&#39;animal.n.01&#39;), Synset(&#39;carnivore.n.01&#39;), Synset(&#39;organism.n.01&#39;), Synset(&#39;placental.n.01&#39;), Synset(&#39;living_thing.n.01&#39;), Synset(&#39;mammal.n.01&#39;), Synset(&#39;whole.n.02&#39;), Synset(&#39;vertebrate.n.01&#39;), Synset(&#39;object.n.01&#39;), Synset(&#39;chordate.n.01&#39;), Synset(&#39;physical_entity.n.01&#39;), Synset(&#39;entity.n.01&#39;)]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">nltk.util</span> <span class="kn">import</span> <span class="n">breadth_first</span>
        <span class="n">synset_offsets</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">synset</span> <span class="ow">in</span> <span class="n">breadth_first</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rel</span><span class="p">,</span> <span class="n">depth</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">synset</span><span class="o">.</span><span class="n">offset</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">offset</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">synset</span><span class="o">.</span><span class="n">offset</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">synset_offsets</span><span class="p">:</span>
                    <span class="n">synset_offsets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">synset</span><span class="o">.</span><span class="n">offset</span><span class="p">)</span>
                    <span class="k">yield</span> <span class="n">synset</span>
</div>
<div class="viewcode-block" id="Synset.hypernym_paths"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.Synset.hypernym_paths">[docs]</a>    <span class="k">def</span> <span class="nf">hypernym_paths</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the path(s) from this synset to the root, where each path is a</span>
<span class="sd">        list of the synset nodes traversed on the way to the root.</span>

<span class="sd">        @return: A list of lists, where each list gives the node sequence</span>
<span class="sd">           connecting the initial L{Synset} node and a root node.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">paths</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">hypernyms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hypernyms</span><span class="p">()</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">instance_hypernyms</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">hypernyms</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">paths</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">self</span><span class="p">]]</span>

        <span class="k">for</span> <span class="n">hypernym</span> <span class="ow">in</span> <span class="n">hypernyms</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ancestor_list</span> <span class="ow">in</span> <span class="n">hypernym</span><span class="o">.</span><span class="n">hypernym_paths</span><span class="p">():</span>
                <span class="n">ancestor_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
                <span class="n">paths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ancestor_list</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">paths</span>
</div>
<div class="viewcode-block" id="Synset.common_hypernyms"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.Synset.common_hypernyms">[docs]</a>    <span class="k">def</span> <span class="nf">common_hypernyms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find all synsets that are hypernyms of this synset and the</span>
<span class="sd">        other synset.</span>

<span class="sd">        @type  other: L{Synset}</span>
<span class="sd">        @param other: other input synset.</span>
<span class="sd">        @return: The synsets that are hypernyms of both synsets.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">self_synsets</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">self_synset</span>
                           <span class="k">for</span> <span class="n">self_synsets</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_iter_hypernym_lists</span><span class="p">()</span>
                           <span class="k">for</span> <span class="n">self_synset</span> <span class="ow">in</span> <span class="n">self_synsets</span><span class="p">)</span>
        <span class="n">other_synsets</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">other_synset</span>
                           <span class="k">for</span> <span class="n">other_synsets</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">_iter_hypernym_lists</span><span class="p">()</span>
                           <span class="k">for</span> <span class="n">other_synset</span> <span class="ow">in</span> <span class="n">other_synsets</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">self_synsets</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">other_synsets</span><span class="p">))</span>
</div>
<div class="viewcode-block" id="Synset.lowest_common_hypernyms"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.Synset.lowest_common_hypernyms">[docs]</a>    <span class="k">def</span> <span class="nf">lowest_common_hypernyms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">simulate_root</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the lowest synset that both synsets have as a hypernym.&quot;&quot;&quot;</span>

        <span class="n">fake_synset</span> <span class="o">=</span> <span class="n">Synset</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
        <span class="n">fake_synset</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&#39;*ROOT*&#39;</span>
        <span class="n">fake_synset</span><span class="o">.</span><span class="n">hypernyms</span> <span class="o">=</span> <span class="k">lambda</span><span class="p">:</span> <span class="p">[]</span>
        <span class="n">fake_synset</span><span class="o">.</span><span class="n">instance_hypernyms</span> <span class="o">=</span> <span class="k">lambda</span><span class="p">:</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="n">simulate_root</span><span class="p">:</span>
            <span class="n">self_hypernyms</span> <span class="o">=</span> <span class="n">chain</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_iter_hypernym_lists</span><span class="p">(),</span> <span class="p">[[</span><span class="n">fake_synset</span><span class="p">]])</span>
            <span class="n">other_hypernyms</span> <span class="o">=</span> <span class="n">chain</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">_iter_hypernym_lists</span><span class="p">(),</span> <span class="p">[[</span><span class="n">fake_synset</span><span class="p">]])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">self_hypernyms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_iter_hypernym_lists</span><span class="p">()</span>
            <span class="n">other_hypernyms</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">_iter_hypernym_lists</span><span class="p">()</span>

        <span class="n">synsets</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">s</span> <span class="k">for</span> <span class="n">synsets</span> <span class="ow">in</span> <span class="n">self_hypernyms</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">synsets</span><span class="p">)</span>
        <span class="n">others</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">s</span> <span class="k">for</span> <span class="n">synsets</span> <span class="ow">in</span> <span class="n">other_hypernyms</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">synsets</span><span class="p">)</span>
        <span class="n">synsets</span><span class="o">.</span><span class="n">intersection_update</span><span class="p">(</span><span class="n">others</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">max_depth</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">min_depth</span><span class="p">()</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">synsets</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">synsets</span> <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">min_depth</span><span class="p">()</span> <span class="o">==</span> <span class="n">max_depth</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
</div>
<div class="viewcode-block" id="Synset.hypernym_distances"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.Synset.hypernym_distances">[docs]</a>    <span class="k">def</span> <span class="nf">hypernym_distances</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">distance</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">simulate_root</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the path(s) from this synset to the root, counting the distance</span>
<span class="sd">        of each node from the initial node on the way. A set of</span>
<span class="sd">        (synset, distance) tuples is returned.</span>

<span class="sd">        @type  distance: C{int}</span>
<span class="sd">        @param distance: the distance (number of edges) from this hypernym to</span>
<span class="sd">            the original hypernym L{Synset} on which this method was called.</span>
<span class="sd">        @return: A set of (L{Synset}, int) tuples where each L{Synset} is</span>
<span class="sd">           a hypernym of the first L{Synset}.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">distances</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([(</span><span class="bp">self</span><span class="p">,</span> <span class="n">distance</span><span class="p">)])</span>
        <span class="k">for</span> <span class="n">hypernym</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">hypernyms</span><span class="p">()</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">instance_hypernyms</span><span class="p">():</span>
            <span class="n">distances</span> <span class="o">|=</span> <span class="n">hypernym</span><span class="o">.</span><span class="n">hypernym_distances</span><span class="p">(</span><span class="n">distance</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">simulate_root</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">simulate_root</span><span class="p">:</span>
            <span class="n">fake_synset</span> <span class="o">=</span> <span class="n">Synset</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
            <span class="n">fake_synset</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&#39;*ROOT*&#39;</span>
            <span class="n">fake_synset_distance</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">distances</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">itemgetter</span><span class="p">(</span><span class="mi">1</span><span class="p">))[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">distances</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">fake_synset</span><span class="p">,</span> <span class="n">fake_synset_distance</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">distances</span>
</div>
<div class="viewcode-block" id="Synset.shortest_path_distance"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.Synset.shortest_path_distance">[docs]</a>    <span class="k">def</span> <span class="nf">shortest_path_distance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">simulate_root</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the distance of the shortest path linking the two synsets (if</span>
<span class="sd">        one exists). For each synset, all the ancestor nodes and their</span>
<span class="sd">        distances are recorded and compared. The ancestor node common to both</span>
<span class="sd">        synsets that can be reached with the minimum number of traversals is</span>
<span class="sd">        used. If no ancestor nodes are common, None is returned. If a node is</span>
<span class="sd">        compared with itself 0 is returned.</span>

<span class="sd">        @type  other: L{Synset}</span>
<span class="sd">        @param other: The Synset to which the shortest path will be found.</span>
<span class="sd">        @return: The number of edges in the shortest path connecting the two</span>
<span class="sd">            nodes, or None if no path exists.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="n">path_distance</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="n">dist_list1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hypernym_distances</span><span class="p">(</span><span class="n">simulate_root</span><span class="o">=</span><span class="n">simulate_root</span><span class="p">)</span>
        <span class="n">dist_dict1</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="n">dist_list2</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">hypernym_distances</span><span class="p">(</span><span class="n">simulate_root</span><span class="o">=</span><span class="n">simulate_root</span><span class="p">)</span>
        <span class="n">dist_dict2</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c"># Transform each distance list into a dictionary. In cases where</span>
        <span class="c"># there are duplicate nodes in the list (due to there being multiple</span>
        <span class="c"># paths to the root) the duplicate with the shortest distance from</span>
        <span class="c"># the original node is entered.</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[(</span><span class="n">dist_list1</span><span class="p">,</span> <span class="n">dist_dict1</span><span class="p">),</span> <span class="p">(</span><span class="n">dist_list2</span><span class="p">,</span> <span class="n">dist_dict2</span><span class="p">)]:</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">d</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">value</span> <span class="o">&lt;</span> <span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]:</span>
                        <span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

        <span class="c"># For each ancestor synset common to both subject synsets, find the</span>
        <span class="c"># connecting path length. Return the shortest of these.</span>

        <span class="k">for</span> <span class="n">synset1</span> <span class="ow">in</span> <span class="n">dist_dict1</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">synset2</span> <span class="ow">in</span> <span class="n">dist_dict2</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">synset1</span> <span class="o">==</span> <span class="n">synset2</span><span class="p">:</span>
                    <span class="n">new_distance</span> <span class="o">=</span> <span class="n">dist_dict1</span><span class="p">[</span><span class="n">synset1</span><span class="p">]</span> <span class="o">+</span> <span class="n">dist_dict2</span><span class="p">[</span><span class="n">synset2</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">path_distance</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">new_distance</span> <span class="o">&lt;</span> <span class="n">path_distance</span><span class="p">:</span>
                        <span class="n">path_distance</span> <span class="o">=</span> <span class="n">new_distance</span>

        <span class="k">return</span> <span class="n">path_distance</span>
</div>
<div class="viewcode-block" id="Synset.tree"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.Synset.tree">[docs]</a>    <span class="k">def</span> <span class="nf">tree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rel</span><span class="p">,</span> <span class="n">depth</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">cut_mark</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        &gt;&gt;&gt; from nltk.corpus import wordnet as wn</span>
<span class="sd">        &gt;&gt;&gt; dog = wn.synset(&#39;dog.n.01&#39;)</span>
<span class="sd">        &gt;&gt;&gt; hyp = lambda s:s.hypernyms()</span>
<span class="sd">        &gt;&gt;&gt; from pprint import pprint</span>
<span class="sd">        &gt;&gt;&gt; pprint(dog.tree(hyp))</span>
<span class="sd">        [Synset(&#39;dog.n.01&#39;),</span>
<span class="sd">         [Synset(&#39;domestic_animal.n.01&#39;),</span>
<span class="sd">          [Synset(&#39;animal.n.01&#39;),</span>
<span class="sd">           [Synset(&#39;organism.n.01&#39;),</span>
<span class="sd">            [Synset(&#39;living_thing.n.01&#39;),</span>
<span class="sd">             [Synset(&#39;whole.n.02&#39;),</span>
<span class="sd">              [Synset(&#39;object.n.01&#39;),</span>
<span class="sd">               [Synset(&#39;physical_entity.n.01&#39;), [Synset(&#39;entity.n.01&#39;)]]]]]]]],</span>
<span class="sd">         [Synset(&#39;canine.n.02&#39;),</span>
<span class="sd">          [Synset(&#39;carnivore.n.01&#39;),</span>
<span class="sd">           [Synset(&#39;placental.n.01&#39;),</span>
<span class="sd">            [Synset(&#39;mammal.n.01&#39;),</span>
<span class="sd">             [Synset(&#39;vertebrate.n.01&#39;),</span>
<span class="sd">              [Synset(&#39;chordate.n.01&#39;),</span>
<span class="sd">               [Synset(&#39;animal.n.01&#39;),</span>
<span class="sd">                [Synset(&#39;organism.n.01&#39;),</span>
<span class="sd">                 [Synset(&#39;living_thing.n.01&#39;),</span>
<span class="sd">                  [Synset(&#39;whole.n.02&#39;),</span>
<span class="sd">                   [Synset(&#39;object.n.01&#39;),</span>
<span class="sd">                    [Synset(&#39;physical_entity.n.01&#39;),</span>
<span class="sd">                     [Synset(&#39;entity.n.01&#39;)]]]]]]]]]]]]]]</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">tree</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">depth</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">tree</span> <span class="o">+=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">tree</span><span class="p">(</span><span class="n">rel</span><span class="p">,</span> <span class="n">depth</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">cut_mark</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">rel</span><span class="p">(</span><span class="bp">self</span><span class="p">)]</span>
        <span class="k">elif</span> <span class="n">cut_mark</span><span class="p">:</span>
            <span class="n">tree</span> <span class="o">+=</span> <span class="p">[</span><span class="n">cut_mark</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">tree</span>

    <span class="c"># interface to similarity methods</span></div>
<div class="viewcode-block" id="Synset.path_similarity"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.Synset.path_similarity">[docs]</a>    <span class="k">def</span> <span class="nf">path_similarity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">simulate_root</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Path Distance Similarity:</span>
<span class="sd">        Return a score denoting how similar two word senses are, based on the</span>
<span class="sd">        shortest path that connects the senses in the is-a (hypernym/hypnoym)</span>
<span class="sd">        taxonomy. The score is in the range 0 to 1, except in those cases where</span>
<span class="sd">        a path cannot be found (will only be true for verbs as there are many</span>
<span class="sd">        distinct verb taxonomies), in which case None is returned. A score of</span>
<span class="sd">        1 represents identity i.e. comparing a sense with itself will return 1.</span>

<span class="sd">        @type other: L{Synset}</span>
<span class="sd">        @param other: The L{Synset} that this L{Synset} is being compared to.</span>
<span class="sd">        @type simulate_root: L{bool}</span>
<span class="sd">        @param simulate_root: The various verb taxonomies do not</span>
<span class="sd">            share a single root which disallows this metric from working for</span>
<span class="sd">            synsets that are not connected. This flag (True by default)</span>
<span class="sd">            creates a fake root that connects all the taxonomies. Set it</span>
<span class="sd">            to false to disable this behavior. For the noun taxonomy, </span>
<span class="sd">            there is usually a default root except for WordNet version 1.6.</span>
<span class="sd">            If you are using wordnet 1.6, a fake root will be added for nouns</span>
<span class="sd">            as well. </span>
<span class="sd">        @return: A score denoting the similarity of the two L{Synset}s,</span>
<span class="sd">            normally between 0 and 1. None is returned if no connecting path</span>
<span class="sd">            could be found. 1 is returned if a L{Synset} is compared with</span>
<span class="sd">            itself.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">distance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shortest_path_distance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">simulate_root</span><span class="o">=</span><span class="n">simulate_root</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_needs_root</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">distance</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">distance</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>
</div>
<div class="viewcode-block" id="Synset.lch_similarity"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.Synset.lch_similarity">[docs]</a>    <span class="k">def</span> <span class="nf">lch_similarity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">simulate_root</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Leacock Chodorow Similarity:</span>
<span class="sd">        Return a score denoting how similar two word senses are, based on the</span>
<span class="sd">        shortest path that connects the senses (as above) and the maximum depth</span>
<span class="sd">        of the taxonomy in which the senses occur. The relationship is given as</span>
<span class="sd">        -log(p/2d) where p is the shortest path length and d is the taxonomy</span>
<span class="sd">        depth.</span>

<span class="sd">        @type  other: L{Synset}</span>
<span class="sd">        @param other: The L{Synset} that this L{Synset} is being compared to.</span>
<span class="sd">        @type simulate_root: L{bool}</span>
<span class="sd">        @param simulate_root: The various verb taxonomies do not</span>
<span class="sd">            share a single root which disallows this metric from working for</span>
<span class="sd">            synsets that are not connected. This flag (True by default)</span>
<span class="sd">            creates a fake root that connects all the taxonomies. Set it</span>
<span class="sd">            to false to disable this behavior. For the noun taxonomy, </span>
<span class="sd">            there is usually a default root except for WordNet version 1.6.</span>
<span class="sd">            If you are using wordnet 1.6, a fake root will be added for nouns</span>
<span class="sd">            as well. </span>
<span class="sd">        @return: A score denoting the similarity of the two L{Synset}s,</span>
<span class="sd">            normally greater than 0. None is returned if no connecting path</span>
<span class="sd">            could be found. If a L{Synset} is compared with itself, the</span>
<span class="sd">            maximum score is returned, which varies depending on the taxonomy</span>
<span class="sd">            depth.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">pos</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">WordNetError</span><span class="p">(</span><span class="s">&#39;Computing the lch similarity requires &#39;</span> <span class="o">+</span> \
                               <span class="s">&#39;</span><span class="si">%s</span><span class="s"> and </span><span class="si">%s</span><span class="s"> to have the same part of speech.&#39;</span> <span class="o">%</span> \
                                   <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">))</span>

        <span class="n">need_root</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_needs_root</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wordnet_corpus_reader</span><span class="o">.</span><span class="n">_max_depth</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_wordnet_corpus_reader</span><span class="o">.</span><span class="n">_compute_max_depth</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pos</span><span class="p">,</span> <span class="n">need_root</span><span class="p">)</span>

        <span class="n">depth</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wordnet_corpus_reader</span><span class="o">.</span><span class="n">_max_depth</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">pos</span><span class="p">]</span>

        <span class="n">distance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shortest_path_distance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">simulate_root</span><span class="o">=</span><span class="n">simulate_root</span> <span class="ow">and</span> <span class="n">need_root</span><span class="p">)</span>
    
        <span class="k">if</span> <span class="n">distance</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">((</span><span class="n">distance</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">depth</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>
</div>
<div class="viewcode-block" id="Synset.wup_similarity"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.Synset.wup_similarity">[docs]</a>    <span class="k">def</span> <span class="nf">wup_similarity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">simulate_root</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wu-Palmer Similarity:</span>
<span class="sd">        Return a score denoting how similar two word senses are, based on the</span>
<span class="sd">        depth of the two senses in the taxonomy and that of their Least Common</span>
<span class="sd">        Subsumer (most specific ancestor node). Previously, the scores computed</span>
<span class="sd">        by this implementation did _not_ always agree with those given by </span>
<span class="sd">        Pedersen&#39;s Perl implementation of WordNet Similarity. However, with</span>
<span class="sd">        the addition of the simulate_root flag (see below), the score for </span>
<span class="sd">        verbs now almost always agree but not always for nouns. </span>

<span class="sd">        The LCS does not necessarily feature in the shortest path connecting</span>
<span class="sd">        the two senses, as it is by definition the common ancestor deepest in</span>
<span class="sd">        the taxonomy, not closest to the two senses. Typically, however, it</span>
<span class="sd">        will so feature. Where multiple candidates for the LCS exist, that</span>
<span class="sd">        whose shortest path to the root node is the longest will be selected.</span>
<span class="sd">        Where the LCS has multiple paths to the root, the longer path is used</span>
<span class="sd">        for the purposes of the calculation.</span>

<span class="sd">        @type  other: L{Synset}</span>
<span class="sd">        @param other: The L{Synset} that this L{Synset} is being compared to.</span>
<span class="sd">        @type simulate_root: L{bool}</span>
<span class="sd">        @param simulate_root: The various verb taxonomies do not</span>
<span class="sd">            share a single root which disallows this metric from working for</span>
<span class="sd">            synsets that are not connected. This flag (True by default)</span>
<span class="sd">            creates a fake root that connects all the taxonomies. Set it</span>
<span class="sd">            to false to disable this behavior. For the noun taxonomy, </span>
<span class="sd">            there is usually a default root except for WordNet version 1.6.</span>
<span class="sd">            If you are using wordnet 1.6, a fake root will be added for nouns</span>
<span class="sd">            as well. </span>
<span class="sd">        @return: A float score denoting the similarity of the two L{Synset}s,</span>
<span class="sd">            normally greater than zero. If no connecting path between the two</span>
<span class="sd">            senses can be found, None is returned.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">need_root</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_needs_root</span><span class="p">()</span>
        <span class="n">subsumers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lowest_common_hypernyms</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">simulate_root</span><span class="o">=</span><span class="n">simulate_root</span> <span class="ow">and</span> <span class="n">need_root</span><span class="p">)</span>

        <span class="c"># If no LCS was found return None</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">subsumers</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>

        <span class="n">subsumer</span> <span class="o">=</span> <span class="n">subsumers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        
        <span class="c"># Get the longest path from the LCS to the root,</span>
        <span class="c"># including a correction:</span>
        <span class="c"># - add one because the calculations include both the start and end</span>
        <span class="c">#   nodes</span>
        <span class="n">depth</span> <span class="o">=</span> <span class="n">subsumer</span><span class="o">.</span><span class="n">max_depth</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="c"># Note: No need for an additional add-one correction for non-nouns </span>
        <span class="c"># to account for an imaginary root node because that is now automatically </span>
        <span class="c"># handled by simulate_root        </span>
        <span class="c"># if subsumer.pos != NOUN:</span>
        <span class="c">#     depth += 1</span>
        
        <span class="c"># Get the shortest path from the LCS to each of the synsets it is</span>
        <span class="c"># subsuming.  Add this to the LCS path length to get the path</span>
        <span class="c"># length from each synset to the root.</span>
        <span class="n">len1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shortest_path_distance</span><span class="p">(</span><span class="n">subsumer</span><span class="p">,</span> <span class="n">simulate_root</span><span class="o">=</span><span class="n">simulate_root</span> <span class="ow">and</span> <span class="n">need_root</span><span class="p">)</span>
        <span class="n">len2</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">shortest_path_distance</span><span class="p">(</span><span class="n">subsumer</span><span class="p">,</span> <span class="n">simulate_root</span><span class="o">=</span><span class="n">simulate_root</span> <span class="ow">and</span> <span class="n">need_root</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">len1</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">len2</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="n">len1</span> <span class="o">+=</span> <span class="n">depth</span>
        <span class="n">len2</span> <span class="o">+=</span> <span class="n">depth</span>
        <span class="k">return</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">depth</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">len1</span> <span class="o">+</span> <span class="n">len2</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Synset.res_similarity"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.Synset.res_similarity">[docs]</a>    <span class="k">def</span> <span class="nf">res_similarity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">ic</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Resnik Similarity:</span>
<span class="sd">        Return a score denoting how similar two word senses are, based on the</span>
<span class="sd">        Information Content (IC) of the Least Common Subsumer (most specific</span>
<span class="sd">        ancestor node).</span>

<span class="sd">        @type  other: L{Synset}</span>
<span class="sd">        @param other: The L{Synset} that this L{Synset} is being compared to.</span>
<span class="sd">        @type  ic: C{dict}</span>
<span class="sd">        @param ic: an information content object (as returned by L{load_ic()}).</span>
<span class="sd">        @return: A float score denoting the similarity of the two L{Synset}s.</span>
<span class="sd">            Synsets whose LCS is the root node of the taxonomy will have a</span>
<span class="sd">            score of 0 (e.g. N[&#39;dog&#39;][0] and N[&#39;table&#39;][0]).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">ic1</span><span class="p">,</span> <span class="n">ic2</span><span class="p">,</span> <span class="n">lcs_ic</span> <span class="o">=</span> <span class="n">_lcs_ic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">ic</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">lcs_ic</span>
</div>
<div class="viewcode-block" id="Synset.jcn_similarity"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.Synset.jcn_similarity">[docs]</a>    <span class="k">def</span> <span class="nf">jcn_similarity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">ic</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Jiang-Conrath Similarity:</span>
<span class="sd">        Return a score denoting how similar two word senses are, based on the</span>
<span class="sd">        Information Content (IC) of the Least Common Subsumer (most specific</span>
<span class="sd">        ancestor node) and that of the two input Synsets. The relationship is</span>
<span class="sd">        given by the equation 1 / (IC(s1) + IC(s2) - 2 * IC(lcs)).</span>

<span class="sd">        @type  other: L{Synset}</span>
<span class="sd">        @param other: The L{Synset} that this L{Synset} is being compared to.</span>
<span class="sd">        @type  ic: C{dict}</span>
<span class="sd">        @param ic: an information content object (as returned by L{load_ic()}).</span>
<span class="sd">        @return: A float score denoting the similarity of the two L{Synset}s.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_INF</span>

        <span class="n">ic1</span><span class="p">,</span> <span class="n">ic2</span><span class="p">,</span> <span class="n">lcs_ic</span> <span class="o">=</span> <span class="n">_lcs_ic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">ic</span><span class="p">)</span>

        <span class="c"># If either of the input synsets are the root synset, or have a</span>
        <span class="c"># frequency of 0 (sparse data problem), return 0.</span>
        <span class="k">if</span> <span class="n">ic1</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">ic2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="n">ic_difference</span> <span class="o">=</span> <span class="n">ic1</span> <span class="o">+</span> <span class="n">ic2</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">lcs_ic</span>

        <span class="k">if</span> <span class="n">ic_difference</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_INF</span>

        <span class="k">return</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">ic_difference</span>
</div>
<div class="viewcode-block" id="Synset.lin_similarity"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.Synset.lin_similarity">[docs]</a>    <span class="k">def</span> <span class="nf">lin_similarity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">ic</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Lin Similarity:</span>
<span class="sd">        Return a score denoting how similar two word senses are, based on the</span>
<span class="sd">        Information Content (IC) of the Least Common Subsumer (most specific</span>
<span class="sd">        ancestor node) and that of the two input Synsets. The relationship is</span>
<span class="sd">        given by the equation 2 * IC(lcs) / (IC(s1) + IC(s2)).</span>

<span class="sd">        @type  other: L{Synset}</span>
<span class="sd">        @param other: The L{Synset} that this L{Synset} is being compared to.</span>
<span class="sd">        @type  ic: C{dict}</span>
<span class="sd">        @param ic: an information content object (as returned by L{load_ic()}).</span>
<span class="sd">        @return: A float score denoting the similarity of the two L{Synset}s,</span>
<span class="sd">            in the range 0 to 1.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">ic1</span><span class="p">,</span> <span class="n">ic2</span><span class="p">,</span> <span class="n">lcs_ic</span> <span class="o">=</span> <span class="n">_lcs_ic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">ic</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">lcs_ic</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">ic1</span> <span class="o">+</span> <span class="n">ic2</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">_iter_hypernym_lists</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        @return: An iterator over L{Synset}s that are either proper</span>
<span class="sd">        hypernyms or instance of hypernyms of the synset.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">todo</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="p">]</span>
        <span class="n">seen</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">while</span> <span class="n">todo</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">synset</span> <span class="ow">in</span> <span class="n">todo</span><span class="p">:</span>
                <span class="n">seen</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">synset</span><span class="p">)</span>
            <span class="k">yield</span> <span class="n">todo</span>
            <span class="n">todo</span> <span class="o">=</span> <span class="p">[</span><span class="n">hypernym</span>
                    <span class="k">for</span> <span class="n">synset</span> <span class="ow">in</span> <span class="n">todo</span>
                    <span class="k">for</span> <span class="n">hypernym</span> <span class="ow">in</span> <span class="p">(</span><span class="n">synset</span><span class="o">.</span><span class="n">hypernyms</span><span class="p">()</span> <span class="o">+</span> \
                        <span class="n">synset</span><span class="o">.</span><span class="n">instance_hypernyms</span><span class="p">())</span>
                    <span class="k">if</span> <span class="n">hypernym</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">seen</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&#39;</span><span class="si">%s</span><span class="s">(</span><span class="si">%r</span><span class="s">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_related</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">relation_symbol</span><span class="p">):</span>
        <span class="n">get_synset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wordnet_corpus_reader</span><span class="o">.</span><span class="n">_synset_from_pos_and_offset</span>
        <span class="n">pointer_tuples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pointers</span><span class="p">[</span><span class="n">relation_symbol</span><span class="p">]</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">get_synset</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">offset</span><span class="p">)</span> <span class="k">for</span> <span class="n">pos</span><span class="p">,</span> <span class="n">offset</span> <span class="ow">in</span> <span class="n">pointer_tuples</span><span class="p">]</span>


<span class="c">######################################################################</span>
<span class="c">## WordNet Corpus Reader</span>
<span class="c">######################################################################</span>
</div>
<div class="viewcode-block" id="WordNetCorpusReader"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.WordNetCorpusReader">[docs]</a><span class="k">class</span> <span class="nc">WordNetCorpusReader</span><span class="p">(</span><span class="n">CorpusReader</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A corpus reader used to access wordnet or its variants.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_ENCODING</span> <span class="o">=</span> <span class="bp">None</span> <span class="c"># what encoding should we be using, if any?</span>

    <span class="c">#{ Part-of-speech constants</span>
    <span class="n">ADJ</span><span class="p">,</span> <span class="n">ADJ_SAT</span><span class="p">,</span> <span class="n">ADV</span><span class="p">,</span> <span class="n">NOUN</span><span class="p">,</span> <span class="n">VERB</span> <span class="o">=</span> <span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="s">&#39;s&#39;</span><span class="p">,</span> <span class="s">&#39;r&#39;</span><span class="p">,</span> <span class="s">&#39;n&#39;</span><span class="p">,</span> <span class="s">&#39;v&#39;</span>
    <span class="c">#}</span>

    <span class="c">#{ Filename constants</span>
    <span class="n">_FILEMAP</span> <span class="o">=</span> <span class="p">{</span><span class="n">ADJ</span><span class="p">:</span> <span class="s">&#39;adj&#39;</span><span class="p">,</span> <span class="n">ADV</span><span class="p">:</span> <span class="s">&#39;adv&#39;</span><span class="p">,</span> <span class="n">NOUN</span><span class="p">:</span> <span class="s">&#39;noun&#39;</span><span class="p">,</span> <span class="n">VERB</span><span class="p">:</span> <span class="s">&#39;verb&#39;</span><span class="p">}</span>
    <span class="c">#}</span>

    <span class="c">#{ Part of speech constants</span>
    <span class="n">_pos_numbers</span> <span class="o">=</span> <span class="p">{</span><span class="n">NOUN</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="n">VERB</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="n">ADJ</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="n">ADV</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="n">ADJ_SAT</span><span class="p">:</span> <span class="mi">5</span><span class="p">}</span>
    <span class="n">_pos_names</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">tup</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">tup</span> <span class="ow">in</span> <span class="n">_pos_numbers</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
    <span class="c">#}</span>

    <span class="c">#: A list of file identifiers for all the fileids used by this</span>
    <span class="c">#: corpus reader.</span>
    <span class="n">_FILES</span> <span class="o">=</span> <span class="p">(</span><span class="s">&#39;cntlist.rev&#39;</span><span class="p">,</span> <span class="s">&#39;lexnames&#39;</span><span class="p">,</span> <span class="s">&#39;index.sense&#39;</span><span class="p">,</span>
              <span class="s">&#39;index.adj&#39;</span><span class="p">,</span> <span class="s">&#39;index.adv&#39;</span><span class="p">,</span> <span class="s">&#39;index.noun&#39;</span><span class="p">,</span> <span class="s">&#39;index.verb&#39;</span><span class="p">,</span>
              <span class="s">&#39;data.adj&#39;</span><span class="p">,</span> <span class="s">&#39;data.adv&#39;</span><span class="p">,</span> <span class="s">&#39;data.noun&#39;</span><span class="p">,</span> <span class="s">&#39;data.verb&#39;</span><span class="p">,</span>
              <span class="s">&#39;adj.exc&#39;</span><span class="p">,</span> <span class="s">&#39;adv.exc&#39;</span><span class="p">,</span> <span class="s">&#39;noun.exc&#39;</span><span class="p">,</span> <span class="s">&#39;verb.exc&#39;</span><span class="p">,</span> <span class="p">)</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a new wordnet corpus reader, with the given root</span>
<span class="sd">        directory.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">CorpusReader</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_FILES</span><span class="p">,</span>
                              <span class="n">encoding</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_ENCODING</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_lemma_pos_offset_map</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">dict</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot;A index that provides the file offset</span>

<span class="sd">        Map from lemma -&gt; pos -&gt; synset_index -&gt; offset&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_synset_offset_cache</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">dict</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot;A cache so we don&#39;t have to reconstuct synsets</span>

<span class="sd">        Map from pos -&gt; offset -&gt; synset&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_max_depth</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">dict</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot;A lookup for the maximum depth of each part of speech.  Useful for</span>
<span class="sd">        the lch similarity metric.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_data_file_map</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_exception_map</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lexnames</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_key_count_file</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_key_synset_file</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="c"># Load the lexnames</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s">&#39;lexnames&#39;</span><span class="p">)):</span>
            <span class="n">index</span><span class="p">,</span> <span class="n">lexname</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
            <span class="k">assert</span> <span class="nb">int</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="o">==</span> <span class="n">i</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_lexnames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lexname</span><span class="p">)</span>

        <span class="c"># Load the indices for lemmas and synset offsets</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_load_lemma_pos_offset_map</span><span class="p">()</span>

        <span class="c"># load the exception file data into memory</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_load_exception_map</span><span class="p">()</span>
        

    <span class="k">def</span> <span class="nf">_load_lemma_pos_offset_map</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">suffix</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_FILEMAP</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>

            <span class="c"># parse each line of the file (ignoring comment lines)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s">&#39;index.</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">suffix</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">line</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&#39; &#39;</span><span class="p">):</span>
                    <span class="k">continue</span>

                <span class="nb">next</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">())</span><span class="o">.</span><span class="n">next</span>
                <span class="k">try</span><span class="p">:</span>

                    <span class="c"># get the lemma and part-of-speech</span>
                    <span class="n">lemma</span> <span class="o">=</span> <span class="nb">next</span><span class="p">()</span>
                    <span class="n">pos</span> <span class="o">=</span> <span class="nb">next</span><span class="p">()</span>

                    <span class="c"># get the number of synsets for this lemma</span>
                    <span class="n">n_synsets</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">next</span><span class="p">())</span>
                    <span class="k">assert</span> <span class="n">n_synsets</span> <span class="o">&gt;</span> <span class="mi">0</span>

                    <span class="c"># get the pointer symbols for all synsets of this lemma</span>
                    <span class="n">n_pointers</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">next</span><span class="p">())</span>
                    <span class="n">_</span> <span class="o">=</span> <span class="p">[</span><span class="nb">next</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">n_pointers</span><span class="p">)]</span>

                    <span class="c"># same as number of synsets</span>
                    <span class="n">n_senses</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">next</span><span class="p">())</span>
                    <span class="k">assert</span> <span class="n">n_synsets</span> <span class="o">==</span> <span class="n">n_senses</span>

                    <span class="c"># get number of senses ranked according to frequency</span>
                    <span class="n">_</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">next</span><span class="p">())</span>

                    <span class="c"># get synset offsets</span>
                    <span class="n">synset_offsets</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="nb">next</span><span class="p">())</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">n_synsets</span><span class="p">)]</span>

                <span class="c"># raise more informative error with file name and line number</span>
                <span class="k">except</span> <span class="p">(</span><span class="ne">AssertionError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">),</span> <span class="n">e</span><span class="p">:</span>
                    <span class="n">tup</span> <span class="o">=</span> <span class="p">(</span><span class="s">&#39;index.</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">suffix</span><span class="p">),</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">e</span>
                    <span class="k">raise</span> <span class="n">WordNetError</span><span class="p">(</span><span class="s">&#39;file </span><span class="si">%s</span><span class="s">, line </span><span class="si">%i</span><span class="s">: </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">tup</span><span class="p">)</span>

                <span class="c"># map lemmas and parts of speech to synsets</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_lemma_pos_offset_map</span><span class="p">[</span><span class="n">lemma</span><span class="p">][</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">synset_offsets</span>
                <span class="k">if</span> <span class="n">pos</span> <span class="o">==</span> <span class="n">ADJ</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_lemma_pos_offset_map</span><span class="p">[</span><span class="n">lemma</span><span class="p">][</span><span class="n">ADJ_SAT</span><span class="p">]</span> <span class="o">=</span> <span class="n">synset_offsets</span>

    <span class="k">def</span> <span class="nf">_load_exception_map</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># load the exception file data into memory</span>
        <span class="k">for</span> <span class="n">pos</span><span class="p">,</span> <span class="n">suffix</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_FILEMAP</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_exception_map</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%s</span><span class="s">.exc&#39;</span> <span class="o">%</span> <span class="n">suffix</span><span class="p">):</span>
                <span class="n">terms</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_exception_map</span><span class="p">[</span><span class="n">pos</span><span class="p">][</span><span class="n">terms</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">terms</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_exception_map</span><span class="p">[</span><span class="n">ADJ_SAT</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_exception_map</span><span class="p">[</span><span class="n">ADJ</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_compute_max_depth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">simulate_root</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the max depth for the given part of speech.  This is</span>
<span class="sd">        used by the lch similarity metric.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">depth</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_synsets</span><span class="p">(</span><span class="n">pos</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">depth</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">depth</span><span class="p">,</span> <span class="n">ii</span><span class="o">.</span><span class="n">max_depth</span><span class="p">())</span>
            <span class="k">except</span> <span class="ne">RuntimeError</span><span class="p">:</span>
                <span class="k">print</span> <span class="n">ii</span>
        <span class="k">if</span> <span class="n">simulate_root</span><span class="p">:</span>
            <span class="n">depth</span> <span class="o">+=</span> <span class="mi">1</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">_max_depth</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">depth</span>

<div class="viewcode-block" id="WordNetCorpusReader.get_version"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.WordNetCorpusReader.get_version">[docs]</a>    <span class="k">def</span> <span class="nf">get_version</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">fh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_file</span><span class="p">(</span><span class="n">ADJ</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">fh</span><span class="p">:</span>
            <span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s">r&#39;WordNet (\d+\.\d+) Copyright&#39;</span><span class="p">,</span> <span class="n">line</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">match</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">version</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">fh</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">version</span>        
            
    <span class="c">#////////////////////////////////////////////////////////////</span>
    <span class="c"># Loading Lemmas</span>
    <span class="c">#////////////////////////////////////////////////////////////</span></div>
<div class="viewcode-block" id="WordNetCorpusReader.lemma"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.WordNetCorpusReader.lemma">[docs]</a>    <span class="k">def</span> <span class="nf">lemma</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="n">synset_name</span><span class="p">,</span> <span class="n">lemma_name</span> <span class="o">=</span> <span class="n">name</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">synset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">synset</span><span class="p">(</span><span class="n">synset_name</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">lemma</span> <span class="ow">in</span> <span class="n">synset</span><span class="o">.</span><span class="n">lemmas</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">lemma</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">lemma_name</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">lemma</span>
        <span class="k">raise</span> <span class="n">WordNetError</span><span class="p">(</span><span class="s">&#39;no lemma </span><span class="si">%r</span><span class="s"> in </span><span class="si">%r</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">lemma_name</span><span class="p">,</span> <span class="n">synset_name</span><span class="p">))</span>
</div>
<div class="viewcode-block" id="WordNetCorpusReader.lemma_from_key"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.WordNetCorpusReader.lemma_from_key">[docs]</a>    <span class="k">def</span> <span class="nf">lemma_from_key</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="c"># Keys are case sensitive and always lower-case</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>

        <span class="n">lemma_name</span><span class="p">,</span> <span class="n">lex_sense</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;%&#39;</span><span class="p">)</span>
        <span class="n">pos_number</span><span class="p">,</span> <span class="n">lexname_index</span><span class="p">,</span> <span class="n">lex_id</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">lex_sense</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;:&#39;</span><span class="p">)</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pos_names</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">pos_number</span><span class="p">)]</span>

        <span class="c"># open the key -&gt; synset file if necessary</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_key_synset_file</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_key_synset_file</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s">&#39;index.sense&#39;</span><span class="p">)</span>

        <span class="c"># Find the synset for the lemma.</span>
        <span class="n">synset_line</span> <span class="o">=</span> <span class="n">_binary_search_file</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_key_synset_file</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">synset_line</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">WordNetError</span><span class="p">(</span><span class="s">&quot;No synset found for key </span><span class="si">%r</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">key</span><span class="p">)</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">synset_line</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">synset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_synset_from_pos_and_offset</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">offset</span><span class="p">)</span>

        <span class="c"># return the corresponding lemma</span>
        <span class="k">for</span> <span class="n">lemma</span> <span class="ow">in</span> <span class="n">synset</span><span class="o">.</span><span class="n">lemmas</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">lemma</span><span class="o">.</span><span class="n">key</span> <span class="o">==</span> <span class="n">key</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">lemma</span>
        <span class="k">raise</span> <span class="n">WordNetError</span><span class="p">(</span><span class="s">&quot;No lemma found for for key </span><span class="si">%r</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">key</span><span class="p">)</span>

    <span class="c">#////////////////////////////////////////////////////////////</span>
    <span class="c"># Loading Synsets</span>
    <span class="c">#////////////////////////////////////////////////////////////</span></div>
<div class="viewcode-block" id="WordNetCorpusReader.synset"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.WordNetCorpusReader.synset">[docs]</a>    <span class="k">def</span> <span class="nf">synset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="c"># split name into lemma, part of speech and synset number</span>
        <span class="n">lemma</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">synset_index_str</span> <span class="o">=</span> <span class="n">name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s">&#39;.&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">synset_index</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">synset_index_str</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="c"># get the offset for this synset</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lemma_pos_offset_map</span><span class="p">[</span><span class="n">lemma</span><span class="p">][</span><span class="n">pos</span><span class="p">][</span><span class="n">synset_index</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">message</span> <span class="o">=</span> <span class="s">&#39;no lemma </span><span class="si">%r</span><span class="s"> with part of speech </span><span class="si">%r</span><span class="s">&#39;</span>
            <span class="k">raise</span> <span class="n">WordNetError</span><span class="p">(</span><span class="n">message</span> <span class="o">%</span> <span class="p">(</span><span class="n">lemma</span><span class="p">,</span> <span class="n">pos</span><span class="p">))</span>
        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="n">n_senses</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lemma_pos_offset_map</span><span class="p">[</span><span class="n">lemma</span><span class="p">][</span><span class="n">pos</span><span class="p">])</span>
            <span class="n">message</span> <span class="o">=</span> <span class="s">&quot;lemma </span><span class="si">%r</span><span class="s"> with part of speech </span><span class="si">%r</span><span class="s"> has only </span><span class="si">%i</span><span class="s"> </span><span class="si">%s</span><span class="s">&quot;</span>
            <span class="k">if</span> <span class="n">n_senses</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">tup</span> <span class="o">=</span> <span class="n">lemma</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">n_senses</span><span class="p">,</span> <span class="s">&quot;sense&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">tup</span> <span class="o">=</span> <span class="n">lemma</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">n_senses</span><span class="p">,</span> <span class="s">&quot;senses&quot;</span>
            <span class="k">raise</span> <span class="n">WordNetError</span><span class="p">(</span><span class="n">message</span> <span class="o">%</span> <span class="n">tup</span><span class="p">)</span>

        <span class="c"># load synset information from the appropriate file</span>
        <span class="n">synset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_synset_from_pos_and_offset</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">offset</span><span class="p">)</span>

        <span class="c"># some basic sanity checks on loaded attributes</span>
        <span class="k">if</span> <span class="n">pos</span> <span class="o">==</span> <span class="s">&#39;s&#39;</span> <span class="ow">and</span> <span class="n">synset</span><span class="o">.</span><span class="n">pos</span> <span class="o">==</span> <span class="s">&#39;a&#39;</span><span class="p">:</span>
            <span class="n">message</span> <span class="o">=</span> <span class="p">(</span><span class="s">&#39;adjective satellite requested but only plain &#39;</span>
                       <span class="s">&#39;adjective found for lemma </span><span class="si">%r</span><span class="s">&#39;</span><span class="p">)</span>
            <span class="k">raise</span> <span class="n">WordNetError</span><span class="p">(</span><span class="n">message</span> <span class="o">%</span> <span class="n">lemma</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">synset</span><span class="o">.</span><span class="n">pos</span> <span class="o">==</span> <span class="n">pos</span> <span class="ow">or</span> <span class="p">(</span><span class="n">pos</span> <span class="o">==</span> <span class="s">&#39;a&#39;</span> <span class="ow">and</span> <span class="n">synset</span><span class="o">.</span><span class="n">pos</span> <span class="o">==</span> <span class="s">&#39;s&#39;</span><span class="p">)</span>

        <span class="c"># Return the synset object.</span>
        <span class="k">return</span> <span class="n">synset</span>
</div>
    <span class="k">def</span> <span class="nf">_data_file</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an open file pointer for the data file for the given</span>
<span class="sd">        part of speech.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">pos</span> <span class="o">==</span> <span class="n">ADJ_SAT</span><span class="p">:</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">ADJ</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_file_map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">fileid</span> <span class="o">=</span> <span class="s">&#39;data.</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">_FILEMAP</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data_file_map</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">fileid</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_file_map</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_synset_from_pos_and_offset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">offset</span><span class="p">):</span>
        <span class="c"># Check to see if the synset is in the cache</span>
        <span class="k">if</span> <span class="n">offset</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_synset_offset_cache</span><span class="p">[</span><span class="n">pos</span><span class="p">]:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_synset_offset_cache</span><span class="p">[</span><span class="n">pos</span><span class="p">][</span><span class="n">offset</span><span class="p">]</span>

        <span class="n">data_file</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_file</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>
        <span class="n">data_file</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="n">offset</span><span class="p">)</span>
        <span class="n">data_file_line</span> <span class="o">=</span> <span class="n">data_file</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
        <span class="n">synset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_synset_from_pos_and_line</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">data_file_line</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">synset</span><span class="o">.</span><span class="n">offset</span> <span class="o">==</span> <span class="n">offset</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_synset_offset_cache</span><span class="p">[</span><span class="n">pos</span><span class="p">][</span><span class="n">offset</span><span class="p">]</span> <span class="o">=</span> <span class="n">synset</span>
        <span class="k">return</span> <span class="n">synset</span>

    <span class="k">def</span> <span class="nf">_synset_from_pos_and_line</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">data_file_line</span><span class="p">):</span>
        <span class="c"># Construct a new (empty) synset.</span>
        <span class="n">synset</span> <span class="o">=</span> <span class="n">Synset</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="c"># parse the entry for this synset</span>
        <span class="k">try</span><span class="p">:</span>

            <span class="c"># parse out the definitions and examples from the gloss</span>
            <span class="n">columns_str</span><span class="p">,</span> <span class="n">gloss</span> <span class="o">=</span> <span class="n">data_file_line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;|&#39;</span><span class="p">)</span>
            <span class="n">gloss</span> <span class="o">=</span> <span class="n">gloss</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
            <span class="n">definitions</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">gloss_part</span> <span class="ow">in</span> <span class="n">gloss</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;;&#39;</span><span class="p">):</span>
                <span class="n">gloss_part</span> <span class="o">=</span> <span class="n">gloss_part</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">gloss_part</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&#39;&quot;&#39;</span><span class="p">):</span>
                    <span class="n">synset</span><span class="o">.</span><span class="n">examples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">gloss_part</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s">&#39;&quot;&#39;</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">definitions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">gloss_part</span><span class="p">)</span>
            <span class="n">synset</span><span class="o">.</span><span class="n">definition</span> <span class="o">=</span> <span class="s">&#39;; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">definitions</span><span class="p">)</span>

            <span class="c"># split the other info into fields</span>
            <span class="nb">next</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">columns_str</span><span class="o">.</span><span class="n">split</span><span class="p">())</span><span class="o">.</span><span class="n">next</span>

            <span class="c"># get the offset</span>
            <span class="n">synset</span><span class="o">.</span><span class="n">offset</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">next</span><span class="p">())</span>

            <span class="c"># determine the lexicographer file name</span>
            <span class="n">lexname_index</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">next</span><span class="p">())</span>
            <span class="n">synset</span><span class="o">.</span><span class="n">lexname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lexnames</span><span class="p">[</span><span class="n">lexname_index</span><span class="p">]</span>

            <span class="c"># get the part of speech</span>
            <span class="n">synset</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="nb">next</span><span class="p">()</span>

            <span class="c"># create Lemma objects for each lemma</span>
            <span class="n">n_lemmas</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">next</span><span class="p">(),</span> <span class="mi">16</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">n_lemmas</span><span class="p">):</span>
                <span class="c"># get the lemma name</span>
                <span class="n">lemma_name</span> <span class="o">=</span> <span class="nb">next</span><span class="p">()</span>
                <span class="c"># get the lex_id (used for sense_keys)</span>
                <span class="n">lex_id</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">next</span><span class="p">(),</span> <span class="mi">16</span><span class="p">)</span>
                <span class="c"># If the lemma has a syntactic marker, extract it.</span>
                <span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s">r&#39;(.*?)(\(.*\))?$&#39;</span><span class="p">,</span> <span class="n">lemma_name</span><span class="p">)</span>
                <span class="n">lemma_name</span><span class="p">,</span> <span class="n">syn_mark</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">groups</span><span class="p">()</span>
                <span class="c"># create the lemma object</span>
                <span class="n">lemma</span> <span class="o">=</span> <span class="n">Lemma</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">synset</span><span class="p">,</span> <span class="n">lemma_name</span><span class="p">,</span> <span class="n">lexname_index</span><span class="p">,</span>
                              <span class="n">lex_id</span><span class="p">,</span> <span class="n">syn_mark</span><span class="p">)</span>
                <span class="n">synset</span><span class="o">.</span><span class="n">lemmas</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lemma</span><span class="p">)</span>
                <span class="n">synset</span><span class="o">.</span><span class="n">lemma_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lemma</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

            <span class="c"># collect the pointer tuples</span>
            <span class="n">n_pointers</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">next</span><span class="p">())</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">n_pointers</span><span class="p">):</span>
                <span class="n">symbol</span> <span class="o">=</span> <span class="nb">next</span><span class="p">()</span>
                <span class="n">offset</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">next</span><span class="p">())</span>
                <span class="n">pos</span> <span class="o">=</span> <span class="nb">next</span><span class="p">()</span>
                <span class="n">lemma_ids_str</span> <span class="o">=</span> <span class="nb">next</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">lemma_ids_str</span> <span class="o">==</span> <span class="s">&#39;0000&#39;</span><span class="p">:</span>
                    <span class="n">synset</span><span class="o">.</span><span class="n">_pointers</span><span class="p">[</span><span class="n">symbol</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">pos</span><span class="p">,</span> <span class="n">offset</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">source_index</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">lemma_ids_str</span><span class="p">[:</span><span class="mi">2</span><span class="p">],</span> <span class="mi">16</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
                    <span class="n">target_index</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">lemma_ids_str</span><span class="p">[</span><span class="mi">2</span><span class="p">:],</span> <span class="mi">16</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
                    <span class="n">source_lemma_name</span> <span class="o">=</span> <span class="n">synset</span><span class="o">.</span><span class="n">lemmas</span><span class="p">[</span><span class="n">source_index</span><span class="p">]</span><span class="o">.</span><span class="n">name</span>
                    <span class="n">lemma_pointers</span> <span class="o">=</span> <span class="n">synset</span><span class="o">.</span><span class="n">_lemma_pointers</span>
                    <span class="n">tups</span> <span class="o">=</span> <span class="n">lemma_pointers</span><span class="p">[</span><span class="n">source_lemma_name</span><span class="p">,</span> <span class="n">symbol</span><span class="p">]</span>
                    <span class="n">tups</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">pos</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">target_index</span><span class="p">))</span>

            <span class="c"># read the verb frames</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">frame_count</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">next</span><span class="p">())</span>
            <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">frame_count</span><span class="p">):</span>
                    <span class="c"># read the plus sign</span>
                    <span class="n">plus</span> <span class="o">=</span> <span class="nb">next</span><span class="p">()</span>
                    <span class="k">assert</span> <span class="n">plus</span> <span class="o">==</span> <span class="s">&#39;+&#39;</span>
                    <span class="c"># read the frame and lemma number</span>
                    <span class="n">frame_number</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">next</span><span class="p">())</span>
                    <span class="n">frame_string_fmt</span> <span class="o">=</span> <span class="n">VERB_FRAME_STRINGS</span><span class="p">[</span><span class="n">frame_number</span><span class="p">]</span>
                    <span class="n">lemma_number</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">next</span><span class="p">(),</span> <span class="mi">16</span><span class="p">)</span>
                    <span class="c"># lemma number of 00 means all words in the synset</span>
                    <span class="k">if</span> <span class="n">lemma_number</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">synset</span><span class="o">.</span><span class="n">frame_ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">frame_number</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">lemma</span> <span class="ow">in</span> <span class="n">synset</span><span class="o">.</span><span class="n">lemmas</span><span class="p">:</span>
                            <span class="n">lemma</span><span class="o">.</span><span class="n">frame_ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">frame_number</span><span class="p">)</span>
                            <span class="n">lemma</span><span class="o">.</span><span class="n">frame_strings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">frame_string_fmt</span> <span class="o">%</span>
                                                       <span class="n">lemma</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                    <span class="c"># only a specific word in the synset</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">lemma</span> <span class="o">=</span> <span class="n">synset</span><span class="o">.</span><span class="n">lemmas</span><span class="p">[</span><span class="n">lemma_number</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                        <span class="n">lemma</span><span class="o">.</span><span class="n">frame_ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">frame_number</span><span class="p">)</span>
                        <span class="n">lemma</span><span class="o">.</span><span class="n">frame_strings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">frame_string_fmt</span> <span class="o">%</span>
                                                   <span class="n">lemma</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

        <span class="c"># raise a more informative error with line text</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">,</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">WordNetError</span><span class="p">(</span><span class="s">&#39;line </span><span class="si">%r</span><span class="s">: </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">data_file_line</span><span class="p">,</span> <span class="n">e</span><span class="p">))</span>

        <span class="c"># set sense keys for Lemma objects - note that this has to be</span>
        <span class="c"># done afterwards so that the relations are available</span>
        <span class="k">for</span> <span class="n">lemma</span> <span class="ow">in</span> <span class="n">synset</span><span class="o">.</span><span class="n">lemmas</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">synset</span><span class="o">.</span><span class="n">pos</span> <span class="ow">is</span> <span class="n">ADJ_SAT</span><span class="p">:</span>
                <span class="n">head_lemma</span> <span class="o">=</span> <span class="n">synset</span><span class="o">.</span><span class="n">similar_tos</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">lemmas</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">head_name</span> <span class="o">=</span> <span class="n">head_lemma</span><span class="o">.</span><span class="n">name</span>
                <span class="n">head_id</span> <span class="o">=</span> <span class="s">&#39;</span><span class="si">%02d</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">head_lemma</span><span class="o">.</span><span class="n">_lex_id</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">head_name</span> <span class="o">=</span> <span class="n">head_id</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
            <span class="n">tup</span> <span class="o">=</span> <span class="p">(</span><span class="n">lemma</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">WordNetCorpusReader</span><span class="o">.</span><span class="n">_pos_numbers</span><span class="p">[</span><span class="n">synset</span><span class="o">.</span><span class="n">pos</span><span class="p">],</span>
                   <span class="n">lemma</span><span class="o">.</span><span class="n">_lexname_index</span><span class="p">,</span> <span class="n">lemma</span><span class="o">.</span><span class="n">_lex_id</span><span class="p">,</span> <span class="n">head_name</span><span class="p">,</span> <span class="n">head_id</span><span class="p">)</span>
            <span class="n">lemma</span><span class="o">.</span><span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="s">&#39;</span><span class="si">%s%%%d</span><span class="s">:</span><span class="si">%02d</span><span class="s">:</span><span class="si">%02d</span><span class="s">:</span><span class="si">%s</span><span class="s">:</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">tup</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>

        <span class="c"># the canonical name is based on the first lemma</span>
        <span class="n">lemma_name</span> <span class="o">=</span> <span class="n">synset</span><span class="o">.</span><span class="n">lemmas</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="n">offsets</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lemma_pos_offset_map</span><span class="p">[</span><span class="n">lemma_name</span><span class="p">][</span><span class="n">synset</span><span class="o">.</span><span class="n">pos</span><span class="p">]</span>
        <span class="n">sense_index</span> <span class="o">=</span> <span class="n">offsets</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">synset</span><span class="o">.</span><span class="n">offset</span><span class="p">)</span>
        <span class="n">tup</span> <span class="o">=</span> <span class="n">lemma_name</span><span class="p">,</span> <span class="n">synset</span><span class="o">.</span><span class="n">pos</span><span class="p">,</span> <span class="n">sense_index</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">synset</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&#39;</span><span class="si">%s</span><span class="s">.</span><span class="si">%s</span><span class="s">.</span><span class="si">%02i</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">tup</span>

        <span class="k">return</span> <span class="n">synset</span>

    <span class="c">#////////////////////////////////////////////////////////////</span>
    <span class="c"># Retrieve synsets and lemmas.</span>
    <span class="c">#////////////////////////////////////////////////////////////</span>
<div class="viewcode-block" id="WordNetCorpusReader.synsets"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.WordNetCorpusReader.synsets">[docs]</a>    <span class="k">def</span> <span class="nf">synsets</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lemma</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Load all synsets with a given lemma and part of speech tag.</span>
<span class="sd">        If no pos is specified, all synsets for all parts of speech</span>
<span class="sd">        will be loaded.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lemma</span> <span class="o">=</span> <span class="n">lemma</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="n">get_synset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_synset_from_pos_and_offset</span>
        <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lemma_pos_offset_map</span>

        <span class="k">if</span> <span class="n">pos</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">POS_LIST</span>

        <span class="k">return</span> <span class="p">[</span><span class="n">get_synset</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">offset</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">pos</span>
                <span class="k">for</span> <span class="n">form</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_morphy</span><span class="p">(</span><span class="n">lemma</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">offset</span> <span class="ow">in</span> <span class="n">index</span><span class="p">[</span><span class="n">form</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="p">[])]</span>
</div>
<div class="viewcode-block" id="WordNetCorpusReader.lemmas"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.WordNetCorpusReader.lemmas">[docs]</a>    <span class="k">def</span> <span class="nf">lemmas</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lemma</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return all Lemma objects with a name matching the specified lemma</span>
<span class="sd">        name and part of speech tag. Matches any part of speech tag if none is</span>
<span class="sd">        specified.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">lemma_obj</span>
                <span class="k">for</span> <span class="n">synset</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">synsets</span><span class="p">(</span><span class="n">lemma</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">lemma_obj</span> <span class="ow">in</span> <span class="n">synset</span><span class="o">.</span><span class="n">lemmas</span>
                <span class="k">if</span> <span class="n">lemma_obj</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">lemma</span><span class="p">]</span>
</div>
<div class="viewcode-block" id="WordNetCorpusReader.all_lemma_names"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.WordNetCorpusReader.all_lemma_names">[docs]</a>    <span class="k">def</span> <span class="nf">all_lemma_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return all lemma names for all synsets for the given</span>
<span class="sd">        part of speech tag. If pos is not specified, all synsets</span>
<span class="sd">        for all parts of speech will be used.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">pos</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lemma_pos_offset_map</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">lemma</span>
                <span class="k">for</span> <span class="n">lemma</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lemma_pos_offset_map</span>
                <span class="k">if</span> <span class="n">pos</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lemma_pos_offset_map</span><span class="p">[</span><span class="n">lemma</span><span class="p">])</span>
</div>
<div class="viewcode-block" id="WordNetCorpusReader.all_synsets"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.WordNetCorpusReader.all_synsets">[docs]</a>    <span class="k">def</span> <span class="nf">all_synsets</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Iterate over all synsets with a given part of speech tag.</span>
<span class="sd">        If no pos is specified, all synsets for all parts of speech</span>
<span class="sd">        will be loaded.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">pos</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">pos_tags</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_FILEMAP</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pos_tags</span> <span class="o">=</span> <span class="p">[</span><span class="n">pos</span><span class="p">]</span>

        <span class="n">cache</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_synset_offset_cache</span>
        <span class="n">from_pos_and_line</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_synset_from_pos_and_line</span>

        <span class="c"># generate all synsets for each part of speech</span>
        <span class="k">for</span> <span class="n">pos_tag</span> <span class="ow">in</span> <span class="n">pos_tags</span><span class="p">:</span>
            <span class="c"># Open the file for reading.  Note that we can not re-use</span>
            <span class="c"># the file poitners from self._data_file_map here, because</span>
            <span class="c"># we&#39;re defining an iterator, and those file pointers might</span>
            <span class="c"># be moved while we&#39;re not looking.</span>
            <span class="k">if</span> <span class="n">pos_tag</span> <span class="o">==</span> <span class="n">ADJ_SAT</span><span class="p">:</span>
                <span class="n">pos_tag</span> <span class="o">=</span> <span class="n">ADJ</span>
            <span class="n">fileid</span> <span class="o">=</span> <span class="s">&#39;data.</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">_FILEMAP</span><span class="p">[</span><span class="n">pos_tag</span><span class="p">]</span>
            <span class="n">data_file</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">fileid</span><span class="p">)</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="c"># generate synsets for each line in the POS file</span>
                <span class="n">offset</span> <span class="o">=</span> <span class="n">data_file</span><span class="o">.</span><span class="n">tell</span><span class="p">()</span>
                <span class="n">line</span> <span class="o">=</span> <span class="n">data_file</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
                <span class="k">while</span> <span class="n">line</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">line</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">isspace</span><span class="p">():</span>
                        <span class="k">if</span> <span class="n">offset</span> <span class="ow">in</span> <span class="n">cache</span><span class="p">[</span><span class="n">pos_tag</span><span class="p">]:</span>
                            <span class="c"># See if the synset is cached</span>
                            <span class="n">synset</span> <span class="o">=</span> <span class="n">cache</span><span class="p">[</span><span class="n">pos_tag</span><span class="p">][</span><span class="n">offset</span><span class="p">]</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="c"># Otherwise, parse the line</span>
                            <span class="n">synset</span> <span class="o">=</span> <span class="n">from_pos_and_line</span><span class="p">(</span><span class="n">pos_tag</span><span class="p">,</span> <span class="n">line</span><span class="p">)</span>
                            <span class="n">cache</span><span class="p">[</span><span class="n">pos_tag</span><span class="p">][</span><span class="n">offset</span><span class="p">]</span> <span class="o">=</span> <span class="n">synset</span>

                        <span class="c"># adjective satellites are in the same file as</span>
                        <span class="c"># adjectives so only yield the synset if it&#39;s actually</span>
                        <span class="c"># a satellite</span>
                        <span class="k">if</span> <span class="n">pos_tag</span> <span class="o">==</span> <span class="n">ADJ_SAT</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">synset</span><span class="o">.</span><span class="n">pos</span> <span class="o">==</span> <span class="n">pos_tag</span><span class="p">:</span>
                                <span class="k">yield</span> <span class="n">synset</span>

                        <span class="c"># for all other POS tags, yield all synsets (this means</span>
                        <span class="c"># that adjectives also include adjective satellites)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">yield</span> <span class="n">synset</span>
                    <span class="n">offset</span> <span class="o">=</span> <span class="n">data_file</span><span class="o">.</span><span class="n">tell</span><span class="p">()</span>
                    <span class="n">line</span> <span class="o">=</span> <span class="n">data_file</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>

            <span class="c"># close the extra file handle we opened</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="n">data_file</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
                <span class="k">raise</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">data_file</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="c">#////////////////////////////////////////////////////////////</span>
    <span class="c"># Misc</span>
    <span class="c">#////////////////////////////////////////////////////////////</span></div>
<div class="viewcode-block" id="WordNetCorpusReader.lemma_count"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.WordNetCorpusReader.lemma_count">[docs]</a>    <span class="k">def</span> <span class="nf">lemma_count</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lemma</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the frequency count for this Lemma&quot;&quot;&quot;</span>
        <span class="c"># open the count file if we haven&#39;t already</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_key_count_file</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_key_count_file</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s">&#39;cntlist.rev&#39;</span><span class="p">)</span>
        <span class="c"># find the key in the counts file and return the count</span>
        <span class="n">line</span> <span class="o">=</span> <span class="n">_binary_search_file</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_key_count_file</span><span class="p">,</span> <span class="n">lemma</span><span class="o">.</span><span class="n">key</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">line</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s">&#39; &#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
</div>
<div class="viewcode-block" id="WordNetCorpusReader.path_similarity"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.WordNetCorpusReader.path_similarity">[docs]</a>    <span class="k">def</span> <span class="nf">path_similarity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">synset1</span><span class="p">,</span> <span class="n">synset2</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">simulate_root</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">synset1</span><span class="o">.</span><span class="n">path_similarity</span><span class="p">(</span><span class="n">synset2</span><span class="p">,</span> <span class="n">verbose</span><span class="p">,</span> <span class="n">simulate_root</span><span class="p">)</span></div>
    <span class="n">path_similarity</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="n">Synset</span><span class="o">.</span><span class="n">path_similarity</span><span class="o">.</span><span class="n">__doc__</span>

<div class="viewcode-block" id="WordNetCorpusReader.lch_similarity"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.WordNetCorpusReader.lch_similarity">[docs]</a>    <span class="k">def</span> <span class="nf">lch_similarity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">synset1</span><span class="p">,</span> <span class="n">synset2</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">simulate_root</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">synset1</span><span class="o">.</span><span class="n">lch_similarity</span><span class="p">(</span><span class="n">synset2</span><span class="p">,</span> <span class="n">verbose</span><span class="p">,</span> <span class="n">simulate_root</span><span class="p">)</span></div>
    <span class="n">lch_similarity</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="n">Synset</span><span class="o">.</span><span class="n">lch_similarity</span><span class="o">.</span><span class="n">__doc__</span>

<div class="viewcode-block" id="WordNetCorpusReader.wup_similarity"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.WordNetCorpusReader.wup_similarity">[docs]</a>    <span class="k">def</span> <span class="nf">wup_similarity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">synset1</span><span class="p">,</span> <span class="n">synset2</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">simulate_root</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">synset1</span><span class="o">.</span><span class="n">wup_similarity</span><span class="p">(</span><span class="n">synset2</span><span class="p">,</span> <span class="n">verbose</span><span class="p">,</span> <span class="n">simulate_root</span><span class="p">)</span></div>
    <span class="n">wup_similarity</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="n">Synset</span><span class="o">.</span><span class="n">wup_similarity</span><span class="o">.</span><span class="n">__doc__</span>

<div class="viewcode-block" id="WordNetCorpusReader.res_similarity"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.WordNetCorpusReader.res_similarity">[docs]</a>    <span class="k">def</span> <span class="nf">res_similarity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">synset1</span><span class="p">,</span> <span class="n">synset2</span><span class="p">,</span> <span class="n">ic</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">synset1</span><span class="o">.</span><span class="n">res_similarity</span><span class="p">(</span><span class="n">synset2</span><span class="p">,</span> <span class="n">ic</span><span class="p">,</span> <span class="n">verbose</span><span class="p">)</span></div>
    <span class="n">res_similarity</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="n">Synset</span><span class="o">.</span><span class="n">res_similarity</span><span class="o">.</span><span class="n">__doc__</span>

<div class="viewcode-block" id="WordNetCorpusReader.jcn_similarity"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.WordNetCorpusReader.jcn_similarity">[docs]</a>    <span class="k">def</span> <span class="nf">jcn_similarity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">synset1</span><span class="p">,</span> <span class="n">synset2</span><span class="p">,</span> <span class="n">ic</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">synset1</span><span class="o">.</span><span class="n">jcn_similarity</span><span class="p">(</span><span class="n">synset2</span><span class="p">,</span> <span class="n">ic</span><span class="p">,</span> <span class="n">verbose</span><span class="p">)</span></div>
    <span class="n">jcn_similarity</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="n">Synset</span><span class="o">.</span><span class="n">jcn_similarity</span><span class="o">.</span><span class="n">__doc__</span>

<div class="viewcode-block" id="WordNetCorpusReader.lin_similarity"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.WordNetCorpusReader.lin_similarity">[docs]</a>    <span class="k">def</span> <span class="nf">lin_similarity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">synset1</span><span class="p">,</span> <span class="n">synset2</span><span class="p">,</span> <span class="n">ic</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">synset1</span><span class="o">.</span><span class="n">lin_similarity</span><span class="p">(</span><span class="n">synset2</span><span class="p">,</span> <span class="n">ic</span><span class="p">,</span> <span class="n">verbose</span><span class="p">)</span></div>
    <span class="n">lin_similarity</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="n">Synset</span><span class="o">.</span><span class="n">lin_similarity</span><span class="o">.</span><span class="n">__doc__</span>

    <span class="c">#////////////////////////////////////////////////////////////</span>
    <span class="c"># Morphy</span>
    <span class="c">#////////////////////////////////////////////////////////////</span>
    <span class="c"># Morphy, adapted from Oliver Steele&#39;s pywordnet</span>
<div class="viewcode-block" id="WordNetCorpusReader.morphy"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.WordNetCorpusReader.morphy">[docs]</a>    <span class="k">def</span> <span class="nf">morphy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">form</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find a possible base form for the given form, with the given</span>
<span class="sd">        part of speech, by checking WordNet&#39;s list of exceptional</span>
<span class="sd">        forms, and by recursively stripping affixes for this part of</span>
<span class="sd">        speech until a form in WordNet is found.</span>

<span class="sd">        &gt;&gt;&gt; from nltk.corpus import wordnet as wn</span>
<span class="sd">        &gt;&gt;&gt; wn.morphy(&#39;dogs&#39;)</span>
<span class="sd">        &#39;dog&#39;</span>
<span class="sd">        &gt;&gt;&gt; wn.morphy(&#39;churches&#39;)</span>
<span class="sd">        &#39;church&#39;</span>
<span class="sd">        &gt;&gt;&gt; wn.morphy(&#39;aardwolves&#39;)</span>
<span class="sd">        &#39;aardwolf&#39;</span>
<span class="sd">        &gt;&gt;&gt; wn.morphy(&#39;abaci&#39;)</span>
<span class="sd">        &#39;abacus&#39;</span>
<span class="sd">        &gt;&gt;&gt; wn.morphy(&#39;hardrock&#39;, wn.ADV)</span>
<span class="sd">        &gt;&gt;&gt; wn.morphy(&#39;book&#39;, wn.NOUN)</span>
<span class="sd">        &#39;book&#39;</span>
<span class="sd">        &gt;&gt;&gt; wn.morphy(&#39;book&#39;, wn.ADJ)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">pos</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">morphy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_morphy</span>
            <span class="n">analyses</span> <span class="o">=</span> <span class="n">chain</span><span class="p">(</span><span class="n">a</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">POS_LIST</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">morphy</span><span class="p">(</span><span class="n">form</span><span class="p">,</span> <span class="n">p</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">analyses</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_morphy</span><span class="p">(</span><span class="n">form</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span>

        <span class="c"># get the first one we find</span>
        <span class="n">first</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">islice</span><span class="p">(</span><span class="n">analyses</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">first</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">first</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>
</div>
    <span class="n">MORPHOLOGICAL_SUBSTITUTIONS</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">NOUN</span><span class="p">:</span> <span class="p">[(</span><span class="s">&#39;s&#39;</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;ses&#39;</span><span class="p">,</span> <span class="s">&#39;s&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;ves&#39;</span><span class="p">,</span> <span class="s">&#39;f&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;xes&#39;</span><span class="p">,</span> <span class="s">&#39;x&#39;</span><span class="p">),</span>
               <span class="p">(</span><span class="s">&#39;zes&#39;</span><span class="p">,</span> <span class="s">&#39;z&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;ches&#39;</span><span class="p">,</span> <span class="s">&#39;ch&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;shes&#39;</span><span class="p">,</span> <span class="s">&#39;sh&#39;</span><span class="p">),</span>
               <span class="p">(</span><span class="s">&#39;men&#39;</span><span class="p">,</span> <span class="s">&#39;man&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;ies&#39;</span><span class="p">,</span> <span class="s">&#39;y&#39;</span><span class="p">)],</span>
        <span class="n">VERB</span><span class="p">:</span> <span class="p">[(</span><span class="s">&#39;s&#39;</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;ies&#39;</span><span class="p">,</span> <span class="s">&#39;y&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;es&#39;</span><span class="p">,</span> <span class="s">&#39;e&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;es&#39;</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="p">),</span>
               <span class="p">(</span><span class="s">&#39;ed&#39;</span><span class="p">,</span> <span class="s">&#39;e&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;ed&#39;</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;ing&#39;</span><span class="p">,</span> <span class="s">&#39;e&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;ing&#39;</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="p">)],</span>
        <span class="n">ADJ</span><span class="p">:</span> <span class="p">[(</span><span class="s">&#39;er&#39;</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;est&#39;</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;er&#39;</span><span class="p">,</span> <span class="s">&#39;e&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;est&#39;</span><span class="p">,</span> <span class="s">&#39;e&#39;</span><span class="p">)],</span>
        <span class="n">ADV</span><span class="p">:</span> <span class="p">[]}</span>

    <span class="k">def</span> <span class="nf">_morphy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">form</span><span class="p">,</span> <span class="n">pos</span><span class="p">):</span>
        <span class="c"># from jordanbg:</span>
        <span class="c"># Given an original string x</span>
        <span class="c"># 1. Apply rules once to the input to get y1, y2, y3, etc.</span>
        <span class="c"># 2. Return all that are in the database</span>
        <span class="c"># 3. If there are no matches, keep applying rules until you either</span>
        <span class="c">#    find a match or you can&#39;t go any further</span>

        <span class="n">exceptions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_exception_map</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span>
        <span class="n">substitutions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">MORPHOLOGICAL_SUBSTITUTIONS</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span>

        <span class="k">def</span> <span class="nf">apply_rules</span><span class="p">(</span><span class="n">forms</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">form</span><span class="p">[:</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">old</span><span class="p">)]</span> <span class="o">+</span> <span class="n">new</span>
                    <span class="k">for</span> <span class="n">form</span> <span class="ow">in</span> <span class="n">forms</span>
                    <span class="k">for</span> <span class="n">old</span><span class="p">,</span> <span class="n">new</span> <span class="ow">in</span> <span class="n">substitutions</span>
                    <span class="k">if</span> <span class="n">form</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="n">old</span><span class="p">)]</span>

        <span class="k">def</span> <span class="nf">filter_forms</span><span class="p">(</span><span class="n">forms</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">seen</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">form</span> <span class="ow">in</span> <span class="n">forms</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">form</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lemma_pos_offset_map</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">pos</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lemma_pos_offset_map</span><span class="p">[</span><span class="n">form</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="n">form</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">seen</span><span class="p">:</span>
                            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">form</span><span class="p">)</span>
                            <span class="n">seen</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">form</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">result</span>

        <span class="c"># 0. Check the exception lists</span>
        <span class="k">if</span> <span class="n">form</span> <span class="ow">in</span> <span class="n">exceptions</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">filter_forms</span><span class="p">([</span><span class="n">form</span><span class="p">]</span> <span class="o">+</span> <span class="n">exceptions</span><span class="p">[</span><span class="n">form</span><span class="p">])</span>

        <span class="c"># 1. Apply rules once to the input to get y1, y2, y3, etc.</span>
        <span class="n">forms</span> <span class="o">=</span> <span class="n">apply_rules</span><span class="p">([</span><span class="n">form</span><span class="p">])</span>

        <span class="c"># 2. Return all that are in the database (and check the original too)</span>
        <span class="n">results</span> <span class="o">=</span> <span class="n">filter_forms</span><span class="p">([</span><span class="n">form</span><span class="p">]</span> <span class="o">+</span> <span class="n">forms</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">results</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">results</span>

        <span class="c"># 3. If there are no matches, keep applying rules until we find a match</span>
        <span class="k">while</span> <span class="n">forms</span><span class="p">:</span>
            <span class="n">forms</span> <span class="o">=</span> <span class="n">apply_rules</span><span class="p">(</span><span class="n">forms</span><span class="p">)</span>
            <span class="n">results</span> <span class="o">=</span> <span class="n">filter_forms</span><span class="p">(</span><span class="n">forms</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">results</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">results</span>

        <span class="c"># Return an empty list if we can&#39;t find anything</span>
        <span class="k">return</span> <span class="p">[]</span>

    <span class="c">#////////////////////////////////////////////////////////////</span>
    <span class="c"># Create information content from corpus</span>
    <span class="c">#////////////////////////////////////////////////////////////</span>
<div class="viewcode-block" id="WordNetCorpusReader.ic"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.WordNetCorpusReader.ic">[docs]</a>    <span class="k">def</span> <span class="nf">ic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">corpus</span><span class="p">,</span> <span class="n">weight_senses_equally</span> <span class="o">=</span> <span class="bp">False</span><span class="p">,</span> <span class="n">smoothing</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates an information content lookup dictionary from a corpus.</span>

<span class="sd">        @type corpus: L{CorpusReader}</span>
<span class="sd">        @param corpus: The corpus from which we create an information</span>
<span class="sd">        content dictionary.</span>
<span class="sd">        @type weight_senses_equally: L{bool}</span>
<span class="sd">        @param weight_senses_equally: If this is True, gives all</span>
<span class="sd">        possible senses equal weight rather than dividing by the</span>
<span class="sd">        number of possible senses.  (If a word has 3 synses, each</span>
<span class="sd">        sense gets 0.3333 per appearance when this is False, 1.0 when</span>
<span class="sd">        it is true.)</span>
<span class="sd">        @param smoothing: How much do we smooth synset counts (default is 1.0)</span>
<span class="sd">        @type smoothing: L{float}</span>
<span class="sd">        @return: An information content dictionary</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">counts</span> <span class="o">=</span> <span class="n">FreqDist</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">ww</span> <span class="ow">in</span> <span class="n">corpus</span><span class="o">.</span><span class="n">words</span><span class="p">():</span>
            <span class="n">counts</span><span class="o">.</span><span class="n">inc</span><span class="p">(</span><span class="n">ww</span><span class="p">)</span>

        <span class="n">ic</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">pp</span> <span class="ow">in</span> <span class="n">POS_LIST</span><span class="p">:</span>
            <span class="n">ic</span><span class="p">[</span><span class="n">pp</span><span class="p">]</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>

        <span class="c"># Initialize the counts with the smoothing value</span>
        <span class="k">if</span> <span class="n">smoothing</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ss</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_synsets</span><span class="p">():</span>
                <span class="n">pos</span> <span class="o">=</span> <span class="n">ss</span><span class="o">.</span><span class="n">pos</span>
                <span class="k">if</span> <span class="n">pos</span> <span class="o">==</span> <span class="n">ADJ_SAT</span><span class="p">:</span>
                    <span class="n">pos</span> <span class="o">=</span> <span class="n">ADJ</span>
                <span class="n">ic</span><span class="p">[</span><span class="n">pos</span><span class="p">][</span><span class="n">ss</span><span class="o">.</span><span class="n">offset</span><span class="p">]</span> <span class="o">=</span> <span class="n">smoothing</span>

        <span class="k">for</span> <span class="n">ww</span> <span class="ow">in</span> <span class="n">counts</span><span class="p">:</span>
            <span class="n">possible_synsets</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">synsets</span><span class="p">(</span><span class="n">ww</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">possible_synsets</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c"># Distribute weight among possible synsets</span>
            <span class="n">weight</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">counts</span><span class="p">[</span><span class="n">ww</span><span class="p">])</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">weight_senses_equally</span><span class="p">:</span>
                <span class="n">weight</span> <span class="o">/=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">possible_synsets</span><span class="p">))</span>

            <span class="k">for</span> <span class="n">ss</span> <span class="ow">in</span> <span class="n">possible_synsets</span><span class="p">:</span>
                <span class="n">pos</span> <span class="o">=</span> <span class="n">ss</span><span class="o">.</span><span class="n">pos</span>
                <span class="k">if</span> <span class="n">pos</span> <span class="o">==</span> <span class="n">ADJ_SAT</span><span class="p">:</span>
                    <span class="n">pos</span> <span class="o">=</span> <span class="n">ADJ</span>
                <span class="k">for</span> <span class="n">level</span> <span class="ow">in</span> <span class="n">ss</span><span class="o">.</span><span class="n">_iter_hypernym_lists</span><span class="p">():</span>
                    <span class="k">for</span> <span class="n">hh</span> <span class="ow">in</span> <span class="n">level</span><span class="p">:</span>
                        <span class="n">ic</span><span class="p">[</span><span class="n">pos</span><span class="p">][</span><span class="n">hh</span><span class="o">.</span><span class="n">offset</span><span class="p">]</span> <span class="o">+=</span> <span class="n">weight</span>
                <span class="c"># Add the weight to the root</span>
                <span class="n">ic</span><span class="p">[</span><span class="n">pos</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">weight</span>
        <span class="k">return</span> <span class="n">ic</span>


<span class="c">######################################################################</span>
<span class="c">## WordNet Information Content Corpus Reader</span>
<span class="c">######################################################################</span>
</div></div>
<div class="viewcode-block" id="WordNetICCorpusReader"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.WordNetICCorpusReader">[docs]</a><span class="k">class</span> <span class="nc">WordNetICCorpusReader</span><span class="p">(</span><span class="n">CorpusReader</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A corpus reader for the WordNet information content corpus.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">fileids</span><span class="p">):</span>
        <span class="n">CorpusReader</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">fileids</span><span class="p">)</span>

    <span class="c"># this load function would be more efficient if the data was pickled</span>
    <span class="c"># Note that we can&#39;t use NLTK&#39;s frequency distributions because</span>
    <span class="c"># synsets are overlapping (each instance of a synset also counts</span>
    <span class="c"># as an instance of its hypernyms)</span>
<div class="viewcode-block" id="WordNetICCorpusReader.ic"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.WordNetICCorpusReader.ic">[docs]</a>    <span class="k">def</span> <span class="nf">ic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">icfile</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Load an information content file from the wordnet_ic corpus</span>
<span class="sd">        and return a dictionary.  This dictionary has just two keys,</span>
<span class="sd">        NOUN and VERB, whose values are dictionaries that map from</span>
<span class="sd">        synsets to information content values.</span>

<span class="sd">        @type  icfile: L{str}</span>
<span class="sd">        @param icfile: The name of the wordnet_ic file (e.g. &quot;ic-brown.dat&quot;)</span>
<span class="sd">        @return: An information content dictionary</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ic</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">ic</span><span class="p">[</span><span class="n">NOUN</span><span class="p">]</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">ic</span><span class="p">[</span><span class="n">VERB</span><span class="p">]</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">num</span><span class="p">,</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">icfile</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">num</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="c"># skip the header</span>
                <span class="k">continue</span>
            <span class="n">fields</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">fields</span><span class="p">[</span><span class="mi">0</span><span class="p">][:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">value</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">fields</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">_get_pos</span><span class="p">(</span><span class="n">fields</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">fields</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">and</span> <span class="n">fields</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="s">&quot;ROOT&quot;</span><span class="p">:</span>
                <span class="c"># Store root count.</span>
                <span class="n">ic</span><span class="p">[</span><span class="n">pos</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">value</span>
            <span class="k">if</span> <span class="n">value</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">ic</span><span class="p">[</span><span class="n">pos</span><span class="p">][</span><span class="n">offset</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">return</span> <span class="n">ic</span>


<span class="c">######################################################################</span>
<span class="c"># Similarity metrics</span>
<span class="c">######################################################################</span>

<span class="c"># TODO: Add in the option to manually add a new root node; this will be</span>
<span class="c"># useful for verb similarity as there exist multiple verb taxonomies.</span>

<span class="c"># More information about the metrics is available at</span>
<span class="c"># http://marimba.d.umn.edu/similarity/measures.html</span>
</div></div>
<div class="viewcode-block" id="path_similarity"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.path_similarity">[docs]</a><span class="k">def</span> <span class="nf">path_similarity</span><span class="p">(</span><span class="n">synset1</span><span class="p">,</span> <span class="n">synset2</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">simulate_root</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">synset1</span><span class="o">.</span><span class="n">path_similarity</span><span class="p">(</span><span class="n">synset2</span><span class="p">,</span> <span class="n">verbose</span><span class="p">,</span> <span class="n">simulate_root</span><span class="p">)</span></div>
<span class="n">path_similarity</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="n">Synset</span><span class="o">.</span><span class="n">path_similarity</span><span class="o">.</span><span class="n">__doc__</span>


<div class="viewcode-block" id="lch_similarity"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.lch_similarity">[docs]</a><span class="k">def</span> <span class="nf">lch_similarity</span><span class="p">(</span><span class="n">synset1</span><span class="p">,</span> <span class="n">synset2</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">simulate_root</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">synset1</span><span class="o">.</span><span class="n">lch_similarity</span><span class="p">(</span><span class="n">synset2</span><span class="p">,</span> <span class="n">verbose</span><span class="p">,</span> <span class="n">simulate_root</span><span class="p">)</span></div>
<span class="n">lch_similarity</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="n">Synset</span><span class="o">.</span><span class="n">lch_similarity</span><span class="o">.</span><span class="n">__doc__</span>


<div class="viewcode-block" id="wup_similarity"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.wup_similarity">[docs]</a><span class="k">def</span> <span class="nf">wup_similarity</span><span class="p">(</span><span class="n">synset1</span><span class="p">,</span> <span class="n">synset2</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">simulate_root</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">synset1</span><span class="o">.</span><span class="n">wup_similarity</span><span class="p">(</span><span class="n">synset2</span><span class="p">,</span> <span class="n">verbose</span><span class="p">,</span> <span class="n">simulate_root</span><span class="p">)</span></div>
<span class="n">wup_similarity</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="n">Synset</span><span class="o">.</span><span class="n">wup_similarity</span><span class="o">.</span><span class="n">__doc__</span>


<div class="viewcode-block" id="res_similarity"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.res_similarity">[docs]</a><span class="k">def</span> <span class="nf">res_similarity</span><span class="p">(</span><span class="n">synset1</span><span class="p">,</span> <span class="n">synset2</span><span class="p">,</span> <span class="n">ic</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">synset1</span><span class="o">.</span><span class="n">res_similarity</span><span class="p">(</span><span class="n">synset2</span><span class="p">,</span> <span class="n">verbose</span><span class="p">)</span></div>
<span class="n">res_similarity</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="n">Synset</span><span class="o">.</span><span class="n">res_similarity</span><span class="o">.</span><span class="n">__doc__</span>


<div class="viewcode-block" id="jcn_similarity"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.jcn_similarity">[docs]</a><span class="k">def</span> <span class="nf">jcn_similarity</span><span class="p">(</span><span class="n">synset1</span><span class="p">,</span> <span class="n">synset2</span><span class="p">,</span> <span class="n">ic</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">synset1</span><span class="o">.</span><span class="n">jcn_similarity</span><span class="p">(</span><span class="n">synset2</span><span class="p">,</span> <span class="n">verbose</span><span class="p">)</span></div>
<span class="n">jcn_similarity</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="n">Synset</span><span class="o">.</span><span class="n">jcn_similarity</span><span class="o">.</span><span class="n">__doc__</span>


<div class="viewcode-block" id="lin_similarity"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.lin_similarity">[docs]</a><span class="k">def</span> <span class="nf">lin_similarity</span><span class="p">(</span><span class="n">synset1</span><span class="p">,</span> <span class="n">synset2</span><span class="p">,</span> <span class="n">ic</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">synset1</span><span class="o">.</span><span class="n">lin_similarity</span><span class="p">(</span><span class="n">synset2</span><span class="p">,</span> <span class="n">verbose</span><span class="p">)</span></div>
<span class="n">lin_similarity</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="n">Synset</span><span class="o">.</span><span class="n">lin_similarity</span><span class="o">.</span><span class="n">__doc__</span>


<span class="k">def</span> <span class="nf">_lcs_by_depth</span><span class="p">(</span><span class="n">synset1</span><span class="p">,</span> <span class="n">synset2</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Finds the least common subsumer of two synsets in a WordNet taxonomy,</span>
<span class="sd">    where the least common subsumer is defined as the ancestor node common</span>
<span class="sd">    to both input synsets whose shortest path to the root node is the longest.</span>

<span class="sd">    @type  synset1: L{Synset}</span>
<span class="sd">    @param synset1: First input synset.</span>
<span class="sd">    @type  synset2: L{Synset}</span>
<span class="sd">    @param synset2: Second input synset.</span>
<span class="sd">    @return: The ancestor synset common to both input synsets which is also the</span>
<span class="sd">    LCS.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">subsumer</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">max_min_path_length</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

    <span class="n">subsumers</span> <span class="o">=</span> <span class="n">synset1</span><span class="o">.</span><span class="n">common_hypernyms</span><span class="p">(</span><span class="n">synset2</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">&quot;&gt; Subsumers1:&quot;</span><span class="p">,</span> <span class="n">subsumers</span>

    <span class="c"># Eliminate those synsets which are ancestors of other synsets in the</span>
    <span class="c"># set of subsumers.</span>

    <span class="n">eliminated</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="n">hypernym_relation</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="n">s</span><span class="o">.</span><span class="n">hypernyms</span><span class="p">()</span> <span class="o">+</span> <span class="n">s</span><span class="o">.</span><span class="n">instance_hypernyms</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">s1</span> <span class="ow">in</span> <span class="n">subsumers</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">s2</span> <span class="ow">in</span> <span class="n">subsumers</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">s2</span> <span class="ow">in</span> <span class="n">s1</span><span class="o">.</span><span class="n">closure</span><span class="p">(</span><span class="n">hypernym_relation</span><span class="p">):</span>
                <span class="n">eliminated</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">s2</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">&quot;&gt; Eliminated:&quot;</span><span class="p">,</span> <span class="n">eliminated</span>

    <span class="n">subsumers</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">subsumers</span> <span class="k">if</span> <span class="n">s</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">eliminated</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">&quot;&gt; Subsumers2:&quot;</span><span class="p">,</span> <span class="n">subsumers</span>

    <span class="c"># Calculate the length of the shortest path to the root for each</span>
    <span class="c"># subsumer. Select the subsumer with the longest of these.</span>

    <span class="k">for</span> <span class="n">candidate</span> <span class="ow">in</span> <span class="n">subsumers</span><span class="p">:</span>

        <span class="n">paths_to_root</span> <span class="o">=</span> <span class="n">candidate</span><span class="o">.</span><span class="n">hypernym_paths</span><span class="p">()</span>
        <span class="n">min_path_length</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

        <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">paths_to_root</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">min_path_length</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">min_path_length</span><span class="p">:</span>
                <span class="n">min_path_length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">min_path_length</span> <span class="o">&gt;</span> <span class="n">max_min_path_length</span><span class="p">:</span>
            <span class="n">max_min_path_length</span> <span class="o">=</span> <span class="n">min_path_length</span>
            <span class="n">subsumer</span> <span class="o">=</span> <span class="n">candidate</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">&quot;&gt; LCS Subsumer by depth:&quot;</span><span class="p">,</span> <span class="n">subsumer</span>
    <span class="k">return</span> <span class="n">subsumer</span>


<span class="k">def</span> <span class="nf">_lcs_ic</span><span class="p">(</span><span class="n">synset1</span><span class="p">,</span> <span class="n">synset2</span><span class="p">,</span> <span class="n">ic</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the information content of the least common subsumer that has</span>
<span class="sd">    the highest information content value.  If two nodes have no</span>
<span class="sd">    explicit common subsumer, assume that they share an artificial</span>
<span class="sd">    root node that is the hypernym of all explicit roots.</span>

<span class="sd">    @type  synset1: L{Synset}</span>
<span class="sd">    @param synset1: First input synset.</span>
<span class="sd">    @type  synset2: L{Synset}</span>
<span class="sd">    @param synset2: Second input synset.  Must be the same part of</span>
<span class="sd">    speech as the first synset.</span>
<span class="sd">    @type  ic: C{dict}</span>
<span class="sd">    @param ic: an information content object (as returned by L{load_ic()}).</span>
<span class="sd">    @return: The information content of the two synsets and their most</span>
<span class="sd">    informative subsumer</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">synset1</span><span class="o">.</span><span class="n">pos</span> <span class="o">!=</span> <span class="n">synset2</span><span class="o">.</span><span class="n">pos</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">WordNetError</span><span class="p">(</span><span class="s">&#39;Computing the least common subsumer requires &#39;</span> <span class="o">+</span> \
                           <span class="s">&#39;</span><span class="si">%s</span><span class="s"> and </span><span class="si">%s</span><span class="s"> to have the same part of speech.&#39;</span> <span class="o">%</span> \
                               <span class="p">(</span><span class="n">synset1</span><span class="p">,</span> <span class="n">synset2</span><span class="p">))</span>

    <span class="n">ic1</span> <span class="o">=</span> <span class="n">information_content</span><span class="p">(</span><span class="n">synset1</span><span class="p">,</span> <span class="n">ic</span><span class="p">)</span>
    <span class="n">ic2</span> <span class="o">=</span> <span class="n">information_content</span><span class="p">(</span><span class="n">synset2</span><span class="p">,</span> <span class="n">ic</span><span class="p">)</span>
    <span class="n">subsumers</span> <span class="o">=</span> <span class="n">synset1</span><span class="o">.</span><span class="n">common_hypernyms</span><span class="p">(</span><span class="n">synset2</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">subsumers</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">subsumer_ic</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">subsumer_ic</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">information_content</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">ic</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">subsumers</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">&quot;&gt; LCS Subsumer by content:&quot;</span><span class="p">,</span> <span class="n">subsumer_ic</span>

    <span class="k">return</span> <span class="n">ic1</span><span class="p">,</span> <span class="n">ic2</span><span class="p">,</span> <span class="n">subsumer_ic</span>


<span class="c"># Utility functions</span>

<div class="viewcode-block" id="information_content"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.information_content">[docs]</a><span class="k">def</span> <span class="nf">information_content</span><span class="p">(</span><span class="n">synset</span><span class="p">,</span> <span class="n">ic</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">icpos</span> <span class="o">=</span> <span class="n">ic</span><span class="p">[</span><span class="n">synset</span><span class="o">.</span><span class="n">pos</span><span class="p">]</span>
    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s">&#39;Information content file has no entries for part-of-speech: </span><span class="si">%s</span><span class="s">&#39;</span>
        <span class="k">raise</span> <span class="n">WordNetError</span><span class="p">(</span><span class="n">msg</span> <span class="o">%</span> <span class="n">synset</span><span class="o">.</span><span class="n">pos</span><span class="p">)</span>

    <span class="n">counts</span> <span class="o">=</span> <span class="n">icpos</span><span class="p">[</span><span class="n">synset</span><span class="o">.</span><span class="n">offset</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">counts</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_INF</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">counts</span> <span class="o">/</span> <span class="n">icpos</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>


<span class="c"># get the part of speech (NOUN or VERB) from the information content record</span>
<span class="c"># (each identifier has a &#39;n&#39; or &#39;v&#39; suffix)</span>
</div>
<span class="k">def</span> <span class="nf">_get_pos</span><span class="p">(</span><span class="n">field</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">field</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;n&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">NOUN</span>
    <span class="k">elif</span> <span class="n">field</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;v&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">VERB</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s">&quot;Unidentified part of speech in WordNet Information Content file&quot;</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>


<span class="c">######################################################################</span>
<span class="c"># Demo</span>
<span class="c">######################################################################</span>

<div class="viewcode-block" id="demo"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.demo">[docs]</a><span class="k">def</span> <span class="nf">demo</span><span class="p">():</span>
    <span class="kn">import</span> <span class="nn">nltk</span>
    <span class="k">print</span> <span class="s">&#39;loading wordnet&#39;</span>
    <span class="n">wn</span> <span class="o">=</span> <span class="n">WordNetCorpusReader</span><span class="p">(</span><span class="n">nltk</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s">&#39;corpora/wordnet&#39;</span><span class="p">))</span>
    <span class="k">print</span> <span class="s">&#39;done loading&#39;</span>
    <span class="n">S</span> <span class="o">=</span> <span class="n">wn</span><span class="o">.</span><span class="n">synset</span>
    <span class="n">L</span> <span class="o">=</span> <span class="n">wn</span><span class="o">.</span><span class="n">lemma</span>

    <span class="k">print</span> <span class="s">&#39;getting a synset for go&#39;</span>
    <span class="n">move_synset</span> <span class="o">=</span> <span class="n">S</span><span class="p">(</span><span class="s">&#39;go.v.21&#39;</span><span class="p">)</span>
    <span class="k">print</span> <span class="n">move_synset</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">move_synset</span><span class="o">.</span><span class="n">pos</span><span class="p">,</span> <span class="n">move_synset</span><span class="o">.</span><span class="n">lexname</span>
    <span class="k">print</span> <span class="n">move_synset</span><span class="o">.</span><span class="n">lemma_names</span>
    <span class="k">print</span> <span class="n">move_synset</span><span class="o">.</span><span class="n">definition</span>
    <span class="k">print</span> <span class="n">move_synset</span><span class="o">.</span><span class="n">examples</span>

    <span class="n">zap_n</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;zap.n.01&#39;</span><span class="p">]</span>
    <span class="n">zap_v</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;zap.v.01&#39;</span><span class="p">,</span> <span class="s">&#39;zap.v.02&#39;</span><span class="p">,</span> <span class="s">&#39;nuke.v.01&#39;</span><span class="p">,</span> <span class="s">&#39;microwave.v.01&#39;</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_get_synsets</span><span class="p">(</span><span class="n">synset_strings</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">S</span><span class="p">(</span><span class="n">synset</span><span class="p">)</span> <span class="k">for</span> <span class="n">synset</span> <span class="ow">in</span> <span class="n">synset_strings</span><span class="p">]</span>

    <span class="n">zap_n_synsets</span> <span class="o">=</span> <span class="n">_get_synsets</span><span class="p">(</span><span class="n">zap_n</span><span class="p">)</span>
    <span class="n">zap_v_synsets</span> <span class="o">=</span> <span class="n">_get_synsets</span><span class="p">(</span><span class="n">zap_v</span><span class="p">)</span>
    <span class="n">zap_synsets</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">zap_n_synsets</span> <span class="o">+</span> <span class="n">zap_v_synsets</span><span class="p">)</span>

    <span class="k">print</span> <span class="n">zap_n_synsets</span>
    <span class="k">print</span> <span class="n">zap_v_synsets</span>

    <span class="k">print</span> <span class="s">&quot;Navigations:&quot;</span>
    <span class="k">print</span> <span class="n">S</span><span class="p">(</span><span class="s">&#39;travel.v.01&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">hypernyms</span><span class="p">()</span>
    <span class="k">print</span> <span class="n">S</span><span class="p">(</span><span class="s">&#39;travel.v.02&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">hypernyms</span><span class="p">()</span>
    <span class="k">print</span> <span class="n">S</span><span class="p">(</span><span class="s">&#39;travel.v.03&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">hypernyms</span><span class="p">()</span>

    <span class="k">print</span> <span class="n">L</span><span class="p">(</span><span class="s">&#39;zap.v.03.nuke&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">derivationally_related_forms</span><span class="p">()</span>
    <span class="k">print</span> <span class="n">L</span><span class="p">(</span><span class="s">&#39;zap.v.03.atomize&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">derivationally_related_forms</span><span class="p">()</span>
    <span class="k">print</span> <span class="n">L</span><span class="p">(</span><span class="s">&#39;zap.v.03.atomise&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">derivationally_related_forms</span><span class="p">()</span>
    <span class="k">print</span> <span class="n">L</span><span class="p">(</span><span class="s">&#39;zap.v.03.zap&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">derivationally_related_forms</span><span class="p">()</span>

    <span class="k">print</span> <span class="n">S</span><span class="p">(</span><span class="s">&#39;dog.n.01&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">member_holonyms</span><span class="p">()</span>
    <span class="k">print</span> <span class="n">S</span><span class="p">(</span><span class="s">&#39;dog.n.01&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">part_meronyms</span><span class="p">()</span>

    <span class="k">print</span> <span class="n">S</span><span class="p">(</span><span class="s">&#39;breakfast.n.1&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">hypernyms</span><span class="p">()</span>
    <span class="k">print</span> <span class="n">S</span><span class="p">(</span><span class="s">&#39;meal.n.1&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">hyponyms</span><span class="p">()</span>
    <span class="k">print</span> <span class="n">S</span><span class="p">(</span><span class="s">&#39;Austen.n.1&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">instance_hypernyms</span><span class="p">()</span>
    <span class="k">print</span> <span class="n">S</span><span class="p">(</span><span class="s">&#39;composer.n.1&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">instance_hyponyms</span><span class="p">()</span>

    <span class="k">print</span> <span class="n">S</span><span class="p">(</span><span class="s">&#39;faculty.n.2&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">member_meronyms</span><span class="p">()</span>
    <span class="k">print</span> <span class="n">S</span><span class="p">(</span><span class="s">&#39;copilot.n.1&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">member_holonyms</span><span class="p">()</span>

    <span class="k">print</span> <span class="n">S</span><span class="p">(</span><span class="s">&#39;table.n.2&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">part_meronyms</span><span class="p">()</span>
    <span class="k">print</span> <span class="n">S</span><span class="p">(</span><span class="s">&#39;course.n.7&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">part_holonyms</span><span class="p">()</span>

    <span class="k">print</span> <span class="n">S</span><span class="p">(</span><span class="s">&#39;water.n.1&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">substance_meronyms</span><span class="p">()</span>
    <span class="k">print</span> <span class="n">S</span><span class="p">(</span><span class="s">&#39;gin.n.1&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">substance_holonyms</span><span class="p">()</span>

    <span class="k">print</span> <span class="n">L</span><span class="p">(</span><span class="s">&#39;leader.n.1.leader&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">antonyms</span><span class="p">()</span>
    <span class="k">print</span> <span class="n">L</span><span class="p">(</span><span class="s">&#39;increase.v.1.increase&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">antonyms</span><span class="p">()</span>

    <span class="k">print</span> <span class="n">S</span><span class="p">(</span><span class="s">&#39;snore.v.1&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">entailments</span><span class="p">()</span>
    <span class="k">print</span> <span class="n">S</span><span class="p">(</span><span class="s">&#39;heavy.a.1&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">similar_tos</span><span class="p">()</span>
    <span class="k">print</span> <span class="n">S</span><span class="p">(</span><span class="s">&#39;light.a.1&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">attributes</span><span class="p">()</span>
    <span class="k">print</span> <span class="n">S</span><span class="p">(</span><span class="s">&#39;heavy.a.1&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">attributes</span><span class="p">()</span>

    <span class="k">print</span> <span class="n">L</span><span class="p">(</span><span class="s">&#39;English.a.1.English&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">pertainyms</span><span class="p">()</span>

    <span class="k">print</span> <span class="n">S</span><span class="p">(</span><span class="s">&#39;person.n.01&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">root_hypernyms</span><span class="p">()</span>
    <span class="k">print</span> <span class="n">S</span><span class="p">(</span><span class="s">&#39;sail.v.01&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">root_hypernyms</span><span class="p">()</span>
    <span class="k">print</span> <span class="n">S</span><span class="p">(</span><span class="s">&#39;fall.v.12&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">root_hypernyms</span><span class="p">()</span>

    <span class="k">print</span> <span class="n">S</span><span class="p">(</span><span class="s">&#39;person.n.01&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">lowest_common_hypernyms</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="s">&#39;dog.n.01&#39;</span><span class="p">))</span>

    <span class="k">print</span> <span class="n">S</span><span class="p">(</span><span class="s">&#39;dog.n.01&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">path_similarity</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="s">&#39;cat.n.01&#39;</span><span class="p">))</span>
    <span class="k">print</span> <span class="n">S</span><span class="p">(</span><span class="s">&#39;dog.n.01&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">lch_similarity</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="s">&#39;cat.n.01&#39;</span><span class="p">))</span>
    <span class="k">print</span> <span class="n">S</span><span class="p">(</span><span class="s">&#39;dog.n.01&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">wup_similarity</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="s">&#39;cat.n.01&#39;</span><span class="p">))</span>

    <span class="n">wnic</span> <span class="o">=</span> <span class="n">WordNetICCorpusReader</span><span class="p">(</span><span class="n">nltk</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s">&#39;corpora/wordnet_ic&#39;</span><span class="p">),</span>
                                 <span class="s">&#39;.*\.dat&#39;</span><span class="p">)</span>
    <span class="n">ic</span> <span class="o">=</span> <span class="n">wnic</span><span class="o">.</span><span class="n">ic</span><span class="p">(</span><span class="s">&#39;ic-brown.dat&#39;</span><span class="p">)</span>
    <span class="k">print</span> <span class="n">S</span><span class="p">(</span><span class="s">&#39;dog.n.01&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">jcn_similarity</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="s">&#39;cat.n.01&#39;</span><span class="p">),</span> <span class="n">ic</span><span class="p">)</span>

    <span class="n">ic</span> <span class="o">=</span> <span class="n">wnic</span><span class="o">.</span><span class="n">ic</span><span class="p">(</span><span class="s">&#39;ic-semcor.dat&#39;</span><span class="p">)</span>
    <span class="k">print</span> <span class="n">S</span><span class="p">(</span><span class="s">&#39;dog.n.01&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">lin_similarity</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="s">&#39;cat.n.01&#39;</span><span class="p">),</span> <span class="n">ic</span><span class="p">)</span>

    <span class="k">print</span> <span class="n">S</span><span class="p">(</span><span class="s">&#39;code.n.03&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">topic_domains</span><span class="p">()</span>
    <span class="k">print</span> <span class="n">S</span><span class="p">(</span><span class="s">&#39;pukka.a.01&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">region_domains</span><span class="p">()</span>
    <span class="k">print</span> <span class="n">S</span><span class="p">(</span><span class="s">&#39;freaky.a.01&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">usage_domains</span><span class="p">()</span>
</div>
<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">demo</span><span class="p">()</span>
</pre></div>

          </div>
        </div>
      </div>
        </div>
        <div class="sidebar">
          <h3>Table Of Contents</h3>
          <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../news.html">NLTK News</a></li>
</ul>

          <h3 style="margin-top: 1.5em;">Search</h3>
          <form class="search" action="../../../../search.html" method="get">
            <input type="text" name="q" />
            <input type="submit" value="Go" />
            <input type="hidden" name="check_keywords" value="yes" />
            <input type="hidden" name="area" value="default" />
          </form>
          <p class="searchtip" style="font-size: 90%">
            Enter search terms or a module, class or function name.
          </p>
        </div>
        <div class="clearer"></div>
      </div>
    </div>

    <div class="footer-wrapper">
      <div class="footer">
        <div class="left">
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |
          <a href="../../../../genindex.html" title="General Index"
             >index</a>
        </div>

        <div class="right">
          
    <div class="footer">
        &copy; Copyright 2011, Steven Bird.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.2.
    </div>
        </div>
        <div class="clearer"></div>
      </div>
    </div>

  </body>
</html>