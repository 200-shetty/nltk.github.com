

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>nltk.data &mdash; NLTK 2.0 documentation</title>
    
    <link rel="stylesheet" href="../../_static/agogo.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '2.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="top" title="NLTK 2.0 documentation" href="../../index.html" />
    <link rel="up" title="Module code" href="../index.html" /> 
  </head>
  <body>
    <div class="header-wrapper">
      <div class="header">
        <div class="headertitle"><a
          href="../../index.html">NLTK 2.0 documentation</a></div>
        <div class="rel">
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a>
        </div>
       </div>
    </div>

    <div class="content-wrapper">
      <div class="content">
        <div class="document">
            
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for nltk.data</h1><div class="highlight"><pre>
<span class="c"># Natural Language Toolkit: Utility functions</span>
<span class="c">#</span>
<span class="c"># Copyright (C) 2001-2011 NLTK Project</span>
<span class="c"># Author: Edward Loper &lt;edloper@gradient.cis.upenn.edu&gt;</span>
<span class="c"># URL: &lt;http://www.nltk.org/&gt;</span>
<span class="c"># For license information, see LICENSE.TXT</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Functions to find and load NLTK X{resource files}, such as corpora,</span>
<span class="sd">grammars, and saved processing objects.  Resource files are identified</span>
<span class="sd">using URLs, such as&quot;C{nltk:corpora/abc/rural.txt}&quot; or</span>
<span class="sd">&quot;C{http://nltk.org/sample/toy.cfg}&quot;.  The following URL protocols are</span>
<span class="sd">supported:</span>

<span class="sd">  - &quot;C{file:I{path}}&quot;: Specifies the file whose path is C{I{path}}.</span>
<span class="sd">    Both relative and absolute paths may be used.</span>
<span class="sd">    </span>
<span class="sd">  - &quot;C{http://I{host}/{path}}&quot;: Specifies the file stored on the web</span>
<span class="sd">    server C{I{host}} at path C{I{path}}.</span>
<span class="sd">    </span>
<span class="sd">  - &quot;C{nltk:I{path}}&quot;: Specifies the file stored in the NLTK data</span>
<span class="sd">    package at C{I{path}}.  NLTK will search for these files in the</span>
<span class="sd">    directories specified by L{nltk.data.path}.</span>

<span class="sd">If no protocol is specified, then the default protocol &quot;C{nltk:}&quot; will</span>
<span class="sd">be used.</span>
<span class="sd"> </span>
<span class="sd">This module provides to functions that can be used to access a</span>
<span class="sd">resource file, given its URL: L{load()} loads a given resource, and</span>
<span class="sd">adds it to a resource cache; and L{retrieve()} copies a given resource</span>
<span class="sd">to a local file.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">os</span><span class="o">,</span> <span class="nn">os.path</span>
<span class="kn">import</span> <span class="nn">textwrap</span>
<span class="kn">import</span> <span class="nn">weakref</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">urllib2</span>
<span class="kn">import</span> <span class="nn">zipfile</span>
<span class="kn">import</span> <span class="nn">codecs</span>

<span class="kn">from</span> <span class="nn">gzip</span> <span class="kn">import</span> <span class="n">GzipFile</span><span class="p">,</span> <span class="n">READ</span> <span class="k">as</span> <span class="n">GZ_READ</span><span class="p">,</span> <span class="n">WRITE</span> <span class="k">as</span> <span class="n">GZ_WRITE</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">zlib</span> <span class="kn">import</span> <span class="n">Z_SYNC_FLUSH</span> <span class="k">as</span> <span class="n">FLUSH</span>
<span class="k">except</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">zlib</span> <span class="kn">import</span> <span class="n">Z_FINISH</span> <span class="k">as</span> <span class="n">FLUSH</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">cPickle</span> <span class="kn">as</span> <span class="nn">pickle</span>
<span class="k">except</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">pickle</span>
    
<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">cStringIO</span> <span class="kn">import</span> <span class="n">StringIO</span>
<span class="k">except</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">StringIO</span> <span class="kn">import</span> <span class="n">StringIO</span>

<span class="kn">import</span> <span class="nn">nltk</span>

<span class="c">######################################################################</span>
<span class="c"># Search Path</span>
<span class="c">######################################################################</span>

<span class="n">path</span> <span class="o">=</span> <span class="p">[]</span>
<span class="sd">&quot;&quot;&quot;A list of directories where the NLTK data package might reside.</span>
<span class="sd">   These directories will be checked in order when looking for a</span>
<span class="sd">   resource in the data package.  Note that this allows users to</span>
<span class="sd">   substitute in their own versions of resources, if they have them</span>
<span class="sd">   (e.g., in their home directory under ~/nltk_data).&quot;&quot;&quot;</span>

<span class="c"># User-specified locations:</span>
<span class="n">path</span> <span class="o">+=</span> <span class="p">[</span><span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;NLTK_DATA&#39;</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">pathsep</span><span class="p">)</span> <span class="k">if</span> <span class="n">d</span><span class="p">]</span>
<span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">expanduser</span><span class="p">(</span><span class="s">&#39;~/&#39;</span><span class="p">)</span> <span class="o">!=</span> <span class="s">&#39;~/&#39;</span><span class="p">:</span> <span class="n">path</span> <span class="o">+=</span> <span class="p">[</span>
    <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">expanduser</span><span class="p">(</span><span class="s">&#39;~/nltk_data&#39;</span><span class="p">)]</span>

<span class="c"># Common locations on Windows:</span>
<span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">platform</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&#39;win&#39;</span><span class="p">):</span> <span class="n">path</span> <span class="o">+=</span> <span class="p">[</span>
    <span class="s">r&#39;C:\nltk_data&#39;</span><span class="p">,</span> <span class="s">r&#39;D:\nltk_data&#39;</span><span class="p">,</span> <span class="s">r&#39;E:\nltk_data&#39;</span><span class="p">,</span>
    <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">prefix</span><span class="p">,</span> <span class="s">&#39;nltk_data&#39;</span><span class="p">),</span>
    <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">prefix</span><span class="p">,</span> <span class="s">&#39;lib&#39;</span><span class="p">,</span> <span class="s">&#39;nltk_data&#39;</span><span class="p">),</span>
    <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;APPDATA&#39;</span><span class="p">,</span> <span class="s">&#39;C:</span><span class="se">\\</span><span class="s">&#39;</span><span class="p">),</span> <span class="s">&#39;nltk_data&#39;</span><span class="p">)]</span>

<span class="c"># Common locations on UNIX &amp; OS X:</span>
<span class="k">else</span><span class="p">:</span> <span class="n">path</span> <span class="o">+=</span> <span class="p">[</span>
    <span class="s">&#39;/usr/share/nltk_data&#39;</span><span class="p">,</span>
    <span class="s">&#39;/usr/local/share/nltk_data&#39;</span><span class="p">,</span>
    <span class="s">&#39;/usr/lib/nltk_data&#39;</span><span class="p">,</span>
    <span class="s">&#39;/usr/local/lib/nltk_data&#39;</span><span class="p">]</span>

<span class="c">######################################################################</span>
<span class="c"># Path Pointers</span>
<span class="c">######################################################################</span>

<div class="viewcode-block" id="PathPointer"><a class="viewcode-back" href="../../api/nltk.html#nltk.data.PathPointer">[docs]</a><span class="k">class</span> <span class="nc">PathPointer</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An abstract base class for &#39;path pointers,&#39; used by NLTK&#39;s data</span>
<span class="sd">    package to identify specific paths.  Two subclasses exist:</span>
<span class="sd">    L{FileSystemPathPointer} identifies a file that can be accessed</span>
<span class="sd">    directly via a given absolute path.  L{ZipFilePathPointer}</span>
<span class="sd">    identifies a file contained within a zipfile, that can be accessed</span>
<span class="sd">    by reading that zipfile.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="PathPointer.open"><a class="viewcode-back" href="../../api/nltk.html#nltk.data.PathPointer.open">[docs]</a>    <span class="k">def</span> <span class="nf">open</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a seekable read-only stream that can be used to read</span>
<span class="sd">        the contents of the file identified by this path pointer.</span>

<span class="sd">        @raise IOError: If the path specified by this pointer does</span>
<span class="sd">            not contain a readable file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&#39;abstract base class&#39;</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="PathPointer.file_size"><a class="viewcode-back" href="../../api/nltk.html#nltk.data.PathPointer.file_size">[docs]</a>    <span class="k">def</span> <span class="nf">file_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the size of the file pointed to by this path pointer,</span>
<span class="sd">        in bytes.</span>

<span class="sd">        @raise IOError: If the path specified by this pointer does</span>
<span class="sd">            not contain a readable file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&#39;abstract base class&#39;</span><span class="p">)</span>
    </div>
<div class="viewcode-block" id="PathPointer.join"><a class="viewcode-back" href="../../api/nltk.html#nltk.data.PathPointer.join">[docs]</a>    <span class="k">def</span> <span class="nf">join</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fileid</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a new path pointer formed by starting at the path</span>
<span class="sd">        identified by this pointer, and then following the relative</span>
<span class="sd">        path given by C{fileid}.  The path components of C{fileid}</span>
<span class="sd">        should be seperated by forward slashes (C{/}), regardless of</span>
<span class="sd">        the underlying file system&#39;s path seperator character.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&#39;abstract base class&#39;</span><span class="p">)</span>

</div></div>
<div class="viewcode-block" id="FileSystemPathPointer"><a class="viewcode-back" href="../../api/nltk.html#nltk.data.FileSystemPathPointer">[docs]</a><span class="k">class</span> <span class="nc">FileSystemPathPointer</span><span class="p">(</span><span class="n">PathPointer</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A path pointer that identifies a file which can be accessed</span>
<span class="sd">    directly via a given absolute path.  C{FileSystemPathPointer} is a</span>
<span class="sd">    subclass of C{str} for backwards compatibility purposes --</span>
<span class="sd">    this allows old code that expected C{nltk.data.find()} to expect a</span>
<span class="sd">    string to usually work (assuming the resource is not found in a</span>
<span class="sd">    zipfile).  It also permits open() to work on a FileSystemPathPointer.</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new path pointer for the given absolute path.</span>

<span class="sd">        @raise IOError: If the given path does not exist.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s">&#39;No such file or directory: </span><span class="si">%r</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">path</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_path</span> <span class="o">=</span> <span class="n">path</span>
        
        <span class="c"># There&#39;s no need to call str.__init__(), since it&#39;s a no-op;</span>
        <span class="c"># str does all of its setup work in __new__.</span>

    <span class="n">path</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="bp">self</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_path</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;</span>
<span class="s">        The absolute path identified by this path pointer.&quot;&quot;&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="FileSystemPathPointer.open"><a class="viewcode-back" href="../../api/nltk.html#nltk.data.FileSystemPathPointer.open">[docs]</a>    <span class="k">def</span> <span class="nf">open</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="n">stream</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_path</span><span class="p">,</span> <span class="s">&#39;rb&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">encoding</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">stream</span> <span class="o">=</span> <span class="n">SeekableUnicodeStreamReader</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">encoding</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">stream</span>
</div>
<div class="viewcode-block" id="FileSystemPathPointer.file_size"><a class="viewcode-back" href="../../api/nltk.html#nltk.data.FileSystemPathPointer.file_size">[docs]</a>    <span class="k">def</span> <span class="nf">file_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">stat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_path</span><span class="p">)</span><span class="o">.</span><span class="n">st_size</span>
</div>
<div class="viewcode-block" id="FileSystemPathPointer.join"><a class="viewcode-back" href="../../api/nltk.html#nltk.data.FileSystemPathPointer.join">[docs]</a>    <span class="k">def</span> <span class="nf">join</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fileid</span><span class="p">):</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_path</span><span class="p">,</span> <span class="o">*</span><span class="n">fileid</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">FileSystemPathPointer</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&#39;FileSystemPathPointer(</span><span class="si">%r</span><span class="s">)&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">_path</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_path</span>

</div>
<div class="viewcode-block" id="BufferedGzipFile"><a class="viewcode-back" href="../../api/nltk.html#nltk.data.BufferedGzipFile">[docs]</a><span class="k">class</span> <span class="nc">BufferedGzipFile</span><span class="p">(</span><span class="n">GzipFile</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A C{GzipFile} subclass that buffers calls to L{read()} and L{write()}.</span>
<span class="sd">    This allows faster reads and writes of data to and from gzip-compressed </span>
<span class="sd">    files at the cost of using more memory.</span>
<span class="sd">    </span>
<span class="sd">    The default buffer size is 2mb.</span>
<span class="sd">    </span>
<span class="sd">    C{BufferedGzipFile} is useful for loading large gzipped pickle objects</span>
<span class="sd">    as well as writing large encoded feature files for classifier training.</span>
<span class="sd">    &quot;&quot;&quot;</span>    
    <span class="n">SIZE</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="mi">2</span><span class="o">**</span><span class="mi">20</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">compresslevel</span><span class="o">=</span><span class="mi">9</span><span class="p">,</span> 
                 <span class="n">fileobj</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        @return: a buffered gzip file object</span>
<span class="sd">        @rtype: C{BufferedGzipFile}</span>
<span class="sd">        @param filename: a filesystem path</span>
<span class="sd">        @type filename: C{str}</span>
<span class="sd">        @param mode: a file mode which can be any of &#39;r&#39;, &#39;rb&#39;, &#39;a&#39;, &#39;ab&#39;, </span>
<span class="sd">            &#39;w&#39;, or &#39;wb&#39;</span>
<span class="sd">        @type mode: C{str}</span>
<span class="sd">        @param compresslevel: The compresslevel argument is an integer from 1</span>
<span class="sd">            to 9 controlling the level of compression; 1 is fastest and </span>
<span class="sd">            produces the least compression, and 9 is slowest and produces the</span>
<span class="sd">            most compression. The default is 9.</span>
<span class="sd">        @type compresslevel: C{int}</span>
<span class="sd">        @param fileobj: a StringIO stream to read from instead of a file.</span>
<span class="sd">        @type fileobj: C{StringIO}</span>
<span class="sd">        @kwparam size: number of bytes to buffer during calls to</span>
<span class="sd">            L{read()} and L{write()}</span>
<span class="sd">        @type size: C{int}</span>
<span class="sd">        &quot;&quot;&quot;</span>   
        <span class="n">GzipFile</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">compresslevel</span><span class="p">,</span> <span class="n">fileobj</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_size</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;size&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">SIZE</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_buffer</span> <span class="o">=</span> <span class="n">StringIO</span><span class="p">()</span>
        <span class="c"># cStringIO does not support len.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_len</span> <span class="o">=</span> <span class="mi">0</span>
        
    <span class="k">def</span> <span class="nf">_reset_buffer</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># For some reason calling StringIO.truncate() here will lead to </span>
        <span class="c"># inconsistent writes so just set _buffer to a new StringIO object.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_buffer</span> <span class="o">=</span> <span class="n">StringIO</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_len</span> <span class="o">=</span> <span class="mi">0</span>
        
    <span class="k">def</span> <span class="nf">_write_buffer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="c"># Simply write to the buffer and increment the buffer size.</span>
        <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_buffer</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_len</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">_write_gzip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="c"># Write the current buffer to the GzipFile.</span>
        <span class="n">GzipFile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_buffer</span><span class="o">.</span><span class="n">getvalue</span><span class="p">())</span>
        <span class="c"># Then reset the buffer and write the new data to the buffer.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_reset_buffer</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_write_buffer</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

<div class="viewcode-block" id="BufferedGzipFile.close"><a class="viewcode-back" href="../../api/nltk.html#nltk.data.BufferedGzipFile.close">[docs]</a>    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># GzipFile.close() doesn&#39;t actuallly close anything.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">==</span> <span class="n">GZ_WRITE</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_write_gzip</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_reset_buffer</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">GzipFile</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="BufferedGzipFile.flush"><a class="viewcode-back" href="../../api/nltk.html#nltk.data.BufferedGzipFile.flush">[docs]</a>    <span class="k">def</span> <span class="nf">flush</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lib_mode</span><span class="o">=</span><span class="n">FLUSH</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_buffer</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
        <span class="n">GzipFile</span><span class="o">.</span><span class="n">flush</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lib_mode</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="BufferedGzipFile.read"><a class="viewcode-back" href="../../api/nltk.html#nltk.data.BufferedGzipFile.read">[docs]</a>    <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">size</span><span class="p">:</span>
            <span class="n">size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_size</span>
            <span class="n">contents</span> <span class="o">=</span> <span class="n">StringIO</span><span class="p">()</span>
            <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
                <span class="n">blocks</span> <span class="o">=</span> <span class="n">GzipFile</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">blocks</span><span class="p">:</span>
                    <span class="n">contents</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
                    <span class="k">break</span>
                <span class="n">contents</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">blocks</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">contents</span><span class="o">.</span><span class="n">getvalue</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">GzipFile</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="BufferedGzipFile.write"><a class="viewcode-back" href="../../api/nltk.html#nltk.data.BufferedGzipFile.write">[docs]</a>    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">size</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        @param data: C{str} to write to file or buffer</span>
<span class="sd">        @type data: C{str}</span>
<span class="sd">        @param size: buffer at least size bytes before writing to file</span>
<span class="sd">        @type size: C{int}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">size</span><span class="p">:</span> 
            <span class="n">size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_size</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_len</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">size</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_write_buffer</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_write_gzip</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

</div></div>
<div class="viewcode-block" id="GzipFileSystemPathPointer"><a class="viewcode-back" href="../../api/nltk.html#nltk.data.GzipFileSystemPathPointer">[docs]</a><span class="k">class</span> <span class="nc">GzipFileSystemPathPointer</span><span class="p">(</span><span class="n">FileSystemPathPointer</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A subclass of C{FileSystemPathPointer} that identifies a gzip-compressed</span>
<span class="sd">    file located at a given absolute path.  C{GzipFileSystemPathPointer} is</span>
<span class="sd">    appropriate for loading large gzip-compressed pickle objects efficiently.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="GzipFileSystemPathPointer.open"><a class="viewcode-back" href="../../api/nltk.html#nltk.data.GzipFileSystemPathPointer.open">[docs]</a>    <span class="k">def</span> <span class="nf">open</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="n">stream</span> <span class="o">=</span> <span class="n">BufferedGzipFile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_path</span><span class="p">,</span> <span class="s">&#39;rb&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">encoding</span><span class="p">:</span>
            <span class="n">stream</span> <span class="o">=</span> <span class="n">SeekableUnicodeStreamReader</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">encoding</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">stream</span>

</div></div>
<span class="k">class</span> <span class="nc">ZipFilePathPointer</span><span class="p">(</span><span class="n">PathPointer</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A path pointer that identifies a file contained within a zipfile,</span>
<span class="sd">    which can be accessed by reading that zipfile.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">zipfile</span><span class="p">,</span> <span class="n">entry</span><span class="o">=</span><span class="s">&#39;&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new path pointer pointing at the specified entry</span>
<span class="sd">        in the given zipfile.</span>

<span class="sd">        @raise IOError: If the given zipfile does not exist, or if it</span>
<span class="sd">        does not contain the specified entry.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">zipfile</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">):</span>
            <span class="n">zipfile</span> <span class="o">=</span> <span class="n">OpenOnDemandZipFile</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">zipfile</span><span class="p">))</span>
            
        <span class="c"># Normalize the entry string:</span>
        <span class="n">entry</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s">&#39;(^|/)/+&#39;</span><span class="p">,</span> <span class="s">r&#39;\1&#39;</span><span class="p">,</span> <span class="n">entry</span><span class="p">)</span>

        <span class="c"># Check that the entry exists:</span>
        <span class="k">if</span> <span class="n">entry</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span> <span class="n">zipfile</span><span class="o">.</span><span class="n">getinfo</span><span class="p">(</span><span class="n">entry</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="c"># Sometimes directories aren&#39;t explicitly listed in</span>
                <span class="c"># the zip file.  So if `entry` is a directory name,</span>
                <span class="c"># then check if the zipfile contains any files that</span>
                <span class="c"># are under the given directory.</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">)</span> <span class="ow">and</span> 
                    <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">zipfile</span><span class="o">.</span><span class="n">namelist</span><span class="p">()</span> <span class="k">if</span> <span class="n">n</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">entry</span><span class="p">)]):</span>
                    <span class="k">pass</span> <span class="c"># zipfile contains a file in that directory.</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c"># Otherwise, complain.</span>
                    <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s">&#39;Zipfile </span><span class="si">%r</span><span class="s"> does not contain </span><span class="si">%r</span><span class="s">&#39;</span> <span class="o">%</span> 
                                  <span class="p">(</span><span class="n">zipfile</span><span class="o">.</span><span class="n">filename</span><span class="p">,</span> <span class="n">entry</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_zipfile</span> <span class="o">=</span> <span class="n">zipfile</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_entry</span> <span class="o">=</span> <span class="n">entry</span>

    <span class="n">zipfile</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="bp">self</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_zipfile</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;</span>
<span class="s">        The C{zipfile.ZipFile} object used to access the zip file</span>
<span class="s">        containing the entry identified by this path pointer.&quot;&quot;&quot;</span><span class="p">)</span>
    <span class="n">entry</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="bp">self</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_entry</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;</span>
<span class="s">        The name of the file within C{zipfile} that this path</span>
<span class="s">        pointer points to.&quot;&quot;&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">open</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_zipfile</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_entry</span><span class="p">)</span>
        <span class="n">stream</span> <span class="o">=</span> <span class="n">StringIO</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_entry</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s">&#39;.gz&#39;</span><span class="p">):</span>
            <span class="n">stream</span> <span class="o">=</span> <span class="n">BufferedGzipFile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_entry</span><span class="p">,</span> <span class="n">fileobj</span><span class="o">=</span><span class="n">stream</span><span class="p">)</span>                
        <span class="k">elif</span> <span class="n">encoding</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">stream</span> <span class="o">=</span> <span class="n">SeekableUnicodeStreamReader</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">encoding</span><span class="p">)</span>            
        <span class="k">return</span> <span class="n">stream</span>

    <span class="k">def</span> <span class="nf">file_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_zipfile</span><span class="o">.</span><span class="n">getinfo</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_entry</span><span class="p">)</span><span class="o">.</span><span class="n">file_size</span>

    <span class="k">def</span> <span class="nf">join</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fileid</span><span class="p">):</span>
        <span class="n">entry</span> <span class="o">=</span> <span class="s">&#39;</span><span class="si">%s</span><span class="s">/</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_entry</span><span class="p">,</span> <span class="n">fileid</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ZipFilePathPointer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_zipfile</span><span class="p">,</span> <span class="n">entry</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&#39;ZipFilePathPointer(</span><span class="si">%r</span><span class="s">, </span><span class="si">%r</span><span class="s">)&#39;</span> <span class="o">%</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_zipfile</span><span class="o">.</span><span class="n">filename</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_entry</span><span class="p">)</span>
      
<span class="c">######################################################################</span>
<span class="c"># Access Functions</span>
<span class="c">######################################################################</span>

<span class="c"># Don&#39;t use a weak dictionary, because in the common case this</span>
<span class="c"># causes a lot more reloading that necessary.</span>
<span class="n">_resource_cache</span> <span class="o">=</span> <span class="p">{}</span>
<span class="sd">&quot;&quot;&quot;A dictionary used to cache resources so that they won&#39;t</span>
<span class="sd">   need to be loaded more than once.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="find"><a class="viewcode-back" href="../../api/nltk.html#nltk.data.find">[docs]</a><span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="n">resource_name</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find the given resource by searching through the directories and</span>
<span class="sd">    zip files in L{nltk.data.path}, and return a corresponding path</span>
<span class="sd">    name.  If the given resource is not found, raise a C{LookupError},</span>
<span class="sd">    whose message gives a pointer to the installation instructions for</span>
<span class="sd">    the NLTK downloader.</span>

<span class="sd">    Zip File Handling:</span>

<span class="sd">      - If C{resource_name} contains a component with a C{.zip}</span>
<span class="sd">        extension, then it is assumed to be a zipfile; and the</span>
<span class="sd">        remaining path components are used to look inside the zipfile.</span>
<span class="sd">        </span>
<span class="sd">      - If any element of C{nltk.data.path} has a C{.zip} extension,</span>
<span class="sd">        then it is assumed to be a zipfile.</span>

<span class="sd">      - If a given resource name that does not contain any zipfile</span>
<span class="sd">        component is not found initially, then C{find()} will make a</span>
<span class="sd">        second attempt to find that resource, by replacing each</span>
<span class="sd">        component I{p} in the path with I{p.zip/p}.  For example, this</span>
<span class="sd">        allows C{find()} to map the resource name</span>
<span class="sd">        C{corpora/chat80/cities.pl} to a zip file path pointer to</span>
<span class="sd">        C{corpora/chat80.zip/chat80/cities.pl}.</span>

<span class="sd">      - When using C{find()} to locate a directory contained in a</span>
<span class="sd">        zipfile, the resource name I{must} end with the C{&#39;/&#39;}</span>
<span class="sd">        character.  Otherwise, C{find()} will not locate the</span>
<span class="sd">        directory.</span>

<span class="sd">    @type resource_name: C{str}</span>
<span class="sd">    @param resource_name: The name of the resource to search for.</span>
<span class="sd">        Resource names are posix-style relative path names, such as</span>
<span class="sd">        C{&#39;corpora/brown&#39;}.  In particular, directory names should</span>
<span class="sd">        always be separated by the C{&#39;/&#39;} character, which will be</span>
<span class="sd">        automatically converted to a platform-appropriate path</span>
<span class="sd">        separator.</span>
<span class="sd">    @rtype: C{str}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># Check if the resource name includes a zipfile name</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s">&#39;(.*\.zip)/?(.*)$|&#39;</span><span class="p">,</span> <span class="n">resource_name</span><span class="p">)</span>
    <span class="n">zipfile</span><span class="p">,</span> <span class="n">zipentry</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">groups</span><span class="p">()</span>
    
    <span class="c"># Check each item in our path</span>
    <span class="k">for</span> <span class="n">path_item</span> <span class="ow">in</span> <span class="n">path</span><span class="p">:</span>
        
        <span class="c"># Is the path item a zipfile?</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">path_item</span><span class="p">)</span> <span class="ow">and</span> <span class="n">path_item</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s">&#39;.zip&#39;</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span> <span class="k">return</span> <span class="n">ZipFilePathPointer</span><span class="p">(</span><span class="n">path_item</span><span class="p">,</span> <span class="n">resource_name</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">IOError</span><span class="p">:</span> <span class="k">continue</span> <span class="c"># resource not in zipfile</span>

        <span class="c"># Is the path item a directory?</span>
        <span class="k">elif</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">path_item</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">zipfile</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path_item</span><span class="p">,</span> <span class="o">*</span><span class="n">resource_name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s">&#39;.gz&#39;</span><span class="p">):</span>
                        <span class="k">return</span> <span class="n">GzipFileSystemPathPointer</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>   
                        <span class="k">return</span> <span class="n">FileSystemPathPointer</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path_item</span><span class="p">,</span> <span class="o">*</span><span class="n">zipfile</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
                    <span class="k">try</span><span class="p">:</span> <span class="k">return</span> <span class="n">ZipFilePathPointer</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">zipentry</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">IOError</span><span class="p">:</span> <span class="k">continue</span> <span class="c"># resource not in zipfile</span>

    <span class="c"># Fallback: if the path doesn&#39;t include a zip file, then try</span>
    <span class="c"># again, assuming that one of the path components is inside a</span>
    <span class="c"># zipfile of the same name.</span>
    <span class="k">if</span> <span class="n">zipfile</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">pieces</span> <span class="o">=</span> <span class="n">resource_name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pieces</span><span class="p">)):</span>
            <span class="n">modified_name</span> <span class="o">=</span> <span class="s">&#39;/&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">pieces</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="p">[</span><span class="n">pieces</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="s">&#39;.zip&#39;</span><span class="p">]</span><span class="o">+</span><span class="n">pieces</span><span class="p">[</span><span class="n">i</span><span class="p">:])</span>
            <span class="k">try</span><span class="p">:</span> <span class="k">return</span> <span class="n">find</span><span class="p">(</span><span class="n">modified_name</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">LookupError</span><span class="p">:</span> <span class="k">pass</span>

    <span class="c"># Display a friendly error message if the resource wasn&#39;t found:</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="n">textwrap</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span>
        <span class="s">&#39;Resource </span><span class="si">%r</span><span class="s"> not found.  Please use the NLTK Downloader to &#39;</span>
        <span class="s">&#39;obtain the resource: &gt;&gt;&gt; nltk.download().&#39;</span> <span class="o">%</span>
        <span class="p">(</span><span class="n">resource_name</span><span class="p">,),</span> <span class="n">initial_indent</span><span class="o">=</span><span class="s">&#39;  &#39;</span><span class="p">,</span> <span class="n">subsequent_indent</span><span class="o">=</span><span class="s">&#39;  &#39;</span><span class="p">,</span>
        <span class="n">width</span><span class="o">=</span><span class="mi">66</span><span class="p">)</span>
    <span class="n">msg</span> <span class="o">+=</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">  Searched in:&#39;</span> <span class="o">+</span> <span class="s">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">    - </span><span class="si">%r</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">path</span><span class="p">)</span>
    <span class="n">sep</span> <span class="o">=</span> <span class="s">&#39;*&#39;</span><span class="o">*</span><span class="mi">70</span>
    <span class="n">resource_not_found</span> <span class="o">=</span> <span class="s">&#39;</span><span class="se">\n</span><span class="si">%s</span><span class="se">\n</span><span class="si">%s</span><span class="se">\n</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">sep</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">sep</span><span class="p">)</span>
    <span class="k">raise</span> <span class="ne">LookupError</span><span class="p">(</span><span class="n">resource_not_found</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="retrieve"><a class="viewcode-back" href="../../api/nltk.html#nltk.data.retrieve">[docs]</a><span class="k">def</span> <span class="nf">retrieve</span><span class="p">(</span><span class="n">resource_url</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Copy the given resource to a local file.  If no filename is</span>
<span class="sd">    specified, then use the URL&#39;s filename.  If there is already a</span>
<span class="sd">    file named C{filename}, then raise a C{ValueError}.</span>
<span class="sd">    </span>
<span class="sd">    @type resource_url: C{str}</span>
<span class="sd">    @param resource_url: A URL specifying where the resource should be</span>
<span class="sd">        loaded from.  The default protocol is C{&quot;nltk:&quot;}, which searches</span>
<span class="sd">        for the file in the the NLTK data package.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">filename</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">resource_url</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&#39;file:&#39;</span><span class="p">):</span>
            <span class="n">filename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">filename</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">filename</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s">r&#39;(^\w+:)?.*/&#39;</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="p">,</span> <span class="n">resource_url</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">,</span> <span class="s">&quot;File </span><span class="si">%r</span><span class="s"> already exists!&quot;</span> <span class="o">%</span> <span class="n">filename</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">&#39;Retrieving </span><span class="si">%r</span><span class="s">, saving to </span><span class="si">%r</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">resource_url</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>
        
    <span class="c"># Open the input &amp; output streams.</span>
    <span class="n">infile</span> <span class="o">=</span> <span class="n">_open</span><span class="p">(</span><span class="n">resource_url</span><span class="p">)</span>
    <span class="n">outfile</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s">&#39;wb&#39;</span><span class="p">)</span>
    
    <span class="c"># Copy infile -&gt; outfile, using 64k blocks.</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">infile</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">1024</span><span class="o">*</span><span class="mi">64</span><span class="p">)</span> <span class="c"># 64k blocks.</span>
        <span class="n">outfile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">s</span><span class="p">:</span> <span class="k">break</span>

    <span class="c"># Close both files.</span>
    <span class="n">infile</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="n">outfile</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

<span class="c">#: A dictionary describing the formats that are supported by NLTK&#39;s</span>
<span class="c">#: L{load()} method.  Keys are format names, and values are format</span>
<span class="c">#: descriptions.</span></div>
<span class="n">FORMATS</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s">&#39;pickle&#39;</span><span class="p">:</span> <span class="s">&quot;A serialized python object, stored using the pickle module.&quot;</span><span class="p">,</span>
    <span class="s">&#39;yaml&#39;</span><span class="p">:</span> <span class="s">&quot;A serialized python object, stored using the yaml module.&quot;</span><span class="p">,</span>
    <span class="s">&#39;cfg&#39;</span><span class="p">:</span> <span class="s">&quot;A context free grammar, parsed by nltk.parse_cfg().&quot;</span><span class="p">,</span>
    <span class="s">&#39;pcfg&#39;</span><span class="p">:</span> <span class="s">&quot;A probabilistic CFG, parsed by nltk.parse_pcfg().&quot;</span><span class="p">,</span>
    <span class="s">&#39;fcfg&#39;</span><span class="p">:</span> <span class="s">&quot;A feature CFG, parsed by nltk.parse_fcfg().&quot;</span><span class="p">,</span>
    <span class="s">&#39;fol&#39;</span><span class="p">:</span> <span class="s">&quot;A list of first order logic expressions, parsed by &quot;</span>
            <span class="s">&quot;nltk.sem.parse_fol() using nltk.sem.logic.LogicParser.&quot;</span><span class="p">,</span>
    <span class="s">&#39;logic&#39;</span><span class="p">:</span> <span class="s">&quot;A list of first order logic expressions, parsed by &quot;</span>
            <span class="s">&quot;nltk.sem.parse_logic().  Requires an additional logic_parser &quot;</span>
            <span class="s">&quot;parameter&quot;</span><span class="p">,</span>
    <span class="s">&#39;val&#39;</span><span class="p">:</span> <span class="s">&quot;A semantic valuation, parsed by nltk.sem.parse_valuation().&quot;</span><span class="p">,</span>
    <span class="s">&#39;raw&#39;</span><span class="p">:</span> <span class="s">&quot;The raw (byte string) contents of a file.&quot;</span><span class="p">,</span>
    <span class="p">}</span>

<span class="c">#: A dictionary mapping from file extensions to format names, used</span>
<span class="c">#: by L{load()} when C{format=&quot;auto&quot;} to decide the format for a</span>
<span class="c">#: given resource url.</span>
<span class="n">AUTO_FORMATS</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s">&#39;pickle&#39;</span><span class="p">:</span> <span class="s">&#39;pickle&#39;</span><span class="p">,</span>
    <span class="s">&#39;yaml&#39;</span><span class="p">:</span> <span class="s">&#39;yaml&#39;</span><span class="p">,</span>
    <span class="s">&#39;cfg&#39;</span><span class="p">:</span> <span class="s">&#39;cfg&#39;</span><span class="p">,</span>
    <span class="s">&#39;pcfg&#39;</span><span class="p">:</span> <span class="s">&#39;pcfg&#39;</span><span class="p">,</span>
    <span class="s">&#39;fcfg&#39;</span><span class="p">:</span> <span class="s">&#39;fcfg&#39;</span><span class="p">,</span>
    <span class="s">&#39;fol&#39;</span><span class="p">:</span> <span class="s">&#39;fol&#39;</span><span class="p">,</span>
    <span class="s">&#39;logic&#39;</span><span class="p">:</span> <span class="s">&#39;logic&#39;</span><span class="p">,</span>
    <span class="s">&#39;val&#39;</span><span class="p">:</span> <span class="s">&#39;val&#39;</span><span class="p">}</span>

<div class="viewcode-block" id="load"><a class="viewcode-back" href="../../api/nltk.html#nltk.data.load">[docs]</a><span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="n">resource_url</span><span class="p">,</span> <span class="n">format</span><span class="o">=</span><span class="s">&#39;auto&#39;</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> 
         <span class="n">logic_parser</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">fstruct_parser</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Load a given resource from the NLTK data package.  The following</span>
<span class="sd">    resource formats are currently supported:</span>
<span class="sd">      - C{&#39;pickle&#39;}</span>
<span class="sd">      - C{&#39;yaml&#39;}</span>
<span class="sd">      - C{&#39;cfg&#39;} (context free grammars)</span>
<span class="sd">      - C{&#39;pcfg&#39;} (probabilistic CFGs)</span>
<span class="sd">      - C{&#39;fcfg&#39;} (feature-based CFGs)</span>
<span class="sd">      - C{&#39;fol&#39;} (formulas of First Order Logic)</span>
<span class="sd">      - C{&#39;logic&#39;} (Logical formulas to be parsed by the given logic_parser)</span>
<span class="sd">      - C{&#39;val&#39;} (valuation of First Order Logic model)</span>
<span class="sd">      - C{&#39;raw&#39;}</span>

<span class="sd">    If no format is specified, C{load()} will attempt to determine a</span>
<span class="sd">    format based on the resource name&#39;s file extension.  If that</span>
<span class="sd">    fails, C{load()} will raise a C{ValueError} exception.</span>

<span class="sd">    @type resource_url: C{str}</span>
<span class="sd">    @param resource_url: A URL specifying where the resource should be</span>
<span class="sd">        loaded from.  The default protocol is C{&quot;nltk:&quot;}, which searches</span>
<span class="sd">        for the file in the the NLTK data package.</span>
<span class="sd">    @type cache: C{bool}</span>
<span class="sd">    @param cache: If true, add this resource to a cache.  If C{load}</span>
<span class="sd">        finds a resource in its cache, then it will return it from the</span>
<span class="sd">        cache rather than loading it.  The cache uses weak references,</span>
<span class="sd">        so a resource wil automatically be expunged from the cache</span>
<span class="sd">        when no more objects are using it.</span>
<span class="sd">        </span>
<span class="sd">    @type verbose: C{bool}</span>
<span class="sd">    @param verbose: If true, print a message when loading a resource.</span>
<span class="sd">        Messages are not displayed when a resource is retrieved from</span>
<span class="sd">        the cache.</span>
<span class="sd">    </span>
<span class="sd">    @type logic_parser: C{LogicParser}</span>
<span class="sd">    @param logic_parser: The parser that will be used to parse logical </span>
<span class="sd">    expressions.</span>
<span class="sd">    @type fstruct_parser: C{FeatStructParser}</span>
<span class="sd">    @param fstruct_parser: The parser that will be used to parse the</span>
<span class="sd">    feature structure of an fcfg.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># If we&#39;ve cached the resource, then just return it.</span>
    <span class="k">if</span> <span class="n">cache</span><span class="p">:</span>
        <span class="n">resource_val</span> <span class="o">=</span> <span class="n">_resource_cache</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">resource_url</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">resource_val</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="k">print</span> <span class="s">&#39;&lt;&lt;Using cached copy of </span><span class="si">%s</span><span class="s">&gt;&gt;&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">resource_url</span><span class="p">,)</span>
            <span class="k">return</span> <span class="n">resource_val</span>
    
    <span class="c"># Let the user know what&#39;s going on.</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">&#39;&lt;&lt;Loading </span><span class="si">%s</span><span class="s">&gt;&gt;&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">resource_url</span><span class="p">,)</span>

    <span class="c"># Determine the format of the resource.</span>
    <span class="k">if</span> <span class="n">format</span> <span class="o">==</span> <span class="s">&#39;auto&#39;</span><span class="p">:</span>
        <span class="n">resource_url_parts</span> <span class="o">=</span> <span class="n">resource_url</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;.&#39;</span><span class="p">)</span>
        <span class="n">ext</span> <span class="o">=</span> <span class="n">resource_url_parts</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">ext</span> <span class="o">==</span> <span class="s">&#39;gz&#39;</span><span class="p">:</span>
            <span class="n">ext</span> <span class="o">=</span> <span class="n">resource_url_parts</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">format</span> <span class="o">=</span> <span class="n">AUTO_FORMATS</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">ext</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">format</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Could not determine format for </span><span class="si">%s</span><span class="s"> based &#39;</span>
                             <span class="s">&#39;on its file</span><span class="se">\n</span><span class="s">extension; use the &quot;format&quot; &#39;</span>
                             <span class="s">&#39;argument to specify the format explicitly.&#39;</span>
                             <span class="o">%</span> <span class="n">resource_url</span><span class="p">)</span>
    
    <span class="c"># Load the resource.</span>
    <span class="k">if</span> <span class="n">format</span> <span class="o">==</span> <span class="s">&#39;pickle&#39;</span><span class="p">:</span>
        <span class="n">resource_val</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">_open</span><span class="p">(</span><span class="n">resource_url</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">format</span> <span class="o">==</span> <span class="s">&#39;yaml&#39;</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">yaml</span>
        <span class="n">resource_val</span> <span class="o">=</span> <span class="n">yaml</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">_open</span><span class="p">(</span><span class="n">resource_url</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">format</span> <span class="o">==</span> <span class="s">&#39;cfg&#39;</span><span class="p">:</span>
        <span class="n">resource_val</span> <span class="o">=</span> <span class="n">nltk</span><span class="o">.</span><span class="n">grammar</span><span class="o">.</span><span class="n">parse_cfg</span><span class="p">(</span><span class="n">_open</span><span class="p">(</span><span class="n">resource_url</span><span class="p">)</span><span class="o">.</span><span class="n">read</span><span class="p">())</span>
    <span class="k">elif</span> <span class="n">format</span> <span class="o">==</span> <span class="s">&#39;pcfg&#39;</span><span class="p">:</span>
        <span class="n">resource_val</span> <span class="o">=</span> <span class="n">nltk</span><span class="o">.</span><span class="n">grammar</span><span class="o">.</span><span class="n">parse_pcfg</span><span class="p">(</span><span class="n">_open</span><span class="p">(</span><span class="n">resource_url</span><span class="p">)</span><span class="o">.</span><span class="n">read</span><span class="p">())</span>
    <span class="k">elif</span> <span class="n">format</span> <span class="o">==</span> <span class="s">&#39;fcfg&#39;</span><span class="p">:</span>
        <span class="n">resource_val</span> <span class="o">=</span> <span class="n">nltk</span><span class="o">.</span><span class="n">grammar</span><span class="o">.</span><span class="n">parse_fcfg</span><span class="p">(</span><span class="n">_open</span><span class="p">(</span><span class="n">resource_url</span><span class="p">)</span><span class="o">.</span><span class="n">read</span><span class="p">(),</span> 
                                      <span class="n">logic_parser</span><span class="o">=</span><span class="n">logic_parser</span><span class="p">,</span> 
                                      <span class="n">fstruct_parser</span><span class="o">=</span><span class="n">fstruct_parser</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">format</span> <span class="o">==</span> <span class="s">&#39;fol&#39;</span><span class="p">:</span>
        <span class="n">resource_val</span> <span class="o">=</span> <span class="n">nltk</span><span class="o">.</span><span class="n">sem</span><span class="o">.</span><span class="n">parse_logic</span><span class="p">(</span><span class="n">_open</span><span class="p">(</span><span class="n">resource_url</span><span class="p">)</span><span class="o">.</span><span class="n">read</span><span class="p">(),</span> 
                                       <span class="n">logic_parser</span><span class="o">=</span><span class="n">nltk</span><span class="o">.</span><span class="n">sem</span><span class="o">.</span><span class="n">logic</span><span class="o">.</span><span class="n">LogicParser</span><span class="p">())</span>
    <span class="k">elif</span> <span class="n">format</span> <span class="o">==</span> <span class="s">&#39;logic&#39;</span><span class="p">:</span>
        <span class="n">resource_val</span> <span class="o">=</span> <span class="n">nltk</span><span class="o">.</span><span class="n">sem</span><span class="o">.</span><span class="n">parse_logic</span><span class="p">(</span><span class="n">_open</span><span class="p">(</span><span class="n">resource_url</span><span class="p">)</span><span class="o">.</span><span class="n">read</span><span class="p">(),</span>
                                       <span class="n">logic_parser</span><span class="o">=</span><span class="n">logic_parser</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">format</span> <span class="o">==</span> <span class="s">&#39;val&#39;</span><span class="p">:</span>
        <span class="n">resource_val</span> <span class="o">=</span> <span class="n">nltk</span><span class="o">.</span><span class="n">sem</span><span class="o">.</span><span class="n">parse_valuation</span><span class="p">(</span><span class="n">_open</span><span class="p">(</span><span class="n">resource_url</span><span class="p">)</span><span class="o">.</span><span class="n">read</span><span class="p">())</span>
    <span class="k">elif</span> <span class="n">format</span> <span class="o">==</span> <span class="s">&#39;raw&#39;</span><span class="p">:</span>
        <span class="n">resource_val</span> <span class="o">=</span> <span class="n">_open</span><span class="p">(</span><span class="n">resource_url</span><span class="p">)</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">format</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">FORMATS</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Unknown format type!&#39;</span><span class="p">)</span>

    <span class="c"># If requested, add it to the cache.</span>
    <span class="k">if</span> <span class="n">cache</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">_resource_cache</span><span class="p">[</span><span class="n">resource_url</span><span class="p">]</span> <span class="o">=</span> <span class="n">resource_val</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="c"># We can&#39;t create weak references to some object types, like</span>
            <span class="c"># strings and tuples.  For now, just don&#39;t cache them.</span>
            <span class="k">pass</span>
    
    <span class="k">return</span> <span class="n">resource_val</span>
</div>
<div class="viewcode-block" id="show_cfg"><a class="viewcode-back" href="../../api/nltk.html#nltk.data.show_cfg">[docs]</a><span class="k">def</span> <span class="nf">show_cfg</span><span class="p">(</span><span class="n">resource_url</span><span class="p">,</span> <span class="n">escape</span><span class="o">=</span><span class="s">&#39;##&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Write out a grammar file, ignoring escaped and empty lines</span>
<span class="sd">    @type resource_url: C{str}</span>
<span class="sd">    @param resource_url: A URL specifying where the resource should be</span>
<span class="sd">        loaded from.  The default protocol is C{&quot;nltk:&quot;}, which searches</span>
<span class="sd">        for the file in the the NLTK data package.</span>
<span class="sd">    @type escape: C{str}</span>
<span class="sd">    @param escape: Prepended string that signals lines to be ignored</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">resource_val</span> <span class="o">=</span> <span class="n">load</span><span class="p">(</span><span class="n">resource_url</span><span class="p">,</span> <span class="n">format</span><span class="o">=</span><span class="s">&#39;raw&#39;</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
    <span class="n">lines</span> <span class="o">=</span> <span class="n">resource_val</span><span class="o">.</span><span class="n">splitlines</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">l</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">escape</span><span class="p">):</span> <span class="k">continue</span>
        <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s">&#39;^$&#39;</span><span class="p">,</span> <span class="n">l</span><span class="p">):</span> <span class="k">continue</span>
        <span class="k">print</span> <span class="n">l</span>

    </div>
<div class="viewcode-block" id="clear_cache"><a class="viewcode-back" href="../../api/nltk.html#nltk.data.clear_cache">[docs]</a><span class="k">def</span> <span class="nf">clear_cache</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Remove all objects from the resource cache.</span>
<span class="sd">    @see: L{load()}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_resource_cache</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
</div>
<span class="k">def</span> <span class="nf">_open</span><span class="p">(</span><span class="n">resource_url</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Helper function that returns an open file object for a resource,</span>
<span class="sd">    given its resource URL.  If the given resource URL uses the &#39;ntlk&#39;</span>
<span class="sd">    protocol, or uses no protocol, then use L{nltk.data.find} to find</span>
<span class="sd">    its path, and open it with the given mode; if the resource URL</span>
<span class="sd">    uses the &#39;file&#39; protocol, then open the file with the given mode;</span>
<span class="sd">    otherwise, delegate to C{urllib2.urlopen}.</span>
<span class="sd">    </span>
<span class="sd">    @type resource_url: C{str}</span>
<span class="sd">    @param resource_url: A URL specifying where the resource should be</span>
<span class="sd">        loaded from.  The default protocol is C{&quot;nltk:&quot;}, which searches</span>
<span class="sd">        for the file in the the NLTK data package.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># Divide the resource name into &quot;&lt;protocol&gt;:&lt;path&gt;&quot;.</span>
    <span class="n">protocol</span><span class="p">,</span> <span class="n">path</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s">&#39;(?:(\w+):)?(.*)&#39;</span><span class="p">,</span> <span class="n">resource_url</span><span class="p">)</span><span class="o">.</span><span class="n">groups</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">protocol</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">protocol</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s">&#39;nltk&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">find</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="o">.</span><span class="n">open</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">protocol</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s">&#39;file&#39;</span><span class="p">:</span>
        <span class="c"># urllib might not use mode=&#39;rb&#39;, so handle this one ourselves:</span>
        <span class="k">return</span> <span class="nb">open</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s">&#39;rb&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">urllib2</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="n">resource_url</span><span class="p">)</span>

<span class="c">######################################################################</span>
<span class="c"># Lazy Resource Loader</span>
<span class="c">######################################################################</span>

<div class="viewcode-block" id="LazyLoader"><a class="viewcode-back" href="../../api/nltk.html#nltk.data.LazyLoader">[docs]</a><span class="k">class</span> <span class="nc">LazyLoader</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__path</span> <span class="o">=</span> <span class="n">path</span>

    <span class="k">def</span> <span class="nf">__load</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">resource</span> <span class="o">=</span> <span class="n">load</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__path</span><span class="p">)</span>
        <span class="c"># This is where the magic happens!  Transform ourselves into</span>
        <span class="c"># the object by modifying our own __dict__ and __class__ to</span>
        <span class="c"># match that of `resource`.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span> <span class="o">=</span> <span class="n">resource</span><span class="o">.</span><span class="n">__dict__</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span> <span class="o">=</span> <span class="n">resource</span><span class="o">.</span><span class="n">__class__</span>
        
    <span class="k">def</span> <span class="nf">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__load</span><span class="p">()</span>
        <span class="c"># This looks circular, but its not, since __load() changes our</span>
        <span class="c"># __class__ to something new:</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__load</span><span class="p">()</span>
        <span class="c"># This looks circular, but its not, since __load() changes our</span>
        <span class="c"># __class__ to something new:</span>
        <span class="k">return</span> <span class="s">&#39;</span><span class="si">%r</span><span class="s">&#39;</span> <span class="o">%</span> <span class="bp">self</span>

<span class="c">######################################################################</span>
<span class="c"># Open-On-Demand ZipFile</span>
<span class="c">######################################################################</span>
</div>
<div class="viewcode-block" id="OpenOnDemandZipFile"><a class="viewcode-back" href="../../api/nltk.html#nltk.data.OpenOnDemandZipFile">[docs]</a><span class="k">class</span> <span class="nc">OpenOnDemandZipFile</span><span class="p">(</span><span class="n">zipfile</span><span class="o">.</span><span class="n">ZipFile</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A subclass of C{zipfile.ZipFile} that closes its file pointer</span>
<span class="sd">    whenever it is not using it; and re-opens it when it needs to read</span>
<span class="sd">    data from the zipfile.  This is useful for reducing the number of</span>
<span class="sd">    open file handles when many zip files are being accessed at once.</span>
<span class="sd">    C{OpenOnDemandZipFile} must be constructed from a filename, not a</span>
<span class="sd">    file-like object (to allow re-opening).  C{OpenOnDemandZipFile} is</span>
<span class="sd">    read-only (i.e., C{write} and C{writestr} are disabled.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;ReopenableZipFile filename must be a string&#39;</span><span class="p">)</span>
        <span class="n">zipfile</span><span class="o">.</span><span class="n">ZipFile</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">filename</span> <span class="o">==</span> <span class="n">filename</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        
<div class="viewcode-block" id="OpenOnDemandZipFile.read"><a class="viewcode-back" href="../../api/nltk.html#nltk.data.OpenOnDemandZipFile.read">[docs]</a>    <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">fp</span> <span class="ow">is</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fp</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">,</span> <span class="s">&#39;rb&#39;</span><span class="p">)</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">zipfile</span><span class="o">.</span><span class="n">ZipFile</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">value</span>
</div>
<div class="viewcode-block" id="OpenOnDemandZipFile.write"><a class="viewcode-back" href="../../api/nltk.html#nltk.data.OpenOnDemandZipFile.write">[docs]</a>    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;@raise NotImplementedError: OpenOnDemandZipfile is read-only&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&#39;OpenOnDemandZipfile is read-only&#39;</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="OpenOnDemandZipFile.writestr"><a class="viewcode-back" href="../../api/nltk.html#nltk.data.OpenOnDemandZipFile.writestr">[docs]</a>    <span class="k">def</span> <span class="nf">writestr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;@raise NotImplementedError: OpenOnDemandZipfile is read-only&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&#39;OpenOnDemandZipfile is read-only&#39;</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&#39;OpenOnDemandZipFile(</span><span class="si">%r</span><span class="s">)&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">filename</span>

<span class="c">######################################################################</span>
<span class="c">#{ Seekable Unicode Stream Reader</span>
<span class="c">######################################################################</span>
</div>
<div class="viewcode-block" id="SeekableUnicodeStreamReader"><a class="viewcode-back" href="../../api/nltk.html#nltk.data.SeekableUnicodeStreamReader">[docs]</a><span class="k">class</span> <span class="nc">SeekableUnicodeStreamReader</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A stream reader that automatically encodes the source byte stream</span>
<span class="sd">    into unicode (like C{codecs.StreamReader}); but still supports the</span>
<span class="sd">    C{seek()} and C{tell()} operations correctly.  This is in contrast</span>
<span class="sd">    to C{codecs.StreamReader}, which provide *broken* C{seek()} and</span>
<span class="sd">    C{tell()} methods.</span>

<span class="sd">    This class was motivated by L{StreamBackedCorpusView}, which</span>
<span class="sd">    makes extensive use of C{seek()} and C{tell()}, and needs to be</span>
<span class="sd">    able to handle unicode-encoded files.</span>
<span class="sd">    </span>
<span class="sd">    Note: this class requires stateless decoders.  To my knowledge,</span>
<span class="sd">    this shouldn&#39;t cause a problem with any of python&#39;s builtin</span>
<span class="sd">    unicode encodings.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">DEBUG</span> <span class="o">=</span> <span class="bp">True</span> <span class="c">#: If true, then perform extra sanity checks.</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stream</span><span class="p">,</span> <span class="n">encoding</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="s">&#39;strict&#39;</span><span class="p">):</span>
        <span class="c"># Rewind the stream to its beginning.</span>
        <span class="n">stream</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">stream</span> <span class="o">=</span> <span class="n">stream</span>
        <span class="sd">&quot;&quot;&quot;The underlying stream.&quot;&quot;&quot;</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">encoding</span> <span class="o">=</span> <span class="n">encoding</span>
        <span class="sd">&quot;&quot;&quot;The name of the encoding that should be used to encode the</span>
<span class="sd">           underlying stream.&quot;&quot;&quot;</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">errors</span> <span class="o">=</span> <span class="n">errors</span>
        <span class="sd">&quot;&quot;&quot;The error mode that should be used when decoding data from</span>
<span class="sd">           the underlying stream.  Can be &#39;strict&#39;, &#39;ignore&#39;, or</span>
<span class="sd">           &#39;replace&#39;.&quot;&quot;&quot;</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">decode</span> <span class="o">=</span> <span class="n">codecs</span><span class="o">.</span><span class="n">getdecoder</span><span class="p">(</span><span class="n">encoding</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot;The function that is used to decode byte strings into</span>
<span class="sd">           unicode strings.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">bytebuffer</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
        <span class="sd">&quot;&quot;&quot;A buffer to use bytes that have been read but have not yet</span>
<span class="sd">           been decoded.  This is only used when the final bytes from</span>
<span class="sd">           a read do not form a complete encoding for a character.&quot;&quot;&quot;</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">linebuffer</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="sd">&quot;&quot;&quot;A buffer used by L{readline()} to hold characters that have</span>
<span class="sd">           been read, but have not yet been returned by L{read()} or</span>
<span class="sd">           L{readline()}.  This buffer consists of a list of unicode</span>
<span class="sd">           strings, where each string corresponds to a single line.</span>
<span class="sd">           The final element of the list may or may not be a complete</span>
<span class="sd">           line.  Note that the existence of a linebuffer makes the</span>
<span class="sd">           L{tell()} operation more complex, because it must backtrack</span>
<span class="sd">           to the beginning of the buffer to determine the correct</span>
<span class="sd">           file position in the underlying byte stream.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_rewind_checkpoint</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="sd">&quot;&quot;&quot;The file position at which the most recent read on the</span>
<span class="sd">           underlying stream began.  This is used, together with</span>
<span class="sd">           L{_rewind_numchars}, to backtrack to the beginning of</span>
<span class="sd">           L{linebuffer} (which is required by L{tell()}).&quot;&quot;&quot;</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">_rewind_numchars</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="sd">&quot;&quot;&quot;The number of characters that have been returned since the</span>
<span class="sd">           read that started at L{_rewind_checkpoint}.  This is used,</span>
<span class="sd">           together with L{_rewind_checkpoint}, to backtrack to the</span>
<span class="sd">           beginning of L{linebuffer} (which is required by</span>
<span class="sd">           L{tell()}).&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_bom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_bom</span><span class="p">()</span>
        <span class="sd">&quot;&quot;&quot;The length of the byte order marker at the beginning of</span>
<span class="sd">           the stream (or C{None} for no byte order marker).&quot;&quot;&quot;</span>

    <span class="c">#/////////////////////////////////////////////////////////////////</span>
    <span class="c"># Read methods</span>
    <span class="c">#/////////////////////////////////////////////////////////////////</span>
    
<div class="viewcode-block" id="SeekableUnicodeStreamReader.read"><a class="viewcode-back" href="../../api/nltk.html#nltk.data.SeekableUnicodeStreamReader.read">[docs]</a>    <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Read up to C{size} bytes, decode them using this reader&#39;s</span>
<span class="sd">        encoding, and return the resulting unicode string.</span>

<span class="sd">        @param size: The maximum number of bytes to read.  If not</span>
<span class="sd">            specified, then read as many bytes as possible.</span>

<span class="sd">        @rtype: C{unicode}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">chars</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>

        <span class="c"># If linebuffer is not empty, then include it in the result</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">linebuffer</span><span class="p">:</span>
            <span class="n">chars</span> <span class="o">=</span> <span class="s">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">linebuffer</span><span class="p">)</span> <span class="o">+</span> <span class="n">chars</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">linebuffer</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_rewind_numchars</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="k">return</span> <span class="n">chars</span>
</div>
<div class="viewcode-block" id="SeekableUnicodeStreamReader.readline"><a class="viewcode-back" href="../../api/nltk.html#nltk.data.SeekableUnicodeStreamReader.readline">[docs]</a>    <span class="k">def</span> <span class="nf">readline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Read a line of text, decode it using this reader&#39;s encoding,</span>
<span class="sd">        and return the resulting unicode string.</span>

<span class="sd">        @param size: The maximum number of bytes to read.  If no</span>
<span class="sd">            newline is encountered before C{size} bytes have been</span>
<span class="sd">            read, then the returned value may not be a complete line</span>
<span class="sd">            of text.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># If we have a non-empty linebuffer, then return the first</span>
        <span class="c"># line from it.  (Note that the last element of linebuffer may</span>
        <span class="c"># not be a complete line; so let _read() deal with it.)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">linebuffer</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">linebuffer</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">line</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">linebuffer</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_rewind_numchars</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">line</span>
        
        <span class="n">readsize</span> <span class="o">=</span> <span class="n">size</span> <span class="ow">or</span> <span class="mi">72</span>
        <span class="n">chars</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>

        <span class="c"># If there&#39;s a remaining incomplete line in the buffer, add it.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">linebuffer</span><span class="p">:</span>
            <span class="n">chars</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">linebuffer</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">linebuffer</span> <span class="o">=</span> <span class="bp">None</span>
        
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="n">startpos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stream</span><span class="o">.</span><span class="n">tell</span><span class="p">()</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bytebuffer</span><span class="p">)</span>
            <span class="n">new_chars</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read</span><span class="p">(</span><span class="n">readsize</span><span class="p">)</span>

            <span class="c"># If we&#39;re at a &#39;\r&#39;, then read one extra character, since</span>
            <span class="c"># it might be a &#39;\n&#39;, to get the proper line ending.  </span>
            <span class="k">if</span> <span class="n">new_chars</span> <span class="ow">and</span> <span class="n">new_chars</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\r</span><span class="s">&#39;</span><span class="p">):</span>
                <span class="n">new_chars</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

            <span class="n">chars</span> <span class="o">+=</span> <span class="n">new_chars</span>
            <span class="n">lines</span> <span class="o">=</span> <span class="n">chars</span><span class="o">.</span><span class="n">splitlines</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">line</span> <span class="o">=</span> <span class="n">lines</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">linebuffer</span> <span class="o">=</span> <span class="n">lines</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_rewind_numchars</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_chars</span><span class="p">)</span><span class="o">-</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">chars</span><span class="p">)</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">line</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_rewind_checkpoint</span> <span class="o">=</span> <span class="n">startpos</span>
                <span class="k">break</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">line0withend</span> <span class="o">=</span> <span class="n">lines</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">line0withoutend</span> <span class="o">=</span> <span class="n">lines</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">splitlines</span><span class="p">(</span><span class="bp">False</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">line0withend</span> <span class="o">!=</span> <span class="n">line0withoutend</span><span class="p">:</span> <span class="c"># complete line</span>
                    <span class="n">line</span> <span class="o">=</span> <span class="n">line0withend</span>
                    <span class="k">break</span>
                
            <span class="k">if</span> <span class="ow">not</span> <span class="n">new_chars</span> <span class="ow">or</span> <span class="n">size</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">line</span> <span class="o">=</span> <span class="n">chars</span>
                <span class="k">break</span>

            <span class="c"># Read successively larger blocks of text.</span>
            <span class="k">if</span> <span class="n">readsize</span> <span class="o">&lt;</span> <span class="mi">8000</span><span class="p">:</span>
                <span class="n">readsize</span> <span class="o">*=</span> <span class="mi">2</span>

        <span class="k">return</span> <span class="n">line</span>
</div>
<div class="viewcode-block" id="SeekableUnicodeStreamReader.readlines"><a class="viewcode-back" href="../../api/nltk.html#nltk.data.SeekableUnicodeStreamReader.readlines">[docs]</a>    <span class="k">def</span> <span class="nf">readlines</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sizehint</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">keepends</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Read this file&#39;s contents, decode them using this reader&#39;s</span>
<span class="sd">        encoding, and return it as a list of unicode lines.</span>

<span class="sd">        @rtype: C{list} of C{unicode}</span>
<span class="sd">        @param sizehint: Ignored.</span>
<span class="sd">        @param keepends: If false, then strip newlines.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">splitlines</span><span class="p">(</span><span class="n">keepends</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="SeekableUnicodeStreamReader.next"><a class="viewcode-back" href="../../api/nltk.html#nltk.data.SeekableUnicodeStreamReader.next">[docs]</a>    <span class="k">def</span> <span class="nf">next</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the next decoded line from the underlying stream.&quot;&quot;&quot;</span>
        <span class="n">line</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">line</span><span class="p">:</span> <span class="k">return</span> <span class="n">line</span>
        <span class="k">else</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">StopIteration</span>
</div>
    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return self&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span>

<div class="viewcode-block" id="SeekableUnicodeStreamReader.xreadlines"><a class="viewcode-back" href="../../api/nltk.html#nltk.data.SeekableUnicodeStreamReader.xreadlines">[docs]</a>    <span class="k">def</span> <span class="nf">xreadlines</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return self&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="c">#/////////////////////////////////////////////////////////////////</span>
    <span class="c"># Pass-through methods &amp; properties</span>
    <span class="c">#/////////////////////////////////////////////////////////////////</span>
    </div>
    <span class="n">closed</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="bp">self</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">stream</span><span class="o">.</span><span class="n">closed</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;</span>
<span class="s">        True if the underlying stream is closed.&quot;&quot;&quot;</span><span class="p">)</span>

    <span class="n">name</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="bp">self</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">stream</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;</span>
<span class="s">        The name of the underlying stream.&quot;&quot;&quot;</span><span class="p">)</span>

    <span class="n">mode</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="bp">self</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">stream</span><span class="o">.</span><span class="n">mode</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;</span>
<span class="s">        The mode of the underlying stream.&quot;&quot;&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="SeekableUnicodeStreamReader.close"><a class="viewcode-back" href="../../api/nltk.html#nltk.data.SeekableUnicodeStreamReader.close">[docs]</a>    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Close the underlying stream.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stream</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="c">#/////////////////////////////////////////////////////////////////</span>
    <span class="c"># Seek and tell</span>
    <span class="c">#/////////////////////////////////////////////////////////////////</span>
    </div>
<div class="viewcode-block" id="SeekableUnicodeStreamReader.seek"><a class="viewcode-back" href="../../api/nltk.html#nltk.data.SeekableUnicodeStreamReader.seek">[docs]</a>    <span class="k">def</span> <span class="nf">seek</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">whence</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Move the stream to a new file position.  If the reader is</span>
<span class="sd">        maintaining any buffers, tehn they will be cleared.</span>

<span class="sd">        @param offset: A byte count offset.</span>
<span class="sd">        @param whence: If C{whence} is 0, then the offset is from the</span>
<span class="sd">            start of the file (offset should be positive).  If</span>
<span class="sd">            C{whence} is 1, then the offset is from the current</span>
<span class="sd">            position (offset may be positive or negative); and if 2,</span>
<span class="sd">            then the offset is from the end of the file (offset should</span>
<span class="sd">            typically be negative).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">whence</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Relative seek is not supported for &#39;</span>
                             <span class="s">&#39;SeekableUnicodeStreamReader -- consider &#39;</span>
                             <span class="s">&#39;using char_seek_forward() instead.&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stream</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="n">whence</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">linebuffer</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bytebuffer</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_rewind_numchars</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_rewind_checkpoint</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stream</span><span class="o">.</span><span class="n">tell</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="SeekableUnicodeStreamReader.char_seek_forward"><a class="viewcode-back" href="../../api/nltk.html#nltk.data.SeekableUnicodeStreamReader.char_seek_forward">[docs]</a>    <span class="k">def</span> <span class="nf">char_seek_forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">offset</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Move the read pointer forward by C{offset} characters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">offset</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Negative offsets are not supported&#39;</span><span class="p">)</span>
        <span class="c"># Clear all buffers.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tell</span><span class="p">())</span>
        <span class="c"># Perform the seek operation.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_char_seek_forward</span><span class="p">(</span><span class="n">offset</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">_char_seek_forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">est_bytes</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Move the file position forward by C{offset} characters,</span>
<span class="sd">        ignoring all buffers.</span>

<span class="sd">        @param est_bytes: A hint, giving an estimate of the number of</span>
<span class="sd">            bytes that will be neded to move foward by C{offset} chars.</span>
<span class="sd">            Defaults to C{offset}.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">est_bytes</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span> <span class="n">est_bytes</span> <span class="o">=</span> <span class="n">offset</span>
        <span class="nb">bytes</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>

        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="c"># Read in a block of bytes.</span>
            <span class="n">newbytes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stream</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">est_bytes</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="nb">bytes</span><span class="p">))</span>
            <span class="nb">bytes</span> <span class="o">+=</span> <span class="n">newbytes</span>
                
            <span class="c"># Decode the bytes to characters.</span>
            <span class="n">chars</span><span class="p">,</span> <span class="n">bytes_decoded</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_incr_decode</span><span class="p">(</span><span class="nb">bytes</span><span class="p">)</span>

            <span class="c"># If we got the right number of characters, then seek</span>
            <span class="c"># backwards over any truncated characters, and return.</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">chars</span><span class="p">)</span> <span class="o">==</span> <span class="n">offset</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">stream</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="nb">bytes</span><span class="p">)</span><span class="o">+</span><span class="n">bytes_decoded</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                <span class="k">return</span>

            <span class="c"># If we went too far, then we can back-up until we get it</span>
            <span class="c"># right, using the bytes we&#39;ve already read.</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">chars</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">offset</span><span class="p">:</span>
                <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">chars</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">offset</span><span class="p">:</span>
                    <span class="c"># Assume at least one byte/char.</span>
                    <span class="n">est_bytes</span> <span class="o">+=</span> <span class="n">offset</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">chars</span><span class="p">)</span>
                    <span class="n">chars</span><span class="p">,</span> <span class="n">bytes_decoded</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_incr_decode</span><span class="p">(</span><span class="nb">bytes</span><span class="p">[:</span><span class="n">est_bytes</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">stream</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="nb">bytes</span><span class="p">)</span><span class="o">+</span><span class="n">bytes_decoded</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                <span class="k">return</span>

            <span class="c"># Otherwise, we haven&#39;t read enough bytes yet; loop again.</span>
            <span class="n">est_bytes</span> <span class="o">+=</span> <span class="n">offset</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">chars</span><span class="p">)</span>

<div class="viewcode-block" id="SeekableUnicodeStreamReader.tell"><a class="viewcode-back" href="../../api/nltk.html#nltk.data.SeekableUnicodeStreamReader.tell">[docs]</a>    <span class="k">def</span> <span class="nf">tell</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the current file position on the underlying byte</span>
<span class="sd">        stream.  If this reader is maintaining any buffers, then the</span>
<span class="sd">        returned file position will be the position of the beginning</span>
<span class="sd">        of those buffers.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># If nothing&#39;s buffered, then just return our current filepos:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">linebuffer</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">stream</span><span class="o">.</span><span class="n">tell</span><span class="p">()</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bytebuffer</span><span class="p">)</span>

        <span class="c"># Otherwise, we&#39;ll need to backtrack the filepos until we</span>
        <span class="c"># reach the beginning of the buffer.</span>
        
        <span class="c"># Store our original file position, so we can return here.</span>
        <span class="n">orig_filepos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stream</span><span class="o">.</span><span class="n">tell</span><span class="p">()</span>

        <span class="c"># Calculate an estimate of where we think the newline is.</span>
        <span class="n">bytes_read</span> <span class="o">=</span> <span class="p">(</span> <span class="p">(</span><span class="n">orig_filepos</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bytebuffer</span><span class="p">))</span> <span class="o">-</span>
                       <span class="bp">self</span><span class="o">.</span><span class="n">_rewind_checkpoint</span> <span class="p">)</span>
        <span class="n">buf_size</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">line</span><span class="p">)</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">linebuffer</span><span class="p">])</span>
        <span class="n">est_bytes</span> <span class="o">=</span> <span class="p">(</span><span class="n">bytes_read</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rewind_numchars</span> <span class="o">/</span>
                     <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_rewind_numchars</span> <span class="o">+</span> <span class="n">buf_size</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">stream</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_rewind_checkpoint</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_char_seek_forward</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_rewind_numchars</span><span class="p">,</span> <span class="n">est_bytes</span><span class="p">)</span>
        <span class="n">filepos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stream</span><span class="o">.</span><span class="n">tell</span><span class="p">()</span>

        <span class="c"># Sanity check</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stream</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="n">filepos</span><span class="p">)</span>
            <span class="n">check1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_incr_decode</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stream</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">50</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">check2</span> <span class="o">=</span> <span class="s">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">linebuffer</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">check1</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">check2</span><span class="p">)</span> <span class="ow">or</span> <span class="n">check2</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">check1</span><span class="p">)</span>

        <span class="c"># Return to our original filepos (so we don&#39;t have to throw</span>
        <span class="c"># out our buffer.)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stream</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="n">orig_filepos</span><span class="p">)</span>

        <span class="c"># Return the calculated filepos</span>
        <span class="k">return</span> <span class="n">filepos</span>

    <span class="c">#/////////////////////////////////////////////////////////////////</span>
    <span class="c"># Helper methods</span>
    <span class="c">#/////////////////////////////////////////////////////////////////</span>
    </div>
    <span class="k">def</span> <span class="nf">_read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Read up to C{size} bytes from the underlying stream, decode</span>
<span class="sd">        them using this reader&#39;s encoding, and return the resulting</span>
<span class="sd">        unicode string.  C{linebuffer} is *not* included in the</span>
<span class="sd">        result.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="s">u&#39;&#39;</span>
        
        <span class="c"># Skip past the byte order marker, if present.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bom</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">stream</span><span class="o">.</span><span class="n">tell</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stream</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_bom</span><span class="p">)</span>
        
        <span class="c"># Read the requested number of bytes.</span>
        <span class="k">if</span> <span class="n">size</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">new_bytes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stream</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_bytes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stream</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
        <span class="nb">bytes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bytebuffer</span> <span class="o">+</span> <span class="n">new_bytes</span>

        <span class="c"># Decode the bytes into unicode characters</span>
        <span class="n">chars</span><span class="p">,</span> <span class="n">bytes_decoded</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_incr_decode</span><span class="p">(</span><span class="nb">bytes</span><span class="p">)</span>
        
        <span class="c"># If we got bytes but couldn&#39;t decode any, then read further.</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">chars</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">new_bytes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">while</span> <span class="ow">not</span> <span class="n">chars</span><span class="p">:</span>
                <span class="n">new_bytes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stream</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">new_bytes</span><span class="p">:</span> <span class="k">break</span> <span class="c"># end of file.</span>
                <span class="nb">bytes</span> <span class="o">+=</span> <span class="n">new_bytes</span>
                <span class="n">chars</span><span class="p">,</span> <span class="n">bytes_decoded</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_incr_decode</span><span class="p">(</span><span class="nb">bytes</span><span class="p">)</span>
        
        <span class="c"># Record any bytes we didn&#39;t consume.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bytebuffer</span> <span class="o">=</span> <span class="nb">bytes</span><span class="p">[</span><span class="n">bytes_decoded</span><span class="p">:]</span>

        <span class="c"># Return the result</span>
        <span class="k">return</span> <span class="n">chars</span>
        
    <span class="k">def</span> <span class="nf">_incr_decode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Decode the given byte string into a unicode string, using this</span>
<span class="sd">        reader&#39;s encoding.  If an exception is encountered that</span>
<span class="sd">        appears to be caused by a truncation error, then just decode</span>
<span class="sd">        the byte string without the bytes that cause the trunctaion</span>
<span class="sd">        error.</span>

<span class="sd">        @return: A tuple C{(chars, num_consumed)}, where C{chars} is</span>
<span class="sd">            the decoded unicode string, and C{num_consumed} is the</span>
<span class="sd">            number of bytes that were consumed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="nb">bytes</span><span class="p">,</span> <span class="s">&#39;strict&#39;</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">UnicodeDecodeError</span><span class="p">,</span> <span class="n">exc</span><span class="p">:</span>
                <span class="c"># If the exception occurs at the end of the string,</span>
                <span class="c"># then assume that it&#39;s a truncation error.</span>
                <span class="k">if</span> <span class="n">exc</span><span class="o">.</span><span class="n">end</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="nb">bytes</span><span class="p">):</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="nb">bytes</span><span class="p">[:</span><span class="n">exc</span><span class="o">.</span><span class="n">start</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">errors</span><span class="p">)</span>
                
                <span class="c"># Otherwise, if we&#39;re being strict, then raise it.</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">errors</span> <span class="o">==</span> <span class="s">&#39;strict&#39;</span><span class="p">:</span>
                    <span class="k">raise</span>
                
                <span class="c"># If we&#39;re not strcit, then re-process it with our</span>
                <span class="c"># errors setting.  This *may* raise an exception.</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="nb">bytes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">errors</span><span class="p">)</span>

    <span class="n">_BOM_TABLE</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s">&#39;utf8&#39;</span><span class="p">:</span> <span class="p">[(</span><span class="n">codecs</span><span class="o">.</span><span class="n">BOM_UTF8</span><span class="p">,</span> <span class="bp">None</span><span class="p">)],</span>
        <span class="s">&#39;utf16&#39;</span><span class="p">:</span> <span class="p">[(</span><span class="n">codecs</span><span class="o">.</span><span class="n">BOM_UTF16_LE</span><span class="p">,</span> <span class="s">&#39;utf16-le&#39;</span><span class="p">),</span>
                  <span class="p">(</span><span class="n">codecs</span><span class="o">.</span><span class="n">BOM_UTF16_BE</span><span class="p">,</span> <span class="s">&#39;utf16-be&#39;</span><span class="p">)],</span>
        <span class="s">&#39;utf16le&#39;</span><span class="p">:</span> <span class="p">[(</span><span class="n">codecs</span><span class="o">.</span><span class="n">BOM_UTF16_LE</span><span class="p">,</span> <span class="bp">None</span><span class="p">)],</span>
        <span class="s">&#39;utf16be&#39;</span><span class="p">:</span> <span class="p">[(</span><span class="n">codecs</span><span class="o">.</span><span class="n">BOM_UTF16_BE</span><span class="p">,</span> <span class="bp">None</span><span class="p">)],</span>
        <span class="s">&#39;utf32&#39;</span><span class="p">:</span> <span class="p">[(</span><span class="n">codecs</span><span class="o">.</span><span class="n">BOM_UTF32_LE</span><span class="p">,</span> <span class="s">&#39;utf32-le&#39;</span><span class="p">),</span>
                  <span class="p">(</span><span class="n">codecs</span><span class="o">.</span><span class="n">BOM_UTF32_BE</span><span class="p">,</span> <span class="s">&#39;utf32-be&#39;</span><span class="p">)],</span>
        <span class="s">&#39;utf32le&#39;</span><span class="p">:</span> <span class="p">[(</span><span class="n">codecs</span><span class="o">.</span><span class="n">BOM_UTF32_LE</span><span class="p">,</span> <span class="bp">None</span><span class="p">)],</span>
        <span class="s">&#39;utf32be&#39;</span><span class="p">:</span> <span class="p">[(</span><span class="n">codecs</span><span class="o">.</span><span class="n">BOM_UTF32_BE</span><span class="p">,</span> <span class="bp">None</span><span class="p">)],</span>
        <span class="p">}</span>

    <span class="k">def</span> <span class="nf">_check_bom</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># Normalize our encoding name</span>
        <span class="n">enc</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s">&#39;[ -]&#39;</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">encoding</span><span class="o">.</span><span class="n">lower</span><span class="p">())</span>
        
        <span class="c"># Look up our encoding in the BOM table.</span>
        <span class="n">bom_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_BOM_TABLE</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">enc</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">bom_info</span><span class="p">:</span>
            <span class="c"># Read a prefix, to check against the BOM(s)</span>
            <span class="nb">bytes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stream</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stream</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            
            <span class="c"># Check for each possible BOM.</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">bom</span><span class="p">,</span> <span class="n">new_encoding</span><span class="p">)</span> <span class="ow">in</span> <span class="n">bom_info</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">bytes</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">bom</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">new_encoding</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">encoding</span> <span class="o">=</span> <span class="n">new_encoding</span>
                    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">bom</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">None</span>
</div>
<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;path&#39;</span><span class="p">,</span> <span class="s">&#39;PathPointer&#39;</span><span class="p">,</span> <span class="s">&#39;FileSystemPathPointer&#39;</span><span class="p">,</span> <span class="s">&#39;BufferedGzipFile&#39;</span><span class="p">,</span>
           <span class="s">&#39;GzipFileSystemPathPointer&#39;</span><span class="p">,</span> <span class="s">&#39;GzipFileSystemPathPointer&#39;</span><span class="p">,</span>
           <span class="s">&#39;find&#39;</span><span class="p">,</span> <span class="s">&#39;retrieve&#39;</span><span class="p">,</span> <span class="s">&#39;FORMATS&#39;</span><span class="p">,</span> <span class="s">&#39;AUTO_FORMATS&#39;</span><span class="p">,</span> <span class="s">&#39;load&#39;</span><span class="p">,</span>
           <span class="s">&#39;show_cfg&#39;</span><span class="p">,</span> <span class="s">&#39;clear_cache&#39;</span><span class="p">,</span> <span class="s">&#39;LazyLoader&#39;</span><span class="p">,</span> <span class="s">&#39;OpenOnDemandZipFile&#39;</span><span class="p">,</span>
           <span class="s">&#39;GzipFileSystemPathPointer&#39;</span><span class="p">,</span> <span class="s">&#39;SeekableUnicodeStreamReader&#39;</span><span class="p">]</span>
</pre></div>

          </div>
        </div>
      </div>
        </div>
        <div class="sidebar">
          <h3>Table Of Contents</h3>
          <ul>
<li class="toctree-l1"><a class="reference internal" href="../../news.html">NLTK News</a></li>
</ul>

          <h3 style="margin-top: 1.5em;">Search</h3>
          <form class="search" action="../../search.html" method="get">
            <input type="text" name="q" />
            <input type="submit" value="Go" />
            <input type="hidden" name="check_keywords" value="yes" />
            <input type="hidden" name="area" value="default" />
          </form>
          <p class="searchtip" style="font-size: 90%">
            Enter search terms or a module, class or function name.
          </p>
        </div>
        <div class="clearer"></div>
      </div>
    </div>

    <div class="footer-wrapper">
      <div class="footer">
        <div class="left">
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |
          <a href="../../genindex.html" title="General Index"
             >index</a>
        </div>

        <div class="right">
          
    <div class="footer">
        &copy; Copyright 2011, Steven Bird.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.
    </div>
        </div>
        <div class="clearer"></div>
      </div>
    </div>

  </body>
</html>