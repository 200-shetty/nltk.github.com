<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>nltk.featstruct &mdash; NLTK 3.0 documentation</title>
    
    <link rel="stylesheet" href="../../_static/agogo.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '3.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="top" title="NLTK 3.0 documentation" href="../../index.html" />
    <link rel="up" title="Module code" href="../index.html" /> 
  </head>
  <body role="document">
    <div class="header-wrapper" role="banner">
      <div class="header">
        <div class="headertitle"><a
          href="../../index.html">NLTK 3.0 documentation</a></div>
        <div class="rel" role="navigation" aria-label="related navigation">
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a>
        </div>
       </div>
    </div>

    <div class="content-wrapper">
      <div class="content">
        <div class="document">
            
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for nltk.featstruct</h1><div class="highlight"><pre>
<span class="c"># Natural Language Toolkit: Feature Structures</span>
<span class="c">#</span>
<span class="c"># Copyright (C) 2001-2016 NLTK Project</span>
<span class="c"># Author: Edward Loper &lt;edloper@gmail.com&gt;,</span>
<span class="c">#         Rob Speer,</span>
<span class="c">#         Steven Bird &lt;stevenbird1@gmail.com&gt;</span>
<span class="c"># URL: &lt;http://nltk.sourceforge.net&gt;</span>
<span class="c"># For license information, see LICENSE.TXT</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Basic data classes for representing feature structures, and for</span>
<span class="sd">performing basic operations on those feature structures.  A feature</span>
<span class="sd">structure is a mapping from feature identifiers to feature values,</span>
<span class="sd">where each feature value is either a basic value (such as a string or</span>
<span class="sd">an integer), or a nested feature structure.  There are two types of</span>
<span class="sd">feature structure, implemented by two subclasses of ``FeatStruct``:</span>

<span class="sd">    - feature dictionaries, implemented by ``FeatDict``, act like</span>
<span class="sd">      Python dictionaries.  Feature identifiers may be strings or</span>
<span class="sd">      instances of the ``Feature`` class.</span>
<span class="sd">    - feature lists, implemented by ``FeatList``, act like Python</span>
<span class="sd">      lists.  Feature identifiers are integers.</span>

<span class="sd">Feature structures are typically used to represent partial information</span>
<span class="sd">about objects.  A feature identifier that is not mapped to a value</span>
<span class="sd">stands for a feature whose value is unknown (*not* a feature without</span>
<span class="sd">a value).  Two feature structures that represent (potentially</span>
<span class="sd">overlapping) information about the same object can be combined by</span>
<span class="sd">unification.  When two inconsistent feature structures are unified,</span>
<span class="sd">the unification fails and returns None.</span>

<span class="sd">Features can be specified using &quot;feature paths&quot;, or tuples of feature</span>
<span class="sd">identifiers that specify path through the nested feature structures to</span>
<span class="sd">a value.  Feature structures may contain reentrant feature values.  A</span>
<span class="sd">&quot;reentrant feature value&quot; is a single feature value that can be</span>
<span class="sd">accessed via multiple feature paths.  Unification preserves the</span>
<span class="sd">reentrance relations imposed by both of the unified feature</span>
<span class="sd">structures.  In the feature structure resulting from unification, any</span>
<span class="sd">modifications to a reentrant feature value will be visible using any</span>
<span class="sd">of its feature paths.</span>

<span class="sd">Feature structure variables are encoded using the ``nltk.sem.Variable``</span>
<span class="sd">class.  The variables&#39; values are tracked using a bindings</span>
<span class="sd">dictionary, which maps variables to their values.  When two feature</span>
<span class="sd">structures are unified, a fresh bindings dictionary is created to</span>
<span class="sd">track their values; and before unification completes, all bound</span>
<span class="sd">variables are replaced by their values.  Thus, the bindings</span>
<span class="sd">dictionaries are usually strictly internal to the unification process.</span>
<span class="sd">However, it is possible to track the bindings of variables if you</span>
<span class="sd">choose to, by supplying your own initial bindings dictionary to the</span>
<span class="sd">``unify()`` function.</span>

<span class="sd">When unbound variables are unified with one another, they become</span>
<span class="sd">aliased.  This is encoded by binding one variable to the other.</span>

<span class="sd">Lightweight Feature Structures</span>
<span class="sd">==============================</span>
<span class="sd">Many of the functions defined by ``nltk.featstruct`` can be applied</span>
<span class="sd">directly to simple Python dictionaries and lists, rather than to</span>
<span class="sd">full-fledged ``FeatDict`` and ``FeatList`` objects.  In other words,</span>
<span class="sd">Python ``dicts`` and ``lists`` can be used as &quot;light-weight&quot; feature</span>
<span class="sd">structures.</span>

<span class="sd">    &gt;&gt;&gt; from nltk.featstruct import unify</span>
<span class="sd">    &gt;&gt;&gt; unify(dict(x=1, y=dict()), dict(a=&#39;a&#39;, y=dict(b=&#39;b&#39;)))  # doctest: +SKIP</span>
<span class="sd">    {&#39;y&#39;: {&#39;b&#39;: &#39;b&#39;}, &#39;x&#39;: 1, &#39;a&#39;: &#39;a&#39;}</span>

<span class="sd">However, you should keep in mind the following caveats:</span>

<span class="sd">  - Python dictionaries &amp; lists ignore reentrance when checking for</span>
<span class="sd">    equality between values.  But two FeatStructs with different</span>
<span class="sd">    reentrances are considered nonequal, even if all their base</span>
<span class="sd">    values are equal.</span>

<span class="sd">  - FeatStructs can be easily frozen, allowing them to be used as</span>
<span class="sd">    keys in hash tables.  Python dictionaries and lists can not.</span>

<span class="sd">  - FeatStructs display reentrance in their string representations;</span>
<span class="sd">    Python dictionaries and lists do not.</span>

<span class="sd">  - FeatStructs may *not* be mixed with Python dictionaries and lists</span>
<span class="sd">    (e.g., when performing unification).</span>

<span class="sd">  - FeatStructs provide a number of useful methods, such as ``walk()``</span>
<span class="sd">    and ``cyclic()``, which are not available for Python dicts and lists.</span>

<span class="sd">In general, if your feature structures will contain any reentrances,</span>
<span class="sd">or if you plan to use them as dictionary keys, it is strongly</span>
<span class="sd">recommended that you use full-fledged ``FeatStruct`` objects.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">unicode_literals</span><span class="p">,</span> <span class="n">division</span>

<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">copy</span>

<span class="kn">from</span> <span class="nn">nltk.internals</span> <span class="kn">import</span> <span class="n">read_str</span><span class="p">,</span> <span class="n">raise_unorderable_types</span>
<span class="kn">from</span> <span class="nn">nltk.sem.logic</span> <span class="kn">import</span> <span class="p">(</span><span class="n">Variable</span><span class="p">,</span> <span class="n">Expression</span><span class="p">,</span> <span class="n">SubstituteBindingsI</span><span class="p">,</span>
                            <span class="n">LogicParser</span><span class="p">,</span> <span class="n">LogicalExpressionException</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">nltk.compat</span> <span class="kn">import</span> <span class="p">(</span><span class="n">string_types</span><span class="p">,</span> <span class="n">integer_types</span><span class="p">,</span> <span class="n">total_ordering</span><span class="p">,</span>
                         <span class="n">python_2_unicode_compatible</span><span class="p">,</span> <span class="n">unicode_repr</span><span class="p">)</span>

<span class="c">######################################################################</span>
<span class="c"># Feature Structure</span>
<span class="c">######################################################################</span>

<span class="nd">@total_ordering</span>
<div class="viewcode-block" id="FeatStruct"><a class="viewcode-back" href="../../api/nltk.html#nltk.featstruct.FeatStruct">[docs]</a><span class="k">class</span> <span class="nc">FeatStruct</span><span class="p">(</span><span class="n">SubstituteBindingsI</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A mapping from feature identifiers to feature values, where each</span>
<span class="sd">    feature value is either a basic value (such as a string or an</span>
<span class="sd">    integer), or a nested feature structure.  There are two types of</span>
<span class="sd">    feature structure:</span>

<span class="sd">      - feature dictionaries, implemented by ``FeatDict``, act like</span>
<span class="sd">        Python dictionaries.  Feature identifiers may be strings or</span>
<span class="sd">        instances of the ``Feature`` class.</span>
<span class="sd">      - feature lists, implemented by ``FeatList``, act like Python</span>
<span class="sd">        lists.  Feature identifiers are integers.</span>

<span class="sd">    Feature structures may be indexed using either simple feature</span>
<span class="sd">    identifiers or &#39;feature paths.&#39;  A feature path is a sequence</span>
<span class="sd">    of feature identifiers that stand for a corresponding sequence of</span>
<span class="sd">    indexing operations.  In particular, ``fstruct[(f1,f2,...,fn)]`` is</span>
<span class="sd">    equivalent to ``fstruct[f1][f2]...[fn]``.</span>

<span class="sd">    Feature structures may contain reentrant feature structures.  A</span>
<span class="sd">    &quot;reentrant feature structure&quot; is a single feature structure</span>
<span class="sd">    object that can be accessed via multiple feature paths.  Feature</span>
<span class="sd">    structures may also be cyclic.  A feature structure is &quot;cyclic&quot;</span>
<span class="sd">    if there is any feature path from the feature structure to itself.</span>

<span class="sd">    Two feature structures are considered equal if they assign the</span>
<span class="sd">    same values to all features, and have the same reentrancies.</span>

<span class="sd">    By default, feature structures are mutable.  They may be made</span>
<span class="sd">    immutable with the ``freeze()`` method.  Once they have been</span>
<span class="sd">    frozen, they may be hashed, and thus used as dictionary keys.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_frozen</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="sd">&quot;&quot;&quot;:ivar: A flag indicating whether this feature structure is</span>
<span class="sd">       frozen or not.  Once this flag is set, it should never be</span>
<span class="sd">       un-set; and no further modification should be made to this</span>
<span class="sd">       feature structue.&quot;&quot;&quot;</span>

    <span class="c">##////////////////////////////////////////////////////////////</span>
    <span class="c">#{ Constructor</span>
    <span class="c">##////////////////////////////////////////////////////////////</span>

    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">features</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">morefeatures</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct and return a new feature structure.  If this</span>
<span class="sd">        constructor is called directly, then the returned feature</span>
<span class="sd">        structure will be an instance of either the ``FeatDict`` class</span>
<span class="sd">        or the ``FeatList`` class.</span>

<span class="sd">        :param features: The initial feature values for this feature</span>
<span class="sd">            structure:</span>
<span class="sd">              - FeatStruct(string) -&gt; FeatStructReader().read(string)</span>
<span class="sd">              - FeatStruct(mapping) -&gt; FeatDict(mapping)</span>
<span class="sd">              - FeatStruct(sequence) -&gt; FeatList(sequence)</span>
<span class="sd">              - FeatStruct() -&gt; FeatDict()</span>
<span class="sd">        :param morefeatures: If ``features`` is a mapping or None,</span>
<span class="sd">            then ``morefeatures`` provides additional features for the</span>
<span class="sd">            ``FeatDict`` constructor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># If the FeatStruct constructor is called directly, then decide</span>
        <span class="c"># whether to create a FeatDict or a FeatList, based on the</span>
        <span class="c"># contents of the `features` argument.</span>
        <span class="k">if</span> <span class="n">cls</span> <span class="ow">is</span> <span class="n">FeatStruct</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">features</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">FeatDict</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">FeatDict</span><span class="p">,</span> <span class="o">**</span><span class="n">morefeatures</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">_is_mapping</span><span class="p">(</span><span class="n">features</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">FeatDict</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">FeatDict</span><span class="p">,</span> <span class="n">features</span><span class="p">,</span> <span class="o">**</span><span class="n">morefeatures</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">morefeatures</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;Keyword arguments may only be specified &#39;</span>
                                <span class="s">&#39;if features is None or is a mapping.&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">features</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">FeatStructReader</span><span class="o">.</span><span class="n">_START_FDICT_RE</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">features</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">FeatDict</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">FeatDict</span><span class="p">,</span> <span class="n">features</span><span class="p">,</span> <span class="o">**</span><span class="n">morefeatures</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">FeatList</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">FeatList</span><span class="p">,</span> <span class="n">features</span><span class="p">,</span> <span class="o">**</span><span class="n">morefeatures</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">_is_sequence</span><span class="p">(</span><span class="n">features</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">FeatList</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">FeatList</span><span class="p">,</span> <span class="n">features</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;Expected string or mapping or sequence&#39;</span><span class="p">)</span>

        <span class="c"># Otherwise, construct the object as normal.</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">FeatStruct</span><span class="p">,</span> <span class="n">cls</span><span class="p">)</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">features</span><span class="p">,</span>
                                                  <span class="o">**</span><span class="n">morefeatures</span><span class="p">)</span>

    <span class="c">##////////////////////////////////////////////////////////////</span>
    <span class="c">#{ Uniform Accessor Methods</span>
    <span class="c">##////////////////////////////////////////////////////////////</span>
    <span class="c"># These helper functions allow the methods defined by FeatStruct</span>
    <span class="c"># to treat all feature structures as mappings, even if they&#39;re</span>
    <span class="c"># really lists.  (Lists are treated as mappings from ints to vals)</span>

    <span class="k">def</span> <span class="nf">_keys</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return an iterable of the feature identifiers used by this</span>
<span class="sd">        FeatStruct.&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span> <span class="c"># Implemented by subclasses.</span>

    <span class="k">def</span> <span class="nf">_values</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return an iterable of the feature values directly defined</span>
<span class="sd">        by this FeatStruct.&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span> <span class="c"># Implemented by subclasses.</span>

    <span class="k">def</span> <span class="nf">_items</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return an iterable of (fid,fval) pairs, where fid is a</span>
<span class="sd">        feature identifier and fval is the corresponding feature</span>
<span class="sd">        value, for all features defined by this FeatStruct.&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span> <span class="c"># Implemented by subclasses.</span>

    <span class="c">##////////////////////////////////////////////////////////////</span>
    <span class="c">#{ Equality &amp; Hashing</span>
    <span class="c">##////////////////////////////////////////////////////////////</span>

<div class="viewcode-block" id="FeatStruct.equal_values"><a class="viewcode-back" href="../../api/nltk.html#nltk.featstruct.FeatStruct.equal_values">[docs]</a>    <span class="k">def</span> <span class="nf">equal_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">check_reentrance</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return True if ``self`` and ``other`` assign the same value to</span>
<span class="sd">        to every feature.  In particular, return true if</span>
<span class="sd">        ``self[p]==other[p]`` for every feature path *p* such</span>
<span class="sd">        that ``self[p]`` or ``other[p]`` is a base value (i.e.,</span>
<span class="sd">        not a nested feature structure).</span>

<span class="sd">        :param check_reentrance: If True, then also return False if</span>
<span class="sd">            there is any difference between the reentrances of ``self``</span>
<span class="sd">            and ``other``.</span>
<span class="sd">        :note: the ``==`` is equivalent to ``equal_values()`` with</span>
<span class="sd">            ``check_reentrance=True``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_equal</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">check_reentrance</span><span class="p">,</span> <span class="nb">set</span><span class="p">(),</span> <span class="nb">set</span><span class="p">(),</span> <span class="nb">set</span><span class="p">())</span>
</div>
    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return true if ``self`` and ``other`` are both feature structures,</span>
<span class="sd">        assign the same values to all features, and contain the same</span>
<span class="sd">        reentrances.  I.e., return</span>
<span class="sd">        ``self.equal_values(other, check_reentrance=True)``.</span>

<span class="sd">        :see: ``equal_values()``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_equal</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">True</span><span class="p">,</span> <span class="nb">set</span><span class="p">(),</span> <span class="nb">set</span><span class="p">(),</span> <span class="nb">set</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span>

    <span class="k">def</span> <span class="nf">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">FeatStruct</span><span class="p">):</span>
            <span class="c"># raise_unorderable_types(&quot;&lt;&quot;, self, other)</span>
            <span class="c"># Sometimes feature values can be pure strings,</span>
            <span class="c"># so we need to be able to compare with non-featstructs:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        If this feature structure is frozen, return its hash value;</span>
<span class="sd">        otherwise, raise ``TypeError``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_frozen</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;FeatStructs must be frozen before they &#39;</span>
                            <span class="s">&#39;can be hashed.&#39;</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hash</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_hash</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_hashvalue</span><span class="p">(</span><span class="nb">set</span><span class="p">())</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hash</span>

    <span class="k">def</span> <span class="nf">_equal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">check_reentrance</span><span class="p">,</span> <span class="n">visited_self</span><span class="p">,</span>
               <span class="n">visited_other</span><span class="p">,</span> <span class="n">visited_pairs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return True iff self and other have equal values.</span>

<span class="sd">        :param visited_self: A set containing the ids of all ``self``</span>
<span class="sd">            feature structures we&#39;ve already visited.</span>
<span class="sd">        :param visited_other: A set containing the ids of all ``other``</span>
<span class="sd">            feature structures we&#39;ve already visited.</span>
<span class="sd">        :param visited_pairs: A set containing ``(selfid, otherid)`` pairs</span>
<span class="sd">            for all pairs of feature structures we&#39;ve already visited.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># If we&#39;re the same object, then we&#39;re equal.</span>
        <span class="k">if</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">other</span><span class="p">:</span> <span class="k">return</span> <span class="bp">True</span>

        <span class="c"># If we have different classes, we&#39;re definitely not equal.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">__class__</span><span class="p">:</span> <span class="k">return</span> <span class="bp">False</span>

        <span class="c"># If we define different features, we&#39;re definitely not equal.</span>
        <span class="c"># (Perform len test first because it&#39;s faster -- we should</span>
        <span class="c"># do profiling to see if this actually helps)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="p">):</span> <span class="k">return</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_keys</span><span class="p">())</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">_keys</span><span class="p">()):</span> <span class="k">return</span> <span class="bp">False</span>

        <span class="c"># If we&#39;re checking reentrance, then any time we revisit a</span>
        <span class="c"># structure, make sure that it was paired with the same</span>
        <span class="c"># feature structure that it is now.  Note: if check_reentrance,</span>
        <span class="c"># then visited_pairs will never contain two pairs whose first</span>
        <span class="c"># values are equal, or two pairs whose second values are equal.</span>
        <span class="k">if</span> <span class="n">check_reentrance</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">in</span> <span class="n">visited_self</span> <span class="ow">or</span> <span class="nb">id</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">in</span> <span class="n">visited_other</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="nb">id</span><span class="p">(</span><span class="n">other</span><span class="p">))</span> <span class="ow">in</span> <span class="n">visited_pairs</span>

        <span class="c"># If we&#39;re not checking reentrance, then we still need to deal</span>
        <span class="c"># with cycles.  If we encounter the same (self, other) pair a</span>
        <span class="c"># second time, then we won&#39;t learn anything more by examining</span>
        <span class="c"># their children a second time, so just return true.</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="nb">id</span><span class="p">(</span><span class="n">other</span><span class="p">))</span> <span class="ow">in</span> <span class="n">visited_pairs</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">True</span>

        <span class="c"># Keep track of which nodes we&#39;ve visited.</span>
        <span class="n">visited_self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="n">visited_other</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">other</span><span class="p">))</span>
        <span class="n">visited_pairs</span><span class="o">.</span><span class="n">add</span><span class="p">(</span> <span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="nb">id</span><span class="p">(</span><span class="n">other</span><span class="p">))</span> <span class="p">)</span>

        <span class="c"># Now we have to check all values.  If any of them don&#39;t match,</span>
        <span class="c"># then return false.</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">self_fval</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_items</span><span class="p">():</span>
            <span class="n">other_fval</span> <span class="o">=</span> <span class="n">other</span><span class="p">[</span><span class="n">fname</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">self_fval</span><span class="p">,</span> <span class="n">FeatStruct</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">self_fval</span><span class="o">.</span><span class="n">_equal</span><span class="p">(</span><span class="n">other_fval</span><span class="p">,</span> <span class="n">check_reentrance</span><span class="p">,</span>
                                        <span class="n">visited_self</span><span class="p">,</span> <span class="n">visited_other</span><span class="p">,</span>
                                        <span class="n">visited_pairs</span><span class="p">):</span>
                    <span class="k">return</span> <span class="bp">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">self_fval</span> <span class="o">!=</span> <span class="n">other_fval</span><span class="p">:</span> <span class="k">return</span> <span class="bp">False</span>

        <span class="c"># Everything matched up; return true.</span>
        <span class="k">return</span> <span class="bp">True</span>

    <span class="k">def</span> <span class="nf">_calculate_hashvalue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">visited</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a hash value for this feature structure.</span>

<span class="sd">        :require: ``self`` must be frozen.</span>
<span class="sd">        :param visited: A set containing the ids of all feature</span>
<span class="sd">            structures we&#39;ve already visited while hashing.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span> <span class="k">return</span> <span class="mi">1</span>
        <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

        <span class="n">hashval</span> <span class="o">=</span> <span class="mi">5831</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">fval</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_items</span><span class="p">()):</span>
            <span class="n">hashval</span> <span class="o">*=</span> <span class="mi">37</span>
            <span class="n">hashval</span> <span class="o">+=</span> <span class="nb">hash</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
            <span class="n">hashval</span> <span class="o">*=</span> <span class="mi">37</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fval</span><span class="p">,</span> <span class="n">FeatStruct</span><span class="p">):</span>
                <span class="n">hashval</span> <span class="o">+=</span> <span class="n">fval</span><span class="o">.</span><span class="n">_calculate_hashvalue</span><span class="p">(</span><span class="n">visited</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">hashval</span> <span class="o">+=</span> <span class="nb">hash</span><span class="p">(</span><span class="n">fval</span><span class="p">)</span>
            <span class="c"># Convert to a 32 bit int.</span>
            <span class="n">hashval</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">hashval</span> <span class="o">&amp;</span> <span class="mh">0x7fffffff</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">hashval</span>

    <span class="c">##////////////////////////////////////////////////////////////</span>
    <span class="c">#{ Freezing</span>
    <span class="c">##////////////////////////////////////////////////////////////</span>

    <span class="c">#: Error message used by mutating methods when called on a frozen</span>
    <span class="c">#: feature structure.</span>
    <span class="n">_FROZEN_ERROR</span> <span class="o">=</span> <span class="s">&quot;Frozen FeatStructs may not be modified.&quot;</span>

<div class="viewcode-block" id="FeatStruct.freeze"><a class="viewcode-back" href="../../api/nltk.html#nltk.featstruct.FeatStruct.freeze">[docs]</a>    <span class="k">def</span> <span class="nf">freeze</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make this feature structure, and any feature structures it</span>
<span class="sd">        contains, immutable.  Note: this method does not attempt to</span>
<span class="sd">        &#39;freeze&#39; any feature value that is not a ``FeatStruct``; it</span>
<span class="sd">        is recommended that you use only immutable feature values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_frozen</span><span class="p">:</span> <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_freeze</span><span class="p">(</span><span class="nb">set</span><span class="p">())</span>
</div>
<div class="viewcode-block" id="FeatStruct.frozen"><a class="viewcode-back" href="../../api/nltk.html#nltk.featstruct.FeatStruct.frozen">[docs]</a>    <span class="k">def</span> <span class="nf">frozen</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return True if this feature structure is immutable.  Feature</span>
<span class="sd">        structures can be made immutable with the ``freeze()`` method.</span>
<span class="sd">        Immutable feature structures may not be made mutable again,</span>
<span class="sd">        but new mutable copies can be produced with the ``copy()`` method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_frozen</span>
</div>
    <span class="k">def</span> <span class="nf">_freeze</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">visited</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make this feature structure, and any feature structure it</span>
<span class="sd">        contains, immutable.</span>

<span class="sd">        :param visited: A set containing the ids of all feature</span>
<span class="sd">            structures we&#39;ve already visited while freezing.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span> <span class="k">return</span>
        <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_frozen</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">fval</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_items</span><span class="p">()):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fval</span><span class="p">,</span> <span class="n">FeatStruct</span><span class="p">):</span>
                <span class="n">fval</span><span class="o">.</span><span class="n">_freeze</span><span class="p">(</span><span class="n">visited</span><span class="p">)</span>

    <span class="c">##////////////////////////////////////////////////////////////</span>
    <span class="c">#{ Copying</span>
    <span class="c">##////////////////////////////////////////////////////////////</span>

<div class="viewcode-block" id="FeatStruct.copy"><a class="viewcode-back" href="../../api/nltk.html#nltk.featstruct.FeatStruct.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a new copy of ``self``.  The new copy will not be frozen.</span>

<span class="sd">        :param deep: If true, create a deep copy; if false, create</span>
<span class="sd">            a shallow copy.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">deep</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="c"># Subclasses should define __deepcopy__ to ensure that the new</span>
    <span class="c"># copy will not be frozen.</span></div>
    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span> <span class="c"># Implemented by subclasses.</span>

    <span class="c">##////////////////////////////////////////////////////////////</span>
    <span class="c">#{ Structural Information</span>
    <span class="c">##////////////////////////////////////////////////////////////</span>

<div class="viewcode-block" id="FeatStruct.cyclic"><a class="viewcode-back" href="../../api/nltk.html#nltk.featstruct.FeatStruct.cyclic">[docs]</a>    <span class="k">def</span> <span class="nf">cyclic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return True if this feature structure contains itself.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_reentrances</span><span class="p">({})[</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)]</span>
</div>
<div class="viewcode-block" id="FeatStruct.walk"><a class="viewcode-back" href="../../api/nltk.html#nltk.featstruct.FeatStruct.walk">[docs]</a>    <span class="k">def</span> <span class="nf">walk</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an iterator that generates this feature structure, and</span>
<span class="sd">        each feature structure it contains.  Each feature structure will</span>
<span class="sd">        be generated exactly once.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_walk</span><span class="p">(</span><span class="nb">set</span><span class="p">())</span>
</div>
    <span class="k">def</span> <span class="nf">_walk</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">visited</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an iterator that generates this feature structure, and</span>
<span class="sd">        each feature structure it contains.</span>

<span class="sd">        :param visited: A set containing the ids of all feature</span>
<span class="sd">            structures we&#39;ve already visited while freezing.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span> <span class="c"># Implemented by subclasses.</span>

    <span class="k">def</span> <span class="nf">_walk</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">visited</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span> <span class="k">return</span>
        <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="k">yield</span> <span class="bp">self</span>
        <span class="k">for</span> <span class="n">fval</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fval</span><span class="p">,</span> <span class="n">FeatStruct</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">elt</span> <span class="ow">in</span> <span class="n">fval</span><span class="o">.</span><span class="n">_walk</span><span class="p">(</span><span class="n">visited</span><span class="p">):</span>
                    <span class="k">yield</span> <span class="n">elt</span>

    <span class="c"># Walk through the feature tree.  The first time we see a feature</span>
    <span class="c"># value, map it to False (not reentrant).  If we see a feature</span>
    <span class="c"># value more than once, then map it to True (reentrant).</span>
    <span class="k">def</span> <span class="nf">_find_reentrances</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reentrances</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a dictionary that maps from the ``id`` of each feature</span>
<span class="sd">        structure contained in ``self`` (including ``self``) to a</span>
<span class="sd">        boolean value, indicating whether it is reentrant or not.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">in</span> <span class="n">reentrances</span><span class="p">:</span>
            <span class="c"># We&#39;ve seen it more than once.</span>
            <span class="n">reentrances</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)]</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># This is the first time we&#39;ve seen it.</span>
            <span class="n">reentrances</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)]</span> <span class="o">=</span> <span class="bp">False</span>

            <span class="c"># Recurse to contained feature structures.</span>
            <span class="k">for</span> <span class="n">fval</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">():</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fval</span><span class="p">,</span> <span class="n">FeatStruct</span><span class="p">):</span>
                    <span class="n">fval</span><span class="o">.</span><span class="n">_find_reentrances</span><span class="p">(</span><span class="n">reentrances</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">reentrances</span>

    <span class="c">##////////////////////////////////////////////////////////////</span>
    <span class="c">#{ Variables &amp; Bindings</span>
    <span class="c">##////////////////////////////////////////////////////////////</span>

<div class="viewcode-block" id="FeatStruct.substitute_bindings"><a class="viewcode-back" href="../../api/nltk.html#nltk.featstruct.FeatStruct.substitute_bindings">[docs]</a>    <span class="k">def</span> <span class="nf">substitute_bindings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bindings</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;:see: ``nltk.featstruct.substitute_bindings()``&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">substitute_bindings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bindings</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="FeatStruct.retract_bindings"><a class="viewcode-back" href="../../api/nltk.html#nltk.featstruct.FeatStruct.retract_bindings">[docs]</a>    <span class="k">def</span> <span class="nf">retract_bindings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bindings</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;:see: ``nltk.featstruct.retract_bindings()``&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">retract_bindings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bindings</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="FeatStruct.variables"><a class="viewcode-back" href="../../api/nltk.html#nltk.featstruct.FeatStruct.variables">[docs]</a>    <span class="k">def</span> <span class="nf">variables</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;:see: ``nltk.featstruct.find_variables()``&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">find_variables</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="FeatStruct.rename_variables"><a class="viewcode-back" href="../../api/nltk.html#nltk.featstruct.FeatStruct.rename_variables">[docs]</a>    <span class="k">def</span> <span class="nf">rename_variables</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">used_vars</span><span class="o">=</span><span class="p">(),</span> <span class="n">new_vars</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;:see: ``nltk.featstruct.rename_variables()``&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">rename_variables</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">,</span> <span class="n">used_vars</span><span class="p">,</span> <span class="n">new_vars</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="FeatStruct.remove_variables"><a class="viewcode-back" href="../../api/nltk.html#nltk.featstruct.FeatStruct.remove_variables">[docs]</a>    <span class="k">def</span> <span class="nf">remove_variables</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the feature structure that is obtained by deleting</span>
<span class="sd">        any feature whose value is a ``Variable``.</span>

<span class="sd">        :rtype: FeatStruct</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">remove_variables</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="c">##////////////////////////////////////////////////////////////</span>
    <span class="c">#{ Unification</span>
    <span class="c">##////////////////////////////////////////////////////////////</span>
</div>
<div class="viewcode-block" id="FeatStruct.unify"><a class="viewcode-back" href="../../api/nltk.html#nltk.featstruct.FeatStruct.unify">[docs]</a>    <span class="k">def</span> <span class="nf">unify</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">bindings</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">trace</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
              <span class="n">fail</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">rename_vars</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">unify</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">bindings</span><span class="p">,</span> <span class="n">trace</span><span class="p">,</span> <span class="n">fail</span><span class="p">,</span> <span class="n">rename_vars</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="FeatStruct.subsumes"><a class="viewcode-back" href="../../api/nltk.html#nltk.featstruct.FeatStruct.subsumes">[docs]</a>    <span class="k">def</span> <span class="nf">subsumes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return True if ``self`` subsumes ``other``.  I.e., return true</span>
<span class="sd">        If unifying ``self`` with ``other`` would result in a feature</span>
<span class="sd">        structure equal to ``other``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">subsumes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="c">##////////////////////////////////////////////////////////////</span>
    <span class="c">#{ String Representations</span>
    <span class="c">##////////////////////////////////////////////////////////////</span>
</div>
    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Display a single-line representation of this feature structure,</span>
<span class="sd">        suitable for embedding in other representations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_find_reentrances</span><span class="p">({}),</span> <span class="p">{})</span>

    <span class="k">def</span> <span class="nf">_repr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reentrances</span><span class="p">,</span> <span class="n">reentrance_ids</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a string representation of this feature structure.</span>

<span class="sd">        :param reentrances: A dictionary that maps from the ``id`` of</span>
<span class="sd">            each feature value in self, indicating whether that value</span>
<span class="sd">            is reentrant or not.</span>
<span class="sd">        :param reentrance_ids: A dictionary mapping from each ``id``</span>
<span class="sd">            of a feature value to a unique identifier.  This is modified</span>
<span class="sd">            by ``repr``: the first time a reentrant feature value is</span>
<span class="sd">            displayed, an identifier is added to ``reentrance_ids`` for it.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>

<span class="c"># Mutation: disable if frozen.</span></div>
<span class="n">_FROZEN_ERROR</span> <span class="o">=</span> <span class="s">&quot;Frozen FeatStructs may not be modified.&quot;</span>
<span class="n">_FROZEN_NOTICE</span> <span class="o">=</span> <span class="s">&quot;</span><span class="se">\n</span><span class="si">%s</span><span class="s">If self is frozen, raise ValueError.&quot;</span>
<span class="k">def</span> <span class="nf">_check_frozen</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="s">&#39;&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a method function, return a new method function that first</span>
<span class="sd">    checks if ``self._frozen`` is true; and if so, raises ``ValueError``</span>
<span class="sd">    with an appropriate message.  Otherwise, call the method and return</span>
<span class="sd">    its result.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">wrapped</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_frozen</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">_FROZEN_ERROR</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span> <span class="k">return</span> <span class="n">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">wrapped</span><span class="o">.</span><span class="n">__name__</span> <span class="o">=</span> <span class="n">method</span><span class="o">.</span><span class="n">__name__</span>
    <span class="n">wrapped</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="p">(</span><span class="n">method</span><span class="o">.</span><span class="n">__doc__</span> <span class="ow">or</span> <span class="s">&#39;&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">_FROZEN_NOTICE</span> <span class="o">%</span> <span class="n">indent</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">wrapped</span>


<span class="c">######################################################################</span>
<span class="c"># Feature Dictionary</span>
<span class="c">######################################################################</span>

<span class="nd">@python_2_unicode_compatible</span>
<div class="viewcode-block" id="FeatDict"><a class="viewcode-back" href="../../api/nltk.html#nltk.featstruct.FeatDict">[docs]</a><span class="k">class</span> <span class="nc">FeatDict</span><span class="p">(</span><span class="n">FeatStruct</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A feature structure that acts like a Python dictionary.  I.e., a</span>
<span class="sd">    mapping from feature identifiers to feature values, where a feature</span>
<span class="sd">    identifier can be a string or a ``Feature``; and where a feature value</span>
<span class="sd">    can be either a basic value (such as a string or an integer), or a nested</span>
<span class="sd">    feature structure.  A feature identifiers for a ``FeatDict`` is</span>
<span class="sd">    sometimes called a &quot;feature name&quot;.</span>

<span class="sd">    Two feature dicts are considered equal if they assign the same</span>
<span class="sd">    values to all features, and have the same reentrances.</span>

<span class="sd">    :see: ``FeatStruct`` for information about feature paths, reentrance,</span>
<span class="sd">        cyclic feature structures, mutability, freezing, and hashing.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">features</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">morefeatures</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new feature dictionary, with the specified features.</span>

<span class="sd">        :param features: The initial value for this feature</span>
<span class="sd">            dictionary.  If ``features`` is a ``FeatStruct``, then its</span>
<span class="sd">            features are copied (shallow copy).  If ``features`` is a</span>
<span class="sd">            dict, then a feature is created for each item, mapping its</span>
<span class="sd">            key to its value.  If ``features`` is a string, then it is</span>
<span class="sd">            processed using ``FeatStructReader``.  If ``features`` is a list of</span>
<span class="sd">            tuples ``(name, val)``, then a feature is created for each tuple.</span>
<span class="sd">        :param morefeatures: Additional features for the new feature</span>
<span class="sd">            dictionary.  If a feature is listed under both ``features`` and</span>
<span class="sd">            ``morefeatures``, then the value from ``morefeatures`` will be</span>
<span class="sd">            used.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">features</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
            <span class="n">FeatStructReader</span><span class="p">()</span><span class="o">.</span><span class="n">fromstring</span><span class="p">(</span><span class="n">features</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="o">**</span><span class="n">morefeatures</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># update() checks the types of features.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">features</span><span class="p">,</span> <span class="o">**</span><span class="n">morefeatures</span><span class="p">)</span>

    <span class="c">#////////////////////////////////////////////////////////////</span>
    <span class="c">#{ Dict methods</span>
    <span class="c">#////////////////////////////////////////////////////////////</span>
    <span class="n">_INDEX_ERROR</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="s">&quot;Expected feature name or path.  Got </span><span class="si">%r</span><span class="s">.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name_or_path</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;If the feature with the given name or path exists, return</span>
<span class="sd">        its value; otherwise, raise ``KeyError``.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name_or_path</span><span class="p">,</span> <span class="p">(</span><span class="n">string_types</span><span class="p">,</span> <span class="n">Feature</span><span class="p">)):</span>
            <span class="k">return</span> <span class="nb">dict</span><span class="o">.</span><span class="n">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name_or_path</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name_or_path</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">val</span> <span class="o">=</span> <span class="bp">self</span>
                <span class="k">for</span> <span class="n">fid</span> <span class="ow">in</span> <span class="n">name_or_path</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">FeatStruct</span><span class="p">):</span>
                        <span class="k">raise</span> <span class="ne">KeyError</span> <span class="c"># path contains base value</span>
                    <span class="n">val</span> <span class="o">=</span> <span class="n">val</span><span class="p">[</span><span class="n">fid</span><span class="p">]</span>
                <span class="k">return</span> <span class="n">val</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">KeyError</span><span class="p">,</span> <span class="ne">IndexError</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">name_or_path</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_INDEX_ERROR</span> <span class="o">%</span> <span class="n">name_or_path</span><span class="p">)</span>

<div class="viewcode-block" id="FeatDict.get"><a class="viewcode-back" href="../../api/nltk.html#nltk.featstruct.FeatDict.get">[docs]</a>    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name_or_path</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;If the feature with the given name or path exists, return its</span>
<span class="sd">        value; otherwise, return ``default``.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span> <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">name_or_path</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span> <span class="k">return</span> <span class="n">default</span>
</div>
    <span class="k">def</span> <span class="nf">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name_or_path</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return true if a feature with the given name or path exists.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span> <span class="bp">self</span><span class="p">[</span><span class="n">name_or_path</span><span class="p">];</span> <span class="k">return</span> <span class="bp">True</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span> <span class="k">return</span> <span class="bp">False</span>

<div class="viewcode-block" id="FeatDict.has_key"><a class="viewcode-back" href="../../api/nltk.html#nltk.featstruct.FeatDict.has_key">[docs]</a>    <span class="k">def</span> <span class="nf">has_key</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name_or_path</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return true if a feature with the given name or path exists.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">name_or_path</span> <span class="ow">in</span> <span class="bp">self</span>
</div>
    <span class="k">def</span> <span class="nf">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name_or_path</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;If the feature with the given name or path exists, delete</span>
<span class="sd">        its value; otherwise, raise ``KeyError``.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_frozen</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">_FROZEN_ERROR</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name_or_path</span><span class="p">,</span> <span class="p">(</span><span class="n">string_types</span><span class="p">,</span> <span class="n">Feature</span><span class="p">)):</span>
            <span class="k">return</span> <span class="nb">dict</span><span class="o">.</span><span class="n">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name_or_path</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name_or_path</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">name_or_path</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;The path () can not be set&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">name_or_path</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">FeatStruct</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">name_or_path</span><span class="p">)</span> <span class="c"># path contains base value</span>
                <span class="k">del</span> <span class="n">parent</span><span class="p">[</span><span class="n">name_or_path</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_INDEX_ERROR</span> <span class="o">%</span> <span class="n">name_or_path</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name_or_path</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the value for the feature with the given name or path</span>
<span class="sd">        to ``value``.  If ``name_or_path`` is an invalid path, raise</span>
<span class="sd">        ``KeyError``.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_frozen</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">_FROZEN_ERROR</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name_or_path</span><span class="p">,</span> <span class="p">(</span><span class="n">string_types</span><span class="p">,</span> <span class="n">Feature</span><span class="p">)):</span>
            <span class="k">return</span> <span class="nb">dict</span><span class="o">.</span><span class="n">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name_or_path</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name_or_path</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">name_or_path</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;The path () can not be set&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">name_or_path</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">FeatStruct</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">name_or_path</span><span class="p">)</span> <span class="c"># path contains base value</span>
                <span class="n">parent</span><span class="p">[</span><span class="n">name_or_path</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_INDEX_ERROR</span> <span class="o">%</span> <span class="n">name_or_path</span><span class="p">)</span>

    <span class="n">clear</span> <span class="o">=</span> <span class="n">_check_frozen</span><span class="p">(</span><span class="nb">dict</span><span class="o">.</span><span class="n">clear</span><span class="p">)</span>
    <span class="n">pop</span> <span class="o">=</span> <span class="n">_check_frozen</span><span class="p">(</span><span class="nb">dict</span><span class="o">.</span><span class="n">pop</span><span class="p">)</span>
    <span class="n">popitem</span> <span class="o">=</span> <span class="n">_check_frozen</span><span class="p">(</span><span class="nb">dict</span><span class="o">.</span><span class="n">popitem</span><span class="p">)</span>
    <span class="n">setdefault</span> <span class="o">=</span> <span class="n">_check_frozen</span><span class="p">(</span><span class="nb">dict</span><span class="o">.</span><span class="n">setdefault</span><span class="p">)</span>

<div class="viewcode-block" id="FeatDict.update"><a class="viewcode-back" href="../../api/nltk.html#nltk.featstruct.FeatDict.update">[docs]</a>    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">features</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">morefeatures</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_frozen</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">_FROZEN_ERROR</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">features</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">items</span> <span class="o">=</span> <span class="p">()</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">features</span><span class="p">,</span> <span class="s">&#39;items&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">callable</span><span class="p">(</span><span class="n">features</span><span class="o">.</span><span class="n">items</span><span class="p">):</span>
            <span class="n">items</span> <span class="o">=</span> <span class="n">features</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">features</span><span class="p">,</span> <span class="s">&#39;__iter__&#39;</span><span class="p">):</span>
            <span class="n">items</span> <span class="o">=</span> <span class="n">features</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Expected mapping or list of tuples&#39;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">items</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="p">(</span><span class="n">string_types</span><span class="p">,</span> <span class="n">Feature</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;Feature names must be strings&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">morefeatures</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="p">(</span><span class="n">string_types</span><span class="p">,</span> <span class="n">Feature</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;Feature names must be strings&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>

    <span class="c">##////////////////////////////////////////////////////////////</span>
    <span class="c">#{ Copying</span>
    <span class="c">##////////////////////////////////////////////////////////////</span>
</div>
    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="p">):</span>
        <span class="n">memo</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)]</span> <span class="o">=</span> <span class="n">selfcopy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">()</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_items</span><span class="p">():</span>
            <span class="n">selfcopy</span><span class="p">[</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="n">memo</span><span class="p">)]</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">val</span><span class="p">,</span><span class="n">memo</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">selfcopy</span>

    <span class="c">##////////////////////////////////////////////////////////////</span>
    <span class="c">#{ Uniform Accessor Methods</span>
    <span class="c">##////////////////////////////////////////////////////////////</span>

    <span class="k">def</span> <span class="nf">_keys</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">_values</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">_items</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>

    <span class="c">##////////////////////////////////////////////////////////////</span>
    <span class="c">#{ String Representations</span>
    <span class="c">##////////////////////////////////////////////////////////////</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Display a multi-line representation of this feature dictionary</span>
<span class="sd">        as an FVM (feature value matrix).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_find_reentrances</span><span class="p">({}),</span> <span class="p">{}))</span>

    <span class="k">def</span> <span class="nf">_repr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reentrances</span><span class="p">,</span> <span class="n">reentrance_ids</span><span class="p">):</span>
        <span class="n">segments</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">prefix</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
        <span class="n">suffix</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>

        <span class="c"># If this is the first time we&#39;ve seen a reentrant structure,</span>
        <span class="c"># then assign it a unique identifier.</span>
        <span class="k">if</span> <span class="n">reentrances</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)]:</span>
            <span class="k">assert</span> <span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">reentrance_ids</span>
            <span class="n">reentrance_ids</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)]</span> <span class="o">=</span> <span class="nb">repr</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">reentrance_ids</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

        <span class="c"># sorting note: keys are unique strings, so we&#39;ll never fall</span>
        <span class="c"># through to comparing values.</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">fval</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
            <span class="n">display</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="s">&#39;display&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">id</span><span class="p">(</span><span class="n">fval</span><span class="p">)</span> <span class="ow">in</span> <span class="n">reentrance_ids</span><span class="p">:</span>
                <span class="n">segments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%s</span><span class="s">-&gt;(</span><span class="si">%s</span><span class="s">)&#39;</span> <span class="o">%</span>
                                <span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">reentrance_ids</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="n">fval</span><span class="p">)]))</span>
            <span class="k">elif</span> <span class="p">(</span><span class="n">display</span> <span class="o">==</span> <span class="s">&#39;prefix&#39;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">prefix</span> <span class="ow">and</span>
                  <span class="nb">isinstance</span><span class="p">(</span><span class="n">fval</span><span class="p">,</span> <span class="p">(</span><span class="n">Variable</span><span class="p">,</span> <span class="n">string_types</span><span class="p">))):</span>
                    <span class="n">prefix</span> <span class="o">=</span> <span class="s">&#39;</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">fval</span>
            <span class="k">elif</span> <span class="n">display</span> <span class="o">==</span> <span class="s">&#39;slash&#39;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">suffix</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fval</span><span class="p">,</span> <span class="n">Variable</span><span class="p">):</span>
                    <span class="n">suffix</span> <span class="o">=</span> <span class="s">&#39;/</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">fval</span><span class="o">.</span><span class="n">name</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">suffix</span> <span class="o">=</span> <span class="s">&#39;/</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">unicode_repr</span><span class="p">(</span><span class="n">fval</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fval</span><span class="p">,</span> <span class="n">Variable</span><span class="p">):</span>
                <span class="n">segments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%s</span><span class="s">=</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">fval</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">fval</span> <span class="ow">is</span> <span class="bp">True</span><span class="p">:</span>
                <span class="n">segments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;+</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">fname</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">fval</span> <span class="ow">is</span> <span class="bp">False</span><span class="p">:</span>
                <span class="n">segments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;-</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">fname</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fval</span><span class="p">,</span> <span class="n">Expression</span><span class="p">):</span>
                <span class="n">segments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%s</span><span class="s">=&lt;</span><span class="si">%s</span><span class="s">&gt;&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">fval</span><span class="p">))</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fval</span><span class="p">,</span> <span class="n">FeatStruct</span><span class="p">):</span>
                <span class="n">segments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%s</span><span class="s">=</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">unicode_repr</span><span class="p">(</span><span class="n">fval</span><span class="p">)))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">fval_repr</span> <span class="o">=</span> <span class="n">fval</span><span class="o">.</span><span class="n">_repr</span><span class="p">(</span><span class="n">reentrances</span><span class="p">,</span> <span class="n">reentrance_ids</span><span class="p">)</span>
                <span class="n">segments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%s</span><span class="s">=</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">fval_repr</span><span class="p">))</span>
        <span class="c"># If it&#39;s reentrant, then add on an identifier tag.</span>
        <span class="k">if</span> <span class="n">reentrances</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)]:</span>
            <span class="n">prefix</span> <span class="o">=</span> <span class="s">&#39;(</span><span class="si">%s</span><span class="s">)</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">reentrance_ids</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)],</span> <span class="n">prefix</span><span class="p">)</span>
        <span class="k">return</span> <span class="s">&#39;</span><span class="si">%s</span><span class="s">[</span><span class="si">%s</span><span class="s">]</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">prefix</span><span class="p">,</span> <span class="s">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">segments</span><span class="p">),</span> <span class="n">suffix</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_str</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reentrances</span><span class="p">,</span> <span class="n">reentrance_ids</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :return: A list of lines composing a string representation of</span>
<span class="sd">            this feature dictionary.</span>
<span class="sd">        :param reentrances: A dictionary that maps from the ``id`` of</span>
<span class="sd">            each feature value in self, indicating whether that value</span>
<span class="sd">            is reentrant or not.</span>
<span class="sd">        :param reentrance_ids: A dictionary mapping from each ``id``</span>
<span class="sd">            of a feature value to a unique identifier.  This is modified</span>
<span class="sd">            by ``repr``: the first time a reentrant feature value is</span>
<span class="sd">            displayed, an identifier is added to ``reentrance_ids`` for</span>
<span class="sd">            it.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># If this is the first time we&#39;ve seen a reentrant structure,</span>
        <span class="c"># then tack on an id string.</span>
        <span class="k">if</span> <span class="n">reentrances</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)]:</span>
            <span class="k">assert</span> <span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">reentrance_ids</span>
            <span class="n">reentrance_ids</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)]</span> <span class="o">=</span> <span class="nb">repr</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">reentrance_ids</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

        <span class="c"># Special case: empty feature dict.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">reentrances</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)]:</span>
                <span class="k">return</span> <span class="p">[</span><span class="s">&#39;(</span><span class="si">%s</span><span class="s">) []&#39;</span> <span class="o">%</span> <span class="n">reentrance_ids</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)]]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[</span><span class="s">&#39;[]&#39;</span><span class="p">]</span>

        <span class="c"># What&#39;s the longest feature name?  Use this to align names.</span>
        <span class="n">maxfnamelen</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

        <span class="n">lines</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c"># sorting note: keys are unique strings, so we&#39;ll never fall</span>
        <span class="c"># through to comparing values.</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">fval</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
            <span class="n">fname</span> <span class="o">=</span> <span class="p">(</span><span class="s">&quot;</span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">fname</span><span class="p">)</span><span class="o">.</span><span class="n">ljust</span><span class="p">(</span><span class="n">maxfnamelen</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fval</span><span class="p">,</span> <span class="n">Variable</span><span class="p">):</span>
                <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%s</span><span class="s"> = </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">fname</span><span class="p">,</span><span class="n">fval</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>

            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fval</span><span class="p">,</span> <span class="n">Expression</span><span class="p">):</span>
                <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%s</span><span class="s"> = &lt;</span><span class="si">%s</span><span class="s">&gt;&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">fval</span><span class="p">))</span>

            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fval</span><span class="p">,</span> <span class="n">FeatList</span><span class="p">):</span>
                <span class="n">fval_repr</span> <span class="o">=</span> <span class="n">fval</span><span class="o">.</span><span class="n">_repr</span><span class="p">(</span><span class="n">reentrances</span><span class="p">,</span> <span class="n">reentrance_ids</span><span class="p">)</span>
                <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%s</span><span class="s"> = </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">unicode_repr</span><span class="p">(</span><span class="n">fval_repr</span><span class="p">)))</span>

            <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fval</span><span class="p">,</span> <span class="n">FeatDict</span><span class="p">):</span>
                <span class="c"># It&#39;s not a nested feature structure -- just print it.</span>
                <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%s</span><span class="s"> = </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">unicode_repr</span><span class="p">(</span><span class="n">fval</span><span class="p">)))</span>

            <span class="k">elif</span> <span class="nb">id</span><span class="p">(</span><span class="n">fval</span><span class="p">)</span> <span class="ow">in</span> <span class="n">reentrance_ids</span><span class="p">:</span>
                <span class="c"># It&#39;s a feature structure we&#39;ve seen before -- print</span>
                <span class="c"># the reentrance id.</span>
                <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%s</span><span class="s"> -&gt; (</span><span class="si">%s</span><span class="s">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">reentrance_ids</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="n">fval</span><span class="p">)]))</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="c"># It&#39;s a new feature structure.  Separate it from</span>
                <span class="c"># other values by a blank line.</span>
                <span class="k">if</span> <span class="n">lines</span> <span class="ow">and</span> <span class="n">lines</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="s">&#39;&#39;</span><span class="p">:</span> <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;&#39;</span><span class="p">)</span>

                <span class="c"># Recursively print the feature&#39;s value (fval).</span>
                <span class="n">fval_lines</span> <span class="o">=</span> <span class="n">fval</span><span class="o">.</span><span class="n">_str</span><span class="p">(</span><span class="n">reentrances</span><span class="p">,</span> <span class="n">reentrance_ids</span><span class="p">)</span>

                <span class="c"># Indent each line to make room for fname.</span>
                <span class="n">fval_lines</span> <span class="o">=</span> <span class="p">[(</span><span class="s">&#39; &#39;</span><span class="o">*</span><span class="p">(</span><span class="n">maxfnamelen</span><span class="o">+</span><span class="mi">3</span><span class="p">))</span><span class="o">+</span><span class="n">l</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">fval_lines</span><span class="p">]</span>

                <span class="c"># Pick which line we&#39;ll display fname on, &amp; splice it in.</span>
                <span class="n">nameline</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">fval_lines</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
                <span class="n">fval_lines</span><span class="p">[</span><span class="n">nameline</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">fname</span><span class="o">+</span><span class="s">&#39; =&#39;</span><span class="o">+</span><span class="n">fval_lines</span><span class="p">[</span><span class="n">nameline</span><span class="p">][</span><span class="n">maxfnamelen</span><span class="o">+</span><span class="mi">2</span><span class="p">:])</span>

                <span class="c"># Add the feature structure to the output.</span>
                <span class="n">lines</span> <span class="o">+=</span> <span class="n">fval_lines</span>

                <span class="c"># Separate FeatStructs by a blank line.</span>
                <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;&#39;</span><span class="p">)</span>

        <span class="c"># Get rid of any excess blank lines.</span>
        <span class="k">if</span> <span class="n">lines</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;&#39;</span><span class="p">:</span> <span class="n">lines</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

        <span class="c"># Add brackets around everything.</span>
        <span class="n">maxlen</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">line</span><span class="p">)</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">)</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;[ </span><span class="si">%s%s</span><span class="s"> ]&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="s">&#39; &#39;</span><span class="o">*</span><span class="p">(</span><span class="n">maxlen</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">line</span><span class="p">)))</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">]</span>

        <span class="c"># If it&#39;s reentrant, then add on an identifier tag.</span>
        <span class="k">if</span> <span class="n">reentrances</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)]:</span>
            <span class="n">idstr</span> <span class="o">=</span> <span class="s">&#39;(</span><span class="si">%s</span><span class="s">) &#39;</span> <span class="o">%</span> <span class="n">reentrance_ids</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)]</span>
            <span class="n">lines</span> <span class="o">=</span> <span class="p">[(</span><span class="s">&#39; &#39;</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">idstr</span><span class="p">))</span><span class="o">+</span><span class="n">l</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">]</span>
            <span class="n">idline</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
            <span class="n">lines</span><span class="p">[</span><span class="n">idline</span><span class="p">]</span> <span class="o">=</span> <span class="n">idstr</span> <span class="o">+</span> <span class="n">lines</span><span class="p">[</span><span class="n">idline</span><span class="p">][</span><span class="nb">len</span><span class="p">(</span><span class="n">idstr</span><span class="p">):]</span>

        <span class="k">return</span> <span class="n">lines</span>


<span class="c">######################################################################</span>
<span class="c"># Feature List</span>
<span class="c">######################################################################</span>
</div>
<div class="viewcode-block" id="FeatList"><a class="viewcode-back" href="../../api/nltk.html#nltk.featstruct.FeatList">[docs]</a><span class="k">class</span> <span class="nc">FeatList</span><span class="p">(</span><span class="n">FeatStruct</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A list of feature values, where each feature value is either a</span>
<span class="sd">    basic value (such as a string or an integer), or a nested feature</span>
<span class="sd">    structure.</span>

<span class="sd">    Feature lists may contain reentrant feature values.  A &quot;reentrant</span>
<span class="sd">    feature value&quot; is a single feature value that can be accessed via</span>
<span class="sd">    multiple feature paths.  Feature lists may also be cyclic.</span>

<span class="sd">    Two feature lists are considered equal if they assign the same</span>
<span class="sd">    values to all features, and have the same reentrances.</span>

<span class="sd">    :see: ``FeatStruct`` for information about feature paths, reentrance,</span>
<span class="sd">        cyclic feature structures, mutability, freezing, and hashing.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">features</span><span class="o">=</span><span class="p">()):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new feature list, with the specified features.</span>

<span class="sd">        :param features: The initial list of features for this feature</span>
<span class="sd">            list.  If ``features`` is a string, then it is paresd using</span>
<span class="sd">            ``FeatStructReader``.  Otherwise, it should be a sequence</span>
<span class="sd">            of basic values and nested feature structures.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">features</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
            <span class="n">FeatStructReader</span><span class="p">()</span><span class="o">.</span><span class="n">fromstring</span><span class="p">(</span><span class="n">features</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">list</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">features</span><span class="p">)</span>

    <span class="c">#////////////////////////////////////////////////////////////</span>
    <span class="c">#{ List methods</span>
    <span class="c">#////////////////////////////////////////////////////////////</span>
    <span class="n">_INDEX_ERROR</span> <span class="o">=</span> <span class="s">&quot;Expected int or feature path.  Got </span><span class="si">%r</span><span class="s">.&quot;</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name_or_path</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name_or_path</span><span class="p">,</span> <span class="n">integer_types</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">list</span><span class="o">.</span><span class="n">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name_or_path</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name_or_path</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">val</span> <span class="o">=</span> <span class="bp">self</span>
                <span class="k">for</span> <span class="n">fid</span> <span class="ow">in</span> <span class="n">name_or_path</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">FeatStruct</span><span class="p">):</span>
                        <span class="k">raise</span> <span class="ne">KeyError</span> <span class="c"># path contains base value</span>
                    <span class="n">val</span> <span class="o">=</span> <span class="n">val</span><span class="p">[</span><span class="n">fid</span><span class="p">]</span>
                <span class="k">return</span> <span class="n">val</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">KeyError</span><span class="p">,</span> <span class="ne">IndexError</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">name_or_path</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_INDEX_ERROR</span> <span class="o">%</span> <span class="n">name_or_path</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name_or_path</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;If the feature with the given name or path exists, delete</span>
<span class="sd">        its value; otherwise, raise ``KeyError``.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_frozen</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">_FROZEN_ERROR</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name_or_path</span><span class="p">,</span> <span class="p">(</span><span class="n">integer_types</span><span class="p">,</span> <span class="nb">slice</span><span class="p">)):</span>
            <span class="k">return</span> <span class="nb">list</span><span class="o">.</span><span class="n">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name_or_path</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name_or_path</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">name_or_path</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;The path () can not be set&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">name_or_path</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">FeatStruct</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">name_or_path</span><span class="p">)</span> <span class="c"># path contains base value</span>
                <span class="k">del</span> <span class="n">parent</span><span class="p">[</span><span class="n">name_or_path</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_INDEX_ERROR</span> <span class="o">%</span> <span class="n">name_or_path</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name_or_path</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the value for the feature with the given name or path</span>
<span class="sd">        to ``value``.  If ``name_or_path`` is an invalid path, raise</span>
<span class="sd">        ``KeyError``.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_frozen</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">_FROZEN_ERROR</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name_or_path</span><span class="p">,</span> <span class="p">(</span><span class="n">integer_types</span><span class="p">,</span> <span class="nb">slice</span><span class="p">)):</span>
            <span class="k">return</span> <span class="nb">list</span><span class="o">.</span><span class="n">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name_or_path</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name_or_path</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">name_or_path</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;The path () can not be set&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">name_or_path</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">FeatStruct</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">name_or_path</span><span class="p">)</span> <span class="c"># path contains base value</span>
                <span class="n">parent</span><span class="p">[</span><span class="n">name_or_path</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_INDEX_ERROR</span> <span class="o">%</span> <span class="n">name_or_path</span><span class="p">)</span>

<span class="c">#    __delslice__ = _check_frozen(list.__delslice__, &#39;               &#39;)</span>
<span class="c">#    __setslice__ = _check_frozen(list.__setslice__, &#39;               &#39;)</span>
    <span class="n">__iadd__</span> <span class="o">=</span> <span class="n">_check_frozen</span><span class="p">(</span><span class="nb">list</span><span class="o">.</span><span class="n">__iadd__</span><span class="p">)</span>
    <span class="n">__imul__</span> <span class="o">=</span> <span class="n">_check_frozen</span><span class="p">(</span><span class="nb">list</span><span class="o">.</span><span class="n">__imul__</span><span class="p">)</span>
    <span class="n">append</span> <span class="o">=</span> <span class="n">_check_frozen</span><span class="p">(</span><span class="nb">list</span><span class="o">.</span><span class="n">append</span><span class="p">)</span>
    <span class="n">extend</span> <span class="o">=</span> <span class="n">_check_frozen</span><span class="p">(</span><span class="nb">list</span><span class="o">.</span><span class="n">extend</span><span class="p">)</span>
    <span class="n">insert</span> <span class="o">=</span> <span class="n">_check_frozen</span><span class="p">(</span><span class="nb">list</span><span class="o">.</span><span class="n">insert</span><span class="p">)</span>
    <span class="n">pop</span> <span class="o">=</span> <span class="n">_check_frozen</span><span class="p">(</span><span class="nb">list</span><span class="o">.</span><span class="n">pop</span><span class="p">)</span>
    <span class="n">remove</span> <span class="o">=</span> <span class="n">_check_frozen</span><span class="p">(</span><span class="nb">list</span><span class="o">.</span><span class="n">remove</span><span class="p">)</span>
    <span class="n">reverse</span> <span class="o">=</span> <span class="n">_check_frozen</span><span class="p">(</span><span class="nb">list</span><span class="o">.</span><span class="n">reverse</span><span class="p">)</span>
    <span class="n">sort</span> <span class="o">=</span> <span class="n">_check_frozen</span><span class="p">(</span><span class="nb">list</span><span class="o">.</span><span class="n">sort</span><span class="p">)</span>

    <span class="c">##////////////////////////////////////////////////////////////</span>
    <span class="c">#{ Copying</span>
    <span class="c">##////////////////////////////////////////////////////////////</span>

    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="p">):</span>
        <span class="n">memo</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)]</span> <span class="o">=</span> <span class="n">selfcopy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">()</span>
        <span class="n">selfcopy</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">fval</span><span class="p">,</span><span class="n">memo</span><span class="p">)</span> <span class="k">for</span> <span class="n">fval</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">selfcopy</span>

    <span class="c">##////////////////////////////////////////////////////////////</span>
    <span class="c">#{ Uniform Accessor Methods</span>
    <span class="c">##////////////////////////////////////////////////////////////</span>

    <span class="k">def</span> <span class="nf">_keys</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)))</span>
    <span class="k">def</span> <span class="nf">_values</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span>
    <span class="k">def</span> <span class="nf">_items</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="c">##////////////////////////////////////////////////////////////</span>
    <span class="c">#{ String Representations</span>
    <span class="c">##////////////////////////////////////////////////////////////</span>

    <span class="c"># Special handling for: reentrances, variables, expressions.</span>
    <span class="k">def</span> <span class="nf">_repr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reentrances</span><span class="p">,</span> <span class="n">reentrance_ids</span><span class="p">):</span>
        <span class="c"># If this is the first time we&#39;ve seen a reentrant structure,</span>
        <span class="c"># then assign it a unique identifier.</span>
        <span class="k">if</span> <span class="n">reentrances</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)]:</span>
            <span class="k">assert</span> <span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">reentrance_ids</span>
            <span class="n">reentrance_ids</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)]</span> <span class="o">=</span> <span class="nb">repr</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">reentrance_ids</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">prefix</span> <span class="o">=</span> <span class="s">&#39;(</span><span class="si">%s</span><span class="s">)&#39;</span> <span class="o">%</span> <span class="n">reentrance_ids</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">prefix</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>

        <span class="n">segments</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">fval</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">id</span><span class="p">(</span><span class="n">fval</span><span class="p">)</span> <span class="ow">in</span> <span class="n">reentrance_ids</span><span class="p">:</span>
                <span class="n">segments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;-&gt;(</span><span class="si">%s</span><span class="s">)&#39;</span> <span class="o">%</span> <span class="n">reentrance_ids</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="n">fval</span><span class="p">)])</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fval</span><span class="p">,</span> <span class="n">Variable</span><span class="p">):</span>
                <span class="n">segments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fval</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fval</span><span class="p">,</span> <span class="n">Expression</span><span class="p">):</span>
                <span class="n">segments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">fval</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fval</span><span class="p">,</span> <span class="n">FeatStruct</span><span class="p">):</span>
                <span class="n">segments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fval</span><span class="o">.</span><span class="n">_repr</span><span class="p">(</span><span class="n">reentrances</span><span class="p">,</span> <span class="n">reentrance_ids</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">segments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">unicode_repr</span><span class="p">(</span><span class="n">fval</span><span class="p">))</span>

        <span class="k">return</span> <span class="s">&#39;</span><span class="si">%s</span><span class="s">[</span><span class="si">%s</span><span class="s">]&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">prefix</span><span class="p">,</span> <span class="s">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">segments</span><span class="p">))</span>

<span class="c">######################################################################</span>
<span class="c"># Variables &amp; Bindings</span>
<span class="c">######################################################################</span>
</div>
<span class="k">def</span> <span class="nf">substitute_bindings</span><span class="p">(</span><span class="n">fstruct</span><span class="p">,</span> <span class="n">bindings</span><span class="p">,</span> <span class="n">fs_class</span><span class="o">=</span><span class="s">&#39;default&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the feature structure that is obtained by replacing each</span>
<span class="sd">    variable bound by ``bindings`` with its binding.  If a variable is</span>
<span class="sd">    aliased to a bound variable, then it will be replaced by that</span>
<span class="sd">    variable&#39;s value.  If a variable is aliased to an unbound</span>
<span class="sd">    variable, then it will be replaced by that variable.</span>

<span class="sd">    :type bindings: dict(Variable -&gt; any)</span>
<span class="sd">    :param bindings: A dictionary mapping from variables to values.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">fs_class</span> <span class="o">==</span> <span class="s">&#39;default&#39;</span><span class="p">:</span> <span class="n">fs_class</span> <span class="o">=</span> <span class="n">_default_fs_class</span><span class="p">(</span><span class="n">fstruct</span><span class="p">)</span>
    <span class="n">fstruct</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">fstruct</span><span class="p">)</span>
    <span class="n">_substitute_bindings</span><span class="p">(</span><span class="n">fstruct</span><span class="p">,</span> <span class="n">bindings</span><span class="p">,</span> <span class="n">fs_class</span><span class="p">,</span> <span class="nb">set</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">fstruct</span>

<span class="k">def</span> <span class="nf">_substitute_bindings</span><span class="p">(</span><span class="n">fstruct</span><span class="p">,</span> <span class="n">bindings</span><span class="p">,</span> <span class="n">fs_class</span><span class="p">,</span> <span class="n">visited</span><span class="p">):</span>
    <span class="c"># Visit each node only once:</span>
    <span class="k">if</span> <span class="nb">id</span><span class="p">(</span><span class="n">fstruct</span><span class="p">)</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span> <span class="k">return</span>
    <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">fstruct</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">_is_mapping</span><span class="p">(</span><span class="n">fstruct</span><span class="p">):</span> <span class="n">items</span> <span class="o">=</span> <span class="n">fstruct</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">_is_sequence</span><span class="p">(</span><span class="n">fstruct</span><span class="p">):</span> <span class="n">items</span> <span class="o">=</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">fstruct</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Expected mapping or sequence&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">fval</span><span class="p">)</span> <span class="ow">in</span> <span class="n">items</span><span class="p">:</span>
        <span class="k">while</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">fval</span><span class="p">,</span> <span class="n">Variable</span><span class="p">)</span> <span class="ow">and</span> <span class="n">fval</span> <span class="ow">in</span> <span class="n">bindings</span><span class="p">):</span>
            <span class="n">fval</span> <span class="o">=</span> <span class="n">fstruct</span><span class="p">[</span><span class="n">fname</span><span class="p">]</span> <span class="o">=</span> <span class="n">bindings</span><span class="p">[</span><span class="n">fval</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fval</span><span class="p">,</span> <span class="n">fs_class</span><span class="p">):</span>
            <span class="n">_substitute_bindings</span><span class="p">(</span><span class="n">fval</span><span class="p">,</span> <span class="n">bindings</span><span class="p">,</span> <span class="n">fs_class</span><span class="p">,</span> <span class="n">visited</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fval</span><span class="p">,</span> <span class="n">SubstituteBindingsI</span><span class="p">):</span>
            <span class="n">fstruct</span><span class="p">[</span><span class="n">fname</span><span class="p">]</span> <span class="o">=</span> <span class="n">fval</span><span class="o">.</span><span class="n">substitute_bindings</span><span class="p">(</span><span class="n">bindings</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">retract_bindings</span><span class="p">(</span><span class="n">fstruct</span><span class="p">,</span> <span class="n">bindings</span><span class="p">,</span> <span class="n">fs_class</span><span class="o">=</span><span class="s">&#39;default&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the feature structure that is obtained by replacing each</span>
<span class="sd">    feature structure value that is bound by ``bindings`` with the</span>
<span class="sd">    variable that binds it.  A feature structure value must be</span>
<span class="sd">    identical to a bound value (i.e., have equal id) to be replaced.</span>

<span class="sd">    ``bindings`` is modified to point to this new feature structure,</span>
<span class="sd">    rather than the original feature structure.  Feature structure</span>
<span class="sd">    values in ``bindings`` may be modified if they are contained in</span>
<span class="sd">    ``fstruct``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">fs_class</span> <span class="o">==</span> <span class="s">&#39;default&#39;</span><span class="p">:</span> <span class="n">fs_class</span> <span class="o">=</span> <span class="n">_default_fs_class</span><span class="p">(</span><span class="n">fstruct</span><span class="p">)</span>
    <span class="p">(</span><span class="n">fstruct</span><span class="p">,</span> <span class="n">new_bindings</span><span class="p">)</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">((</span><span class="n">fstruct</span><span class="p">,</span> <span class="n">bindings</span><span class="p">))</span>
    <span class="n">bindings</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">new_bindings</span><span class="p">)</span>
    <span class="n">inv_bindings</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="nb">id</span><span class="p">(</span><span class="n">val</span><span class="p">),</span><span class="n">var</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">var</span><span class="p">,</span><span class="n">val</span><span class="p">)</span> <span class="ow">in</span> <span class="n">bindings</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
    <span class="n">_retract_bindings</span><span class="p">(</span><span class="n">fstruct</span><span class="p">,</span> <span class="n">inv_bindings</span><span class="p">,</span> <span class="n">fs_class</span><span class="p">,</span> <span class="nb">set</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">fstruct</span>

<span class="k">def</span> <span class="nf">_retract_bindings</span><span class="p">(</span><span class="n">fstruct</span><span class="p">,</span> <span class="n">inv_bindings</span><span class="p">,</span> <span class="n">fs_class</span><span class="p">,</span> <span class="n">visited</span><span class="p">):</span>
    <span class="c"># Visit each node only once:</span>
    <span class="k">if</span> <span class="nb">id</span><span class="p">(</span><span class="n">fstruct</span><span class="p">)</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span> <span class="k">return</span>
    <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">fstruct</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">_is_mapping</span><span class="p">(</span><span class="n">fstruct</span><span class="p">):</span> <span class="n">items</span> <span class="o">=</span> <span class="n">fstruct</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">_is_sequence</span><span class="p">(</span><span class="n">fstruct</span><span class="p">):</span> <span class="n">items</span> <span class="o">=</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">fstruct</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Expected mapping or sequence&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">fval</span><span class="p">)</span> <span class="ow">in</span> <span class="n">items</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fval</span><span class="p">,</span> <span class="n">fs_class</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">id</span><span class="p">(</span><span class="n">fval</span><span class="p">)</span> <span class="ow">in</span> <span class="n">inv_bindings</span><span class="p">:</span>
                <span class="n">fstruct</span><span class="p">[</span><span class="n">fname</span><span class="p">]</span> <span class="o">=</span> <span class="n">inv_bindings</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="n">fval</span><span class="p">)]</span>
            <span class="n">_retract_bindings</span><span class="p">(</span><span class="n">fval</span><span class="p">,</span> <span class="n">inv_bindings</span><span class="p">,</span> <span class="n">fs_class</span><span class="p">,</span> <span class="n">visited</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">find_variables</span><span class="p">(</span><span class="n">fstruct</span><span class="p">,</span> <span class="n">fs_class</span><span class="o">=</span><span class="s">&#39;default&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    :return: The set of variables used by this feature structure.</span>
<span class="sd">    :rtype: set(Variable)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">fs_class</span> <span class="o">==</span> <span class="s">&#39;default&#39;</span><span class="p">:</span> <span class="n">fs_class</span> <span class="o">=</span> <span class="n">_default_fs_class</span><span class="p">(</span><span class="n">fstruct</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_variables</span><span class="p">(</span><span class="n">fstruct</span><span class="p">,</span> <span class="nb">set</span><span class="p">(),</span> <span class="n">fs_class</span><span class="p">,</span> <span class="nb">set</span><span class="p">())</span>

<span class="k">def</span> <span class="nf">_variables</span><span class="p">(</span><span class="n">fstruct</span><span class="p">,</span> <span class="nb">vars</span><span class="p">,</span> <span class="n">fs_class</span><span class="p">,</span> <span class="n">visited</span><span class="p">):</span>
    <span class="c"># Visit each node only once:</span>
    <span class="k">if</span> <span class="nb">id</span><span class="p">(</span><span class="n">fstruct</span><span class="p">)</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span> <span class="k">return</span>
    <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">fstruct</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">_is_mapping</span><span class="p">(</span><span class="n">fstruct</span><span class="p">):</span> <span class="n">items</span> <span class="o">=</span> <span class="n">fstruct</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">_is_sequence</span><span class="p">(</span><span class="n">fstruct</span><span class="p">):</span> <span class="n">items</span> <span class="o">=</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">fstruct</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Expected mapping or sequence&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">fval</span><span class="p">)</span> <span class="ow">in</span> <span class="n">items</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fval</span><span class="p">,</span> <span class="n">Variable</span><span class="p">):</span>
            <span class="nb">vars</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">fval</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fval</span><span class="p">,</span> <span class="n">fs_class</span><span class="p">):</span>
            <span class="n">_variables</span><span class="p">(</span><span class="n">fval</span><span class="p">,</span> <span class="nb">vars</span><span class="p">,</span> <span class="n">fs_class</span><span class="p">,</span> <span class="n">visited</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fval</span><span class="p">,</span> <span class="n">SubstituteBindingsI</span><span class="p">):</span>
            <span class="nb">vars</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">fval</span><span class="o">.</span><span class="n">variables</span><span class="p">())</span>
    <span class="k">return</span> <span class="nb">vars</span>

<span class="k">def</span> <span class="nf">rename_variables</span><span class="p">(</span><span class="n">fstruct</span><span class="p">,</span> <span class="nb">vars</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">used_vars</span><span class="o">=</span><span class="p">(),</span> <span class="n">new_vars</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                     <span class="n">fs_class</span><span class="o">=</span><span class="s">&#39;default&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the feature structure that is obtained by replacing</span>
<span class="sd">    any of this feature structure&#39;s variables that are in ``vars``</span>
<span class="sd">    with new variables.  The names for these new variables will be</span>
<span class="sd">    names that are not used by any variable in ``vars``, or in</span>
<span class="sd">    ``used_vars``, or in this feature structure.</span>

<span class="sd">    :type vars: set</span>
<span class="sd">    :param vars: The set of variables that should be renamed.</span>
<span class="sd">        If not specified, ``find_variables(fstruct)`` is used; i.e., all</span>
<span class="sd">        variables will be given new names.</span>
<span class="sd">    :type used_vars: set</span>
<span class="sd">    :param used_vars: A set of variables whose names should not be</span>
<span class="sd">        used by the new variables.</span>
<span class="sd">    :type new_vars: dict(Variable -&gt; Variable)</span>
<span class="sd">    :param new_vars: A dictionary that is used to hold the mapping</span>
<span class="sd">        from old variables to new variables.  For each variable *v*</span>
<span class="sd">        in this feature structure:</span>

<span class="sd">        - If ``new_vars`` maps *v* to *v&#39;*, then *v* will be</span>
<span class="sd">          replaced by *v&#39;*.</span>
<span class="sd">        - If ``new_vars`` does not contain *v*, but ``vars``</span>
<span class="sd">          does contain *v*, then a new entry will be added to</span>
<span class="sd">          ``new_vars``, mapping *v* to the new variable that is used</span>
<span class="sd">          to replace it.</span>

<span class="sd">    To consistently rename the variables in a set of feature</span>
<span class="sd">    structures, simply apply rename_variables to each one, using</span>
<span class="sd">    the same dictionary:</span>

<span class="sd">        &gt;&gt;&gt; from nltk.featstruct import FeatStruct</span>
<span class="sd">        &gt;&gt;&gt; fstruct1 = FeatStruct(&#39;[subj=[agr=[gender=?y]], obj=[agr=[gender=?y]]]&#39;)</span>
<span class="sd">        &gt;&gt;&gt; fstruct2 = FeatStruct(&#39;[subj=[agr=[number=?z,gender=?y]], obj=[agr=[number=?z,gender=?y]]]&#39;)</span>
<span class="sd">        &gt;&gt;&gt; new_vars = {}  # Maps old vars to alpha-renamed vars</span>
<span class="sd">        &gt;&gt;&gt; fstruct1.rename_variables(new_vars=new_vars)</span>
<span class="sd">        [obj=[agr=[gender=?y2]], subj=[agr=[gender=?y2]]]</span>
<span class="sd">        &gt;&gt;&gt; fstruct2.rename_variables(new_vars=new_vars)</span>
<span class="sd">        [obj=[agr=[gender=?y2, number=?z2]], subj=[agr=[gender=?y2, number=?z2]]]</span>

<span class="sd">    If new_vars is not specified, then an empty dictionary is used.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">fs_class</span> <span class="o">==</span> <span class="s">&#39;default&#39;</span><span class="p">:</span> <span class="n">fs_class</span> <span class="o">=</span> <span class="n">_default_fs_class</span><span class="p">(</span><span class="n">fstruct</span><span class="p">)</span>

    <span class="c"># Default values:</span>
    <span class="k">if</span> <span class="n">new_vars</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span> <span class="n">new_vars</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">if</span> <span class="nb">vars</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span> <span class="nb">vars</span> <span class="o">=</span> <span class="n">find_variables</span><span class="p">(</span><span class="n">fstruct</span><span class="p">,</span> <span class="n">fs_class</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span> <span class="nb">vars</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">vars</span><span class="p">)</span>

    <span class="c"># Add our own variables to used_vars.</span>
    <span class="n">used_vars</span> <span class="o">=</span> <span class="n">find_variables</span><span class="p">(</span><span class="n">fstruct</span><span class="p">,</span> <span class="n">fs_class</span><span class="p">)</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">used_vars</span><span class="p">)</span>

    <span class="c"># Copy ourselves, and rename variables in the copy.</span>
    <span class="k">return</span> <span class="n">_rename_variables</span><span class="p">(</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">fstruct</span><span class="p">),</span> <span class="nb">vars</span><span class="p">,</span> <span class="n">used_vars</span><span class="p">,</span>
                             <span class="n">new_vars</span><span class="p">,</span> <span class="n">fs_class</span><span class="p">,</span> <span class="nb">set</span><span class="p">())</span>

<span class="k">def</span> <span class="nf">_rename_variables</span><span class="p">(</span><span class="n">fstruct</span><span class="p">,</span> <span class="nb">vars</span><span class="p">,</span> <span class="n">used_vars</span><span class="p">,</span> <span class="n">new_vars</span><span class="p">,</span> <span class="n">fs_class</span><span class="p">,</span> <span class="n">visited</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">id</span><span class="p">(</span><span class="n">fstruct</span><span class="p">)</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span> <span class="k">return</span>
    <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">fstruct</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">_is_mapping</span><span class="p">(</span><span class="n">fstruct</span><span class="p">):</span> <span class="n">items</span> <span class="o">=</span> <span class="n">fstruct</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">_is_sequence</span><span class="p">(</span><span class="n">fstruct</span><span class="p">):</span> <span class="n">items</span> <span class="o">=</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">fstruct</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Expected mapping or sequence&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">fval</span><span class="p">)</span> <span class="ow">in</span> <span class="n">items</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fval</span><span class="p">,</span> <span class="n">Variable</span><span class="p">):</span>
            <span class="c"># If it&#39;s in new_vars, then rebind it.</span>
            <span class="k">if</span> <span class="n">fval</span> <span class="ow">in</span> <span class="n">new_vars</span><span class="p">:</span>
                <span class="n">fstruct</span><span class="p">[</span><span class="n">fname</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_vars</span><span class="p">[</span><span class="n">fval</span><span class="p">]</span>
            <span class="c"># If it&#39;s in vars, pick a new name for it.</span>
            <span class="k">elif</span> <span class="n">fval</span> <span class="ow">in</span> <span class="nb">vars</span><span class="p">:</span>
                <span class="n">new_vars</span><span class="p">[</span><span class="n">fval</span><span class="p">]</span> <span class="o">=</span> <span class="n">_rename_variable</span><span class="p">(</span><span class="n">fval</span><span class="p">,</span> <span class="n">used_vars</span><span class="p">)</span>
                <span class="n">fstruct</span><span class="p">[</span><span class="n">fname</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_vars</span><span class="p">[</span><span class="n">fval</span><span class="p">]</span>
                <span class="n">used_vars</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">new_vars</span><span class="p">[</span><span class="n">fval</span><span class="p">])</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fval</span><span class="p">,</span> <span class="n">fs_class</span><span class="p">):</span>
            <span class="n">_rename_variables</span><span class="p">(</span><span class="n">fval</span><span class="p">,</span> <span class="nb">vars</span><span class="p">,</span> <span class="n">used_vars</span><span class="p">,</span> <span class="n">new_vars</span><span class="p">,</span>
                              <span class="n">fs_class</span><span class="p">,</span> <span class="n">visited</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fval</span><span class="p">,</span> <span class="n">SubstituteBindingsI</span><span class="p">):</span>
            <span class="c"># Pick new names for any variables in `vars`</span>
            <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">fval</span><span class="o">.</span><span class="n">variables</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">var</span> <span class="ow">in</span> <span class="nb">vars</span> <span class="ow">and</span> <span class="n">var</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">new_vars</span><span class="p">:</span>
                    <span class="n">new_vars</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="n">_rename_variable</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">used_vars</span><span class="p">)</span>
                    <span class="n">used_vars</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">new_vars</span><span class="p">[</span><span class="n">var</span><span class="p">])</span>
            <span class="c"># Replace all variables in `new_vars`.</span>
            <span class="n">fstruct</span><span class="p">[</span><span class="n">fname</span><span class="p">]</span> <span class="o">=</span> <span class="n">fval</span><span class="o">.</span><span class="n">substitute_bindings</span><span class="p">(</span><span class="n">new_vars</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">fstruct</span>

<span class="k">def</span> <span class="nf">_rename_variable</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">used_vars</span><span class="p">):</span>
    <span class="n">name</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s">&#39;\d+$&#39;</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="p">,</span> <span class="n">var</span><span class="o">.</span><span class="n">name</span><span class="p">),</span> <span class="mi">2</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">name</span><span class="p">:</span> <span class="n">name</span> <span class="o">=</span> <span class="s">&#39;?&#39;</span>
    <span class="k">while</span> <span class="n">Variable</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%s%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span> <span class="ow">in</span> <span class="n">used_vars</span><span class="p">:</span> <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">Variable</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%s%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">remove_variables</span><span class="p">(</span><span class="n">fstruct</span><span class="p">,</span> <span class="n">fs_class</span><span class="o">=</span><span class="s">&#39;default&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    :rtype: FeatStruct</span>
<span class="sd">    :return: The feature structure that is obtained by deleting</span>
<span class="sd">        all features whose values are ``Variables``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">fs_class</span> <span class="o">==</span> <span class="s">&#39;default&#39;</span><span class="p">:</span> <span class="n">fs_class</span> <span class="o">=</span> <span class="n">_default_fs_class</span><span class="p">(</span><span class="n">fstruct</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_remove_variables</span><span class="p">(</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">fstruct</span><span class="p">),</span> <span class="n">fs_class</span><span class="p">,</span> <span class="nb">set</span><span class="p">())</span>

<span class="k">def</span> <span class="nf">_remove_variables</span><span class="p">(</span><span class="n">fstruct</span><span class="p">,</span> <span class="n">fs_class</span><span class="p">,</span> <span class="n">visited</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">id</span><span class="p">(</span><span class="n">fstruct</span><span class="p">)</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
        <span class="k">return</span>
    <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">fstruct</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">_is_mapping</span><span class="p">(</span><span class="n">fstruct</span><span class="p">):</span>
        <span class="n">items</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">fstruct</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
    <span class="k">elif</span> <span class="n">_is_sequence</span><span class="p">(</span><span class="n">fstruct</span><span class="p">):</span>
        <span class="n">items</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="n">fstruct</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Expected mapping or sequence&#39;</span><span class="p">)</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">fval</span><span class="p">)</span> <span class="ow">in</span> <span class="n">items</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fval</span><span class="p">,</span> <span class="n">Variable</span><span class="p">):</span>
            <span class="k">del</span> <span class="n">fstruct</span><span class="p">[</span><span class="n">fname</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fval</span><span class="p">,</span> <span class="n">fs_class</span><span class="p">):</span>
            <span class="n">_remove_variables</span><span class="p">(</span><span class="n">fval</span><span class="p">,</span> <span class="n">fs_class</span><span class="p">,</span> <span class="n">visited</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">fstruct</span>


<span class="c">######################################################################</span>
<span class="c"># Unification</span>
<span class="c">######################################################################</span>

<span class="nd">@python_2_unicode_compatible</span>
<span class="k">class</span> <span class="nc">_UnificationFailure</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&#39;nltk.featstruct.UnificationFailure&#39;</span>

<span class="n">UnificationFailure</span> <span class="o">=</span> <span class="n">_UnificationFailure</span><span class="p">()</span>
<span class="sd">&quot;&quot;&quot;A unique value used to indicate unification failure.  It can be</span>
<span class="sd">   returned by ``Feature.unify_base_values()`` or by custom ``fail()``</span>
<span class="sd">   functions to indicate that unificaiton should fail.&quot;&quot;&quot;</span>

<span class="c"># The basic unification algorithm:</span>
<span class="c">#   1. Make copies of self and other (preserving reentrance)</span>
<span class="c">#   2. Destructively unify self and other</span>
<span class="c">#   3. Apply forward pointers, to preserve reentrance.</span>
<span class="c">#   4. Replace bound variables with their values.</span>
<div class="viewcode-block" id="unify"><a class="viewcode-back" href="../../api/nltk.html#nltk.featstruct.unify">[docs]</a><span class="k">def</span> <span class="nf">unify</span><span class="p">(</span><span class="n">fstruct1</span><span class="p">,</span> <span class="n">fstruct2</span><span class="p">,</span> <span class="n">bindings</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">trace</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
          <span class="n">fail</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">rename_vars</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">fs_class</span><span class="o">=</span><span class="s">&#39;default&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Unify ``fstruct1`` with ``fstruct2``, and return the resulting feature</span>
<span class="sd">    structure.  This unified feature structure is the minimal</span>
<span class="sd">    feature structure that contains all feature value assignments from both</span>
<span class="sd">    ``fstruct1`` and ``fstruct2``, and that preserves all reentrancies.</span>

<span class="sd">    If no such feature structure exists (because ``fstruct1`` and</span>
<span class="sd">    ``fstruct2`` specify incompatible values for some feature), then</span>
<span class="sd">    unification fails, and ``unify`` returns None.</span>

<span class="sd">    Bound variables are replaced by their values.  Aliased</span>
<span class="sd">    variables are replaced by their representative variable</span>
<span class="sd">    (if unbound) or the value of their representative variable</span>
<span class="sd">    (if bound).  I.e., if variable *v* is in ``bindings``,</span>
<span class="sd">    then *v* is replaced by ``bindings[v]``.  This will</span>
<span class="sd">    be repeated until the variable is replaced by an unbound</span>
<span class="sd">    variable or a non-variable value.</span>

<span class="sd">    Unbound variables are bound when they are unified with</span>
<span class="sd">    values; and aliased when they are unified with variables.</span>
<span class="sd">    I.e., if variable *v* is not in ``bindings``, and is</span>
<span class="sd">    unified with a variable or value *x*, then</span>
<span class="sd">    ``bindings[v]`` is set to *x*.</span>

<span class="sd">    If ``bindings`` is unspecified, then all variables are</span>
<span class="sd">    assumed to be unbound.  I.e., ``bindings`` defaults to an</span>
<span class="sd">    empty dict.</span>

<span class="sd">        &gt;&gt;&gt; from nltk.featstruct import FeatStruct</span>
<span class="sd">        &gt;&gt;&gt; FeatStruct(&#39;[a=?x]&#39;).unify(FeatStruct(&#39;[b=?x]&#39;))</span>
<span class="sd">        [a=?x, b=?x2]</span>

<span class="sd">    :type bindings: dict(Variable -&gt; any)</span>
<span class="sd">    :param bindings: A set of variable bindings to be used and</span>
<span class="sd">        updated during unification.</span>
<span class="sd">    :type trace: bool</span>
<span class="sd">    :param trace: If true, generate trace output.</span>
<span class="sd">    :type rename_vars: bool</span>
<span class="sd">    :param rename_vars: If True, then rename any variables in</span>
<span class="sd">        ``fstruct2`` that are also used in ``fstruct1``, in order to</span>
<span class="sd">        avoid collisions on variable names.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># Decide which class(es) will be treated as feature structures,</span>
    <span class="c"># for the purposes of unification.</span>
    <span class="k">if</span> <span class="n">fs_class</span> <span class="o">==</span> <span class="s">&#39;default&#39;</span><span class="p">:</span>
        <span class="n">fs_class</span> <span class="o">=</span> <span class="n">_default_fs_class</span><span class="p">(</span><span class="n">fstruct1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">_default_fs_class</span><span class="p">(</span><span class="n">fstruct2</span><span class="p">)</span> <span class="o">!=</span> <span class="n">fs_class</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Mixing FeatStruct objects with Python &quot;</span>
                             <span class="s">&quot;dicts and lists is not supported.&quot;</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fstruct1</span><span class="p">,</span> <span class="n">fs_class</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fstruct2</span><span class="p">,</span> <span class="n">fs_class</span><span class="p">)</span>

    <span class="c"># If bindings are unspecified, use an empty set of bindings.</span>
    <span class="n">user_bindings</span> <span class="o">=</span> <span class="p">(</span><span class="n">bindings</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">bindings</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span> <span class="n">bindings</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="c"># Make copies of fstruct1 and fstruct2 (since the unification</span>
    <span class="c"># algorithm is destructive). Do it all at once, to preserve</span>
    <span class="c"># reentrance links between fstruct1 and fstruct2.  Copy bindings</span>
    <span class="c"># as well, in case there are any bound vars that contain parts</span>
    <span class="c"># of fstruct1 or fstruct2.</span>
    <span class="p">(</span><span class="n">fstruct1copy</span><span class="p">,</span> <span class="n">fstruct2copy</span><span class="p">,</span> <span class="n">bindings_copy</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">((</span><span class="n">fstruct1</span><span class="p">,</span> <span class="n">fstruct2</span><span class="p">,</span> <span class="n">bindings</span><span class="p">)))</span>

    <span class="c"># Copy the bindings back to the original bindings dict.</span>
    <span class="n">bindings</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">bindings_copy</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">rename_vars</span><span class="p">:</span>
        <span class="n">vars1</span> <span class="o">=</span> <span class="n">find_variables</span><span class="p">(</span><span class="n">fstruct1copy</span><span class="p">,</span> <span class="n">fs_class</span><span class="p">)</span>
        <span class="n">vars2</span> <span class="o">=</span> <span class="n">find_variables</span><span class="p">(</span><span class="n">fstruct2copy</span><span class="p">,</span> <span class="n">fs_class</span><span class="p">)</span>
        <span class="n">_rename_variables</span><span class="p">(</span><span class="n">fstruct2copy</span><span class="p">,</span> <span class="n">vars1</span><span class="p">,</span> <span class="n">vars2</span><span class="p">,</span> <span class="p">{},</span> <span class="n">fs_class</span><span class="p">,</span> <span class="nb">set</span><span class="p">())</span>

    <span class="c"># Do the actual unification.  If it fails, return None.</span>
    <span class="n">forward</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">if</span> <span class="n">trace</span><span class="p">:</span> <span class="n">_trace_unify_start</span><span class="p">((),</span> <span class="n">fstruct1copy</span><span class="p">,</span> <span class="n">fstruct2copy</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span> <span class="n">result</span> <span class="o">=</span> <span class="n">_destructively_unify</span><span class="p">(</span><span class="n">fstruct1copy</span><span class="p">,</span> <span class="n">fstruct2copy</span><span class="p">,</span> <span class="n">bindings</span><span class="p">,</span>
                                       <span class="n">forward</span><span class="p">,</span> <span class="n">trace</span><span class="p">,</span> <span class="n">fail</span><span class="p">,</span> <span class="n">fs_class</span><span class="p">,</span> <span class="p">())</span>
    <span class="k">except</span> <span class="n">_UnificationFailureError</span><span class="p">:</span> <span class="k">return</span> <span class="bp">None</span>

    <span class="c"># _destructively_unify might return UnificationFailure, e.g. if we</span>
    <span class="c"># tried to unify a mapping with a sequence.</span>
    <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="n">UnificationFailure</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">fail</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span> <span class="k">return</span> <span class="bp">None</span>
        <span class="k">else</span><span class="p">:</span> <span class="k">return</span> <span class="n">fail</span><span class="p">(</span><span class="n">fstruct1copy</span><span class="p">,</span> <span class="n">fstruct2copy</span><span class="p">,</span> <span class="p">())</span>

    <span class="c"># Replace any feature structure that has a forward pointer</span>
    <span class="c"># with the target of its forward pointer.</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">_apply_forwards</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">forward</span><span class="p">,</span> <span class="n">fs_class</span><span class="p">,</span> <span class="nb">set</span><span class="p">())</span>
    <span class="k">if</span> <span class="n">user_bindings</span><span class="p">:</span> <span class="n">_apply_forwards_to_bindings</span><span class="p">(</span><span class="n">forward</span><span class="p">,</span> <span class="n">bindings</span><span class="p">)</span>

    <span class="c"># Replace bound vars with values.</span>
    <span class="n">_resolve_aliases</span><span class="p">(</span><span class="n">bindings</span><span class="p">)</span>
    <span class="n">_substitute_bindings</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">bindings</span><span class="p">,</span> <span class="n">fs_class</span><span class="p">,</span> <span class="nb">set</span><span class="p">())</span>

    <span class="c"># Return the result.</span>
    <span class="k">if</span> <span class="n">trace</span><span class="p">:</span> <span class="n">_trace_unify_succeed</span><span class="p">((),</span> <span class="n">result</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">trace</span><span class="p">:</span> <span class="n">_trace_bindings</span><span class="p">((),</span> <span class="n">bindings</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span>
</div>
<span class="k">class</span> <span class="nc">_UnificationFailureError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;An exception that is used by ``_destructively_unify`` to abort</span>
<span class="sd">    unification when a failure is encountered.&quot;&quot;&quot;</span>

<span class="k">def</span> <span class="nf">_destructively_unify</span><span class="p">(</span><span class="n">fstruct1</span><span class="p">,</span> <span class="n">fstruct2</span><span class="p">,</span> <span class="n">bindings</span><span class="p">,</span> <span class="n">forward</span><span class="p">,</span>
                         <span class="n">trace</span><span class="p">,</span> <span class="n">fail</span><span class="p">,</span> <span class="n">fs_class</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Attempt to unify ``fstruct1`` and ``fstruct2`` by modifying them</span>
<span class="sd">    in-place.  If the unification succeeds, then ``fstruct1`` will</span>
<span class="sd">    contain the unified value, the value of ``fstruct2`` is undefined,</span>
<span class="sd">    and forward[id(fstruct2)] is set to fstruct1.  If the unification</span>
<span class="sd">    fails, then a _UnificationFailureError is raised, and the</span>
<span class="sd">    values of ``fstruct1`` and ``fstruct2`` are undefined.</span>

<span class="sd">    :param bindings: A dictionary mapping variables to values.</span>
<span class="sd">    :param forward: A dictionary mapping feature structures ids</span>
<span class="sd">        to replacement structures.  When two feature structures</span>
<span class="sd">        are merged, a mapping from one to the other will be added</span>
<span class="sd">        to the forward dictionary; and changes will be made only</span>
<span class="sd">        to the target of the forward dictionary.</span>
<span class="sd">        ``_destructively_unify`` will always &#39;follow&#39; any links</span>
<span class="sd">        in the forward dictionary for fstruct1 and fstruct2 before</span>
<span class="sd">        actually unifying them.</span>
<span class="sd">    :param trace: If true, generate trace output</span>
<span class="sd">    :param path: The feature path that led us to this unification</span>
<span class="sd">        step.  Used for trace output.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># If fstruct1 is already identical to fstruct2, we&#39;re done.</span>
    <span class="c"># Note: this, together with the forward pointers, ensures</span>
    <span class="c"># that unification will terminate even for cyclic structures.</span>
    <span class="k">if</span> <span class="n">fstruct1</span> <span class="ow">is</span> <span class="n">fstruct2</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">trace</span><span class="p">:</span> <span class="n">_trace_unify_identity</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">fstruct1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fstruct1</span>

    <span class="c"># Set fstruct2&#39;s forward pointer to point to fstruct1; this makes</span>
    <span class="c"># fstruct1 the canonical copy for fstruct2.  Note that we need to</span>
    <span class="c"># do this before we recurse into any child structures, in case</span>
    <span class="c"># they&#39;re cyclic.</span>
    <span class="n">forward</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="n">fstruct2</span><span class="p">)]</span> <span class="o">=</span> <span class="n">fstruct1</span>

    <span class="c"># Unifying two mappings:</span>
    <span class="k">if</span> <span class="n">_is_mapping</span><span class="p">(</span><span class="n">fstruct1</span><span class="p">)</span> <span class="ow">and</span> <span class="n">_is_mapping</span><span class="p">(</span><span class="n">fstruct2</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">fname</span> <span class="ow">in</span> <span class="n">fstruct1</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="s">&#39;default&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">fstruct2</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">fname</span><span class="o">.</span><span class="n">default</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">fname</span> <span class="ow">in</span> <span class="n">fstruct2</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="s">&#39;default&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">fstruct1</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">fname</span><span class="o">.</span><span class="n">default</span><span class="p">)</span>

        <span class="c"># Unify any values that are defined in both fstruct1 and</span>
        <span class="c"># fstruct2.  Copy any values that are defined in fstruct2 but</span>
        <span class="c"># not in fstruct1 to fstruct1.  Note: sorting fstruct2&#39;s</span>
        <span class="c"># features isn&#39;t actually necessary; but we do it to give</span>
        <span class="c"># deterministic behavior, e.g. for tracing.</span>
        <span class="k">for</span> <span class="n">fname</span><span class="p">,</span> <span class="n">fval2</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">fstruct2</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
            <span class="k">if</span> <span class="n">fname</span> <span class="ow">in</span> <span class="n">fstruct1</span><span class="p">:</span>
                <span class="n">fstruct1</span><span class="p">[</span><span class="n">fname</span><span class="p">]</span> <span class="o">=</span> <span class="n">_unify_feature_values</span><span class="p">(</span>
                    <span class="n">fname</span><span class="p">,</span> <span class="n">fstruct1</span><span class="p">[</span><span class="n">fname</span><span class="p">],</span> <span class="n">fval2</span><span class="p">,</span> <span class="n">bindings</span><span class="p">,</span>
                    <span class="n">forward</span><span class="p">,</span> <span class="n">trace</span><span class="p">,</span> <span class="n">fail</span><span class="p">,</span> <span class="n">fs_class</span><span class="p">,</span> <span class="n">path</span><span class="o">+</span><span class="p">(</span><span class="n">fname</span><span class="p">,))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">fstruct1</span><span class="p">[</span><span class="n">fname</span><span class="p">]</span> <span class="o">=</span> <span class="n">fval2</span>

        <span class="k">return</span> <span class="n">fstruct1</span> <span class="c"># Contains the unified value.</span>

    <span class="c"># Unifying two sequences:</span>
    <span class="k">elif</span> <span class="n">_is_sequence</span><span class="p">(</span><span class="n">fstruct1</span><span class="p">)</span> <span class="ow">and</span> <span class="n">_is_sequence</span><span class="p">(</span><span class="n">fstruct2</span><span class="p">):</span>
        <span class="c"># If the lengths don&#39;t match, fail.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">fstruct1</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">fstruct2</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">UnificationFailure</span>

        <span class="c"># Unify corresponding values in fstruct1 and fstruct2.</span>
        <span class="k">for</span> <span class="n">findex</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">fstruct1</span><span class="p">)):</span>
            <span class="n">fstruct1</span><span class="p">[</span><span class="n">findex</span><span class="p">]</span> <span class="o">=</span> <span class="n">_unify_feature_values</span><span class="p">(</span>
                <span class="n">findex</span><span class="p">,</span> <span class="n">fstruct1</span><span class="p">[</span><span class="n">findex</span><span class="p">],</span> <span class="n">fstruct2</span><span class="p">[</span><span class="n">findex</span><span class="p">],</span> <span class="n">bindings</span><span class="p">,</span>
                <span class="n">forward</span><span class="p">,</span> <span class="n">trace</span><span class="p">,</span> <span class="n">fail</span><span class="p">,</span> <span class="n">fs_class</span><span class="p">,</span> <span class="n">path</span><span class="o">+</span><span class="p">(</span><span class="n">findex</span><span class="p">,))</span>

        <span class="k">return</span> <span class="n">fstruct1</span> <span class="c"># Contains the unified value.</span>

    <span class="c"># Unifying sequence &amp; mapping: fail.  The failure function</span>
    <span class="c"># doesn&#39;t get a chance to recover in this case.</span>
    <span class="k">elif</span> <span class="p">((</span><span class="n">_is_sequence</span><span class="p">(</span><span class="n">fstruct1</span><span class="p">)</span> <span class="ow">or</span> <span class="n">_is_mapping</span><span class="p">(</span><span class="n">fstruct1</span><span class="p">))</span> <span class="ow">and</span>
          <span class="p">(</span><span class="n">_is_sequence</span><span class="p">(</span><span class="n">fstruct2</span><span class="p">)</span> <span class="ow">or</span> <span class="n">_is_mapping</span><span class="p">(</span><span class="n">fstruct2</span><span class="p">))):</span>
        <span class="k">return</span> <span class="n">UnificationFailure</span>

    <span class="c"># Unifying anything else: not allowed!</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;Expected mappings or sequences&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_unify_feature_values</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">fval1</span><span class="p">,</span> <span class="n">fval2</span><span class="p">,</span> <span class="n">bindings</span><span class="p">,</span> <span class="n">forward</span><span class="p">,</span>
                          <span class="n">trace</span><span class="p">,</span> <span class="n">fail</span><span class="p">,</span> <span class="n">fs_class</span><span class="p">,</span> <span class="n">fpath</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Attempt to unify ``fval1`` and and ``fval2``, and return the</span>
<span class="sd">    resulting unified value.  The method of unification will depend on</span>
<span class="sd">    the types of ``fval1`` and ``fval2``:</span>

<span class="sd">      1. If they&#39;re both feature structures, then destructively</span>
<span class="sd">         unify them (see ``_destructively_unify()``.</span>
<span class="sd">      2. If they&#39;re both unbound variables, then alias one variable</span>
<span class="sd">         to the other (by setting bindings[v2]=v1).</span>
<span class="sd">      3. If one is an unbound variable, and the other is a value,</span>
<span class="sd">         then bind the unbound variable to the value.</span>
<span class="sd">      4. If one is a feature structure, and the other is a base value,</span>
<span class="sd">         then fail.</span>
<span class="sd">      5. If they&#39;re both base values, then unify them.  By default,</span>
<span class="sd">         this will succeed if they are equal, and fail otherwise.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">trace</span><span class="p">:</span> <span class="n">_trace_unify_start</span><span class="p">(</span><span class="n">fpath</span><span class="p">,</span> <span class="n">fval1</span><span class="p">,</span> <span class="n">fval2</span><span class="p">)</span>

    <span class="c"># Look up the &quot;canonical&quot; copy of fval1 and fval2</span>
    <span class="k">while</span> <span class="nb">id</span><span class="p">(</span><span class="n">fval1</span><span class="p">)</span> <span class="ow">in</span> <span class="n">forward</span><span class="p">:</span> <span class="n">fval1</span> <span class="o">=</span> <span class="n">forward</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="n">fval1</span><span class="p">)]</span>
    <span class="k">while</span> <span class="nb">id</span><span class="p">(</span><span class="n">fval2</span><span class="p">)</span> <span class="ow">in</span> <span class="n">forward</span><span class="p">:</span> <span class="n">fval2</span> <span class="o">=</span> <span class="n">forward</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="n">fval2</span><span class="p">)]</span>

    <span class="c"># If fval1 or fval2 is a bound variable, then</span>
    <span class="c"># replace it by the variable&#39;s bound value.  This</span>
    <span class="c"># includes aliased variables, which are encoded as</span>
    <span class="c"># variables bound to other variables.</span>
    <span class="n">fvar1</span> <span class="o">=</span> <span class="n">fvar2</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="k">while</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fval1</span><span class="p">,</span> <span class="n">Variable</span><span class="p">)</span> <span class="ow">and</span> <span class="n">fval1</span> <span class="ow">in</span> <span class="n">bindings</span><span class="p">:</span>
        <span class="n">fvar1</span> <span class="o">=</span> <span class="n">fval1</span>
        <span class="n">fval1</span> <span class="o">=</span> <span class="n">bindings</span><span class="p">[</span><span class="n">fval1</span><span class="p">]</span>
    <span class="k">while</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fval2</span><span class="p">,</span> <span class="n">Variable</span><span class="p">)</span> <span class="ow">and</span> <span class="n">fval2</span> <span class="ow">in</span> <span class="n">bindings</span><span class="p">:</span>
        <span class="n">fvar2</span> <span class="o">=</span> <span class="n">fval2</span>
        <span class="n">fval2</span> <span class="o">=</span> <span class="n">bindings</span><span class="p">[</span><span class="n">fval2</span><span class="p">]</span>

    <span class="c"># Case 1: Two feature structures (recursive case)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fval1</span><span class="p">,</span> <span class="n">fs_class</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fval2</span><span class="p">,</span> <span class="n">fs_class</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">_destructively_unify</span><span class="p">(</span><span class="n">fval1</span><span class="p">,</span> <span class="n">fval2</span><span class="p">,</span> <span class="n">bindings</span><span class="p">,</span> <span class="n">forward</span><span class="p">,</span>
                                      <span class="n">trace</span><span class="p">,</span> <span class="n">fail</span><span class="p">,</span> <span class="n">fs_class</span><span class="p">,</span> <span class="n">fpath</span><span class="p">)</span>

    <span class="c"># Case 2: Two unbound variables (create alias)</span>
    <span class="k">elif</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">fval1</span><span class="p">,</span> <span class="n">Variable</span><span class="p">)</span> <span class="ow">and</span>
          <span class="nb">isinstance</span><span class="p">(</span><span class="n">fval2</span><span class="p">,</span> <span class="n">Variable</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">fval1</span> <span class="o">!=</span> <span class="n">fval2</span><span class="p">:</span> <span class="n">bindings</span><span class="p">[</span><span class="n">fval2</span><span class="p">]</span> <span class="o">=</span> <span class="n">fval1</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">fval1</span>

    <span class="c"># Case 3: An unbound variable and a value (bind)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fval1</span><span class="p">,</span> <span class="n">Variable</span><span class="p">):</span>
        <span class="n">bindings</span><span class="p">[</span><span class="n">fval1</span><span class="p">]</span> <span class="o">=</span> <span class="n">fval2</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">fval1</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fval2</span><span class="p">,</span> <span class="n">Variable</span><span class="p">):</span>
        <span class="n">bindings</span><span class="p">[</span><span class="n">fval2</span><span class="p">]</span> <span class="o">=</span> <span class="n">fval1</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">fval2</span>

    <span class="c"># Case 4: A feature structure &amp; a base value (fail)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fval1</span><span class="p">,</span> <span class="n">fs_class</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fval2</span><span class="p">,</span> <span class="n">fs_class</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">UnificationFailure</span>

    <span class="c"># Case 5: Two base values</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c"># Case 5a: Feature defines a custom unification method for base values</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">Feature</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">fname</span><span class="o">.</span><span class="n">unify_base_values</span><span class="p">(</span><span class="n">fval1</span><span class="p">,</span> <span class="n">fval2</span><span class="p">,</span> <span class="n">bindings</span><span class="p">)</span>
        <span class="c"># Case 5b: Feature value defines custom unification method</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fval1</span><span class="p">,</span> <span class="n">CustomFeatureValue</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">fval1</span><span class="o">.</span><span class="n">unify</span><span class="p">(</span><span class="n">fval2</span><span class="p">)</span>
            <span class="c"># Sanity check: unify value should be symmetric</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">fval2</span><span class="p">,</span> <span class="n">CustomFeatureValue</span><span class="p">)</span> <span class="ow">and</span>
                <span class="n">result</span> <span class="o">!=</span> <span class="n">fval2</span><span class="o">.</span><span class="n">unify</span><span class="p">(</span><span class="n">fval1</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span>
                    <span class="s">&#39;CustomFeatureValue objects </span><span class="si">%r</span><span class="s"> and </span><span class="si">%r</span><span class="s"> disagree &#39;</span>
                    <span class="s">&#39;about unification value: </span><span class="si">%r</span><span class="s"> vs. </span><span class="si">%r</span><span class="s">&#39;</span> <span class="o">%</span>
                    <span class="p">(</span><span class="n">fval1</span><span class="p">,</span> <span class="n">fval2</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">fval2</span><span class="o">.</span><span class="n">unify</span><span class="p">(</span><span class="n">fval1</span><span class="p">)))</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fval2</span><span class="p">,</span> <span class="n">CustomFeatureValue</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">fval2</span><span class="o">.</span><span class="n">unify</span><span class="p">(</span><span class="n">fval1</span><span class="p">)</span>
        <span class="c"># Case 5c: Simple values -- check if they&#39;re equal.</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">fval1</span> <span class="o">==</span> <span class="n">fval2</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">fval1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">UnificationFailure</span>

        <span class="c"># If either value was a bound variable, then update the</span>
        <span class="c"># bindings.  (This is really only necessary if fname is a</span>
        <span class="c"># Feature or if either value is a CustomFeatureValue.)</span>
        <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">UnificationFailure</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">fvar1</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">bindings</span><span class="p">[</span><span class="n">fvar1</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">fvar1</span>
            <span class="k">if</span> <span class="n">fvar2</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">fvar2</span> <span class="o">!=</span> <span class="n">fvar1</span><span class="p">:</span>
                <span class="n">bindings</span><span class="p">[</span><span class="n">fvar2</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">fvar2</span>

    <span class="c"># If we unification failed, call the failure function; it</span>
    <span class="c"># might decide to continue anyway.</span>
    <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="n">UnificationFailure</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">fail</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span> <span class="n">result</span> <span class="o">=</span> <span class="n">fail</span><span class="p">(</span><span class="n">fval1</span><span class="p">,</span> <span class="n">fval2</span><span class="p">,</span> <span class="n">fpath</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">trace</span><span class="p">:</span> <span class="n">_trace_unify_fail</span><span class="p">(</span><span class="n">fpath</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">result</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="n">UnificationFailure</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">_UnificationFailureError</span>

    <span class="c"># Normalize the result.</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">fs_class</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">_apply_forwards</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">forward</span><span class="p">,</span> <span class="n">fs_class</span><span class="p">,</span> <span class="nb">set</span><span class="p">())</span>

    <span class="k">if</span> <span class="n">trace</span><span class="p">:</span> <span class="n">_trace_unify_succeed</span><span class="p">(</span><span class="n">fpath</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">trace</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">fs_class</span><span class="p">):</span>
        <span class="n">_trace_bindings</span><span class="p">(</span><span class="n">fpath</span><span class="p">,</span> <span class="n">bindings</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">result</span>

<span class="k">def</span> <span class="nf">_apply_forwards_to_bindings</span><span class="p">(</span><span class="n">forward</span><span class="p">,</span> <span class="n">bindings</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Replace any feature structure that has a forward pointer with</span>
<span class="sd">    the target of its forward pointer (to preserve reentrancy).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="ow">in</span> <span class="n">bindings</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">while</span> <span class="nb">id</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="ow">in</span> <span class="n">forward</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">forward</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="n">value</span><span class="p">)]</span>
        <span class="n">bindings</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

<span class="k">def</span> <span class="nf">_apply_forwards</span><span class="p">(</span><span class="n">fstruct</span><span class="p">,</span> <span class="n">forward</span><span class="p">,</span> <span class="n">fs_class</span><span class="p">,</span> <span class="n">visited</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Replace any feature structure that has a forward pointer with</span>
<span class="sd">    the target of its forward pointer (to preserve reentrancy).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># Follow our own forwards pointers (if any)</span>
    <span class="k">while</span> <span class="nb">id</span><span class="p">(</span><span class="n">fstruct</span><span class="p">)</span> <span class="ow">in</span> <span class="n">forward</span><span class="p">:</span> <span class="n">fstruct</span> <span class="o">=</span> <span class="n">forward</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="n">fstruct</span><span class="p">)]</span>

    <span class="c"># Visit each node only once:</span>
    <span class="k">if</span> <span class="nb">id</span><span class="p">(</span><span class="n">fstruct</span><span class="p">)</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span> <span class="k">return</span>
    <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">fstruct</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">_is_mapping</span><span class="p">(</span><span class="n">fstruct</span><span class="p">):</span> <span class="n">items</span> <span class="o">=</span> <span class="n">fstruct</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">_is_sequence</span><span class="p">(</span><span class="n">fstruct</span><span class="p">):</span> <span class="n">items</span> <span class="o">=</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">fstruct</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Expected mapping or sequence&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">fname</span><span class="p">,</span> <span class="n">fval</span> <span class="ow">in</span> <span class="n">items</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fval</span><span class="p">,</span> <span class="n">fs_class</span><span class="p">):</span>
            <span class="c"># Replace w/ forwarded value.</span>
            <span class="k">while</span> <span class="nb">id</span><span class="p">(</span><span class="n">fval</span><span class="p">)</span> <span class="ow">in</span> <span class="n">forward</span><span class="p">:</span>
                <span class="n">fval</span> <span class="o">=</span> <span class="n">forward</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="n">fval</span><span class="p">)]</span>
            <span class="n">fstruct</span><span class="p">[</span><span class="n">fname</span><span class="p">]</span> <span class="o">=</span> <span class="n">fval</span>
            <span class="c"># Recurse to child.</span>
            <span class="n">_apply_forwards</span><span class="p">(</span><span class="n">fval</span><span class="p">,</span> <span class="n">forward</span><span class="p">,</span> <span class="n">fs_class</span><span class="p">,</span> <span class="n">visited</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">fstruct</span>

<span class="k">def</span> <span class="nf">_resolve_aliases</span><span class="p">(</span><span class="n">bindings</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Replace any bound aliased vars with their binding; and replace</span>
<span class="sd">    any unbound aliased vars with their representative var.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="ow">in</span> <span class="n">bindings</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">while</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Variable</span><span class="p">)</span> <span class="ow">and</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">bindings</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">bindings</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="n">bindings</span><span class="p">[</span><span class="n">value</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">_trace_unify_start</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">fval1</span><span class="p">,</span> <span class="n">fval2</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">path</span> <span class="o">==</span> <span class="p">():</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">Unification trace:&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">fullname</span> <span class="o">=</span> <span class="s">&#39;.&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">path</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&#39;  &#39;</span><span class="o">+</span><span class="s">&#39;|   &#39;</span><span class="o">*</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="s">&#39;|&#39;</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&#39;  &#39;</span><span class="o">+</span><span class="s">&#39;|   &#39;</span><span class="o">*</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="s">&#39;| Unify feature: </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">fullname</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;  &#39;</span><span class="o">+</span><span class="s">&#39;|   &#39;</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="o">+</span><span class="s">&#39; / &#39;</span><span class="o">+</span><span class="n">_trace_valrepr</span><span class="p">(</span><span class="n">fval1</span><span class="p">))</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;  &#39;</span><span class="o">+</span><span class="s">&#39;|   &#39;</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="o">+</span><span class="s">&#39;|</span><span class="se">\\</span><span class="s"> &#39;</span><span class="o">+</span><span class="n">_trace_valrepr</span><span class="p">(</span><span class="n">fval2</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">_trace_unify_identity</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">fval1</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;  &#39;</span><span class="o">+</span><span class="s">&#39;|   &#39;</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="o">+</span><span class="s">&#39;|&#39;</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;  &#39;</span><span class="o">+</span><span class="s">&#39;|   &#39;</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="o">+</span><span class="s">&#39;| (identical objects)&#39;</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;  &#39;</span><span class="o">+</span><span class="s">&#39;|   &#39;</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="o">+</span><span class="s">&#39;|&#39;</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;  &#39;</span><span class="o">+</span><span class="s">&#39;|   &#39;</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="o">+</span><span class="s">&#39;+--&gt;&#39;</span><span class="o">+</span><span class="n">unicode_repr</span><span class="p">(</span><span class="n">fval1</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">_trace_unify_fail</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">result</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="n">UnificationFailure</span><span class="p">:</span> <span class="n">resume</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
    <span class="k">else</span><span class="p">:</span> <span class="n">resume</span> <span class="o">=</span> <span class="s">&#39; (nonfatal)&#39;</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;  &#39;</span><span class="o">+</span><span class="s">&#39;|   &#39;</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="o">+</span><span class="s">&#39;|   |&#39;</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;  &#39;</span><span class="o">+</span><span class="s">&#39;X   &#39;</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="o">+</span><span class="s">&#39;X   X &lt;-- FAIL&#39;</span><span class="o">+</span><span class="n">resume</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_trace_unify_succeed</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">fval1</span><span class="p">):</span>
    <span class="c"># Print the result.</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;  &#39;</span><span class="o">+</span><span class="s">&#39;|   &#39;</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="o">+</span><span class="s">&#39;|&#39;</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;  &#39;</span><span class="o">+</span><span class="s">&#39;|   &#39;</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="o">+</span><span class="s">&#39;+--&gt;&#39;</span><span class="o">+</span><span class="n">unicode_repr</span><span class="p">(</span><span class="n">fval1</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">_trace_bindings</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">bindings</span><span class="p">):</span>
    <span class="c"># Print the bindings (if any).</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bindings</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">binditems</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">bindings</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">v</span><span class="p">:</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="n">bindstr</span> <span class="o">=</span> <span class="s">&#39;{</span><span class="si">%s</span><span class="s">}&#39;</span> <span class="o">%</span> <span class="s">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="s">&#39;</span><span class="si">%s</span><span class="s">: </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">_trace_valrepr</span><span class="p">(</span><span class="n">val</span><span class="p">))</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span> <span class="ow">in</span> <span class="n">binditems</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&#39;  &#39;</span><span class="o">+</span><span class="s">&#39;|   &#39;</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="o">+</span><span class="s">&#39;    Bindings: &#39;</span><span class="o">+</span><span class="n">bindstr</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_trace_valrepr</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">Variable</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&#39;</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">val</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="s">&#39;</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">unicode_repr</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

<div class="viewcode-block" id="subsumes"><a class="viewcode-back" href="../../api/nltk.html#nltk.featstruct.subsumes">[docs]</a><span class="k">def</span> <span class="nf">subsumes</span><span class="p">(</span><span class="n">fstruct1</span><span class="p">,</span> <span class="n">fstruct2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return True if ``fstruct1`` subsumes ``fstruct2``.  I.e., return</span>
<span class="sd">    true if unifying ``fstruct1`` with ``fstruct2`` would result in a</span>
<span class="sd">    feature structure equal to ``fstruct2.``</span>

<span class="sd">    :rtype: bool</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">fstruct2</span> <span class="o">==</span> <span class="n">unify</span><span class="p">(</span><span class="n">fstruct1</span><span class="p">,</span> <span class="n">fstruct2</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="conflicts"><a class="viewcode-back" href="../../api/nltk.html#nltk.featstruct.conflicts">[docs]</a><span class="k">def</span> <span class="nf">conflicts</span><span class="p">(</span><span class="n">fstruct1</span><span class="p">,</span> <span class="n">fstruct2</span><span class="p">,</span> <span class="n">trace</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a list of the feature paths of all features which are</span>
<span class="sd">    assigned incompatible values by ``fstruct1`` and ``fstruct2``.</span>

<span class="sd">    :rtype: list(tuple)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">conflict_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">def</span> <span class="nf">add_conflict</span><span class="p">(</span><span class="n">fval1</span><span class="p">,</span> <span class="n">fval2</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="n">conflict_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fval1</span>
    <span class="n">unify</span><span class="p">(</span><span class="n">fstruct1</span><span class="p">,</span> <span class="n">fstruct2</span><span class="p">,</span> <span class="n">fail</span><span class="o">=</span><span class="n">add_conflict</span><span class="p">,</span> <span class="n">trace</span><span class="o">=</span><span class="n">trace</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">conflict_list</span>

<span class="c">######################################################################</span>
<span class="c"># Helper Functions</span>
<span class="c">######################################################################</span>
</div>
<span class="k">def</span> <span class="nf">_is_mapping</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="s">&#39;__contains__&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="s">&#39;keys&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_is_sequence</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="s">&#39;__iter__&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="s">&#39;__len__&#39;</span><span class="p">)</span> <span class="ow">and</span>
            <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">string_types</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">_default_fs_class</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">FeatStruct</span><span class="p">):</span> <span class="k">return</span> <span class="n">FeatStruct</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="p">(</span><span class="nb">dict</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span> <span class="k">return</span> <span class="p">(</span><span class="nb">dict</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;To unify objects of type </span><span class="si">%s</span><span class="s">, you must specify &#39;</span>
                         <span class="s">&#39;fs_class explicitly.&#39;</span> <span class="o">%</span> <span class="n">obj</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">)</span>
<span class="c">######################################################################</span>
<span class="c"># FeatureValueSet &amp; FeatureValueTuple</span>
<span class="c">######################################################################</span>

<span class="k">class</span> <span class="nc">SubstituteBindingsSequence</span><span class="p">(</span><span class="n">SubstituteBindingsI</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A mixin class for sequence clases that distributes variables() and</span>
<span class="sd">    substitute_bindings() over the object&#39;s elements.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">variables</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">([</span><span class="n">elt</span> <span class="k">for</span> <span class="n">elt</span> <span class="ow">in</span> <span class="bp">self</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">elt</span><span class="p">,</span> <span class="n">Variable</span><span class="p">)]</span> <span class="o">+</span>
                <span class="nb">sum</span><span class="p">([</span><span class="nb">list</span><span class="p">(</span><span class="n">elt</span><span class="o">.</span><span class="n">variables</span><span class="p">())</span> <span class="k">for</span> <span class="n">elt</span> <span class="ow">in</span> <span class="bp">self</span>
                     <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">elt</span><span class="p">,</span> <span class="n">SubstituteBindingsI</span><span class="p">)],</span> <span class="p">[]))</span>

    <span class="k">def</span> <span class="nf">substitute_bindings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bindings</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">subst</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">bindings</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">subst</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">bindings</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">SubstituteBindingsI</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">v</span><span class="o">.</span><span class="n">substitute_bindings</span><span class="p">(</span><span class="n">bindings</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">bindings</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

<span class="nd">@python_2_unicode_compatible</span>
<span class="k">class</span> <span class="nc">FeatureValueTuple</span><span class="p">(</span><span class="n">SubstituteBindingsSequence</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A base feature value that is a tuple of other base feature values.</span>
<span class="sd">    FeatureValueTuple implements ``SubstituteBindingsI``, so it any</span>
<span class="sd">    variable substitutions will be propagated to the elements</span>
<span class="sd">    contained by the set.  A ``FeatureValueTuple`` is immutable.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="c"># [xx] really use %s here?</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="s">&#39;()&#39;</span>
        <span class="k">return</span> <span class="s">&#39;(</span><span class="si">%s</span><span class="s">)&#39;</span> <span class="o">%</span> <span class="s">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">b</span><span class="p">,)</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">)</span>


<span class="nd">@python_2_unicode_compatible</span>
<span class="k">class</span> <span class="nc">FeatureValueSet</span><span class="p">(</span><span class="n">SubstituteBindingsSequence</span><span class="p">,</span> <span class="nb">frozenset</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A base feature value that is a set of other base feature values.</span>
<span class="sd">    FeatureValueSet implements ``SubstituteBindingsI``, so it any</span>
<span class="sd">    variable substitutions will be propagated to the elements</span>
<span class="sd">    contained by the set.  A ``FeatureValueSet`` is immutable.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="c"># [xx] really use %s here?</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="s">&#39;{/}&#39;</span> <span class="c"># distinguish from dict.</span>
        <span class="c"># n.b., we sort the string reprs of our elements, to ensure</span>
        <span class="c"># that our own repr is deterministic.</span>
        <span class="k">return</span> <span class="s">&#39;{</span><span class="si">%s</span><span class="s">}&#39;</span> <span class="o">%</span> <span class="s">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">b</span><span class="p">,)</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">))</span>
    <span class="n">__str__</span> <span class="o">=</span> <span class="n">__repr__</span>

<span class="nd">@python_2_unicode_compatible</span>
<span class="k">class</span> <span class="nc">FeatureValueUnion</span><span class="p">(</span><span class="n">SubstituteBindingsSequence</span><span class="p">,</span> <span class="nb">frozenset</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A base feature value that represents the union of two or more</span>
<span class="sd">    ``FeatureValueSet`` or ``Variable``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="c"># If values contains FeatureValueUnions, then collapse them.</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">_flatten</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">FeatureValueUnion</span><span class="p">)</span>

        <span class="c"># If the resulting list contains no variables, then</span>
        <span class="c"># use a simple FeatureValueSet instead.</span>
        <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">Variable</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">values</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">_flatten</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">FeatureValueSet</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">FeatureValueSet</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>

        <span class="c"># If we contain a single variable, return that variable.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">values</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c"># Otherwise, build the FeatureValueUnion.</span>
        <span class="k">return</span> <span class="nb">frozenset</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># n.b., we sort the string reprs of our elements, to ensure</span>
        <span class="c"># that our own repr is deterministic.  also, note that len(self)</span>
        <span class="c"># is guaranteed to be 2 or more.</span>
        <span class="k">return</span> <span class="s">&#39;{</span><span class="si">%s</span><span class="s">}&#39;</span> <span class="o">%</span> <span class="s">&#39;+&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">b</span><span class="p">,)</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">))</span>

<span class="nd">@python_2_unicode_compatible</span>
<span class="k">class</span> <span class="nc">FeatureValueConcat</span><span class="p">(</span><span class="n">SubstituteBindingsSequence</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A base feature value that represents the concatenation of two or</span>
<span class="sd">    more ``FeatureValueTuple`` or ``Variable``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="c"># If values contains FeatureValueConcats, then collapse them.</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">_flatten</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">FeatureValueConcat</span><span class="p">)</span>

        <span class="c"># If the resulting list contains no variables, then</span>
        <span class="c"># use a simple FeatureValueTuple instead.</span>
        <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">Variable</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">values</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">_flatten</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">FeatureValueTuple</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">FeatureValueTuple</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>

        <span class="c"># If we contain a single variable, return that variable.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">values</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c"># Otherwise, build the FeatureValueConcat.</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># n.b.: len(self) is guaranteed to be 2 or more.</span>
        <span class="k">return</span> <span class="s">&#39;(</span><span class="si">%s</span><span class="s">)&#39;</span> <span class="o">%</span> <span class="s">&#39;+&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">b</span><span class="p">,)</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_flatten</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="n">cls</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Helper function -- return a copy of list, with all elements of</span>
<span class="sd">    type ``cls`` spliced in rather than appended in.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">elt</span> <span class="ow">in</span> <span class="n">lst</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">elt</span><span class="p">,</span> <span class="n">cls</span><span class="p">):</span> <span class="n">result</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">elt</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span> <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">elt</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span>

<span class="c">######################################################################</span>
<span class="c"># Specialized Features</span>
<span class="c">######################################################################</span>

<span class="nd">@total_ordering</span>
<span class="nd">@python_2_unicode_compatible</span>
<div class="viewcode-block" id="Feature"><a class="viewcode-back" href="../../api/nltk.html#nltk.featstruct.Feature">[docs]</a><span class="k">class</span> <span class="nc">Feature</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A feature identifier that&#39;s specialized to put additional</span>
<span class="sd">    constraints, default values, etc.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">display</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">display</span> <span class="ow">in</span> <span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="s">&#39;prefix&#39;</span><span class="p">,</span> <span class="s">&#39;slash&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">name</span> <span class="c"># [xx] rename to .identifier?</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_default</span> <span class="o">=</span> <span class="n">default</span> <span class="c"># [xx] not implemented yet.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_display</span> <span class="o">=</span> <span class="n">display</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_display</span> <span class="o">==</span> <span class="s">&#39;prefix&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sortkey</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_display</span> <span class="o">==</span> <span class="s">&#39;slash&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sortkey</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sortkey</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The name of this feature.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">default</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Default value for this feature.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_default</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">display</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Custom display location: can be prefix, or slash.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_display</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&#39;*</span><span class="si">%s</span><span class="s">*&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>

    <span class="k">def</span> <span class="nf">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Feature</span><span class="p">):</span>
            <span class="n">raise_unorderable_types</span><span class="p">(</span><span class="s">&quot;&lt;&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sortkey</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="n">_sortkey</span>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_name</span>

    <span class="k">def</span> <span class="nf">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span>

    <span class="k">def</span> <span class="nf">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">)</span>

    <span class="c">#////////////////////////////////////////////////////////////</span>
    <span class="c"># These can be overridden by subclasses:</span>
    <span class="c">#////////////////////////////////////////////////////////////</span>

<div class="viewcode-block" id="Feature.read_value"><a class="viewcode-back" href="../../api/nltk.html#nltk.featstruct.Feature.read_value">[docs]</a>    <span class="k">def</span> <span class="nf">read_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">reentrances</span><span class="p">,</span> <span class="n">parser</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">parser</span><span class="o">.</span><span class="n">read_value</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">reentrances</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Feature.unify_base_values"><a class="viewcode-back" href="../../api/nltk.html#nltk.featstruct.Feature.unify_base_values">[docs]</a>    <span class="k">def</span> <span class="nf">unify_base_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fval1</span><span class="p">,</span> <span class="n">fval2</span><span class="p">,</span> <span class="n">bindings</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        If possible, return a single value..  If not, return</span>
<span class="sd">        the value ``UnificationFailure``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">fval1</span> <span class="o">==</span> <span class="n">fval2</span><span class="p">:</span> <span class="k">return</span> <span class="n">fval1</span>
        <span class="k">else</span><span class="p">:</span> <span class="k">return</span> <span class="n">UnificationFailure</span>

</div></div>
<div class="viewcode-block" id="SlashFeature"><a class="viewcode-back" href="../../api/nltk.html#nltk.featstruct.SlashFeature">[docs]</a><span class="k">class</span> <span class="nc">SlashFeature</span><span class="p">(</span><span class="n">Feature</span><span class="p">):</span>
<div class="viewcode-block" id="SlashFeature.read_value"><a class="viewcode-back" href="../../api/nltk.html#nltk.featstruct.SlashFeature.read_value">[docs]</a>    <span class="k">def</span> <span class="nf">read_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">reentrances</span><span class="p">,</span> <span class="n">parser</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">parser</span><span class="o">.</span><span class="n">read_partial</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">reentrances</span><span class="p">)</span>
</div></div>
<div class="viewcode-block" id="RangeFeature"><a class="viewcode-back" href="../../api/nltk.html#nltk.featstruct.RangeFeature">[docs]</a><span class="k">class</span> <span class="nc">RangeFeature</span><span class="p">(</span><span class="n">Feature</span><span class="p">):</span>
    <span class="n">RANGE_RE</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s">&#39;(-?\d+):(-?\d+)&#39;</span><span class="p">)</span>
<div class="viewcode-block" id="RangeFeature.read_value"><a class="viewcode-back" href="../../api/nltk.html#nltk.featstruct.RangeFeature.read_value">[docs]</a>    <span class="k">def</span> <span class="nf">read_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">reentrances</span><span class="p">,</span> <span class="n">parser</span><span class="p">):</span>
        <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RANGE_RE</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">m</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;range&#39;</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)),</span> <span class="nb">int</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">2</span><span class="p">))),</span> <span class="n">m</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="RangeFeature.unify_base_values"><a class="viewcode-back" href="../../api/nltk.html#nltk.featstruct.RangeFeature.unify_base_values">[docs]</a>    <span class="k">def</span> <span class="nf">unify_base_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fval1</span><span class="p">,</span> <span class="n">fval2</span><span class="p">,</span> <span class="n">bindings</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">fval1</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span> <span class="k">return</span> <span class="n">fval2</span>
        <span class="k">if</span> <span class="n">fval2</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span> <span class="k">return</span> <span class="n">fval1</span>
        <span class="n">rng</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">fval1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">fval2</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">min</span><span class="p">(</span><span class="n">fval1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">fval2</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">rng</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">rng</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="k">return</span> <span class="n">UnificationFailure</span>
        <span class="k">return</span> <span class="n">rng</span>
</div></div>
<span class="n">SLASH</span> <span class="o">=</span> <span class="n">SlashFeature</span><span class="p">(</span><span class="s">&#39;slash&#39;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">display</span><span class="o">=</span><span class="s">&#39;slash&#39;</span><span class="p">)</span>
<span class="n">TYPE</span> <span class="o">=</span> <span class="n">Feature</span><span class="p">(</span><span class="s">&#39;type&#39;</span><span class="p">,</span> <span class="n">display</span><span class="o">=</span><span class="s">&#39;prefix&#39;</span><span class="p">)</span>

<span class="c">######################################################################</span>
<span class="c"># Specialized Feature Values</span>
<span class="c">######################################################################</span>

<span class="nd">@total_ordering</span>
<span class="k">class</span> <span class="nc">CustomFeatureValue</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An abstract base class for base values that define a custom</span>
<span class="sd">    unification method.  The custom unification method of</span>
<span class="sd">    ``CustomFeatureValue`` will be used during unification if:</span>

<span class="sd">      - The ``CustomFeatureValue`` is unified with another base value.</span>
<span class="sd">      - The ``CustomFeatureValue`` is not the value of a customized</span>
<span class="sd">        ``Feature`` (which defines its own unification method).</span>

<span class="sd">    If two ``CustomFeatureValue`` objects are unified with one another</span>
<span class="sd">    during feature structure unification, then the unified base values</span>
<span class="sd">    they return *must* be equal; otherwise, an ``AssertionError`` will</span>
<span class="sd">    be raised.</span>

<span class="sd">    Subclasses must define ``unify()``, ``__eq__()`` and ``__lt__()``.</span>
<span class="sd">    Subclasses may also wish to define ``__hash__()``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">unify</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        If this base value unifies with ``other``, then return the</span>
<span class="sd">        unified value.  Otherwise, return ``UnificationFailure``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&#39;abstract base class&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&#39;abstract base class&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span>

    <span class="k">def</span> <span class="nf">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&#39;abstract base class&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%s</span><span class="s"> objects or unhashable&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">)</span>

<span class="c">######################################################################</span>
<span class="c"># Feature Structure Reader</span>
<span class="c">######################################################################</span>

<div class="viewcode-block" id="FeatStructReader"><a class="viewcode-back" href="../../api/nltk.html#nltk.featstruct.FeatStructReader">[docs]</a><span class="k">class</span> <span class="nc">FeatStructReader</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">features</span><span class="o">=</span><span class="p">(</span><span class="n">SLASH</span><span class="p">,</span> <span class="n">TYPE</span><span class="p">),</span> <span class="n">fdict_class</span><span class="o">=</span><span class="n">FeatStruct</span><span class="p">,</span>
                 <span class="n">flist_class</span><span class="o">=</span><span class="n">FeatList</span><span class="p">,</span> <span class="n">logic_parser</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_features</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">f</span><span class="o">.</span><span class="n">name</span><span class="p">,</span><span class="n">f</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">features</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fdict_class</span> <span class="o">=</span> <span class="n">fdict_class</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_flist_class</span> <span class="o">=</span> <span class="n">flist_class</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_prefix_feature</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_slash_feature</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">for</span> <span class="n">feature</span> <span class="ow">in</span> <span class="n">features</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">feature</span><span class="o">.</span><span class="n">display</span> <span class="o">==</span> <span class="s">&#39;slash&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_slash_feature</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Multiple features w/ display=slash&#39;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_slash_feature</span> <span class="o">=</span> <span class="n">feature</span>
            <span class="k">if</span> <span class="n">feature</span><span class="o">.</span><span class="n">display</span> <span class="o">==</span> <span class="s">&#39;prefix&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prefix_feature</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Multiple features w/ display=prefix&#39;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_prefix_feature</span> <span class="o">=</span> <span class="n">feature</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_features_with_defaults</span> <span class="o">=</span> <span class="p">[</span><span class="n">feature</span> <span class="k">for</span> <span class="n">feature</span> <span class="ow">in</span> <span class="n">features</span>
                                        <span class="k">if</span> <span class="n">feature</span><span class="o">.</span><span class="n">default</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">logic_parser</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">logic_parser</span> <span class="o">=</span> <span class="n">LogicParser</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_logic_parser</span> <span class="o">=</span> <span class="n">logic_parser</span>

<div class="viewcode-block" id="FeatStructReader.fromstring"><a class="viewcode-back" href="../../api/nltk.html#nltk.featstruct.FeatStructReader.fromstring">[docs]</a>    <span class="k">def</span> <span class="nf">fromstring</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">fstruct</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert a string representation of a feature structure (as</span>
<span class="sd">        displayed by repr) into a ``FeatStruct``.  This process</span>
<span class="sd">        imposes the following restrictions on the string</span>
<span class="sd">        representation:</span>

<span class="sd">        - Feature names cannot contain any of the following:</span>
<span class="sd">          whitespace, parentheses, quote marks, equals signs,</span>
<span class="sd">          dashes, commas, and square brackets.  Feature names may</span>
<span class="sd">          not begin with plus signs or minus signs.</span>
<span class="sd">        - Only the following basic feature value are supported:</span>
<span class="sd">          strings, integers, variables, None, and unquoted</span>
<span class="sd">          alphanumeric strings.</span>
<span class="sd">        - For reentrant values, the first mention must specify</span>
<span class="sd">          a reentrance identifier and a value; and any subsequent</span>
<span class="sd">          mentions must use arrows (``&#39;-&gt;&#39;``) to reference the</span>
<span class="sd">          reentrance identifier.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="n">value</span><span class="p">,</span> <span class="n">position</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_partial</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">{},</span> <span class="n">fstruct</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">position</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_error</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&#39;end of string&#39;</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">value</span>
</div>
    <span class="n">_START_FSTRUCT_RE</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s">r&#39;\s*(?:\((\d+)\)\s*)?(\??[\w-]+)?(\[)&#39;</span><span class="p">)</span>
    <span class="n">_END_FSTRUCT_RE</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s">r&#39;\s*]\s*&#39;</span><span class="p">)</span>
    <span class="n">_SLASH_RE</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s">r&#39;/&#39;</span><span class="p">)</span>
    <span class="n">_FEATURE_NAME_RE</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s">r&#39;\s*([+-]?)([^\s\(\)&lt;&gt;&quot;</span><span class="se">\&#39;</span><span class="s">\-=\[\],]+)\s*&#39;</span><span class="p">)</span>
    <span class="n">_REENTRANCE_RE</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s">r&#39;\s*-&gt;\s*&#39;</span><span class="p">)</span>
    <span class="n">_TARGET_RE</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s">r&#39;\s*\((\d+)\)\s*&#39;</span><span class="p">)</span>
    <span class="n">_ASSIGN_RE</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s">r&#39;\s*=\s*&#39;</span><span class="p">)</span>
    <span class="n">_COMMA_RE</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s">r&#39;\s*,\s*&#39;</span><span class="p">)</span>
    <span class="n">_BARE_PREFIX_RE</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s">r&#39;\s*(?:\((\d+)\)\s*)?(\??[\w-]+\s*)()&#39;</span><span class="p">)</span>
    <span class="c"># This one is used to distinguish fdicts from flists:</span>
    <span class="n">_START_FDICT_RE</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s">r&#39;(</span><span class="si">%s</span><span class="s">)|(</span><span class="si">%s</span><span class="s">\s*(</span><span class="si">%s</span><span class="s">\s*(=|-&gt;)|[+-]</span><span class="si">%s</span><span class="s">|\]))&#39;</span> <span class="o">%</span> <span class="p">(</span>
        <span class="n">_BARE_PREFIX_RE</span><span class="o">.</span><span class="n">pattern</span><span class="p">,</span> <span class="n">_START_FSTRUCT_RE</span><span class="o">.</span><span class="n">pattern</span><span class="p">,</span>
        <span class="n">_FEATURE_NAME_RE</span><span class="o">.</span><span class="n">pattern</span><span class="p">,</span> <span class="n">_FEATURE_NAME_RE</span><span class="o">.</span><span class="n">pattern</span><span class="p">))</span>

<div class="viewcode-block" id="FeatStructReader.read_partial"><a class="viewcode-back" href="../../api/nltk.html#nltk.featstruct.FeatStructReader.read_partial">[docs]</a>    <span class="k">def</span> <span class="nf">read_partial</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">position</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">reentrances</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">fstruct</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper function that reads in a feature structure.</span>

<span class="sd">        :param s: The string to read.</span>
<span class="sd">        :param position: The position in the string to start parsing.</span>
<span class="sd">        :param reentrances: A dictionary from reentrance ids to values.</span>
<span class="sd">            Defaults to an empty dictionary.</span>
<span class="sd">        :return: A tuple (val, pos) of the feature structure created by</span>
<span class="sd">            parsing and the position where the parsed feature structure ends.</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">reentrances</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span> <span class="n">reentrances</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_partial</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">reentrances</span><span class="p">,</span> <span class="n">fstruct</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">args</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span> <span class="k">raise</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_error</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="o">*</span><span class="n">e</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">_read_partial</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">reentrances</span><span class="p">,</span> <span class="n">fstruct</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="c"># Create the new feature structure</span>
        <span class="k">if</span> <span class="n">fstruct</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_START_FDICT_RE</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">position</span><span class="p">):</span>
                <span class="n">fstruct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fdict_class</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">fstruct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flist_class</span><span class="p">()</span>

        <span class="c"># Read up to the open bracket.</span>
        <span class="n">match</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_START_FSTRUCT_RE</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">match</span><span class="p">:</span>
            <span class="n">match</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_BARE_PREFIX_RE</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">match</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;open bracket or identifier&#39;</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span>
        <span class="n">position</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>

        <span class="c"># If there as an identifier, record it.</span>
        <span class="k">if</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">identifier</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">identifier</span> <span class="ow">in</span> <span class="n">reentrances</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;new identifier&#39;</span><span class="p">,</span> <span class="n">match</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
            <span class="n">reentrances</span><span class="p">[</span><span class="n">identifier</span><span class="p">]</span> <span class="o">=</span> <span class="n">fstruct</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fstruct</span><span class="p">,</span> <span class="n">FeatDict</span><span class="p">):</span>
            <span class="n">fstruct</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_partial_featdict</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">match</span><span class="p">,</span>
                                                <span class="n">reentrances</span><span class="p">,</span> <span class="n">fstruct</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">del</span> <span class="n">fstruct</span><span class="p">[:]</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_partial_featlist</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">match</span><span class="p">,</span>
                                                <span class="n">reentrances</span><span class="p">,</span> <span class="n">fstruct</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_read_partial_featlist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">match</span><span class="p">,</span>
                                <span class="n">reentrances</span><span class="p">,</span> <span class="n">fstruct</span><span class="p">):</span>
        <span class="c"># Prefix features are not allowed:</span>
        <span class="k">if</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;open bracket&#39;</span><span class="p">)</span>
        <span class="c"># Bare prefixes are not allowed:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;open bracket&#39;</span><span class="p">)</span>

        <span class="c"># Build a list of the features defined by the structure.</span>
        <span class="k">while</span> <span class="n">position</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
            <span class="c"># Check for the close bracket.</span>
            <span class="n">match</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_END_FSTRUCT_RE</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">match</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">fstruct</span><span class="p">,</span> <span class="n">match</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>

            <span class="c"># Reentances have the form &quot;-&gt; (target)&quot;</span>
            <span class="n">match</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_REENTRANCE_RE</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">match</span><span class="p">:</span>
                <span class="n">position</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>
                <span class="n">match</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_TARGET_RE</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">match</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;identifier&#39;</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span>
                <span class="n">target</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">target</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">reentrances</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;bound identifier&#39;</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span>
                <span class="n">position</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>
                <span class="n">fstruct</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">reentrances</span><span class="p">[</span><span class="n">target</span><span class="p">])</span>

            <span class="c"># Anything else is a value.</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">value</span><span class="p">,</span> <span class="n">position</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_read_value</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">reentrances</span><span class="p">))</span>
                <span class="n">fstruct</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

            <span class="c"># If there&#39;s a close bracket, handle it at the top of the loop.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_END_FSTRUCT_RE</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">position</span><span class="p">):</span>
                <span class="k">continue</span>

            <span class="c"># Otherwise, there should be a comma</span>
            <span class="n">match</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_COMMA_RE</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">match</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;comma&#39;</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span>
            <span class="n">position</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>

        <span class="c"># We never saw a close bracket.</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;close bracket&#39;</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_read_partial_featdict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">match</span><span class="p">,</span>
                                <span class="n">reentrances</span><span class="p">,</span> <span class="n">fstruct</span><span class="p">):</span>
        <span class="c"># If there was a prefix feature, record it.</span>
        <span class="k">if</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prefix_feature</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;open bracket or identifier&#39;</span><span class="p">,</span> <span class="n">match</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
            <span class="n">prefixval</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">prefixval</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&#39;?&#39;</span><span class="p">):</span>
                <span class="n">prefixval</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="n">prefixval</span><span class="p">)</span>
            <span class="n">fstruct</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_prefix_feature</span><span class="p">]</span> <span class="o">=</span> <span class="n">prefixval</span>

        <span class="c"># If group 3 is empty, then we just have a bare prefix, so</span>
        <span class="c"># we&#39;re done.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_finalize</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">match</span><span class="o">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">reentrances</span><span class="p">,</span> <span class="n">fstruct</span><span class="p">)</span>

        <span class="c"># Build a list of the features defined by the structure.</span>
        <span class="c"># Each feature has one of the three following forms:</span>
        <span class="c">#     name = value</span>
        <span class="c">#     name -&gt; (target)</span>
        <span class="c">#     +name</span>
        <span class="c">#     -name</span>
        <span class="k">while</span> <span class="n">position</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
            <span class="c"># Use these variables to hold info about each feature:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">value</span> <span class="o">=</span> <span class="bp">None</span>

            <span class="c"># Check for the close bracket.</span>
            <span class="n">match</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_END_FSTRUCT_RE</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">match</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_finalize</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">match</span><span class="o">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">reentrances</span><span class="p">,</span> <span class="n">fstruct</span><span class="p">)</span>

            <span class="c"># Get the feature name&#39;s name</span>
            <span class="n">match</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_FEATURE_NAME_RE</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">match</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;feature name&#39;</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">position</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>

            <span class="c"># Check if it&#39;s a special feature.</span>
            <span class="k">if</span> <span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;*&#39;</span> <span class="ow">and</span> <span class="n">name</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;*&#39;</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_features</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;known special feature&#39;</span><span class="p">,</span> <span class="n">match</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>

            <span class="c"># Check if this feature has a value already.</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">fstruct</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;new name&#39;</span><span class="p">,</span> <span class="n">match</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>

            <span class="c"># Boolean value (&quot;+name&quot; or &quot;-name&quot;)</span>
            <span class="k">if</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="s">&#39;+&#39;</span><span class="p">:</span> <span class="n">value</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">if</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="s">&#39;-&#39;</span><span class="p">:</span> <span class="n">value</span> <span class="o">=</span> <span class="bp">False</span>

            <span class="c"># Reentrance link (&quot;-&gt; (target)&quot;)</span>
            <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">match</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_REENTRANCE_RE</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">match</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">position</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>
                    <span class="n">match</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_TARGET_RE</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">match</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;identifier&#39;</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span>
                    <span class="n">target</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">target</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">reentrances</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;bound identifier&#39;</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span>
                    <span class="n">position</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="n">reentrances</span><span class="p">[</span><span class="n">target</span><span class="p">]</span>

            <span class="c"># Assignment (&quot;= value&quot;).</span>
            <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">match</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ASSIGN_RE</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">match</span><span class="p">:</span>
                    <span class="n">position</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>
                    <span class="n">value</span><span class="p">,</span> <span class="n">position</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_read_value</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">reentrances</span><span class="p">))</span>
                <span class="c"># None of the above: error.</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;equals sign&#39;</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span>

            <span class="c"># Store the value.</span>
            <span class="n">fstruct</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

            <span class="c"># If there&#39;s a close bracket, handle it at the top of the loop.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_END_FSTRUCT_RE</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">position</span><span class="p">):</span>
                <span class="k">continue</span>

            <span class="c"># Otherwise, there should be a comma</span>
            <span class="n">match</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_COMMA_RE</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">match</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;comma&#39;</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span>
            <span class="n">position</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>

        <span class="c"># We never saw a close bracket.</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;close bracket&#39;</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_finalize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">reentrances</span><span class="p">,</span> <span class="n">fstruct</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Called when we see the close brace -- checks for a slash feature,</span>
<span class="sd">        and adds in default values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Add the slash feature (if any)</span>
        <span class="n">match</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_SLASH_RE</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">match</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_slash_feature</span>
            <span class="n">v</span><span class="p">,</span> <span class="n">pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_value</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">match</span><span class="o">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">reentrances</span><span class="p">)</span>
            <span class="n">fstruct</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
        <span class="c">## Add any default features.  -- handle in unficiation instead?</span>
        <span class="c">#for feature in self._features_with_defaults:</span>
        <span class="c">#    fstruct.setdefault(feature, feature.default)</span>
        <span class="c"># Return the value.</span>
        <span class="k">return</span> <span class="n">fstruct</span><span class="p">,</span> <span class="n">pos</span>

    <span class="k">def</span> <span class="nf">_read_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">reentrances</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">Feature</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">name</span><span class="o">.</span><span class="n">read_value</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">reentrances</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_value</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">reentrances</span><span class="p">)</span>

<div class="viewcode-block" id="FeatStructReader.read_value"><a class="viewcode-back" href="../../api/nltk.html#nltk.featstruct.FeatStructReader.read_value">[docs]</a>    <span class="k">def</span> <span class="nf">read_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">reentrances</span><span class="p">):</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">handler</span><span class="p">,</span> <span class="n">regexp</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">VALUE_HANDLERS</span><span class="p">:</span>
            <span class="n">match</span> <span class="o">=</span> <span class="n">regexp</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">match</span><span class="p">:</span>
                <span class="n">handler_func</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">handler</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">handler_func</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">reentrances</span><span class="p">,</span> <span class="n">match</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;value&#39;</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">_error</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">expected</span><span class="p">,</span> <span class="n">position</span><span class="p">):</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">position</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">lines</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">position</span> <span class="o">-=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lines</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span><span class="o">+</span><span class="mi">1</span> <span class="c"># +1 for the newline.</span>
        <span class="n">estr</span> <span class="o">=</span> <span class="p">(</span><span class="s">&#39;Error parsing feature structure</span><span class="se">\n</span><span class="s">    &#39;</span> <span class="o">+</span>
                <span class="n">lines</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">    &#39;</span> <span class="o">+</span> <span class="s">&#39; &#39;</span><span class="o">*</span><span class="n">position</span> <span class="o">+</span> <span class="s">&#39;^ &#39;</span> <span class="o">+</span>
                <span class="s">&#39;Expected </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">expected</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">estr</span><span class="p">)</span>

    <span class="c">#////////////////////////////////////////////////////////////</span>
    <span class="c">#{ Value Readers</span>
    <span class="c">#////////////////////////////////////////////////////////////</span>

    <span class="c">#: A table indicating how feature values should be processed.  Each</span>
    <span class="c">#: entry in the table is a pair (handler, regexp).  The first entry</span>
    <span class="c">#: with a matching regexp will have its handler called.  Handlers</span>
    <span class="c">#: should have the following signature::</span>
    <span class="c">#:</span>
    <span class="c">#:    def handler(s, position, reentrances, match): ...</span>
    <span class="c">#:</span>
    <span class="c">#: and should return a tuple (value, position), where position is</span>
    <span class="c">#: the string position where the value ended.  (n.b.: order is</span>
    <span class="c">#: important here!)</span>
    <span class="n">VALUE_HANDLERS</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">(</span><span class="s">&#39;read_fstruct_value&#39;</span><span class="p">,</span> <span class="n">_START_FSTRUCT_RE</span><span class="p">),</span>
        <span class="p">(</span><span class="s">&#39;read_var_value&#39;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s">r&#39;\?[a-zA-Z_][a-zA-Z0-9_]*&#39;</span><span class="p">)),</span>
        <span class="p">(</span><span class="s">&#39;read_str_value&#39;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s">&quot;[uU]?[rR]?([&#39;</span><span class="se">\&quot;</span><span class="s">])&quot;</span><span class="p">)),</span>
        <span class="p">(</span><span class="s">&#39;read_int_value&#39;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s">r&#39;-?\d+&#39;</span><span class="p">)),</span>
        <span class="p">(</span><span class="s">&#39;read_sym_value&#39;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s">r&#39;[a-zA-Z_][a-zA-Z0-9_]*&#39;</span><span class="p">)),</span>
        <span class="p">(</span><span class="s">&#39;read_app_value&#39;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s">r&#39;&lt;(app)\((\?[a-z][a-z]*)\s*,&#39;</span>
                                       <span class="s">r&#39;\s*(\?[a-z][a-z]*)\)&gt;&#39;</span><span class="p">)),</span>
<span class="c">#       (&#39;read_logic_value&#39;, re.compile(r&#39;&lt;([^&gt;]*)&gt;&#39;)),</span>
        <span class="c">#lazily match any character after &#39;&lt;&#39; until we hit a &#39;&gt;&#39; not preceded by &#39;-&#39;</span>
        <span class="p">(</span><span class="s">&#39;read_logic_value&#39;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s">r&#39;&lt;(.*?)(?&lt;!-)&gt;&#39;</span><span class="p">)),</span>
        <span class="p">(</span><span class="s">&#39;read_set_value&#39;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s">r&#39;{&#39;</span><span class="p">)),</span>
        <span class="p">(</span><span class="s">&#39;read_tuple_value&#39;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s">r&#39;\(&#39;</span><span class="p">)),</span>
        <span class="p">]</span>

<div class="viewcode-block" id="FeatStructReader.read_fstruct_value"><a class="viewcode-back" href="../../api/nltk.html#nltk.featstruct.FeatStructReader.read_fstruct_value">[docs]</a>    <span class="k">def</span> <span class="nf">read_fstruct_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">reentrances</span><span class="p">,</span> <span class="n">match</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_partial</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">reentrances</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="FeatStructReader.read_str_value"><a class="viewcode-back" href="../../api/nltk.html#nltk.featstruct.FeatStructReader.read_str_value">[docs]</a>    <span class="k">def</span> <span class="nf">read_str_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">reentrances</span><span class="p">,</span> <span class="n">match</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">read_str</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="FeatStructReader.read_int_value"><a class="viewcode-back" href="../../api/nltk.html#nltk.featstruct.FeatStructReader.read_int_value">[docs]</a>    <span class="k">def</span> <span class="nf">read_int_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">reentrances</span><span class="p">,</span> <span class="n">match</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">()),</span> <span class="n">match</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>

    <span class="c"># Note: the &#39;?&#39; is included in the variable name.</span></div>
<div class="viewcode-block" id="FeatStructReader.read_var_value"><a class="viewcode-back" href="../../api/nltk.html#nltk.featstruct.FeatStructReader.read_var_value">[docs]</a>    <span class="k">def</span> <span class="nf">read_var_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">reentrances</span><span class="p">,</span> <span class="n">match</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Variable</span><span class="p">(</span><span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">()),</span> <span class="n">match</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>
</div>
    <span class="n">_SYM_CONSTS</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;None&#39;</span><span class="p">:</span><span class="bp">None</span><span class="p">,</span> <span class="s">&#39;True&#39;</span><span class="p">:</span><span class="bp">True</span><span class="p">,</span> <span class="s">&#39;False&#39;</span><span class="p">:</span><span class="bp">False</span><span class="p">}</span>
<div class="viewcode-block" id="FeatStructReader.read_sym_value"><a class="viewcode-back" href="../../api/nltk.html#nltk.featstruct.FeatStructReader.read_sym_value">[docs]</a>    <span class="k">def</span> <span class="nf">read_sym_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">reentrances</span><span class="p">,</span> <span class="n">match</span><span class="p">):</span>
        <span class="n">val</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(),</span> <span class="n">match</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_SYM_CONSTS</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">val</span><span class="p">),</span> <span class="n">end</span>
</div>
<div class="viewcode-block" id="FeatStructReader.read_app_value"><a class="viewcode-back" href="../../api/nltk.html#nltk.featstruct.FeatStructReader.read_app_value">[docs]</a>    <span class="k">def</span> <span class="nf">read_app_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">reentrances</span><span class="p">,</span> <span class="n">match</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Mainly included for backwards compat.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_logic_parser</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%s</span><span class="s">(</span><span class="si">%s</span><span class="s">)&#39;</span> <span class="o">%</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)),</span> <span class="n">match</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="FeatStructReader.read_logic_value"><a class="viewcode-back" href="../../api/nltk.html#nltk.featstruct.FeatStructReader.read_logic_value">[docs]</a>    <span class="k">def</span> <span class="nf">read_logic_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">reentrances</span><span class="p">,</span> <span class="n">match</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">expr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_logic_parser</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
            <span class="k">except</span> <span class="n">LogicalExpressionException</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">expr</span><span class="p">,</span> <span class="n">match</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;logic expression&#39;</span><span class="p">,</span> <span class="n">match</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
</div>
<div class="viewcode-block" id="FeatStructReader.read_tuple_value"><a class="viewcode-back" href="../../api/nltk.html#nltk.featstruct.FeatStructReader.read_tuple_value">[docs]</a>    <span class="k">def</span> <span class="nf">read_tuple_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">reentrances</span><span class="p">,</span> <span class="n">match</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_seq_value</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">reentrances</span><span class="p">,</span> <span class="n">match</span><span class="p">,</span> <span class="s">&#39;)&#39;</span><span class="p">,</span>
                                     <span class="n">FeatureValueTuple</span><span class="p">,</span> <span class="n">FeatureValueConcat</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="FeatStructReader.read_set_value"><a class="viewcode-back" href="../../api/nltk.html#nltk.featstruct.FeatStructReader.read_set_value">[docs]</a>    <span class="k">def</span> <span class="nf">read_set_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">reentrances</span><span class="p">,</span> <span class="n">match</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_seq_value</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">reentrances</span><span class="p">,</span> <span class="n">match</span><span class="p">,</span> <span class="s">&#39;}&#39;</span><span class="p">,</span>
                                     <span class="n">FeatureValueSet</span><span class="p">,</span> <span class="n">FeatureValueUnion</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">_read_seq_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">reentrances</span><span class="p">,</span> <span class="n">match</span><span class="p">,</span>
                         <span class="n">close_paren</span><span class="p">,</span> <span class="n">seq_class</span><span class="p">,</span> <span class="n">plus_class</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper function used by read_tuple_value and read_set_value.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cp</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="n">close_paren</span><span class="p">)</span>
        <span class="n">position</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>
        <span class="c"># Special syntax fo empty tuples:</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s">r&#39;\s*/?\s*</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">cp</span><span class="p">)</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">m</span><span class="p">:</span> <span class="k">return</span> <span class="n">seq_class</span><span class="p">(),</span> <span class="n">m</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>
        <span class="c"># Read values:</span>
        <span class="n">values</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">seen_plus</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="c"># Close paren: return value.</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s">r&#39;\s*</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">cp</span><span class="p">)</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">m</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">seen_plus</span><span class="p">:</span> <span class="k">return</span> <span class="n">plus_class</span><span class="p">(</span><span class="n">values</span><span class="p">),</span> <span class="n">m</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span> <span class="k">return</span> <span class="n">seq_class</span><span class="p">(</span><span class="n">values</span><span class="p">),</span> <span class="n">m</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>

            <span class="c"># Read the next value.</span>
            <span class="n">val</span><span class="p">,</span> <span class="n">position</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_value</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">reentrances</span><span class="p">)</span>
            <span class="n">values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

            <span class="c"># Comma or looking at close paren</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s">r&#39;\s*(,|\+|(?=</span><span class="si">%s</span><span class="s">))\s*&#39;</span> <span class="o">%</span> <span class="n">cp</span><span class="p">)</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">m</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;&#39;,&#39; or &#39;+&#39; or &#39;</span><span class="si">%s</span><span class="s">&#39;&quot;</span> <span class="o">%</span> <span class="n">cp</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="s">&#39;+&#39;</span><span class="p">:</span> <span class="n">seen_plus</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="n">position</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>

<span class="c">######################################################################</span>
<span class="c">#{ Demo</span>
<span class="c">######################################################################</span>
</div>
<span class="k">def</span> <span class="nf">display_unification</span><span class="p">(</span><span class="n">fs1</span><span class="p">,</span> <span class="n">fs2</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="s">&#39;  &#39;</span><span class="p">):</span>
    <span class="c"># Print the two input feature structures, side by side.</span>
    <span class="n">fs1_lines</span> <span class="o">=</span> <span class="p">(</span><span class="s">&quot;</span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">fs1</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">)</span>
    <span class="n">fs2_lines</span> <span class="o">=</span> <span class="p">(</span><span class="s">&quot;</span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">fs2</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">fs1_lines</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">fs2_lines</span><span class="p">):</span>
        <span class="n">blankline</span> <span class="o">=</span> <span class="s">&#39;[&#39;</span><span class="o">+</span><span class="s">&#39; &#39;</span><span class="o">*</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">fs2_lines</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="s">&#39;]&#39;</span>
        <span class="n">fs2_lines</span> <span class="o">+=</span> <span class="p">[</span><span class="n">blankline</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">fs1_lines</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">blankline</span> <span class="o">=</span> <span class="s">&#39;[&#39;</span><span class="o">+</span><span class="s">&#39; &#39;</span><span class="o">*</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">fs1_lines</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="s">&#39;]&#39;</span>
        <span class="n">fs1_lines</span> <span class="o">+=</span> <span class="p">[</span><span class="n">blankline</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">fs2_lines</span><span class="p">)</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">fs1_line</span><span class="p">,</span> <span class="n">fs2_line</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">fs1_lines</span><span class="p">,</span> <span class="n">fs2_lines</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="n">indent</span> <span class="o">+</span> <span class="n">fs1_line</span> <span class="o">+</span> <span class="s">&#39;   &#39;</span> <span class="o">+</span> <span class="n">fs2_line</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">indent</span><span class="o">+</span><span class="s">&#39;-&#39;</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">fs1_lines</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">+</span><span class="s">&#39;   &#39;</span><span class="o">+</span><span class="s">&#39;-&#39;</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">fs2_lines</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

    <span class="n">linelen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">fs1_lines</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">3</span>
    <span class="k">print</span><span class="p">(</span><span class="n">indent</span><span class="o">+</span><span class="s">&#39;|               |&#39;</span><span class="o">.</span><span class="n">center</span><span class="p">(</span><span class="n">linelen</span><span class="p">))</span>
    <span class="k">print</span><span class="p">(</span><span class="n">indent</span><span class="o">+</span><span class="s">&#39;+-----UNIFY-----+&#39;</span><span class="o">.</span><span class="n">center</span><span class="p">(</span><span class="n">linelen</span><span class="p">))</span>
    <span class="k">print</span><span class="p">(</span><span class="n">indent</span><span class="o">+</span><span class="s">&#39;|&#39;</span><span class="o">.</span><span class="n">center</span><span class="p">(</span><span class="n">linelen</span><span class="p">))</span>
    <span class="k">print</span><span class="p">(</span><span class="n">indent</span><span class="o">+</span><span class="s">&#39;V&#39;</span><span class="o">.</span><span class="n">center</span><span class="p">(</span><span class="n">linelen</span><span class="p">))</span>

    <span class="n">bindings</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">fs1</span><span class="o">.</span><span class="n">unify</span><span class="p">(</span><span class="n">fs2</span><span class="p">,</span> <span class="n">bindings</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="n">indent</span><span class="o">+</span><span class="s">&#39;(FAILED)&#39;</span><span class="o">.</span><span class="n">center</span><span class="p">(</span><span class="n">linelen</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">indent</span><span class="o">+</span><span class="n">l</span><span class="o">.</span><span class="n">center</span><span class="p">(</span><span class="n">linelen</span><span class="p">)</span>
                         <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&quot;</span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">result</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">)))</span>
        <span class="k">if</span> <span class="n">bindings</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">bindings</span><span class="o">.</span><span class="n">bound_variables</span><span class="p">())</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">bindings</span><span class="p">)</span><span class="o">.</span><span class="n">center</span><span class="p">(</span><span class="n">linelen</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">result</span>

<span class="k">def</span> <span class="nf">interactive_demo</span><span class="p">(</span><span class="n">trace</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="kn">import</span> <span class="nn">random</span><span class="o">,</span> <span class="nn">sys</span>

    <span class="n">HELP</span> <span class="o">=</span> <span class="s">&#39;&#39;&#39;</span>
<span class="s">    1-</span><span class="si">%d</span><span class="s">: Select the corresponding feature structure</span>
<span class="s">    q: Quit</span>
<span class="s">    t: Turn tracing on or off</span>
<span class="s">    l: List all feature structures</span>
<span class="s">    ?: Help</span>
<span class="s">    &#39;&#39;&#39;</span>

    <span class="k">print</span><span class="p">(</span><span class="s">&#39;&#39;&#39;</span>
<span class="s">    This demo will repeatedly present you with a list of feature</span>
<span class="s">    structures, and ask you to choose two for unification.  Whenever a</span>
<span class="s">    new feature structure is generated, it is added to the list of</span>
<span class="s">    choices that you can pick from.  However, since this can be a</span>
<span class="s">    large number of feature structures, the demo will only print out a</span>
<span class="s">    random subset for you to choose between at a given time.  If you</span>
<span class="s">    want to see the complete lists, type &quot;l&quot;.  For a list of valid</span>
<span class="s">    commands, type &quot;?&quot;.</span>
<span class="s">    &#39;&#39;&#39;</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;Press &quot;Enter&quot; to continue...&#39;</span><span class="p">)</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">stdin</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>

    <span class="n">fstruct_strings</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s">&#39;[agr=[number=sing, gender=masc]]&#39;</span><span class="p">,</span>
        <span class="s">&#39;[agr=[gender=masc, person=3]]&#39;</span><span class="p">,</span>
        <span class="s">&#39;[agr=[gender=fem, person=3]]&#39;</span><span class="p">,</span>
        <span class="s">&#39;[subj=[agr=(1)[]], agr-&gt;(1)]&#39;</span><span class="p">,</span>
        <span class="s">&#39;[obj=?x]&#39;</span><span class="p">,</span> <span class="s">&#39;[subj=?x]&#39;</span><span class="p">,</span>
        <span class="s">&#39;[/=None]&#39;</span><span class="p">,</span> <span class="s">&#39;[/=NP]&#39;</span><span class="p">,</span>
        <span class="s">&#39;[cat=NP]&#39;</span><span class="p">,</span> <span class="s">&#39;[cat=VP]&#39;</span><span class="p">,</span> <span class="s">&#39;[cat=PP]&#39;</span><span class="p">,</span>
        <span class="s">&#39;[subj=[agr=[gender=?y]], obj=[agr=[gender=?y]]]&#39;</span><span class="p">,</span>
        <span class="s">&#39;[gender=masc, agr=?C]&#39;</span><span class="p">,</span>
        <span class="s">&#39;[gender=?S, agr=[gender=?S,person=3]]&#39;</span>
        <span class="p">]</span>

    <span class="n">all_fstructs</span> <span class="o">=</span> <span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="n">FeatStruct</span><span class="p">(</span><span class="n">fstruct_strings</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">fstruct_strings</span><span class="p">))]</span>

    <span class="k">def</span> <span class="nf">list_fstructs</span><span class="p">(</span><span class="n">fstructs</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">fstruct</span> <span class="ow">in</span> <span class="n">fstructs</span><span class="p">:</span>
            <span class="k">print</span><span class="p">()</span>
            <span class="n">lines</span> <span class="o">=</span> <span class="p">(</span><span class="s">&quot;</span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">fstruct</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">)</span>
            <span class="k">print</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%3d</span><span class="s">: </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">lines</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span> <span class="k">print</span><span class="p">(</span><span class="s">&#39;     &#39;</span><span class="o">+</span><span class="n">line</span><span class="p">)</span>
        <span class="k">print</span><span class="p">()</span>


    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="c"># Pick 5 feature structures at random from the master list.</span>
        <span class="n">MAX_CHOICES</span> <span class="o">=</span> <span class="mi">5</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_fstructs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">MAX_CHOICES</span><span class="p">:</span>
            <span class="n">fstructs</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">random</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">all_fstructs</span><span class="p">,</span> <span class="n">MAX_CHOICES</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fstructs</span> <span class="o">=</span> <span class="n">all_fstructs</span>

        <span class="k">print</span><span class="p">(</span><span class="s">&#39;_&#39;</span><span class="o">*</span><span class="mi">75</span><span class="p">)</span>

        <span class="k">print</span><span class="p">(</span><span class="s">&#39;Choose two feature structures to unify:&#39;</span><span class="p">)</span>
        <span class="n">list_fstructs</span><span class="p">(</span><span class="n">fstructs</span><span class="p">)</span>

        <span class="n">selected</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">,</span><span class="bp">None</span><span class="p">]</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">nth</span><span class="p">,</span><span class="n">i</span><span class="p">)</span> <span class="ow">in</span> <span class="p">((</span><span class="s">&#39;First&#39;</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;Second&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">)):</span>
            <span class="k">while</span> <span class="n">selected</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">print</span><span class="p">((</span><span class="s">&#39;</span><span class="si">%s</span><span class="s"> feature structure (1-</span><span class="si">%d</span><span class="s">,q,t,l,?): &#39;</span>
                       <span class="o">%</span> <span class="p">(</span><span class="n">nth</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_fstructs</span><span class="p">))),</span> <span class="n">end</span><span class="o">=</span><span class="s">&#39; &#39;</span><span class="p">)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="nb">input</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdin</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
                    <span class="k">if</span> <span class="nb">input</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;q&#39;</span><span class="p">,</span> <span class="s">&#39;Q&#39;</span><span class="p">,</span> <span class="s">&#39;x&#39;</span><span class="p">,</span> <span class="s">&#39;X&#39;</span><span class="p">):</span> <span class="k">return</span>
                    <span class="k">if</span> <span class="nb">input</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;t&#39;</span><span class="p">,</span> <span class="s">&#39;T&#39;</span><span class="p">):</span>
                        <span class="n">trace</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">trace</span>
                        <span class="k">print</span><span class="p">(</span><span class="s">&#39;   Trace = </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">trace</span><span class="p">)</span>
                        <span class="k">continue</span>
                    <span class="k">if</span> <span class="nb">input</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;h&#39;</span><span class="p">,</span> <span class="s">&#39;H&#39;</span><span class="p">,</span> <span class="s">&#39;?&#39;</span><span class="p">):</span>
                        <span class="k">print</span><span class="p">(</span><span class="n">HELP</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">fstructs</span><span class="p">));</span> <span class="k">continue</span>
                    <span class="k">if</span> <span class="nb">input</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;l&#39;</span><span class="p">,</span> <span class="s">&#39;L&#39;</span><span class="p">):</span>
                        <span class="n">list_fstructs</span><span class="p">(</span><span class="n">all_fstructs</span><span class="p">);</span> <span class="k">continue</span>
                    <span class="n">num</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
                    <span class="n">selected</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">all_fstructs</span><span class="p">[</span><span class="n">num</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                    <span class="k">print</span><span class="p">()</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="k">print</span><span class="p">(</span><span class="s">&#39;Bad sentence number&#39;</span><span class="p">)</span>
                    <span class="k">continue</span>

        <span class="k">if</span> <span class="n">trace</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">selected</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">unify</span><span class="p">(</span><span class="n">selected</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">trace</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">display_unification</span><span class="p">(</span><span class="n">selected</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">selected</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">fstruct</span> <span class="ow">in</span> <span class="n">all_fstructs</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">repr</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">==</span> <span class="nb">repr</span><span class="p">(</span><span class="n">fstruct</span><span class="p">):</span> <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">all_fstructs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">all_fstructs</span><span class="p">),</span> <span class="n">result</span><span class="p">))</span>

        <span class="k">print</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">Type &quot;Enter&quot; to continue unifying; or &quot;q&quot; to quit.&#39;</span><span class="p">)</span>
        <span class="nb">input</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdin</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">input</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;q&#39;</span><span class="p">,</span> <span class="s">&#39;Q&#39;</span><span class="p">,</span> <span class="s">&#39;x&#39;</span><span class="p">,</span> <span class="s">&#39;X&#39;</span><span class="p">):</span> <span class="k">return</span>

<span class="k">def</span> <span class="nf">demo</span><span class="p">(</span><span class="n">trace</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Just for testing</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c">#import random</span>

    <span class="c"># processor breaks with values like &#39;3rd&#39;</span>
    <span class="n">fstruct_strings</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s">&#39;[agr=[number=sing, gender=masc]]&#39;</span><span class="p">,</span>
        <span class="s">&#39;[agr=[gender=masc, person=3]]&#39;</span><span class="p">,</span>
        <span class="s">&#39;[agr=[gender=fem, person=3]]&#39;</span><span class="p">,</span>
        <span class="s">&#39;[subj=[agr=(1)[]], agr-&gt;(1)]&#39;</span><span class="p">,</span>
        <span class="s">&#39;[obj=?x]&#39;</span><span class="p">,</span> <span class="s">&#39;[subj=?x]&#39;</span><span class="p">,</span>
        <span class="s">&#39;[/=None]&#39;</span><span class="p">,</span> <span class="s">&#39;[/=NP]&#39;</span><span class="p">,</span>
        <span class="s">&#39;[cat=NP]&#39;</span><span class="p">,</span> <span class="s">&#39;[cat=VP]&#39;</span><span class="p">,</span> <span class="s">&#39;[cat=PP]&#39;</span><span class="p">,</span>
        <span class="s">&#39;[subj=[agr=[gender=?y]], obj=[agr=[gender=?y]]]&#39;</span><span class="p">,</span>
        <span class="s">&#39;[gender=masc, agr=?C]&#39;</span><span class="p">,</span>
        <span class="s">&#39;[gender=?S, agr=[gender=?S,person=3]]&#39;</span>
    <span class="p">]</span>
    <span class="n">all_fstructs</span> <span class="o">=</span> <span class="p">[</span><span class="n">FeatStruct</span><span class="p">(</span><span class="n">fss</span><span class="p">)</span> <span class="k">for</span> <span class="n">fss</span> <span class="ow">in</span> <span class="n">fstruct_strings</span><span class="p">]</span>
    <span class="c">#MAX_CHOICES = 5</span>
    <span class="c">#if len(all_fstructs) &gt; MAX_CHOICES:</span>
        <span class="c">#fstructs = random.sample(all_fstructs, MAX_CHOICES)</span>
        <span class="c">#fstructs.sort()</span>
    <span class="c">#else:</span>
        <span class="c">#fstructs = all_fstructs</span>

    <span class="k">for</span> <span class="n">fs1</span> <span class="ow">in</span> <span class="n">all_fstructs</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">fs2</span> <span class="ow">in</span> <span class="n">all_fstructs</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">*******************</span><span class="se">\n</span><span class="s">fs1 is:</span><span class="se">\n</span><span class="si">%s</span><span class="se">\n\n</span><span class="s">fs2 is:</span><span class="se">\n</span><span class="si">%s</span><span class="se">\n\n</span><span class="s">result is:</span><span class="se">\n</span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">fs1</span><span class="p">,</span> <span class="n">fs2</span><span class="p">,</span> <span class="n">unify</span><span class="p">(</span><span class="n">fs1</span><span class="p">,</span> <span class="n">fs2</span><span class="p">)))</span>


<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">demo</span><span class="p">()</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;FeatStruct&#39;</span><span class="p">,</span> <span class="s">&#39;FeatDict&#39;</span><span class="p">,</span> <span class="s">&#39;FeatList&#39;</span><span class="p">,</span> <span class="s">&#39;unify&#39;</span><span class="p">,</span> <span class="s">&#39;subsumes&#39;</span><span class="p">,</span> <span class="s">&#39;conflicts&#39;</span><span class="p">,</span>
           <span class="s">&#39;Feature&#39;</span><span class="p">,</span> <span class="s">&#39;SlashFeature&#39;</span><span class="p">,</span> <span class="s">&#39;RangeFeature&#39;</span><span class="p">,</span> <span class="s">&#39;SLASH&#39;</span><span class="p">,</span> <span class="s">&#39;TYPE&#39;</span><span class="p">,</span>
           <span class="s">&#39;FeatStructReader&#39;</span><span class="p">]</span>
</pre></div>

          </div>
        </div>
      </div>
        </div>
        <div class="sidebar">
          <h3>Table Of Contents</h3>
          <ul>
<li class="toctree-l1"><a class="reference internal" href="../../news.html">NLTK News</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../install.html">Installing NLTK</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../data.html">Installing NLTK Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contribute.html">Contribute to NLTK</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/nltk/nltk/wiki/FAQ">FAQ</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/nltk/nltk/wiki">Wiki</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api/nltk.html">API</a></li>
<li class="toctree-l1"><a class="reference external" href="http://www.nltk.org/howto">HOWTO</a></li>
</ul>

          <div role="search">
            <h3 style="margin-top: 1.5em;">Search</h3>
            <form class="search" action="../../search.html" method="get">
                <input type="text" name="q" />
                <input type="submit" value="Go" />
                <input type="hidden" name="check_keywords" value="yes" />
                <input type="hidden" name="area" value="default" />
            </form>
            <p class="searchtip" style="font-size: 90%">
                Enter search terms or a module, class or function name.
            </p>
          </div>
        </div>
        <div class="clearer"></div>
      </div>
    </div>

    <div class="footer-wrapper">
      <div class="footer">
        <div class="left">
          <div role="navigation" aria-label="related navigaton">
            <a href="../../py-modindex.html" title="Python Module Index"
              >modules</a> |
            <a href="../../genindex.html" title="General Index"
              >index</a>
          </div>
          <div role="note" aria-label="source link">
          </div>
        </div>

        <div class="right">
          
    <div class="footer" role="contentinfo">
        &copy; Copyright 2015, NLTK Project.
      Last updated on Apr 09, 2016.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.1.
    </div>
        </div>
        <div class="clearer"></div>
      </div>
    </div>

  </body>
</html>