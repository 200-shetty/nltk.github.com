

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>nltk.parse.pchart &mdash; NLTK 2.0 documentation</title>
    
    <link rel="stylesheet" href="../../../_static/agogo.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '2.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <link rel="top" title="NLTK 2.0 documentation" href="../../../index.html" />
    <link rel="up" title="Module code" href="../../index.html" /> 
  </head>
  <body>
    <div class="header-wrapper">
      <div class="header">
        <div class="headertitle"><a
          href="../../../index.html">NLTK 2.0 documentation</a></div>
        <div class="rel">
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a>
        </div>
       </div>
    </div>

    <div class="content-wrapper">
      <div class="content">
        <div class="document">
            
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for nltk.parse.pchart</h1><div class="highlight"><pre>
<span class="c"># Natural Language Toolkit: Probabilistic Chart Parsers</span>
<span class="c">#</span>
<span class="c"># Copyright (C) 2001-2012 NLTK Project</span>
<span class="c"># Author: Edward Loper &lt;edloper@gradient.cis.upenn.edu&gt;</span>
<span class="c">#         Steven Bird &lt;sb@csse.unimelb.edu.au&gt;</span>
<span class="c"># URL: &lt;http://www.nltk.org/&gt;</span>
<span class="c"># For license information, see LICENSE.TXT</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Classes and interfaces for associating probabilities with tree</span>
<span class="sd">structures that represent the internal organization of a text.  The</span>
<span class="sd">probabilistic parser module defines ``BottomUpProbabilisticChartParser``.</span>

<span class="sd">``BottomUpProbabilisticChartParser`` is an abstract class that implements</span>
<span class="sd">a bottom-up chart parser for ``PCFG`` grammars.  It maintains a queue of edges,</span>
<span class="sd">and adds them to the chart one at a time.  The ordering of this queue</span>
<span class="sd">is based on the probabilities associated with the edges, allowing the</span>
<span class="sd">parser to expand more likely edges before less likely ones.  Each</span>
<span class="sd">subclass implements a different queue ordering, producing different</span>
<span class="sd">search strategies.  Currently the following subclasses are defined:</span>

<span class="sd">  - ``InsideChartParser`` searches edges in decreasing order of</span>
<span class="sd">    their trees&#39; inside probabilities.</span>
<span class="sd">  - ``RandomChartParser`` searches edges in random order.</span>
<span class="sd">  - ``LongestChartParser`` searches edges in decreasing order of their</span>
<span class="sd">    location&#39;s length.</span>

<span class="sd">The ``BottomUpProbabilisticChartParser`` constructor has an optional</span>
<span class="sd">argument beam_size.  If non-zero, this controls the size of the beam</span>
<span class="sd">(aka the edge queue).  This option is most useful with InsideChartParser.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c">##//////////////////////////////////////////////////////</span>
<span class="c">##  Bottom-Up PCFG Chart Parser</span>
<span class="c">##//////////////////////////////////////////////////////</span>

<span class="c"># [XX] This might not be implemented quite right -- it would be better</span>
<span class="c"># to associate probabilities with child pointer lists.</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span>
<span class="kn">from</span> <span class="nn">nltk.tree</span> <span class="kn">import</span> <span class="n">Tree</span><span class="p">,</span> <span class="n">ProbabilisticTree</span>
<span class="kn">from</span> <span class="nn">nltk.grammar</span> <span class="kn">import</span> <span class="n">Nonterminal</span><span class="p">,</span> <span class="n">WeightedGrammar</span>

<span class="kn">from</span> <span class="nn">nltk.parse.api</span> <span class="kn">import</span> <span class="n">ParserI</span>
<span class="kn">from</span> <span class="nn">nltk.parse.chart</span> <span class="kn">import</span> <span class="n">Chart</span><span class="p">,</span> <span class="n">LeafEdge</span><span class="p">,</span> <span class="n">TreeEdge</span><span class="p">,</span> <span class="n">AbstractChartRule</span>

<span class="c"># Probabilistic edges</span>
<div class="viewcode-block" id="ProbabilisticLeafEdge"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.pchart.ProbabilisticLeafEdge">[docs]</a><span class="k">class</span> <span class="nc">ProbabilisticLeafEdge</span><span class="p">(</span><span class="n">LeafEdge</span><span class="p">):</span>
<div class="viewcode-block" id="ProbabilisticLeafEdge.prob"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.pchart.ProbabilisticLeafEdge.prob">[docs]</a>    <span class="k">def</span> <span class="nf">prob</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="mf">1.0</span>
</div></div>
<div class="viewcode-block" id="ProbabilisticTreeEdge"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.pchart.ProbabilisticTreeEdge">[docs]</a><span class="k">class</span> <span class="nc">ProbabilisticTreeEdge</span><span class="p">(</span><span class="n">TreeEdge</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prob</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_prob</span> <span class="o">=</span> <span class="n">prob</span>
        <span class="n">TreeEdge</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<div class="viewcode-block" id="ProbabilisticTreeEdge.prob"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.pchart.ProbabilisticTreeEdge.prob">[docs]</a>    <span class="k">def</span> <span class="nf">prob</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prob</span>
</div>
    <span class="k">def</span> <span class="nf">__cmp__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prob</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">prob</span><span class="p">():</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">return</span> <span class="n">TreeEdge</span><span class="o">.</span><span class="n">__cmp__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="ProbabilisticTreeEdge.from_production"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.pchart.ProbabilisticTreeEdge.from_production">[docs]</a>    <span class="k">def</span> <span class="nf">from_production</span><span class="p">(</span><span class="n">production</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">ProbabilisticTreeEdge</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">index</span><span class="p">),</span> <span class="n">production</span><span class="o">.</span><span class="n">lhs</span><span class="p">(),</span>
                                     <span class="n">production</span><span class="o">.</span><span class="n">rhs</span><span class="p">(),</span> <span class="mi">0</span><span class="p">)</span>

<span class="c"># Rules using probabilistic edges</span></div></div>
<div class="viewcode-block" id="ProbabilisticBottomUpInitRule"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.pchart.ProbabilisticBottomUpInitRule">[docs]</a><span class="k">class</span> <span class="nc">ProbabilisticBottomUpInitRule</span><span class="p">(</span><span class="n">AbstractChartRule</span><span class="p">):</span>
    <span class="n">NUM_EDGES</span><span class="o">=</span><span class="mi">0</span>
<div class="viewcode-block" id="ProbabilisticBottomUpInitRule.apply_iter"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.pchart.ProbabilisticBottomUpInitRule.apply_iter">[docs]</a>    <span class="k">def</span> <span class="nf">apply_iter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chart</span><span class="p">,</span> <span class="n">grammar</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">chart</span><span class="o">.</span><span class="n">num_leaves</span><span class="p">()):</span>
            <span class="n">new_edge</span> <span class="o">=</span> <span class="n">ProbabilisticLeafEdge</span><span class="p">(</span><span class="n">chart</span><span class="o">.</span><span class="n">leaf</span><span class="p">(</span><span class="n">index</span><span class="p">),</span> <span class="n">index</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">chart</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">new_edge</span><span class="p">,</span> <span class="p">()):</span>
                <span class="k">yield</span> <span class="n">new_edge</span>
</div></div>
<div class="viewcode-block" id="ProbabilisticBottomUpPredictRule"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.pchart.ProbabilisticBottomUpPredictRule">[docs]</a><span class="k">class</span> <span class="nc">ProbabilisticBottomUpPredictRule</span><span class="p">(</span><span class="n">AbstractChartRule</span><span class="p">):</span>
    <span class="n">NUM_EDGES</span><span class="o">=</span><span class="mi">1</span>
<div class="viewcode-block" id="ProbabilisticBottomUpPredictRule.apply_iter"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.pchart.ProbabilisticBottomUpPredictRule.apply_iter">[docs]</a>    <span class="k">def</span> <span class="nf">apply_iter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chart</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span> <span class="n">edge</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">edge</span><span class="o">.</span><span class="n">is_incomplete</span><span class="p">():</span> <span class="k">return</span>
        <span class="k">for</span> <span class="n">prod</span> <span class="ow">in</span> <span class="n">grammar</span><span class="o">.</span><span class="n">productions</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">edge</span><span class="o">.</span><span class="n">lhs</span><span class="p">()</span> <span class="o">==</span> <span class="n">prod</span><span class="o">.</span><span class="n">rhs</span><span class="p">()[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">new_edge</span> <span class="o">=</span> <span class="n">ProbabilisticTreeEdge</span><span class="o">.</span><span class="n">from_production</span><span class="p">(</span><span class="n">prod</span><span class="p">,</span> <span class="n">edge</span><span class="o">.</span><span class="n">start</span><span class="p">(),</span> <span class="n">prod</span><span class="o">.</span><span class="n">prob</span><span class="p">())</span>
                <span class="k">if</span> <span class="n">chart</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">new_edge</span><span class="p">,</span> <span class="p">()):</span>
                    <span class="k">yield</span> <span class="n">new_edge</span>
</div></div>
<div class="viewcode-block" id="ProbabilisticFundamentalRule"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.pchart.ProbabilisticFundamentalRule">[docs]</a><span class="k">class</span> <span class="nc">ProbabilisticFundamentalRule</span><span class="p">(</span><span class="n">AbstractChartRule</span><span class="p">):</span>
    <span class="n">NUM_EDGES</span><span class="o">=</span><span class="mi">2</span>
<div class="viewcode-block" id="ProbabilisticFundamentalRule.apply_iter"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.pchart.ProbabilisticFundamentalRule.apply_iter">[docs]</a>    <span class="k">def</span> <span class="nf">apply_iter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chart</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span> <span class="n">left_edge</span><span class="p">,</span> <span class="n">right_edge</span><span class="p">):</span>
        <span class="c"># Make sure the rule is applicable.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">left_edge</span><span class="o">.</span><span class="n">end</span><span class="p">()</span> <span class="o">==</span> <span class="n">right_edge</span><span class="o">.</span><span class="n">start</span><span class="p">()</span> <span class="ow">and</span>
                <span class="n">left_edge</span><span class="o">.</span><span class="n">next</span><span class="p">()</span> <span class="o">==</span> <span class="n">right_edge</span><span class="o">.</span><span class="n">lhs</span><span class="p">()</span> <span class="ow">and</span>
                <span class="n">left_edge</span><span class="o">.</span><span class="n">is_incomplete</span><span class="p">()</span> <span class="ow">and</span> <span class="n">right_edge</span><span class="o">.</span><span class="n">is_complete</span><span class="p">()):</span>
            <span class="k">return</span>

        <span class="c"># Construct the new edge.</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">left_edge</span><span class="o">.</span><span class="n">prob</span><span class="p">()</span> <span class="o">*</span> <span class="n">right_edge</span><span class="o">.</span><span class="n">prob</span><span class="p">()</span>
        <span class="n">new_edge</span> <span class="o">=</span> <span class="n">ProbabilisticTreeEdge</span><span class="p">(</span><span class="n">p</span><span class="p">,</span>
                            <span class="n">span</span><span class="o">=</span><span class="p">(</span><span class="n">left_edge</span><span class="o">.</span><span class="n">start</span><span class="p">(),</span> <span class="n">right_edge</span><span class="o">.</span><span class="n">end</span><span class="p">()),</span>
                            <span class="n">lhs</span><span class="o">=</span><span class="n">left_edge</span><span class="o">.</span><span class="n">lhs</span><span class="p">(),</span> <span class="n">rhs</span><span class="o">=</span><span class="n">left_edge</span><span class="o">.</span><span class="n">rhs</span><span class="p">(),</span>
                            <span class="n">dot</span><span class="o">=</span><span class="n">left_edge</span><span class="o">.</span><span class="n">dot</span><span class="p">()</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

        <span class="c"># Add it to the chart, with appropriate child pointers.</span>
        <span class="n">changed_chart</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">for</span> <span class="n">cpl1</span> <span class="ow">in</span> <span class="n">chart</span><span class="o">.</span><span class="n">child_pointer_lists</span><span class="p">(</span><span class="n">left_edge</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">chart</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">new_edge</span><span class="p">,</span> <span class="n">cpl1</span><span class="o">+</span><span class="p">(</span><span class="n">right_edge</span><span class="p">,)):</span>
                <span class="n">changed_chart</span> <span class="o">=</span> <span class="bp">True</span>

        <span class="c"># If we changed the chart, then generate the edge.</span>
        <span class="k">if</span> <span class="n">changed_chart</span><span class="p">:</span> <span class="k">yield</span> <span class="n">new_edge</span>
</div></div>
<div class="viewcode-block" id="SingleEdgeProbabilisticFundamentalRule"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.pchart.SingleEdgeProbabilisticFundamentalRule">[docs]</a><span class="k">class</span> <span class="nc">SingleEdgeProbabilisticFundamentalRule</span><span class="p">(</span><span class="n">AbstractChartRule</span><span class="p">):</span>
    <span class="n">NUM_EDGES</span><span class="o">=</span><span class="mi">1</span>

    <span class="n">_fundamental_rule</span> <span class="o">=</span> <span class="n">ProbabilisticFundamentalRule</span><span class="p">()</span>

<div class="viewcode-block" id="SingleEdgeProbabilisticFundamentalRule.apply_iter"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.pchart.SingleEdgeProbabilisticFundamentalRule.apply_iter">[docs]</a>    <span class="k">def</span> <span class="nf">apply_iter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chart</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span> <span class="n">edge1</span><span class="p">):</span>
        <span class="n">fr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fundamental_rule</span>
        <span class="k">if</span> <span class="n">edge1</span><span class="o">.</span><span class="n">is_incomplete</span><span class="p">():</span>
            <span class="c"># edge1 = left_edge; edge2 = right_edge</span>
            <span class="k">for</span> <span class="n">edge2</span> <span class="ow">in</span> <span class="n">chart</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="n">edge1</span><span class="o">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">is_complete</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                                     <span class="n">lhs</span><span class="o">=</span><span class="n">edge1</span><span class="o">.</span><span class="n">next</span><span class="p">()):</span>
                <span class="k">for</span> <span class="n">new_edge</span> <span class="ow">in</span> <span class="n">fr</span><span class="o">.</span><span class="n">apply_iter</span><span class="p">(</span><span class="n">chart</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span> <span class="n">edge1</span><span class="p">,</span> <span class="n">edge2</span><span class="p">):</span>
                    <span class="k">yield</span> <span class="n">new_edge</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># edge2 = left_edge; edge1 = right_edge</span>
            <span class="k">for</span> <span class="n">edge2</span> <span class="ow">in</span> <span class="n">chart</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">end</span><span class="o">=</span><span class="n">edge1</span><span class="o">.</span><span class="n">start</span><span class="p">(),</span> <span class="n">is_complete</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                                     <span class="nb">next</span><span class="o">=</span><span class="n">edge1</span><span class="o">.</span><span class="n">lhs</span><span class="p">()):</span>
                <span class="k">for</span> <span class="n">new_edge</span> <span class="ow">in</span> <span class="n">fr</span><span class="o">.</span><span class="n">apply_iter</span><span class="p">(</span><span class="n">chart</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span> <span class="n">edge2</span><span class="p">,</span> <span class="n">edge1</span><span class="p">):</span>
                    <span class="k">yield</span> <span class="n">new_edge</span>
</div>
    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="s">&#39;Fundamental Rule&#39;</span>
</div>
<div class="viewcode-block" id="BottomUpProbabilisticChartParser"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.pchart.BottomUpProbabilisticChartParser">[docs]</a><span class="k">class</span> <span class="nc">BottomUpProbabilisticChartParser</span><span class="p">(</span><span class="n">ParserI</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An abstract bottom-up parser for ``PCFG`` grammars that uses a ``Chart`` to</span>
<span class="sd">    record partial results.  ``BottomUpProbabilisticChartParser`` maintains</span>
<span class="sd">    a queue of edges that can be added to the chart.  This queue is</span>
<span class="sd">    initialized with edges for each token in the text that is being</span>
<span class="sd">    parsed.  ``BottomUpProbabilisticChartParser`` inserts these edges into</span>
<span class="sd">    the chart one at a time, starting with the most likely edges, and</span>
<span class="sd">    proceeding to less likely edges.  For each edge that is added to</span>
<span class="sd">    the chart, it may become possible to insert additional edges into</span>
<span class="sd">    the chart; these are added to the queue.  This process continues</span>
<span class="sd">    until enough complete parses have been generated, or until the</span>
<span class="sd">    queue is empty.</span>

<span class="sd">    The sorting order for the queue is not specified by</span>
<span class="sd">    ``BottomUpProbabilisticChartParser``.  Different sorting orders will</span>
<span class="sd">    result in different search strategies.  The sorting order for the</span>
<span class="sd">    queue is defined by the method ``sort_queue``; subclasses are required</span>
<span class="sd">    to provide a definition for this method.</span>

<span class="sd">    :type _grammar: PCFG</span>
<span class="sd">    :ivar _grammar: The grammar used to parse sentences.</span>
<span class="sd">    :type _trace: int</span>
<span class="sd">    :ivar _trace: The level of tracing output that should be generated</span>
<span class="sd">        when parsing a text.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span> <span class="n">beam_size</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">trace</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new ``BottomUpProbabilisticChartParser``, that uses</span>
<span class="sd">        ``grammar`` to parse texts.</span>

<span class="sd">        :type grammar: PCFG</span>
<span class="sd">        :param grammar: The grammar used to parse texts.</span>
<span class="sd">        :type beam_size: int</span>
<span class="sd">        :param beam_size: The maximum length for the parser&#39;s edge queue.</span>
<span class="sd">        :type trace: int</span>
<span class="sd">        :param trace: The level of tracing that should be used when</span>
<span class="sd">            parsing a text.  ``0`` will generate no tracing output;</span>
<span class="sd">            and higher numbers will produce more verbose tracing</span>
<span class="sd">            output.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">grammar</span><span class="p">,</span> <span class="n">WeightedGrammar</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;The grammar must be probabilistic WeightedGrammar&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_grammar</span> <span class="o">=</span> <span class="n">grammar</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">beam_size</span> <span class="o">=</span> <span class="n">beam_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_trace</span> <span class="o">=</span> <span class="n">trace</span>

<div class="viewcode-block" id="BottomUpProbabilisticChartParser.grammar"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.pchart.BottomUpProbabilisticChartParser.grammar">[docs]</a>    <span class="k">def</span> <span class="nf">grammar</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grammar</span>
</div>
<div class="viewcode-block" id="BottomUpProbabilisticChartParser.trace"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.pchart.BottomUpProbabilisticChartParser.trace">[docs]</a>    <span class="k">def</span> <span class="nf">trace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trace</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the level of tracing output that should be generated when</span>
<span class="sd">        parsing a text.</span>

<span class="sd">        :type trace: int</span>
<span class="sd">        :param trace: The trace level.  A trace level of ``0`` will</span>
<span class="sd">            generate no tracing output; and higher trace levels will</span>
<span class="sd">            produce more verbose tracing output.</span>
<span class="sd">        :rtype: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_trace</span> <span class="o">=</span> <span class="n">trace</span>

    <span class="c"># TODO: change this to conform more with the standard ChartParser</span></div>
<div class="viewcode-block" id="BottomUpProbabilisticChartParser.nbest_parse"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.pchart.BottomUpProbabilisticChartParser.nbest_parse">[docs]</a>    <span class="k">def</span> <span class="nf">nbest_parse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tokens</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_grammar</span><span class="o">.</span><span class="n">check_coverage</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span>
        <span class="n">chart</span> <span class="o">=</span> <span class="n">Chart</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">tokens</span><span class="p">))</span>
        <span class="n">grammar</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grammar</span>

        <span class="c"># Chart parser rules.</span>
        <span class="n">bu_init</span> <span class="o">=</span> <span class="n">ProbabilisticBottomUpInitRule</span><span class="p">()</span>
        <span class="n">bu</span> <span class="o">=</span> <span class="n">ProbabilisticBottomUpPredictRule</span><span class="p">()</span>
        <span class="n">fr</span> <span class="o">=</span> <span class="n">SingleEdgeProbabilisticFundamentalRule</span><span class="p">()</span>

        <span class="c"># Our queue!</span>
        <span class="n">queue</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c"># Initialize the chart.</span>
        <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">bu_init</span><span class="o">.</span><span class="n">apply_iter</span><span class="p">(</span><span class="n">chart</span><span class="p">,</span> <span class="n">grammar</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_trace</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="s">&#39;  </span><span class="si">%-50s</span><span class="s"> [</span><span class="si">%s</span><span class="s">]&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">chart</span><span class="o">.</span><span class="n">pp_edge</span><span class="p">(</span><span class="n">edge</span><span class="p">,</span><span class="n">width</span><span class="o">=</span><span class="mi">2</span><span class="p">),</span>
                                        <span class="n">edge</span><span class="o">.</span><span class="n">prob</span><span class="p">()))</span>
            <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>

        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">queue</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c"># Re-sort the queue.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sort_queue</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="n">chart</span><span class="p">)</span>

            <span class="c"># Prune the queue to the correct size if a beam was defined</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">beam_size</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_prune</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="n">chart</span><span class="p">)</span>

            <span class="c"># Get the best edge.</span>
            <span class="n">edge</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_trace</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="s">&#39;  </span><span class="si">%-50s</span><span class="s"> [</span><span class="si">%s</span><span class="s">]&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">chart</span><span class="o">.</span><span class="n">pp_edge</span><span class="p">(</span><span class="n">edge</span><span class="p">,</span><span class="n">width</span><span class="o">=</span><span class="mi">2</span><span class="p">),</span>
                                        <span class="n">edge</span><span class="o">.</span><span class="n">prob</span><span class="p">()))</span>

            <span class="c"># Apply BU &amp; FR to it.</span>
            <span class="n">queue</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">bu</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">chart</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span> <span class="n">edge</span><span class="p">))</span>
            <span class="n">queue</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">fr</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">chart</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span> <span class="n">edge</span><span class="p">))</span>

        <span class="c"># Get a list of complete parses.</span>
        <span class="n">parses</span> <span class="o">=</span> <span class="n">chart</span><span class="o">.</span><span class="n">parses</span><span class="p">(</span><span class="n">grammar</span><span class="o">.</span><span class="n">start</span><span class="p">(),</span> <span class="n">ProbabilisticTree</span><span class="p">)</span>

        <span class="c"># Assign probabilities to the trees.</span>
        <span class="n">prod_probs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">prod</span> <span class="ow">in</span> <span class="n">grammar</span><span class="o">.</span><span class="n">productions</span><span class="p">():</span>
            <span class="n">prod_probs</span><span class="p">[</span><span class="n">prod</span><span class="o">.</span><span class="n">lhs</span><span class="p">(),</span> <span class="n">prod</span><span class="o">.</span><span class="n">rhs</span><span class="p">()]</span> <span class="o">=</span> <span class="n">prod</span><span class="o">.</span><span class="n">prob</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">parse</span> <span class="ow">in</span> <span class="n">parses</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_setprob</span><span class="p">(</span><span class="n">parse</span><span class="p">,</span> <span class="n">prod_probs</span><span class="p">)</span>

        <span class="c"># Sort by probability</span>
        <span class="n">parses</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="k">lambda</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">:</span> <span class="nb">cmp</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">prob</span><span class="p">(),</span> <span class="n">a</span><span class="o">.</span><span class="n">prob</span><span class="p">()))</span>

        <span class="k">return</span> <span class="n">parses</span><span class="p">[:</span><span class="n">n</span><span class="p">]</span>
</div>
    <span class="k">def</span> <span class="nf">_setprob</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">,</span> <span class="n">prod_probs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">tree</span><span class="o">.</span><span class="n">prob</span><span class="p">()</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span> <span class="k">return</span>

        <span class="c"># Get the prob of the CFG production.</span>
        <span class="n">lhs</span> <span class="o">=</span> <span class="n">Nonterminal</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">node</span><span class="p">)</span>
        <span class="n">rhs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">tree</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">Tree</span><span class="p">):</span>
                <span class="n">rhs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Nonterminal</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">node</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">rhs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
        <span class="n">prob</span> <span class="o">=</span> <span class="n">prod_probs</span><span class="p">[</span><span class="n">lhs</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">rhs</span><span class="p">)]</span>

        <span class="c"># Get the probs of children.</span>
        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">tree</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">Tree</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_setprob</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">prod_probs</span><span class="p">)</span>
                <span class="n">prob</span> <span class="o">*=</span> <span class="n">child</span><span class="o">.</span><span class="n">prob</span><span class="p">()</span>

        <span class="n">tree</span><span class="o">.</span><span class="n">set_prob</span><span class="p">(</span><span class="n">prob</span><span class="p">)</span>

<div class="viewcode-block" id="BottomUpProbabilisticChartParser.sort_queue"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.pchart.BottomUpProbabilisticChartParser.sort_queue">[docs]</a>    <span class="k">def</span> <span class="nf">sort_queue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">queue</span><span class="p">,</span> <span class="n">chart</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sort the given queue of ``Edge`` objects, placing the edge that should</span>
<span class="sd">        be tried first at the beginning of the queue.  This method</span>
<span class="sd">        will be called after each ``Edge`` is added to the queue.</span>

<span class="sd">        :param queue: The queue of ``Edge`` objects to sort.  Each edge in</span>
<span class="sd">            this queue is an edge that could be added to the chart by</span>
<span class="sd">            the fundamental rule; but that has not yet been added.</span>
<span class="sd">        :type queue: list(Edge)</span>
<span class="sd">        :param chart: The chart being used to parse the text.  This</span>
<span class="sd">            chart can be used to provide extra information for sorting</span>
<span class="sd">            the queue.</span>
<span class="sd">        :type chart: Chart</span>
<span class="sd">        :rtype: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
    <span class="k">def</span> <span class="nf">_prune</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">queue</span><span class="p">,</span> <span class="n">chart</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Discard items in the queue if the queue is longer than the beam.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">queue</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">beam_size</span><span class="p">:</span>
            <span class="n">split</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">queue</span><span class="p">)</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">beam_size</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_trace</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">queue</span><span class="p">[:</span><span class="n">split</span><span class="p">]:</span>
                    <span class="k">print</span><span class="p">(</span><span class="s">&#39;  </span><span class="si">%-50s</span><span class="s"> [DISCARDED]&#39;</span> <span class="o">%</span> <span class="n">chart</span><span class="o">.</span><span class="n">pp_edge</span><span class="p">(</span><span class="n">edge</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
            <span class="k">del</span> <span class="n">queue</span><span class="p">[:</span><span class="n">split</span><span class="p">]</span>
</div>
<div class="viewcode-block" id="InsideChartParser"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.pchart.InsideChartParser">[docs]</a><span class="k">class</span> <span class="nc">InsideChartParser</span><span class="p">(</span><span class="n">BottomUpProbabilisticChartParser</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A bottom-up parser for ``PCFG`` grammars that tries edges in descending</span>
<span class="sd">    order of the inside probabilities of their trees.  The &quot;inside</span>
<span class="sd">    probability&quot; of a tree is simply the</span>
<span class="sd">    probability of the entire tree, ignoring its context.  In</span>
<span class="sd">    particular, the inside probability of a tree generated by</span>
<span class="sd">    production *p* with children *c[1], c[2], ..., c[n]* is</span>
<span class="sd">    *P(p)P(c[1])P(c[2])...P(c[n])*; and the inside</span>
<span class="sd">    probability of a token is 1 if it is present in the text, and 0 if</span>
<span class="sd">    it is absent.</span>

<span class="sd">    This sorting order results in a type of lowest-cost-first search</span>
<span class="sd">    strategy.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># Inherit constructor.</span>
<div class="viewcode-block" id="InsideChartParser.sort_queue"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.pchart.InsideChartParser.sort_queue">[docs]</a>    <span class="k">def</span> <span class="nf">sort_queue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">queue</span><span class="p">,</span> <span class="n">chart</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sort the given queue of edges, in descending order of the</span>
<span class="sd">        inside probabilities of the edges&#39; trees.</span>

<span class="sd">        :param queue: The queue of ``Edge`` objects to sort.  Each edge in</span>
<span class="sd">            this queue is an edge that could be added to the chart by</span>
<span class="sd">            the fundamental rule; but that has not yet been added.</span>
<span class="sd">        :type queue: list(Edge)</span>
<span class="sd">        :param chart: The chart being used to parse the text.  This</span>
<span class="sd">            chart can be used to provide extra information for sorting</span>
<span class="sd">            the queue.</span>
<span class="sd">        :type chart: Chart</span>
<span class="sd">        :rtype: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">queue</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="k">lambda</span> <span class="n">e1</span><span class="p">,</span><span class="n">e2</span><span class="p">:</span><span class="nb">cmp</span><span class="p">(</span><span class="n">e1</span><span class="o">.</span><span class="n">prob</span><span class="p">(),</span> <span class="n">e2</span><span class="o">.</span><span class="n">prob</span><span class="p">()))</span>

<span class="c"># Eventually, this will become some sort of inside-outside parser:</span>
<span class="c"># class InsideOutsideParser(BottomUpProbabilisticChartParser):</span>
<span class="c">#     def __init__(self, grammar, trace=0):</span>
<span class="c">#         # Inherit docs.</span>
<span class="c">#         BottomUpProbabilisticChartParser.__init__(self, grammar, trace)</span>
<span class="c">#</span>
<span class="c">#         # Find the best path from S to each nonterminal</span>
<span class="c">#         bestp = {}</span>
<span class="c">#         for production in grammar.productions(): bestp[production.lhs()]=0</span>
<span class="c">#         bestp[grammar.start()] = 1.0</span>
<span class="c">#</span>
<span class="c">#         for i in range(len(grammar.productions())):</span>
<span class="c">#             for production in grammar.productions():</span>
<span class="c">#                 lhs = production.lhs()</span>
<span class="c">#                 for elt in production.rhs():</span>
<span class="c">#                     bestp[elt] = max(bestp[lhs]*production.prob(),</span>
<span class="c">#                                      bestp.get(elt,0))</span>
<span class="c">#</span>
<span class="c">#         self._bestp = bestp</span>
<span class="c">#         for (k,v) in self._bestp.items(): print k,v</span>
<span class="c">#</span>
<span class="c">#     def _cmp(self, e1, e2):</span>
<span class="c">#         return cmp(e1.structure()[PROB]*self._bestp[e1.lhs()],</span>
<span class="c">#                    e2.structure()[PROB]*self._bestp[e2.lhs()])</span>
<span class="c">#</span>
<span class="c">#     def sort_queue(self, queue, chart):</span>
<span class="c">#         queue.sort(self._cmp)</span>
</div></div>
<span class="kn">import</span> <span class="nn">random</span>
<div class="viewcode-block" id="RandomChartParser"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.pchart.RandomChartParser">[docs]</a><span class="k">class</span> <span class="nc">RandomChartParser</span><span class="p">(</span><span class="n">BottomUpProbabilisticChartParser</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A bottom-up parser for ``PCFG`` grammars that tries edges in random order.</span>
<span class="sd">    This sorting order results in a random search strategy.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># Inherit constructor</span>
<div class="viewcode-block" id="RandomChartParser.sort_queue"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.pchart.RandomChartParser.sort_queue">[docs]</a>    <span class="k">def</span> <span class="nf">sort_queue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">queue</span><span class="p">,</span> <span class="n">chart</span><span class="p">):</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">queue</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="p">(</span><span class="n">queue</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">queue</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">=</span> <span class="p">(</span><span class="n">queue</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">queue</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
</div></div>
<div class="viewcode-block" id="UnsortedChartParser"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.pchart.UnsortedChartParser">[docs]</a><span class="k">class</span> <span class="nc">UnsortedChartParser</span><span class="p">(</span><span class="n">BottomUpProbabilisticChartParser</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A bottom-up parser for ``PCFG`` grammars that tries edges in whatever order.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># Inherit constructor</span>
<div class="viewcode-block" id="UnsortedChartParser.sort_queue"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.pchart.UnsortedChartParser.sort_queue">[docs]</a>    <span class="k">def</span> <span class="nf">sort_queue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">queue</span><span class="p">,</span> <span class="n">chart</span><span class="p">):</span> <span class="k">return</span>
</div></div>
<div class="viewcode-block" id="LongestChartParser"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.pchart.LongestChartParser">[docs]</a><span class="k">class</span> <span class="nc">LongestChartParser</span><span class="p">(</span><span class="n">BottomUpProbabilisticChartParser</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A bottom-up parser for ``PCFG`` grammars that tries longer edges before</span>
<span class="sd">    shorter ones.  This sorting order results in a type of best-first</span>
<span class="sd">    search strategy.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># Inherit constructor</span>
<div class="viewcode-block" id="LongestChartParser.sort_queue"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.pchart.LongestChartParser.sort_queue">[docs]</a>    <span class="k">def</span> <span class="nf">sort_queue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">queue</span><span class="p">,</span> <span class="n">chart</span><span class="p">):</span>
        <span class="n">queue</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="k">lambda</span> <span class="n">e1</span><span class="p">,</span><span class="n">e2</span><span class="p">:</span> <span class="nb">cmp</span><span class="p">(</span><span class="n">e1</span><span class="o">.</span><span class="n">length</span><span class="p">(),</span> <span class="n">e2</span><span class="o">.</span><span class="n">length</span><span class="p">()))</span>

<span class="c">##//////////////////////////////////////////////////////</span>
<span class="c">##  Test Code</span>
<span class="c">##//////////////////////////////////////////////////////</span>
</div></div>
<div class="viewcode-block" id="demo"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.pchart.demo">[docs]</a><span class="k">def</span> <span class="nf">demo</span><span class="p">(</span><span class="n">choice</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">draw_parses</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">print_parses</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A demonstration of the probabilistic parsers.  The user is</span>
<span class="sd">    prompted to select which demo to run, and how many parses should</span>
<span class="sd">    be found; and then each parser is run on the same demo, and a</span>
<span class="sd">    summary of the results are displayed.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">sys</span><span class="o">,</span> <span class="nn">time</span>
    <span class="kn">from</span> <span class="nn">nltk</span> <span class="kn">import</span> <span class="n">tokenize</span><span class="p">,</span> <span class="n">toy_pcfg1</span><span class="p">,</span> <span class="n">toy_pcfg2</span>
    <span class="kn">from</span> <span class="nn">nltk.parse</span> <span class="kn">import</span> <span class="n">pchart</span>

    <span class="c"># Define two demos.  Each demo has a sentence and a grammar.</span>
    <span class="n">demos</span> <span class="o">=</span> <span class="p">[(</span><span class="s">&#39;I saw John with my telescope&#39;</span><span class="p">,</span> <span class="n">toy_pcfg1</span><span class="p">),</span>
             <span class="p">(</span><span class="s">&#39;the boy saw Jack with Bob under the table with a telescope&#39;</span><span class="p">,</span>
              <span class="n">toy_pcfg2</span><span class="p">)]</span>

    <span class="k">if</span> <span class="n">choice</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="c"># Ask the user which demo they want to use.</span>
        <span class="k">print</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">demos</span><span class="p">)):</span>
            <span class="k">print</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%3s</span><span class="s">: </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">demos</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]))</span>
            <span class="k">print</span><span class="p">(</span><span class="s">&#39;     </span><span class="si">%r</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">demos</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">print</span><span class="p">()</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&#39;Which demo (</span><span class="si">%d</span><span class="s">-</span><span class="si">%d</span><span class="s">)? &#39;</span> <span class="o">%</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">demos</span><span class="p">)),</span> <span class="n">end</span><span class="o">=</span><span class="s">&#39; &#39;</span><span class="p">)</span>
        <span class="n">choice</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">stdin</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span><span class="o">-</span><span class="mi">1</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">sent</span><span class="p">,</span> <span class="n">grammar</span> <span class="o">=</span> <span class="n">demos</span><span class="p">[</span><span class="n">choice</span><span class="p">]</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&#39;Bad sentence number&#39;</span><span class="p">)</span>
        <span class="k">return</span>

    <span class="c"># Tokenize the sentence.</span>
    <span class="n">tokens</span> <span class="o">=</span> <span class="n">sent</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>

    <span class="c"># Define a list of parsers.  We&#39;ll use all parsers.</span>
    <span class="n">parsers</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">pchart</span><span class="o">.</span><span class="n">InsideChartParser</span><span class="p">(</span><span class="n">grammar</span><span class="p">),</span>
        <span class="n">pchart</span><span class="o">.</span><span class="n">RandomChartParser</span><span class="p">(</span><span class="n">grammar</span><span class="p">),</span>
        <span class="n">pchart</span><span class="o">.</span><span class="n">UnsortedChartParser</span><span class="p">(</span><span class="n">grammar</span><span class="p">),</span>
        <span class="n">pchart</span><span class="o">.</span><span class="n">LongestChartParser</span><span class="p">(</span><span class="n">grammar</span><span class="p">),</span>
        <span class="n">pchart</span><span class="o">.</span><span class="n">InsideChartParser</span><span class="p">(</span><span class="n">grammar</span><span class="p">,</span> <span class="n">beam_size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>   <span class="c"># was BeamParser</span>
        <span class="p">]</span>

    <span class="c"># Run the parsers on the tokenized sentence.</span>
    <span class="n">times</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">average_p</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">num_parses</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">all_parses</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">parser</span> <span class="ow">in</span> <span class="n">parsers</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">s: </span><span class="si">%s</span><span class="se">\n</span><span class="s">parser: </span><span class="si">%s</span><span class="se">\n</span><span class="s">grammar: </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">sent</span><span class="p">,</span><span class="n">parser</span><span class="p">,</span><span class="n">grammar</span><span class="p">))</span>
        <span class="n">parser</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">parses</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">nbest_parse</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span>
        <span class="n">times</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">t</span><span class="p">)</span>
        <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="nb">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">:</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="o">.</span><span class="n">prob</span><span class="p">(),</span> <span class="n">parses</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">parses</span><span class="p">)</span> <span class="k">if</span> <span class="n">parses</span> <span class="k">else</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">average_p</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="n">num_parses</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">parses</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">parses</span><span class="p">:</span> <span class="n">all_parses</span><span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">freeze</span><span class="p">()]</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="c"># Print some summary statistics</span>
    <span class="k">print</span><span class="p">()</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;       Parser      Beam | Time (secs)   # Parses   Average P(parse)&#39;</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;------------------------+------------------------------------------&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">parsers</span><span class="p">)):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%18s</span><span class="s"> </span><span class="si">%4d</span><span class="s"> |</span><span class="si">%11.4f%11d%19.14f</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">parsers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span>
                                             <span class="n">parsers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">beam_size</span><span class="p">,</span>
                                             <span class="n">times</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">num_parses</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">average_p</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
    <span class="n">parses</span> <span class="o">=</span> <span class="n">all_parses</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">parses</span><span class="p">:</span> <span class="n">p</span> <span class="o">=</span> <span class="nb">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">:</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="o">.</span><span class="n">prob</span><span class="p">(),</span> <span class="n">parses</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">parses</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span> <span class="n">p</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;------------------------+------------------------------------------&#39;</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%18s</span><span class="s">      |</span><span class="si">%11s%11d%19.14f</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="s">&#39;(All Parses)&#39;</span><span class="p">,</span> <span class="s">&#39;n/a&#39;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">parses</span><span class="p">),</span> <span class="n">p</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">draw_parses</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="c"># Ask the user if we should draw the parses.</span>
        <span class="k">print</span><span class="p">()</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&#39;Draw parses (y/n)? &#39;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s">&#39; &#39;</span><span class="p">)</span>
        <span class="n">draw_parses</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdin</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&#39;y&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">draw_parses</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">nltk.draw.tree</span> <span class="kn">import</span> <span class="n">draw_trees</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&#39;  please wait...&#39;</span><span class="p">)</span>
        <span class="n">draw_trees</span><span class="p">(</span><span class="o">*</span><span class="n">parses</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">print_parses</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="c"># Ask the user if we should print the parses.</span>
        <span class="k">print</span><span class="p">()</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&#39;Print parses (y/n)? &#39;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s">&#39; &#39;</span><span class="p">)</span>
        <span class="n">print_parses</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdin</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&#39;y&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">print_parses</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">parse</span> <span class="ow">in</span> <span class="n">parses</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="n">parse</span><span class="p">)</span>
</div>
<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">demo</span><span class="p">()</span>
</pre></div>

          </div>
        </div>
      </div>
        </div>
        <div class="sidebar">
          <h3>Table Of Contents</h3>
          <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../news.html">NLTK News</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../install.html">Installing NLTK</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../data.html">Installing NLTK Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/nltk.html">nltk Package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../team.html">Team NLTK</a></li>
</ul>

          <h3 style="margin-top: 1.5em;">Search</h3>
          <form class="search" action="../../../search.html" method="get">
            <input type="text" name="q" />
            <input type="submit" value="Go" />
            <input type="hidden" name="check_keywords" value="yes" />
            <input type="hidden" name="area" value="default" />
          </form>
          <p class="searchtip" style="font-size: 90%">
            Enter search terms or a module, class or function name.
          </p>
        </div>
        <div class="clearer"></div>
      </div>
    </div>

    <div class="footer-wrapper">
      <div class="footer">
        <div class="left">
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |
          <a href="../../../genindex.html" title="General Index"
             >index</a>
        </div>

        <div class="right">
          
    <div class="footer">
        &copy; Copyright 2012, NLTK Project.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
        </div>
        <div class="clearer"></div>
      </div>
    </div>

  </body>
</html>