

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>nltk.parse.chart &mdash; NLTK 2.0 documentation</title>
    
    <link rel="stylesheet" href="../../../_static/agogo.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '2.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <link rel="top" title="NLTK 2.0 documentation" href="../../../index.html" />
    <link rel="up" title="nltk.parse" href="../parse.html" /> 
  </head>
  <body>
    <div class="header-wrapper">
      <div class="header">
        <div class="headertitle"><a
          href="../../../index.html">NLTK 2.0 documentation</a></div>
        <div class="rel">
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a>
        </div>
       </div>
    </div>

    <div class="content-wrapper">
      <div class="content">
        <div class="document">
            
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for nltk.parse.chart</h1><div class="highlight"><pre>
<span class="c"># -*- coding: utf-8 -*-</span>
<span class="c"># Natural Language Toolkit: A Chart Parser</span>
<span class="c">#</span>
<span class="c"># Copyright (C) 2001-2011 NLTK Project</span>
<span class="c"># Author: Edward Loper &lt;edloper@gradient.cis.upenn.edu&gt;</span>
<span class="c">#         Steven Bird &lt;sb@csse.unimelb.edu.au&gt;</span>
<span class="c">#         Jean Mark Gawron &lt;gawron@mail.sdsu.edu&gt;</span>
<span class="c">#         Peter Ljungl√∂f &lt;peter.ljunglof@heatherleaf.se&gt;</span>
<span class="c"># URL: &lt;http://www.nltk.org/&gt;</span>
<span class="c"># For license information, see LICENSE.TXT</span>
<span class="c">#</span>
<span class="c"># $Id: chart.py 8778 2011-04-10 07:29:10Z StevenBird1 $</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Data classes and parser implementations for \&quot;chart parsers\&quot;, which</span>
<span class="sd">use dynamic programming to efficiently parse a text.  A X{chart</span>
<span class="sd">parser} derives parse trees for a text by iteratively adding \&quot;edges\&quot;</span>
<span class="sd">to a \&quot;chart.\&quot;  Each X{edge} represents a hypothesis about the tree</span>
<span class="sd">structure for a subsequence of the text.  The X{chart} is a</span>
<span class="sd">\&quot;blackboard\&quot; for composing and combining these hypotheses.</span>

<span class="sd">When a chart parser begins parsing a text, it creates a new (empty)</span>
<span class="sd">chart, spanning the text.  It then incrementally adds new edges to the</span>
<span class="sd">chart.  A set of X{chart rules} specifies the conditions under which</span>
<span class="sd">new edges should be added to the chart.  Once the chart reaches a</span>
<span class="sd">stage where none of the chart rules adds any new edges, parsing is</span>
<span class="sd">complete.</span>

<span class="sd">Charts are encoded with the L{Chart} class, and edges are encoded with</span>
<span class="sd">the L{TreeEdge} and L{LeafEdge} classes.  The chart parser module</span>
<span class="sd">defines three chart parsers:</span>

<span class="sd">  - C{ChartParser} is a simple and flexible chart parser.  Given a</span>
<span class="sd">    set of chart rules, it will apply those rules to the chart until</span>
<span class="sd">    no more edges are added.</span>

<span class="sd">  - C{SteppingChartParser} is a subclass of C{ChartParser} that can</span>
<span class="sd">    be used to step through the parsing process.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">nltk.tree</span> <span class="kn">import</span> <span class="n">Tree</span>
<span class="kn">from</span> <span class="nn">nltk.grammar</span> <span class="kn">import</span> <span class="n">WeightedGrammar</span><span class="p">,</span> <span class="n">is_nonterminal</span><span class="p">,</span> <span class="n">is_terminal</span>
<span class="kn">from</span> <span class="nn">nltk.compat</span> <span class="kn">import</span> <span class="n">defaultdict</span>

<span class="kn">from</span> <span class="nn">api</span> <span class="kn">import</span> <span class="o">*</span>

<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="c">########################################################################</span>
<span class="c">##  Edges</span>
<span class="c">########################################################################</span>

<div class="viewcode-block" id="EdgeI"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.chart.EdgeI">[docs]</a><span class="k">class</span> <span class="nc">EdgeI</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A hypothesis about the structure of part of a sentence.</span>
<span class="sd">    Each edge records the fact that a structure is (partially)</span>
<span class="sd">    consistent with the sentence.  An edge contains:</span>

<span class="sd">        - A X{span}, indicating what part of the sentence is</span>
<span class="sd">          consistent with the hypothesized structure.</span>
<span class="sd">          </span>
<span class="sd">        - A X{left-hand side}, specifying what kind of structure is</span>
<span class="sd">          hypothesized.</span>

<span class="sd">        - A X{right-hand side}, specifying the contents of the</span>
<span class="sd">          hypothesized structure.</span>

<span class="sd">        - A X{dot position}, indicating how much of the hypothesized</span>
<span class="sd">          structure is consistent with the sentence.</span>

<span class="sd">    Every edge is either X{complete} or X{incomplete}:</span>

<span class="sd">      - An edge is X{complete} if its structure is fully consistent</span>
<span class="sd">        with the sentence.</span>

<span class="sd">      - An edge is X{incomplete} if its structure is partially</span>
<span class="sd">        consistent with the sentence.  For every incomplete edge, the</span>
<span class="sd">        span specifies a possible prefix for the edge&#39;s structure.</span>
<span class="sd">    </span>
<span class="sd">    There are two kinds of edge:</span>

<span class="sd">        - C{TreeEdges&lt;TreeEdge&gt;} record which trees have been found to</span>
<span class="sd">          be (partially) consistent with the text.</span>
<span class="sd">          </span>
<span class="sd">        - C{LeafEdges&lt;leafEdge&gt;} record the tokens occur in the text.</span>

<span class="sd">    The C{EdgeI} interface provides a common interface to both types</span>
<span class="sd">    of edge, allowing chart parsers to treat them in a uniform manner.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span> <span class="o">==</span> <span class="n">EdgeI</span><span class="p">:</span> 
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;Edge is an abstract interface&#39;</span><span class="p">)</span>
        
    <span class="c">#////////////////////////////////////////////////////////////</span>
    <span class="c"># Span</span>
    <span class="c">#////////////////////////////////////////////////////////////</span>

<div class="viewcode-block" id="EdgeI.span"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.chart.EdgeI.span">[docs]</a>    <span class="k">def</span> <span class="nf">span</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        @return: A tuple C{(s,e)}, where C{subtokens[s:e]} is the</span>
<span class="sd">            portion of the sentence that is consistent with this</span>
<span class="sd">            edge&#39;s structure.</span>
<span class="sd">        @rtype: C{(int, int)}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s">&#39;EdgeI is an abstract interface&#39;</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="EdgeI.start"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.chart.EdgeI.start">[docs]</a>    <span class="k">def</span> <span class="nf">start</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        @return: The start index of this edge&#39;s span.</span>
<span class="sd">        @rtype: C{int}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s">&#39;EdgeI is an abstract interface&#39;</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="EdgeI.end"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.chart.EdgeI.end">[docs]</a>    <span class="k">def</span> <span class="nf">end</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        @return: The end index of this edge&#39;s span.</span>
<span class="sd">        @rtype: C{int}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s">&#39;EdgeI is an abstract interface&#39;</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="EdgeI.length"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.chart.EdgeI.length">[docs]</a>    <span class="k">def</span> <span class="nf">length</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        @return: The length of this edge&#39;s span.</span>
<span class="sd">        @rtype: C{int}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s">&#39;EdgeI is an abstract interface&#39;</span><span class="p">)</span>

    <span class="c">#////////////////////////////////////////////////////////////</span>
    <span class="c"># Left Hand Side</span>
    <span class="c">#////////////////////////////////////////////////////////////</span>
</div>
<div class="viewcode-block" id="EdgeI.lhs"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.chart.EdgeI.lhs">[docs]</a>    <span class="k">def</span> <span class="nf">lhs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        @return: This edge&#39;s left-hand side, which specifies what kind</span>
<span class="sd">            of structure is hypothesized by this edge.</span>
<span class="sd">        @see: L{TreeEdge} and L{LeafEdge} for a description of</span>
<span class="sd">            the left-hand side values for each edge type.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s">&#39;EdgeI is an abstract interface&#39;</span><span class="p">)</span>

    <span class="c">#////////////////////////////////////////////////////////////</span>
    <span class="c"># Right Hand Side</span>
    <span class="c">#////////////////////////////////////////////////////////////</span>
</div>
<div class="viewcode-block" id="EdgeI.rhs"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.chart.EdgeI.rhs">[docs]</a>    <span class="k">def</span> <span class="nf">rhs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        @return: This edge&#39;s right-hand side, which specifies</span>
<span class="sd">            the content of the structure hypothesized by this</span>
<span class="sd">            edge.</span>
<span class="sd">        @see: L{TreeEdge} and L{LeafEdge} for a description of</span>
<span class="sd">            the right-hand side values for each edge type.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s">&#39;EdgeI is an abstract interface&#39;</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="EdgeI.dot"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.chart.EdgeI.dot">[docs]</a>    <span class="k">def</span> <span class="nf">dot</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        @return: This edge&#39;s dot position, which indicates how much of</span>
<span class="sd">            the hypothesized structure is consistent with the</span>
<span class="sd">            sentence.  In particular, C{self.rhs[:dot]} is consistent</span>
<span class="sd">            with C{subtoks[self.start():self.end()]}.</span>
<span class="sd">        @rtype: C{int}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s">&#39;EdgeI is an abstract interface&#39;</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="EdgeI.next"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.chart.EdgeI.next">[docs]</a>    <span class="k">def</span> <span class="nf">next</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        @return: The element of this edge&#39;s right-hand side that</span>
<span class="sd">            immediately follows its dot.</span>
<span class="sd">        @rtype: C{Nonterminal} or X{terminal} or C{None}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s">&#39;EdgeI is an abstract interface&#39;</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="EdgeI.is_complete"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.chart.EdgeI.is_complete">[docs]</a>    <span class="k">def</span> <span class="nf">is_complete</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        @return: True if this edge&#39;s structure is fully consistent</span>
<span class="sd">            with the text.</span>
<span class="sd">        @rtype: C{boolean}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s">&#39;EdgeI is an abstract interface&#39;</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="EdgeI.is_incomplete"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.chart.EdgeI.is_incomplete">[docs]</a>    <span class="k">def</span> <span class="nf">is_incomplete</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        @return: True if this edge&#39;s structure is partially consistent</span>
<span class="sd">            with the text.</span>
<span class="sd">        @rtype: C{boolean}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s">&#39;EdgeI is an abstract interface&#39;</span><span class="p">)</span>

    <span class="c">#////////////////////////////////////////////////////////////</span>
    <span class="c"># Comparisons</span>
    <span class="c">#////////////////////////////////////////////////////////////</span></div>
    <span class="k">def</span> <span class="nf">__cmp__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s">&#39;EdgeI is an abstract interface&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s">&#39;EdgeI is an abstract interface&#39;</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="TreeEdge"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.chart.TreeEdge">[docs]</a><span class="k">class</span> <span class="nc">TreeEdge</span><span class="p">(</span><span class="n">EdgeI</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An edge that records the fact that a tree is (partially)</span>
<span class="sd">    consistent with the sentence.  A tree edge consists of:</span>

<span class="sd">        - A X{span}, indicating what part of the sentence is</span>
<span class="sd">          consistent with the hypothesized tree.</span>
<span class="sd">          </span>
<span class="sd">        - A X{left-hand side}, specifying the hypothesized tree&#39;s node</span>
<span class="sd">          value.</span>

<span class="sd">        - A X{right-hand side}, specifying the hypothesized tree&#39;s</span>
<span class="sd">          children.  Each element of the right-hand side is either a</span>
<span class="sd">          terminal, specifying a token with that terminal as its leaf</span>
<span class="sd">          value; or a nonterminal, specifying a subtree with that</span>
<span class="sd">          nonterminal&#39;s symbol as its node value.</span>

<span class="sd">        - A X{dot position}, indicating which children are consistent</span>
<span class="sd">          with part of the sentence.  In particular, if C{dot} is the</span>
<span class="sd">          dot position, C{rhs} is the right-hand size, C{(start,end)}</span>
<span class="sd">          is the span, and C{sentence} is the list of subtokens in the</span>
<span class="sd">          sentence, then C{subtokens[start:end]} can be spanned by the</span>
<span class="sd">          children specified by C{rhs[:dot]}.</span>

<span class="sd">    For more information about edges, see the L{EdgeI} interface.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">span</span><span class="p">,</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">dot</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a new C{TreeEdge}.</span>
<span class="sd">        </span>
<span class="sd">        @type span: C{(int, int)}</span>
<span class="sd">        @param span: A tuple C{(s,e)}, where C{subtokens[s:e]} is the</span>
<span class="sd">            portion of the sentence that is consistent with the new</span>
<span class="sd">            edge&#39;s structure.</span>
<span class="sd">        @type lhs: L{Nonterminal}</span>
<span class="sd">        @param lhs: The new edge&#39;s left-hand side, specifying the</span>
<span class="sd">            hypothesized tree&#39;s node value.</span>
<span class="sd">        @type rhs: C{list} of (L{Nonterminal} and C{string})</span>
<span class="sd">        @param rhs: The new edge&#39;s right-hand side, specifying the</span>
<span class="sd">            hypothesized tree&#39;s children.</span>
<span class="sd">        @type dot: C{int}</span>
<span class="sd">        @param dot: The position of the new edge&#39;s dot.  This position</span>
<span class="sd">            specifies what prefix of the production&#39;s right hand side</span>
<span class="sd">            is consistent with the text.  In particular, if</span>
<span class="sd">            C{sentence} is the list of subtokens in the sentence, then</span>
<span class="sd">            C{subtokens[span[0]:span[1]]} can be spanned by the</span>
<span class="sd">            children specified by C{rhs[:dot]}.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lhs</span> <span class="o">=</span> <span class="n">lhs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_rhs</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">rhs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_span</span> <span class="o">=</span> <span class="n">span</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dot</span> <span class="o">=</span> <span class="n">dot</span>

    <span class="c"># [staticmethod]</span>
<div class="viewcode-block" id="TreeEdge.from_production"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.chart.TreeEdge.from_production">[docs]</a>    <span class="k">def</span> <span class="nf">from_production</span><span class="p">(</span><span class="n">production</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        @return: A new C{TreeEdge} formed from the given production.</span>
<span class="sd">            The new edge&#39;s left-hand side and right-hand side will</span>
<span class="sd">            be taken from C{production}; its span will be </span>
<span class="sd">            C{(index,index)}; and its dot position will be C{0}.</span>
<span class="sd">        @rtype: L{TreeEdge}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">TreeEdge</span><span class="p">(</span><span class="n">span</span><span class="o">=</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">index</span><span class="p">),</span> <span class="n">lhs</span><span class="o">=</span><span class="n">production</span><span class="o">.</span><span class="n">lhs</span><span class="p">(),</span>
                        <span class="n">rhs</span><span class="o">=</span><span class="n">production</span><span class="o">.</span><span class="n">rhs</span><span class="p">(),</span> <span class="n">dot</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span></div>
    <span class="n">from_production</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">from_production</span><span class="p">)</span>

<div class="viewcode-block" id="TreeEdge.move_dot_forward"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.chart.TreeEdge.move_dot_forward">[docs]</a>    <span class="k">def</span> <span class="nf">move_dot_forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_end</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        @return: A new C{TreeEdge} formed from this edge.</span>
<span class="sd">            The new edge&#39;s dot position is increased by C{1}, </span>
<span class="sd">            and its end index will be replaced by C{new_end}.</span>
<span class="sd">        @rtype: L{TreeEdge}</span>
<span class="sd">        @param new_end: The new end index.</span>
<span class="sd">        @type new_end: C{int}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">TreeEdge</span><span class="p">(</span><span class="n">span</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_span</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">new_end</span><span class="p">),</span>
                        <span class="n">lhs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_rhs</span><span class="p">,</span>
                        <span class="n">dot</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_dot</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

    <span class="c"># Accessors</span></div>
<div class="viewcode-block" id="TreeEdge.lhs"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.chart.TreeEdge.lhs">[docs]</a>    <span class="k">def</span> <span class="nf">lhs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lhs</span></div>
<div class="viewcode-block" id="TreeEdge.span"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.chart.TreeEdge.span">[docs]</a>    <span class="k">def</span> <span class="nf">span</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_span</span></div>
<div class="viewcode-block" id="TreeEdge.start"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.chart.TreeEdge.start">[docs]</a>    <span class="k">def</span> <span class="nf">start</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_span</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>
<div class="viewcode-block" id="TreeEdge.end"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.chart.TreeEdge.end">[docs]</a>    <span class="k">def</span> <span class="nf">end</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_span</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span></div>
<div class="viewcode-block" id="TreeEdge.length"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.chart.TreeEdge.length">[docs]</a>    <span class="k">def</span> <span class="nf">length</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_span</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_span</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>
<div class="viewcode-block" id="TreeEdge.rhs"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.chart.TreeEdge.rhs">[docs]</a>    <span class="k">def</span> <span class="nf">rhs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rhs</span></div>
<div class="viewcode-block" id="TreeEdge.dot"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.chart.TreeEdge.dot">[docs]</a>    <span class="k">def</span> <span class="nf">dot</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dot</span></div>
<div class="viewcode-block" id="TreeEdge.is_complete"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.chart.TreeEdge.is_complete">[docs]</a>    <span class="k">def</span> <span class="nf">is_complete</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dot</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_rhs</span><span class="p">)</span></div>
<div class="viewcode-block" id="TreeEdge.is_incomplete"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.chart.TreeEdge.is_incomplete">[docs]</a>    <span class="k">def</span> <span class="nf">is_incomplete</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dot</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_rhs</span><span class="p">)</span></div>
<div class="viewcode-block" id="TreeEdge.next"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.chart.TreeEdge.next">[docs]</a>    <span class="k">def</span> <span class="nf">next</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dot</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_rhs</span><span class="p">):</span> <span class="k">return</span> <span class="bp">None</span>
        <span class="k">else</span><span class="p">:</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rhs</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_dot</span><span class="p">]</span>

    <span class="c"># Comparisons &amp; hashing</span></div>
    <span class="k">def</span> <span class="nf">__cmp__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">__class__</span><span class="p">:</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">return</span> <span class="nb">cmp</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_span</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lhs</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">rhs</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dot</span><span class="p">),</span>
                   <span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">_span</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">lhs</span><span class="p">(),</span> <span class="n">other</span><span class="o">.</span><span class="n">rhs</span><span class="p">(),</span> <span class="n">other</span><span class="o">.</span><span class="n">_dot</span><span class="p">))</span>
    <span class="k">def</span> <span class="nf">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">lhs</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">rhs</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_span</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dot</span><span class="p">))</span>

    <span class="c"># String representation</span>
    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">str</span> <span class="o">=</span> <span class="s">&#39;[</span><span class="si">%s</span><span class="s">:</span><span class="si">%s</span><span class="s">] &#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_span</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_span</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="nb">str</span> <span class="o">+=</span> <span class="s">&#39;</span><span class="si">%-2r</span><span class="s"> -&gt;&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lhs</span><span class="p">,)</span>
            
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_rhs</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dot</span><span class="p">:</span> <span class="nb">str</span> <span class="o">+=</span> <span class="s">&#39; *&#39;</span>
            <span class="nb">str</span> <span class="o">+=</span> <span class="s">&#39; </span><span class="si">%r</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_rhs</span><span class="p">[</span><span class="n">i</span><span class="p">],)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_rhs</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dot</span><span class="p">:</span> <span class="nb">str</span> <span class="o">+=</span> <span class="s">&#39; *&#39;</span>
        <span class="k">return</span> <span class="nb">str</span>
        
    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&#39;[Edge: </span><span class="si">%s</span><span class="s">]&#39;</span> <span class="o">%</span> <span class="bp">self</span>
</div>
<div class="viewcode-block" id="LeafEdge"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.chart.LeafEdge">[docs]</a><span class="k">class</span> <span class="nc">LeafEdge</span><span class="p">(</span><span class="n">EdgeI</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An edge that records the fact that a leaf value is consistent with</span>
<span class="sd">    a word in the sentence.  A leaf edge consists of:</span>

<span class="sd">      - An X{index}, indicating the position of the word.</span>
<span class="sd">      - A X{leaf}, specifying the word&#39;s content.</span>

<span class="sd">    A leaf edge&#39;s left-hand side is its leaf value, and its right hand</span>
<span class="sd">    side is C{()}.  Its span is C{[index, index+1]}, and its dot</span>
<span class="sd">    position is C{0}.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">leaf</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a new C{LeafEdge}.</span>

<span class="sd">        @param leaf: The new edge&#39;s leaf value, specifying the word</span>
<span class="sd">            that is recorded by this edge.</span>
<span class="sd">        @param index: The new edge&#39;s index, specifying the position of</span>
<span class="sd">            the word that is recorded by this edge.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_leaf</span> <span class="o">=</span> <span class="n">leaf</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_index</span> <span class="o">=</span> <span class="n">index</span>

    <span class="c"># Accessors</span>
<div class="viewcode-block" id="LeafEdge.lhs"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.chart.LeafEdge.lhs">[docs]</a>    <span class="k">def</span> <span class="nf">lhs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_leaf</span></div>
<div class="viewcode-block" id="LeafEdge.span"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.chart.LeafEdge.span">[docs]</a>    <span class="k">def</span> <span class="nf">span</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span></div>
<div class="viewcode-block" id="LeafEdge.start"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.chart.LeafEdge.start">[docs]</a>    <span class="k">def</span> <span class="nf">start</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span></div>
<div class="viewcode-block" id="LeafEdge.end"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.chart.LeafEdge.end">[docs]</a>    <span class="k">def</span> <span class="nf">end</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="o">+</span><span class="mi">1</span></div>
<div class="viewcode-block" id="LeafEdge.length"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.chart.LeafEdge.length">[docs]</a>    <span class="k">def</span> <span class="nf">length</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="mi">1</span></div>
<div class="viewcode-block" id="LeafEdge.rhs"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.chart.LeafEdge.rhs">[docs]</a>    <span class="k">def</span> <span class="nf">rhs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="p">()</span></div>
<div class="viewcode-block" id="LeafEdge.dot"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.chart.LeafEdge.dot">[docs]</a>    <span class="k">def</span> <span class="nf">dot</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="mi">0</span></div>
<div class="viewcode-block" id="LeafEdge.is_complete"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.chart.LeafEdge.is_complete">[docs]</a>    <span class="k">def</span> <span class="nf">is_complete</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">True</span></div>
<div class="viewcode-block" id="LeafEdge.is_incomplete"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.chart.LeafEdge.is_incomplete">[docs]</a>    <span class="k">def</span> <span class="nf">is_incomplete</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">False</span></div>
<div class="viewcode-block" id="LeafEdge.next"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.chart.LeafEdge.next">[docs]</a>    <span class="k">def</span> <span class="nf">next</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">None</span>

    <span class="c"># Comparisons &amp; hashing</span></div>
    <span class="k">def</span> <span class="nf">__cmp__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">LeafEdge</span><span class="p">):</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">return</span> <span class="nb">cmp</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_leaf</span><span class="p">),</span> <span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">_index</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">_leaf</span><span class="p">))</span>
    <span class="k">def</span> <span class="nf">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_leaf</span><span class="p">))</span>

    <span class="c"># String representations</span>
    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> 
        <span class="k">return</span> <span class="s">&#39;[</span><span class="si">%s</span><span class="s">:</span><span class="si">%s</span><span class="s">] </span><span class="si">%r</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_leaf</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&#39;[Edge: </span><span class="si">%s</span><span class="s">]&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">)</span>

<span class="c">########################################################################</span>
<span class="c">##  Chart</span>
<span class="c">########################################################################</span>
</div>
<div class="viewcode-block" id="Chart"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.chart.Chart">[docs]</a><span class="k">class</span> <span class="nc">Chart</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A blackboard for hypotheses about the syntactic constituents of a</span>
<span class="sd">    sentence.  A chart contains a set of edges, and each edge encodes</span>
<span class="sd">    a single hypothesis about the structure of some portion of the</span>
<span class="sd">    sentence.</span>

<span class="sd">    The L{select} method can be used to select a specific collection</span>
<span class="sd">    of edges.  For example C{chart.select(is_complete=True, start=0)}</span>
<span class="sd">    yields all complete edges whose start indices are 0.  To ensure</span>
<span class="sd">    the efficiency of these selection operations, C{Chart} dynamically</span>
<span class="sd">    creates and maintains an index for each set of attributes that</span>
<span class="sd">    have been selected on.</span>

<span class="sd">    In order to reconstruct the trees that are represented by an edge,</span>
<span class="sd">    the chart associates each edge with a set of child pointer lists.</span>
<span class="sd">    A X{child pointer list} is a list of the edges that license an</span>
<span class="sd">    edge&#39;s right-hand side.</span>

<span class="sd">    @ivar _tokens: The sentence that the chart covers.</span>
<span class="sd">    @ivar _num_leaves: The number of tokens.</span>
<span class="sd">    @ivar _edges: A list of the edges in the chart</span>
<span class="sd">    @ivar _edge_to_cpls: A dictionary mapping each edge to a set</span>
<span class="sd">        of child pointer lists that are associated with that edge.</span>
<span class="sd">    @ivar _indexes: A dictionary mapping tuples of edge attributes</span>
<span class="sd">        to indices, where each index maps the corresponding edge</span>
<span class="sd">        attribute values to lists of edges.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tokens</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a new chart. The chart is initialized with the </span>
<span class="sd">        leaf edges corresponding to the terminal leaves.</span>

<span class="sd">        @type tokens: L{list}</span>
<span class="sd">        @param tokens: The sentence that this chart will be used to parse.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Record the sentence token and the sentence length.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tokens</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_num_leaves</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tokens</span><span class="p">)</span>
        
        <span class="c"># Initialise the chart.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initialize</span><span class="p">()</span>

<div class="viewcode-block" id="Chart.initialize"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.chart.Chart.initialize">[docs]</a>    <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Clear the chart.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># A list of edges contained in this chart.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_edges</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="c"># The set of child pointer lists associated with each edge.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_edge_to_cpls</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c"># Indexes mapping attribute values to lists of edges </span>
        <span class="c"># (used by select()).</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_indexes</span> <span class="o">=</span> <span class="p">{}</span>
    
    <span class="c">#////////////////////////////////////////////////////////////</span>
    <span class="c"># Sentence Access</span>
    <span class="c">#////////////////////////////////////////////////////////////</span>
</div>
<div class="viewcode-block" id="Chart.num_leaves"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.chart.Chart.num_leaves">[docs]</a>    <span class="k">def</span> <span class="nf">num_leaves</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        @return: The number of words in this chart&#39;s sentence.</span>
<span class="sd">        @rtype: C{int}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_num_leaves</span>
</div>
<div class="viewcode-block" id="Chart.leaf"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.chart.Chart.leaf">[docs]</a>    <span class="k">def</span> <span class="nf">leaf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        @return: The leaf value of the word at the given index.</span>
<span class="sd">        @rtype: C{string}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tokens</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
</div>
<div class="viewcode-block" id="Chart.leaves"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.chart.Chart.leaves">[docs]</a>    <span class="k">def</span> <span class="nf">leaves</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        @return: A list of the leaf values of each word in the</span>
<span class="sd">            chart&#39;s sentence.</span>
<span class="sd">        @rtype: C{list} of C{string}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tokens</span>

    <span class="c">#////////////////////////////////////////////////////////////</span>
    <span class="c"># Edge access</span>
    <span class="c">#////////////////////////////////////////////////////////////</span>
</div>
<div class="viewcode-block" id="Chart.edges"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.chart.Chart.edges">[docs]</a>    <span class="k">def</span> <span class="nf">edges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        @return: A list of all edges in this chart.  New edges</span>
<span class="sd">            that are added to the chart after the call to edges()</span>
<span class="sd">            will I{not} be contained in this list.</span>
<span class="sd">        @rtype: C{list} of L{EdgeI}</span>
<span class="sd">        @see: L{iteredges}, L{select}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edges</span><span class="p">[:]</span>
</div>
<div class="viewcode-block" id="Chart.iteredges"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.chart.Chart.iteredges">[docs]</a>    <span class="k">def</span> <span class="nf">iteredges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        @return: An iterator over the edges in this chart.  It is </span>
<span class="sd">            I{not} guaranteed that new edges which are added to the </span>
<span class="sd">            chart before the iterator is exhausted will also be  </span>
<span class="sd">            generated.</span>
<span class="sd">        @rtype: C{iter} of L{EdgeI}</span>
<span class="sd">        @see: L{edges}, L{select}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_edges</span><span class="p">)</span>

    <span class="c"># Iterating over the chart yields its edges.</span></div>
    <span class="n">__iter__</span> <span class="o">=</span> <span class="n">iteredges</span>

<div class="viewcode-block" id="Chart.num_edges"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.chart.Chart.num_edges">[docs]</a>    <span class="k">def</span> <span class="nf">num_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        @return: The number of edges contained in this chart.</span>
<span class="sd">        @rtype: C{int}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_edge_to_cpls</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Chart.select"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.chart.Chart.select">[docs]</a>    <span class="k">def</span> <span class="nf">select</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">restrictions</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        @return: An iterator over the edges in this chart.  Any</span>
<span class="sd">            new edges that are added to the chart before the iterator</span>
<span class="sd">            is exahusted will also be generated.  C{restrictions}</span>
<span class="sd">            can be used to restrict the set of edges that will be</span>
<span class="sd">            generated.</span>
<span class="sd">        @rtype: C{iter} of L{EdgeI}</span>

<span class="sd">        @kwarg span: Only generate edges C{e} where C{e.span()==span}</span>
<span class="sd">        @kwarg start: Only generate edges C{e} where C{e.start()==start}</span>
<span class="sd">        @kwarg end: Only generate edges C{e} where C{e.end()==end}</span>
<span class="sd">        @kwarg length: Only generate edges C{e} where C{e.length()==length}</span>
<span class="sd">        @kwarg lhs: Only generate edges C{e} where C{e.lhs()==lhs}</span>
<span class="sd">        @kwarg rhs: Only generate edges C{e} where C{e.rhs()==rhs}</span>
<span class="sd">        @kwarg next: Only generate edges C{e} where C{e.next()==next}</span>
<span class="sd">        @kwarg dot: Only generate edges C{e} where C{e.dot()==dot}</span>
<span class="sd">        @kwarg is_complete: Only generate edges C{e} where</span>
<span class="sd">            C{e.is_complete()==is_complete}</span>
<span class="sd">        @kwarg is_incomplete: Only generate edges C{e} where</span>
<span class="sd">            C{e.is_incomplete()==is_incomplete}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># If there are no restrictions, then return all edges.</span>
        <span class="k">if</span> <span class="n">restrictions</span><span class="o">==</span><span class="p">{}:</span> <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_edges</span><span class="p">)</span>
            
        <span class="c"># Find the index corresponding to the given restrictions.</span>
        <span class="n">restr_keys</span> <span class="o">=</span> <span class="n">restrictions</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="n">restr_keys</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="n">restr_keys</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">restr_keys</span><span class="p">)</span>

        <span class="c"># If it doesn&#39;t exist, then create it.</span>
        <span class="k">if</span> <span class="n">restr_keys</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_indexes</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_add_index</span><span class="p">(</span><span class="n">restr_keys</span><span class="p">)</span>
                
        <span class="n">vals</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">restrictions</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">restr_keys</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_indexes</span><span class="p">[</span><span class="n">restr_keys</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="p">[]))</span>
    </div>
    <span class="k">def</span> <span class="nf">_add_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">restr_keys</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A helper function for L{select}, which creates a new index for</span>
<span class="sd">        a given set of attributes (aka restriction keys).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Make sure it&#39;s a valid index.</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">restr_keys</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">EdgeI</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">,</span> <span class="s">&#39;Bad restriction: </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">key</span>

        <span class="c"># Create the index.</span>
        <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_indexes</span><span class="p">[</span><span class="n">restr_keys</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c"># Add all existing edges to the index.</span>
        <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edges</span><span class="p">:</span>
            <span class="n">vals</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">edge</span><span class="p">,</span> <span class="n">key</span><span class="p">)()</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">restr_keys</span><span class="p">)</span>
            <span class="n">index</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="p">[])</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">_register_with_indexes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A helper function for L{insert}, which registers the new</span>
<span class="sd">        edge with all existing indexes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">restr_keys</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_indexes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">vals</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">edge</span><span class="p">,</span> <span class="n">key</span><span class="p">)()</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">restr_keys</span><span class="p">)</span>
            <span class="n">index</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="p">[])</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>
    
    <span class="c">#////////////////////////////////////////////////////////////</span>
    <span class="c"># Edge Insertion</span>
    <span class="c">#////////////////////////////////////////////////////////////</span>

<div class="viewcode-block" id="Chart.insert_with_backpointer"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.chart.Chart.insert_with_backpointer">[docs]</a>    <span class="k">def</span> <span class="nf">insert_with_backpointer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_edge</span><span class="p">,</span> <span class="n">previous_edge</span><span class="p">,</span> <span class="n">child_edge</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a new edge to the chart, using a pointer to the previous edge.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cpls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">child_pointer_lists</span><span class="p">(</span><span class="n">previous_edge</span><span class="p">)</span>
        <span class="n">new_cpls</span> <span class="o">=</span> <span class="p">[</span><span class="n">cpl</span><span class="o">+</span><span class="p">(</span><span class="n">child_edge</span><span class="p">,)</span> <span class="k">for</span> <span class="n">cpl</span> <span class="ow">in</span> <span class="n">cpls</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">new_edge</span><span class="p">,</span> <span class="o">*</span><span class="n">new_cpls</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Chart.insert"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.chart.Chart.insert">[docs]</a>    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge</span><span class="p">,</span> <span class="o">*</span><span class="n">child_pointer_lists</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a new edge to the chart.</span>

<span class="sd">        @type edge: L{EdgeI}</span>
<span class="sd">        @param edge: The new edge</span>
<span class="sd">        @type child_pointer_lists: C(sequence} of C{tuple} of L{EdgeI} </span>
<span class="sd">        @param child_pointer_lists: A sequence of lists of the edges that </span>
<span class="sd">            were used to form this edge.  This list is used to reconstruct </span>
<span class="sd">            the trees (or partial trees) that are associated with C{edge}.</span>
<span class="sd">        @rtype: C{bool}</span>
<span class="sd">        @return: True if this operation modified the chart.  In</span>
<span class="sd">            particular, return true iff the chart did not already</span>
<span class="sd">            contain C{edge}, or if it did not already associate</span>
<span class="sd">            C{child_pointer_lists} with C{edge}.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Is it a new edge?</span>
        <span class="k">if</span> <span class="n">edge</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edge_to_cpls</span><span class="p">:</span>
            <span class="c"># Add it to the list of edges.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_append_edge</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>
            <span class="c"># Register with indexes.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_register_with_indexes</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>

        <span class="c"># Get the set of child pointer lists for this edge.</span>
        <span class="n">cpls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edge_to_cpls</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">edge</span><span class="p">,{})</span>
        <span class="n">chart_was_modified</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">for</span> <span class="n">child_pointer_list</span> <span class="ow">in</span> <span class="n">child_pointer_lists</span><span class="p">:</span>
            <span class="n">child_pointer_list</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">child_pointer_list</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">child_pointer_list</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cpls</span><span class="p">:</span>
                <span class="c"># It&#39;s a new CPL; register it, and return true.</span>
                <span class="n">cpls</span><span class="p">[</span><span class="n">child_pointer_list</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="n">chart_was_modified</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">return</span> <span class="n">chart_was_modified</span>
    </div>
    <span class="k">def</span> <span class="nf">_append_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_edges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>
    
    <span class="c">#////////////////////////////////////////////////////////////</span>
    <span class="c"># Tree extraction &amp; child pointer lists</span>
    <span class="c">#////////////////////////////////////////////////////////////</span>

<div class="viewcode-block" id="Chart.parses"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.chart.Chart.parses">[docs]</a>    <span class="k">def</span> <span class="nf">parses</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">tree_class</span><span class="o">=</span><span class="n">Tree</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        @return: A list of the complete tree structures that span</span>
<span class="sd">        the entire chart, and whose root node is C{root}.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">trees</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_num_leaves</span><span class="p">,</span> <span class="n">lhs</span><span class="o">=</span><span class="n">root</span><span class="p">):</span>
            <span class="n">trees</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">trees</span><span class="p">(</span><span class="n">edge</span><span class="p">,</span> <span class="n">tree_class</span><span class="o">=</span><span class="n">tree_class</span><span class="p">,</span> <span class="n">complete</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">trees</span>
</div>
<div class="viewcode-block" id="Chart.trees"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.chart.Chart.trees">[docs]</a>    <span class="k">def</span> <span class="nf">trees</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge</span><span class="p">,</span> <span class="n">tree_class</span><span class="o">=</span><span class="n">Tree</span><span class="p">,</span> <span class="n">complete</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        @return: A list of the tree structures that are associated</span>
<span class="sd">        with C{edge}.</span>

<span class="sd">        If C{edge} is incomplete, then the unexpanded children will be</span>
<span class="sd">        encoded as childless subtrees, whose node value is the</span>
<span class="sd">        corresponding terminal or nonterminal.</span>
<span class="sd">            </span>
<span class="sd">        @rtype: C{list} of L{Tree}</span>
<span class="sd">        @note: If two trees share a common subtree, then the same</span>
<span class="sd">            C{Tree} may be used to encode that subtree in</span>
<span class="sd">            both trees.  If you need to eliminate this subtree</span>
<span class="sd">            sharing, then create a deep copy of each tree.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_trees</span><span class="p">(</span><span class="n">edge</span><span class="p">,</span> <span class="n">complete</span><span class="p">,</span> <span class="n">memo</span><span class="o">=</span><span class="p">{},</span> <span class="n">tree_class</span><span class="o">=</span><span class="n">tree_class</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">_trees</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge</span><span class="p">,</span> <span class="n">complete</span><span class="p">,</span> <span class="n">memo</span><span class="p">,</span> <span class="n">tree_class</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A helper function for L{trees}.</span>
<span class="sd">        @param memo: A dictionary used to record the trees that we&#39;ve</span>
<span class="sd">            generated for each edge, so that when we see an edge more</span>
<span class="sd">            than once, we can reuse the same trees.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># If we&#39;ve seen this edge before, then reuse our old answer.</span>
        <span class="k">if</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">memo</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">memo</span><span class="p">[</span><span class="n">edge</span><span class="p">]</span>

        <span class="n">trees</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c"># when we&#39;re reading trees off the chart, don&#39;t use incomplete edges</span>
        <span class="k">if</span> <span class="n">complete</span> <span class="ow">and</span> <span class="n">edge</span><span class="o">.</span><span class="n">is_incomplete</span><span class="p">():</span>
            <span class="k">return</span> <span class="n">trees</span>

        <span class="c"># Until we&#39;re done computing the trees for edge, set</span>
        <span class="c"># memo[edge] to be empty.  This has the effect of filtering</span>
        <span class="c"># out any cyclic trees (i.e., trees that contain themselves as</span>
        <span class="c"># descendants), because if we reach this edge via a cycle,</span>
        <span class="c"># then it will appear that the edge doesn&#39;t generate any</span>
        <span class="c"># trees.</span>
        <span class="n">memo</span><span class="p">[</span><span class="n">edge</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="c"># Leaf edges.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">edge</span><span class="p">,</span> <span class="n">LeafEdge</span><span class="p">):</span>
            <span class="n">leaf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tokens</span><span class="p">[</span><span class="n">edge</span><span class="o">.</span><span class="n">start</span><span class="p">()]</span>
            <span class="n">memo</span><span class="p">[</span><span class="n">edge</span><span class="p">]</span> <span class="o">=</span> <span class="n">leaf</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">leaf</span><span class="p">]</span>
        
        <span class="c"># Each child pointer list can be used to form trees.</span>
        <span class="k">for</span> <span class="n">cpl</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">child_pointer_lists</span><span class="p">(</span><span class="n">edge</span><span class="p">):</span>
            <span class="c"># Get the set of child choices for each child pointer.</span>
            <span class="c"># child_choices[i] is the set of choices for the tree&#39;s</span>
            <span class="c"># ith child.</span>
            <span class="n">child_choices</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_trees</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">complete</span><span class="p">,</span> <span class="n">memo</span><span class="p">,</span> <span class="n">tree_class</span><span class="p">)</span>
                             <span class="k">for</span> <span class="n">cp</span> <span class="ow">in</span> <span class="n">cpl</span><span class="p">]</span>

            <span class="c"># For each combination of children, add a tree.</span>
            <span class="k">for</span> <span class="n">children</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_choose_children</span><span class="p">(</span><span class="n">child_choices</span><span class="p">):</span>
                <span class="n">lhs</span> <span class="o">=</span> <span class="n">edge</span><span class="o">.</span><span class="n">lhs</span><span class="p">()</span><span class="o">.</span><span class="n">symbol</span><span class="p">()</span>
                <span class="n">trees</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tree_class</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">children</span><span class="p">))</span>

        <span class="c"># If the edge is incomplete, then extend it with &quot;partial trees&quot;:</span>
        <span class="k">if</span> <span class="n">edge</span><span class="o">.</span><span class="n">is_incomplete</span><span class="p">():</span>
            <span class="n">unexpanded</span> <span class="o">=</span> <span class="p">[</span><span class="n">tree_class</span><span class="p">(</span><span class="n">elt</span><span class="p">,[])</span>
                          <span class="k">for</span> <span class="n">elt</span> <span class="ow">in</span> <span class="n">edge</span><span class="o">.</span><span class="n">rhs</span><span class="p">()[</span><span class="n">edge</span><span class="o">.</span><span class="n">dot</span><span class="p">():]]</span>
            <span class="k">for</span> <span class="n">tree</span> <span class="ow">in</span> <span class="n">trees</span><span class="p">:</span>
                <span class="n">tree</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">unexpanded</span><span class="p">)</span>

        <span class="c"># Update the memoization dictionary.</span>
        <span class="n">memo</span><span class="p">[</span><span class="n">edge</span><span class="p">]</span> <span class="o">=</span> <span class="n">trees</span>

        <span class="c"># Return the list of trees.</span>
        <span class="k">return</span> <span class="n">trees</span>

    <span class="k">def</span> <span class="nf">_choose_children</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">child_choices</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A helper function for L{_trees} that finds the possible sets</span>
<span class="sd">        of subtrees for a new tree.</span>
<span class="sd">        </span>
<span class="sd">        @param child_choices: A list that specifies the options for</span>
<span class="sd">        each child.  In particular, C{child_choices[i]} is a list of</span>
<span class="sd">        tokens and subtrees that can be used as the C{i}th child.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">children_lists</span> <span class="o">=</span> <span class="p">[[]]</span>
        <span class="k">for</span> <span class="n">child_choice</span> <span class="ow">in</span> <span class="n">child_choices</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">child_choice</span><span class="p">,</span> <span class="s">&#39;__iter__&#39;</span><span class="p">)</span> <span class="ow">and</span> \
                    <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child_choice</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">):</span>
                <span class="c"># Only iterate over the child trees </span>
                <span class="c"># if child_choice is iterable and NOT a string</span>
                <span class="n">children_lists</span> <span class="o">=</span> <span class="p">[</span><span class="n">child_list</span><span class="o">+</span><span class="p">[</span><span class="n">child</span><span class="p">]</span>
                                  <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">child_choice</span>
                                  <span class="k">for</span> <span class="n">child_list</span> <span class="ow">in</span> <span class="n">children_lists</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c"># If child_choice is a string (or non-iterable)</span>
                <span class="c"># then it is a leaf</span>
                <span class="n">children_lists</span> <span class="o">=</span> <span class="p">[</span><span class="n">child_list</span><span class="o">+</span><span class="p">[</span><span class="n">child_choice</span><span class="p">]</span> 
                                  <span class="k">for</span> <span class="n">child_list</span> <span class="ow">in</span> <span class="n">children_lists</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">children_lists</span>
    
<div class="viewcode-block" id="Chart.child_pointer_lists"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.chart.Chart.child_pointer_lists">[docs]</a>    <span class="k">def</span> <span class="nf">child_pointer_lists</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        @rtype: C{list} of C{list} of C{EdgeI}</span>
<span class="sd">        @return: The set of child pointer lists for the given edge.</span>
<span class="sd">            Each child pointer list is a list of edges that have</span>
<span class="sd">            been used to form this edge.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Make a copy, in case they modify it.</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edge_to_cpls</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">edge</span><span class="p">,</span> <span class="p">{})</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>

    <span class="c">#////////////////////////////////////////////////////////////</span>
    <span class="c"># Display</span>
    <span class="c">#////////////////////////////////////////////////////////////</span></div>
<div class="viewcode-block" id="Chart.pp_edge"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.chart.Chart.pp_edge">[docs]</a>    <span class="k">def</span> <span class="nf">pp_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        @return: A pretty-printed string representation of a given edge</span>
<span class="sd">            in this chart.</span>
<span class="sd">        @rtype: C{string}</span>
<span class="sd">        @param width: The number of characters allotted to each</span>
<span class="sd">            index in the sentence.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">width</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span> <span class="n">width</span> <span class="o">=</span> <span class="mi">50</span><span class="o">/</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_leaves</span><span class="p">()</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">edge</span><span class="o">.</span><span class="n">start</span><span class="p">(),</span> <span class="n">edge</span><span class="o">.</span><span class="n">end</span><span class="p">())</span>

        <span class="nb">str</span> <span class="o">=</span> <span class="s">&#39;|&#39;</span> <span class="o">+</span> <span class="p">(</span><span class="s">&#39;.&#39;</span><span class="o">+</span><span class="s">&#39; &#39;</span><span class="o">*</span><span class="p">(</span><span class="n">width</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">*</span><span class="n">start</span>

        <span class="c"># Zero-width edges are &quot;#&quot; if complete, &quot;&gt;&quot; if incomplete</span>
        <span class="k">if</span> <span class="n">start</span> <span class="o">==</span> <span class="n">end</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">edge</span><span class="o">.</span><span class="n">is_complete</span><span class="p">():</span> <span class="nb">str</span> <span class="o">+=</span> <span class="s">&#39;#&#39;</span>
            <span class="k">else</span><span class="p">:</span> <span class="nb">str</span> <span class="o">+=</span> <span class="s">&#39;&gt;&#39;</span>

        <span class="c"># Spanning complete edges are &quot;[===]&quot;; Other edges are</span>
        <span class="c"># &quot;[---]&quot; if complete, &quot;[---&gt;&quot; if incomplete</span>
        <span class="k">elif</span> <span class="n">edge</span><span class="o">.</span><span class="n">is_complete</span><span class="p">()</span> <span class="ow">and</span> <span class="n">edge</span><span class="o">.</span><span class="n">span</span><span class="p">()</span> <span class="o">==</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_num_leaves</span><span class="p">):</span>
            <span class="nb">str</span> <span class="o">+=</span> <span class="s">&#39;[&#39;</span><span class="o">+</span><span class="p">(</span><span class="s">&#39;=&#39;</span><span class="o">*</span><span class="n">width</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">end</span><span class="o">-</span><span class="n">start</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="s">&#39;=&#39;</span><span class="o">*</span><span class="p">(</span><span class="n">width</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="s">&#39;]&#39;</span>
        <span class="k">elif</span> <span class="n">edge</span><span class="o">.</span><span class="n">is_complete</span><span class="p">():</span>
            <span class="nb">str</span> <span class="o">+=</span> <span class="s">&#39;[&#39;</span><span class="o">+</span><span class="p">(</span><span class="s">&#39;-&#39;</span><span class="o">*</span><span class="n">width</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">end</span><span class="o">-</span><span class="n">start</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="s">&#39;-&#39;</span><span class="o">*</span><span class="p">(</span><span class="n">width</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="s">&#39;]&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">str</span> <span class="o">+=</span> <span class="s">&#39;[&#39;</span><span class="o">+</span><span class="p">(</span><span class="s">&#39;-&#39;</span><span class="o">*</span><span class="n">width</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">end</span><span class="o">-</span><span class="n">start</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="s">&#39;-&#39;</span><span class="o">*</span><span class="p">(</span><span class="n">width</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="s">&#39;&gt;&#39;</span>
        
        <span class="nb">str</span> <span class="o">+=</span> <span class="p">(</span><span class="s">&#39; &#39;</span><span class="o">*</span><span class="p">(</span><span class="n">width</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="s">&#39;.&#39;</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_num_leaves</span><span class="o">-</span><span class="n">end</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">str</span> <span class="o">+</span> <span class="s">&#39;| </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">edge</span>
</div>
<div class="viewcode-block" id="Chart.pp_leaves"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.chart.Chart.pp_leaves">[docs]</a>    <span class="k">def</span> <span class="nf">pp_leaves</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        @return: A pretty-printed string representation of this</span>
<span class="sd">            chart&#39;s leaves.  This string can be used as a header</span>
<span class="sd">            for calls to L{pp_edge}.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">width</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span> <span class="n">width</span> <span class="o">=</span> <span class="mi">50</span><span class="o">/</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_leaves</span><span class="p">()</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tokens</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">width</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">header</span> <span class="o">=</span> <span class="s">&#39;|.&#39;</span>
            <span class="k">for</span> <span class="n">tok</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tokens</span><span class="p">:</span>
                <span class="n">header</span> <span class="o">+=</span> <span class="n">tok</span><span class="p">[:</span><span class="n">width</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">center</span><span class="p">(</span><span class="n">width</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="s">&#39;.&#39;</span>
            <span class="n">header</span> <span class="o">+=</span> <span class="s">&#39;|&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">header</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>

        <span class="k">return</span> <span class="n">header</span>
</div>
<div class="viewcode-block" id="Chart.pp"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.chart.Chart.pp">[docs]</a>    <span class="k">def</span> <span class="nf">pp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        @return: A pretty-printed string representation of this chart.</span>
<span class="sd">        @rtype: C{string}</span>
<span class="sd">        @param width: The number of characters allotted to each</span>
<span class="sd">            index in the sentence.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">width</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span> <span class="n">width</span> <span class="o">=</span> <span class="mi">50</span><span class="o">/</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_leaves</span><span class="p">()</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="c"># sort edges: primary key=length, secondary key=start index.</span>
        <span class="c"># (and filter out the token edges)</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="p">[(</span><span class="n">e</span><span class="o">.</span><span class="n">length</span><span class="p">(),</span> <span class="n">e</span><span class="o">.</span><span class="n">start</span><span class="p">(),</span> <span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]</span>
        <span class="n">edges</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span> <span class="k">for</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span><span class="n">_</span><span class="p">,</span><span class="n">e</span><span class="p">)</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">]</span>
        
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pp_leaves</span><span class="p">(</span><span class="n">width</span><span class="p">)</span> <span class="o">+</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span> <span class="o">+</span>
                <span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pp_edge</span><span class="p">(</span><span class="n">edge</span><span class="p">,</span> <span class="n">width</span><span class="p">)</span> <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">))</span>
                
    <span class="c">#////////////////////////////////////////////////////////////</span>
    <span class="c"># Display: Dot (AT&amp;T Graphviz)</span>
    <span class="c">#////////////////////////////////////////////////////////////</span>
</div>
<div class="viewcode-block" id="Chart.dot_digraph"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.chart.Chart.dot_digraph">[docs]</a>    <span class="k">def</span> <span class="nf">dot_digraph</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># Header</span>
        <span class="n">s</span> <span class="o">=</span> <span class="s">&#39;digraph nltk_chart {</span><span class="se">\n</span><span class="s">&#39;</span>
        <span class="c">#s += &#39;  size=&quot;5,5&quot;;\n&#39;</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s">&#39;  rankdir=LR;</span><span class="se">\n</span><span class="s">&#39;</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s">&#39;  node [height=0.1,width=0.1];</span><span class="se">\n</span><span class="s">&#39;</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s">&#39;  node [style=filled, color=&quot;lightgray&quot;];</span><span class="se">\n</span><span class="s">&#39;</span>

        <span class="c"># Set up the nodes</span>
        <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_edges</span><span class="p">(),</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">y</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">s</span> <span class="o">+=</span> <span class="s">&#39;  node [style=filled, color=&quot;black&quot;];</span><span class="se">\n</span><span class="s">&#39;</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_leaves</span><span class="p">()</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">y</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edges</span><span class="p">[</span><span class="n">y</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">start</span><span class="p">()</span> <span class="ow">or</span>
                              <span class="n">x</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edges</span><span class="p">[</span><span class="n">y</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">end</span><span class="p">()):</span>
                    <span class="n">s</span> <span class="o">+=</span> <span class="s">&#39;  </span><span class="si">%04d</span><span class="s">.</span><span class="si">%04d</span><span class="s"> [label=&quot;&quot;];</span><span class="se">\n</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>

        <span class="c"># Add a spacer</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s">&#39;  x [style=invis]; x-&gt;0000.0000 [style=invis];</span><span class="se">\n</span><span class="s">&#39;</span>

        <span class="c"># Declare ranks.</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_leaves</span><span class="p">()</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s">&#39;  {rank=same;&#39;</span>
            <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_edges</span><span class="p">()</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">y</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edges</span><span class="p">[</span><span class="n">y</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">start</span><span class="p">()</span> <span class="ow">or</span>
                              <span class="n">x</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edges</span><span class="p">[</span><span class="n">y</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">end</span><span class="p">()):</span>
                    <span class="n">s</span> <span class="o">+=</span> <span class="s">&#39; </span><span class="si">%04d</span><span class="s">.</span><span class="si">%04d</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s">&#39;}</span><span class="se">\n</span><span class="s">&#39;</span>

        <span class="c"># Add the leaves</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s">&#39;  edge [style=invis, weight=100];</span><span class="se">\n</span><span class="s">&#39;</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s">&#39;  node [shape=plaintext]</span><span class="se">\n</span><span class="s">&#39;</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s">&#39;  0000.0000&#39;</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_leaves</span><span class="p">()):</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s">&#39;-&gt;</span><span class="si">%s</span><span class="s">-&gt;</span><span class="si">%04d</span><span class="s">.0000&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">leaf</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s">&#39;;</span><span class="se">\n\n</span><span class="s">&#39;</span>

        <span class="c"># Add the edges</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s">&#39;  edge [style=solid, weight=1];</span><span class="se">\n</span><span class="s">&#39;</span>
        <span class="k">for</span> <span class="n">y</span><span class="p">,</span> <span class="n">edge</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">edge</span><span class="o">.</span><span class="n">start</span><span class="p">()):</span>
                <span class="n">s</span> <span class="o">+=</span> <span class="p">(</span><span class="s">&#39;  </span><span class="si">%04d</span><span class="s">.</span><span class="si">%04d</span><span class="s"> -&gt; </span><span class="si">%04d</span><span class="s">.</span><span class="si">%04d</span><span class="s"> [style=&quot;invis&quot;];</span><span class="se">\n</span><span class="s">&#39;</span> <span class="o">%</span>
                      <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="p">(</span><span class="s">&#39;  </span><span class="si">%04d</span><span class="s">.</span><span class="si">%04d</span><span class="s"> -&gt; </span><span class="si">%04d</span><span class="s">.</span><span class="si">%04d</span><span class="s"> [label=&quot;</span><span class="si">%s</span><span class="s">&quot;];</span><span class="se">\n</span><span class="s">&#39;</span> <span class="o">%</span>
                  <span class="p">(</span><span class="n">edge</span><span class="o">.</span><span class="n">start</span><span class="p">(),</span> <span class="n">y</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">edge</span><span class="o">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">y</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">edge</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">edge</span><span class="o">.</span><span class="n">end</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_leaves</span><span class="p">()):</span>
                <span class="n">s</span> <span class="o">+=</span> <span class="p">(</span><span class="s">&#39;  </span><span class="si">%04d</span><span class="s">.</span><span class="si">%04d</span><span class="s"> -&gt; </span><span class="si">%04d</span><span class="s">.</span><span class="si">%04d</span><span class="s"> [style=&quot;invis&quot;];</span><span class="se">\n</span><span class="s">&#39;</span> <span class="o">%</span>
                      <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s">&#39;}</span><span class="se">\n</span><span class="s">&#39;</span>
        <span class="k">return</span> <span class="n">s</span>

<span class="c">########################################################################</span>
<span class="c">##  Chart Rules</span>
<span class="c">########################################################################</span>
</div></div>
<div class="viewcode-block" id="ChartRuleI"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.chart.ChartRuleI">[docs]</a><span class="k">class</span> <span class="nc">ChartRuleI</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A rule that specifies what new edges are licensed by any given set</span>
<span class="sd">    of existing edges.  Each chart rule expects a fixed number of</span>
<span class="sd">    edges, as indicated by the class variable L{NUM_EDGES}.  In</span>
<span class="sd">    particular:</span>
<span class="sd">    </span>
<span class="sd">      - A chart rule with C{NUM_EDGES=0} specifies what new edges are</span>
<span class="sd">        licensed, regardless of existing edges.</span>

<span class="sd">      - A chart rule with C{NUM_EDGES=1} specifies what new edges are</span>
<span class="sd">        licensed by a single existing edge.</span>

<span class="sd">      - A chart rule with C{NUM_EDGES=2} specifies what new edges are</span>
<span class="sd">        licensed by a pair of existing edges.</span>
<span class="sd">      </span>
<span class="sd">    @type NUM_EDGES: C{int}</span>
<span class="sd">    @cvar NUM_EDGES: The number of existing edges that this rule uses</span>
<span class="sd">        to license new edges.  Typically, this number ranges from zero</span>
<span class="sd">        to two.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="ChartRuleI.apply"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.chart.ChartRuleI.apply">[docs]</a>    <span class="k">def</span> <span class="nf">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chart</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span> <span class="o">*</span><span class="n">edges</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add the edges licensed by this rule and the given edges to the</span>
<span class="sd">        chart.</span>

<span class="sd">        @type edges: C{list} of L{EdgeI}</span>
<span class="sd">        @param edges: A set of existing edges.  The number of edges</span>
<span class="sd">            that should be passed to C{apply} is specified by the</span>
<span class="sd">            L{NUM_EDGES} class variable.</span>
<span class="sd">        @rtype: C{list} of L{EdgeI}</span>
<span class="sd">        @return: A list of the edges that were added.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">,</span> <span class="s">&#39;ChartRuleI is an abstract interface&#39;</span>
</div>
<div class="viewcode-block" id="ChartRuleI.apply_iter"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.chart.ChartRuleI.apply_iter">[docs]</a>    <span class="k">def</span> <span class="nf">apply_iter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chart</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span> <span class="o">*</span><span class="n">edges</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        @return: A generator that will add edges licensed by this rule</span>
<span class="sd">            and the given edges to the chart, one at a time.  Each</span>
<span class="sd">            time the generator is resumed, it will either add a new</span>
<span class="sd">            edge and yield that edge; or return.</span>
<span class="sd">        @rtype: C{iter} of L{EdgeI}</span>
<span class="sd">        </span>
<span class="sd">        @type edges: C{list} of L{EdgeI}</span>
<span class="sd">        @param edges: A set of existing edges.  The number of edges</span>
<span class="sd">            that should be passed to C{apply} is specified by the</span>
<span class="sd">            L{NUM_EDGES} class variable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">,</span> <span class="s">&#39;ChartRuleI is an abstract interface&#39;</span>
</div>
<div class="viewcode-block" id="ChartRuleI.apply_everywhere"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.chart.ChartRuleI.apply_everywhere">[docs]</a>    <span class="k">def</span> <span class="nf">apply_everywhere</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chart</span><span class="p">,</span> <span class="n">grammar</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add all the edges licensed by this rule and the edges in the</span>
<span class="sd">        chart to the chart.</span>
<span class="sd">        </span>
<span class="sd">        @rtype: C{list} of L{EdgeI}</span>
<span class="sd">        @return: A list of the edges that were added.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">,</span> <span class="s">&#39;ChartRuleI is an abstract interface&#39;</span>
</div>
<div class="viewcode-block" id="ChartRuleI.apply_everywhere_iter"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.chart.ChartRuleI.apply_everywhere_iter">[docs]</a>    <span class="k">def</span> <span class="nf">apply_everywhere_iter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chart</span><span class="p">,</span> <span class="n">grammar</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        @return: A generator that will add all edges licensed by</span>
<span class="sd">            this rule, given the edges that are currently in the</span>
<span class="sd">            chart, one at a time.  Each time the generator is resumed,</span>
<span class="sd">            it will either add a new edge and yield that edge; or</span>
<span class="sd">            return.</span>
<span class="sd">        @rtype: C{iter} of L{EdgeI}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">,</span> <span class="s">&#39;ChartRuleI is an abstract interface&#39;</span>
        </div></div>
<div class="viewcode-block" id="AbstractChartRule"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.chart.AbstractChartRule">[docs]</a><span class="k">class</span> <span class="nc">AbstractChartRule</span><span class="p">(</span><span class="n">ChartRuleI</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An abstract base class for chart rules.  C{AbstractChartRule}</span>
<span class="sd">    provides:</span>
<span class="sd">      - A default implementation for C{apply}, based on C{apply_iter}.</span>
<span class="sd">      - A default implementation for C{apply_everywhere_iter},</span>
<span class="sd">        based on C{apply_iter}.</span>
<span class="sd">      - A default implementation for C{apply_everywhere}, based on</span>
<span class="sd">        C{apply_everywhere_iter}.  Currently, this implementation</span>
<span class="sd">        assumes that C{NUM_EDGES}&lt;=3.</span>
<span class="sd">      - A default implementation for C{__str__}, which returns a</span>
<span class="sd">        name basd on the rule&#39;s class name.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c"># Subclasses must define apply_iter.</span>
<div class="viewcode-block" id="AbstractChartRule.apply_iter"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.chart.AbstractChartRule.apply_iter">[docs]</a>    <span class="k">def</span> <span class="nf">apply_iter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chart</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span> <span class="o">*</span><span class="n">edges</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">,</span> <span class="s">&#39;AbstractChartRule is an abstract class&#39;</span>

    <span class="c"># Default: loop through the given number of edges, and call</span>
    <span class="c"># self.apply() for each set of edges.</span></div>
<div class="viewcode-block" id="AbstractChartRule.apply_everywhere_iter"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.chart.AbstractChartRule.apply_everywhere_iter">[docs]</a>    <span class="k">def</span> <span class="nf">apply_everywhere_iter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chart</span><span class="p">,</span> <span class="n">grammar</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">NUM_EDGES</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">new_edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply_iter</span><span class="p">(</span><span class="n">chart</span><span class="p">,</span> <span class="n">grammar</span><span class="p">):</span>
                <span class="k">yield</span> <span class="n">new_edge</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">NUM_EDGES</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">e1</span> <span class="ow">in</span> <span class="n">chart</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">new_edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply_iter</span><span class="p">(</span><span class="n">chart</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span> <span class="n">e1</span><span class="p">):</span>
                    <span class="k">yield</span> <span class="n">new_edge</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">NUM_EDGES</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">e1</span> <span class="ow">in</span> <span class="n">chart</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">e2</span> <span class="ow">in</span> <span class="n">chart</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">new_edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply_iter</span><span class="p">(</span><span class="n">chart</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span> <span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">):</span>
                        <span class="k">yield</span> <span class="n">new_edge</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">NUM_EDGES</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">e1</span> <span class="ow">in</span> <span class="n">chart</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">e2</span> <span class="ow">in</span> <span class="n">chart</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">e3</span> <span class="ow">in</span> <span class="n">chart</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">new_edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply_iter</span><span class="p">(</span><span class="n">chart</span><span class="p">,</span><span class="n">grammar</span><span class="p">,</span><span class="n">e1</span><span class="p">,</span><span class="n">e2</span><span class="p">,</span><span class="n">e3</span><span class="p">):</span>
                            <span class="k">yield</span> <span class="n">new_edge</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">,</span> <span class="s">&#39;NUM_EDGES&gt;3 is not currently supported&#39;</span>

    <span class="c"># Default: delegate to apply_iter.</span></div>
<div class="viewcode-block" id="AbstractChartRule.apply"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.chart.AbstractChartRule.apply">[docs]</a>    <span class="k">def</span> <span class="nf">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chart</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span> <span class="o">*</span><span class="n">edges</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">apply_iter</span><span class="p">(</span><span class="n">chart</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span> <span class="o">*</span><span class="n">edges</span><span class="p">))</span>

    <span class="c"># Default: delegate to apply_everywhere_iter.</span></div>
<div class="viewcode-block" id="AbstractChartRule.apply_everywhere"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.chart.AbstractChartRule.apply_everywhere">[docs]</a>    <span class="k">def</span> <span class="nf">apply_everywhere</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chart</span><span class="p">,</span> <span class="n">grammar</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">apply_everywhere_iter</span><span class="p">(</span><span class="n">chart</span><span class="p">,</span> <span class="n">grammar</span><span class="p">))</span>

    <span class="c"># Default: return a name based on the class name.</span></div>
    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># Add spaces between InitialCapsWords.</span>
        <span class="k">return</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s">&#39;([a-z])([A-Z])&#39;</span><span class="p">,</span> <span class="s">r&#39;\1 \2&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">)</span>

<span class="c">#////////////////////////////////////////////////////////////</span>
<span class="c"># Fundamental Rule</span>
<span class="c">#////////////////////////////////////////////////////////////</span>
</div>
<div class="viewcode-block" id="FundamentalRule"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.chart.FundamentalRule">[docs]</a><span class="k">class</span> <span class="nc">FundamentalRule</span><span class="p">(</span><span class="n">AbstractChartRule</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A rule that joins two adjacent edges to form a single combined</span>
<span class="sd">    edge.  In particular, this rule specifies that any pair of edges:</span>
<span class="sd">    </span>
<span class="sd">        - [A S{-&gt;} S{alpha} * B S{beta}][i:j]</span>
<span class="sd">        - [B S{-&gt;} S{gamma} *][j:k]</span>
<span class="sd">    licenses the edge:</span>
<span class="sd">        - [A S{-&gt;} S{alpha} B * S{beta}][i:j]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">NUM_EDGES</span> <span class="o">=</span> <span class="mi">2</span>
<div class="viewcode-block" id="FundamentalRule.apply_iter"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.chart.FundamentalRule.apply_iter">[docs]</a>    <span class="k">def</span> <span class="nf">apply_iter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chart</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span> <span class="n">left_edge</span><span class="p">,</span> <span class="n">right_edge</span><span class="p">):</span>
        <span class="c"># Make sure the rule is applicable.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">left_edge</span><span class="o">.</span><span class="n">is_incomplete</span><span class="p">()</span> <span class="ow">and</span> 
                <span class="n">right_edge</span><span class="o">.</span><span class="n">is_complete</span><span class="p">()</span> <span class="ow">and</span>
                <span class="n">left_edge</span><span class="o">.</span><span class="n">end</span><span class="p">()</span> <span class="o">==</span> <span class="n">right_edge</span><span class="o">.</span><span class="n">start</span><span class="p">()</span> <span class="ow">and</span>
                <span class="n">left_edge</span><span class="o">.</span><span class="n">next</span><span class="p">()</span> <span class="o">==</span> <span class="n">right_edge</span><span class="o">.</span><span class="n">lhs</span><span class="p">()):</span>
            <span class="k">return</span>

        <span class="c"># Construct the new edge.</span>
        <span class="n">new_edge</span> <span class="o">=</span> <span class="n">left_edge</span><span class="o">.</span><span class="n">move_dot_forward</span><span class="p">(</span><span class="n">right_edge</span><span class="o">.</span><span class="n">end</span><span class="p">())</span>
        
        <span class="c"># Insert it into the chart.</span>
        <span class="k">if</span> <span class="n">chart</span><span class="o">.</span><span class="n">insert_with_backpointer</span><span class="p">(</span><span class="n">new_edge</span><span class="p">,</span> <span class="n">left_edge</span><span class="p">,</span> <span class="n">right_edge</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">new_edge</span>
</div></div>
<div class="viewcode-block" id="SingleEdgeFundamentalRule"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.chart.SingleEdgeFundamentalRule">[docs]</a><span class="k">class</span> <span class="nc">SingleEdgeFundamentalRule</span><span class="p">(</span><span class="n">FundamentalRule</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A rule that joins a given edge with adjacent edges in the chart,</span>
<span class="sd">    to form combined edges.  In particular, this rule specifies that</span>
<span class="sd">    either of the edges:</span>
<span class="sd">        - [A S{-&gt;} S{alpha} * B S{beta}][i:j]</span>
<span class="sd">        - [B S{-&gt;} S{gamma} *][j:k]</span>
<span class="sd">    licenses the edge:</span>
<span class="sd">        - [A S{-&gt;} S{alpha} B * S{beta}][i:j]</span>
<span class="sd">    if the other edge is already in the chart.</span>
<span class="sd">    </span>
<span class="sd">    @note: This is basically L{FundamentalRule}, with one edge left</span>
<span class="sd">        unspecified.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">NUM_EDGES</span> <span class="o">=</span> <span class="mi">1</span>

<div class="viewcode-block" id="SingleEdgeFundamentalRule.apply_iter"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.chart.SingleEdgeFundamentalRule.apply_iter">[docs]</a>    <span class="k">def</span> <span class="nf">apply_iter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chart</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span> <span class="n">edge</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">edge</span><span class="o">.</span><span class="n">is_incomplete</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">new_edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_incomplete</span><span class="p">(</span><span class="n">chart</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span> <span class="n">edge</span><span class="p">):</span>
                <span class="k">yield</span> <span class="n">new_edge</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">new_edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_complete</span><span class="p">(</span><span class="n">chart</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span> <span class="n">edge</span><span class="p">):</span>
                <span class="k">yield</span> <span class="n">new_edge</span>
</div>
    <span class="k">def</span> <span class="nf">_apply_complete</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chart</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span> <span class="n">right_edge</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">left_edge</span> <span class="ow">in</span> <span class="n">chart</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">end</span><span class="o">=</span><span class="n">right_edge</span><span class="o">.</span><span class="n">start</span><span class="p">(),</span> 
                                      <span class="n">is_complete</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                                      <span class="nb">next</span><span class="o">=</span><span class="n">right_edge</span><span class="o">.</span><span class="n">lhs</span><span class="p">()):</span>
            <span class="n">new_edge</span> <span class="o">=</span> <span class="n">left_edge</span><span class="o">.</span><span class="n">move_dot_forward</span><span class="p">(</span><span class="n">right_edge</span><span class="o">.</span><span class="n">end</span><span class="p">())</span>
            <span class="k">if</span> <span class="n">chart</span><span class="o">.</span><span class="n">insert_with_backpointer</span><span class="p">(</span><span class="n">new_edge</span><span class="p">,</span> <span class="n">left_edge</span><span class="p">,</span> <span class="n">right_edge</span><span class="p">):</span>
                <span class="k">yield</span> <span class="n">new_edge</span>

    <span class="k">def</span> <span class="nf">_apply_incomplete</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chart</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span> <span class="n">left_edge</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">right_edge</span> <span class="ow">in</span> <span class="n">chart</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="n">left_edge</span><span class="o">.</span><span class="n">end</span><span class="p">(),</span> 
                                       <span class="n">is_complete</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                                       <span class="n">lhs</span><span class="o">=</span><span class="n">left_edge</span><span class="o">.</span><span class="n">next</span><span class="p">()):</span>
            <span class="n">new_edge</span> <span class="o">=</span> <span class="n">left_edge</span><span class="o">.</span><span class="n">move_dot_forward</span><span class="p">(</span><span class="n">right_edge</span><span class="o">.</span><span class="n">end</span><span class="p">())</span>
            <span class="k">if</span> <span class="n">chart</span><span class="o">.</span><span class="n">insert_with_backpointer</span><span class="p">(</span><span class="n">new_edge</span><span class="p">,</span> <span class="n">left_edge</span><span class="p">,</span> <span class="n">right_edge</span><span class="p">):</span>
                <span class="k">yield</span> <span class="n">new_edge</span>

<span class="c">#////////////////////////////////////////////////////////////</span>
<span class="c"># Inserting Terminal Leafs</span>
<span class="c">#////////////////////////////////////////////////////////////</span>
</div>
<div class="viewcode-block" id="LeafInitRule"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.chart.LeafInitRule">[docs]</a><span class="k">class</span> <span class="nc">LeafInitRule</span><span class="p">(</span><span class="n">AbstractChartRule</span><span class="p">):</span>
    <span class="n">NUM_EDGES</span><span class="o">=</span><span class="mi">0</span>
<div class="viewcode-block" id="LeafInitRule.apply_iter"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.chart.LeafInitRule.apply_iter">[docs]</a>    <span class="k">def</span> <span class="nf">apply_iter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chart</span><span class="p">,</span> <span class="n">grammar</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">chart</span><span class="o">.</span><span class="n">num_leaves</span><span class="p">()):</span>
            <span class="n">new_edge</span> <span class="o">=</span> <span class="n">LeafEdge</span><span class="p">(</span><span class="n">chart</span><span class="o">.</span><span class="n">leaf</span><span class="p">(</span><span class="n">index</span><span class="p">),</span> <span class="n">index</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">chart</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">new_edge</span><span class="p">,</span> <span class="p">()):</span>
                <span class="k">yield</span> <span class="n">new_edge</span>

<span class="c">#////////////////////////////////////////////////////////////</span>
<span class="c"># Top-Down Prediction</span>
<span class="c">#////////////////////////////////////////////////////////////</span>
</div></div>
<div class="viewcode-block" id="TopDownInitRule"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.chart.TopDownInitRule">[docs]</a><span class="k">class</span> <span class="nc">TopDownInitRule</span><span class="p">(</span><span class="n">AbstractChartRule</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A rule licensing edges corresponding to the grammar productions for</span>
<span class="sd">    the grammar&#39;s start symbol.  In particular, this rule specifies that:</span>
<span class="sd">        - [S S{-&gt;} * S{alpha}][0:i]</span>
<span class="sd">    is licensed for each grammar production C{S S{-&gt;} S{alpha}}, where</span>
<span class="sd">    C{S} is the grammar&#39;s start symbol.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">NUM_EDGES</span> <span class="o">=</span> <span class="mi">0</span>
<div class="viewcode-block" id="TopDownInitRule.apply_iter"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.chart.TopDownInitRule.apply_iter">[docs]</a>    <span class="k">def</span> <span class="nf">apply_iter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chart</span><span class="p">,</span> <span class="n">grammar</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">prod</span> <span class="ow">in</span> <span class="n">grammar</span><span class="o">.</span><span class="n">productions</span><span class="p">(</span><span class="n">lhs</span><span class="o">=</span><span class="n">grammar</span><span class="o">.</span><span class="n">start</span><span class="p">()):</span>
            <span class="n">new_edge</span> <span class="o">=</span> <span class="n">TreeEdge</span><span class="o">.</span><span class="n">from_production</span><span class="p">(</span><span class="n">prod</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">chart</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">new_edge</span><span class="p">,</span> <span class="p">()):</span>
                <span class="k">yield</span> <span class="n">new_edge</span>
</div></div>
<div class="viewcode-block" id="TopDownPredictRule"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.chart.TopDownPredictRule">[docs]</a><span class="k">class</span> <span class="nc">TopDownPredictRule</span><span class="p">(</span><span class="n">AbstractChartRule</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A rule licensing edges corresponding to the grammar productions</span>
<span class="sd">    for the nonterminal following an incomplete edge&#39;s dot.  In</span>
<span class="sd">    particular, this rule specifies that:</span>
<span class="sd">        - [A S{-&gt;} S{alpha} * B S{beta}][i:j]</span>
<span class="sd">    licenses the edge:</span>
<span class="sd">        - [B S{-&gt;} * S{gamma}][j:j]</span>
<span class="sd">    for each grammar production C{B S{-&gt;} S{gamma}}.</span>
<span class="sd">    </span>
<span class="sd">    @note: This rule corresponds to the Predictor Rule in Earley parsing.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">NUM_EDGES</span> <span class="o">=</span> <span class="mi">1</span>
<div class="viewcode-block" id="TopDownPredictRule.apply_iter"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.chart.TopDownPredictRule.apply_iter">[docs]</a>    <span class="k">def</span> <span class="nf">apply_iter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chart</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span> <span class="n">edge</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">edge</span><span class="o">.</span><span class="n">is_complete</span><span class="p">():</span> <span class="k">return</span>
        <span class="k">for</span> <span class="n">prod</span> <span class="ow">in</span> <span class="n">grammar</span><span class="o">.</span><span class="n">productions</span><span class="p">(</span><span class="n">lhs</span><span class="o">=</span><span class="n">edge</span><span class="o">.</span><span class="n">next</span><span class="p">()):</span>
            <span class="n">new_edge</span> <span class="o">=</span> <span class="n">TreeEdge</span><span class="o">.</span><span class="n">from_production</span><span class="p">(</span><span class="n">prod</span><span class="p">,</span> <span class="n">edge</span><span class="o">.</span><span class="n">end</span><span class="p">())</span>
            <span class="k">if</span> <span class="n">chart</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">new_edge</span><span class="p">,</span> <span class="p">()):</span>
                <span class="k">yield</span> <span class="n">new_edge</span>
</div></div>
<div class="viewcode-block" id="CachedTopDownPredictRule"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.chart.CachedTopDownPredictRule">[docs]</a><span class="k">class</span> <span class="nc">CachedTopDownPredictRule</span><span class="p">(</span><span class="n">TopDownPredictRule</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A cached version of L{TopDownPredictRule}.  After the first time</span>
<span class="sd">    this rule is applied to an edge with a given C{end} and C{next},</span>
<span class="sd">    it will not generate any more edges for edges with that C{end} and</span>
<span class="sd">    C{next}.</span>
<span class="sd">    </span>
<span class="sd">    If C{chart} or C{grammar} are changed, then the cache is flushed.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">TopDownPredictRule</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_done</span> <span class="o">=</span> <span class="p">{}</span>
        
<div class="viewcode-block" id="CachedTopDownPredictRule.apply_iter"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.chart.CachedTopDownPredictRule.apply_iter">[docs]</a>    <span class="k">def</span> <span class="nf">apply_iter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chart</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span> <span class="n">edge</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">edge</span><span class="o">.</span><span class="n">is_complete</span><span class="p">():</span> <span class="k">return</span>
        <span class="nb">next</span><span class="p">,</span> <span class="n">index</span> <span class="o">=</span> <span class="n">edge</span><span class="o">.</span><span class="n">next</span><span class="p">(),</span> <span class="n">edge</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_nonterminal</span><span class="p">(</span><span class="nb">next</span><span class="p">):</span> <span class="k">return</span>

        <span class="c"># If we&#39;ve already applied this rule to an edge with the same</span>
        <span class="c"># next &amp; end, and the chart &amp; grammar have not changed, then</span>
        <span class="c"># just return (no new edges to add).</span>
        <span class="n">done</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_done</span><span class="o">.</span><span class="n">get</span><span class="p">((</span><span class="nb">next</span><span class="p">,</span> <span class="n">index</span><span class="p">),</span> <span class="p">(</span><span class="bp">None</span><span class="p">,</span><span class="bp">None</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">done</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="n">chart</span> <span class="ow">and</span> <span class="n">done</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="n">grammar</span><span class="p">:</span> <span class="k">return</span>

        <span class="c"># Add all the edges indicated by the top down expand rule.</span>
        <span class="k">for</span> <span class="n">prod</span> <span class="ow">in</span> <span class="n">grammar</span><span class="o">.</span><span class="n">productions</span><span class="p">(</span><span class="n">lhs</span><span class="o">=</span><span class="nb">next</span><span class="p">):</span>
            <span class="c"># If the left corner in the predicted production is </span>
            <span class="c"># leaf, it must match with the input.</span>
            <span class="k">if</span> <span class="n">prod</span><span class="o">.</span><span class="n">rhs</span><span class="p">():</span>
                <span class="n">first</span> <span class="o">=</span> <span class="n">prod</span><span class="o">.</span><span class="n">rhs</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">is_terminal</span><span class="p">(</span><span class="n">first</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">index</span> <span class="o">&gt;=</span> <span class="n">chart</span><span class="o">.</span><span class="n">num_leaves</span><span class="p">()</span> <span class="ow">or</span> <span class="n">first</span> <span class="o">!=</span> <span class="n">chart</span><span class="o">.</span><span class="n">leaf</span><span class="p">(</span><span class="n">index</span><span class="p">):</span> <span class="k">continue</span>
            
            <span class="n">new_edge</span> <span class="o">=</span> <span class="n">TreeEdge</span><span class="o">.</span><span class="n">from_production</span><span class="p">(</span><span class="n">prod</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">chart</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">new_edge</span><span class="p">,</span> <span class="p">()):</span>
                <span class="k">yield</span> <span class="n">new_edge</span>
            
        <span class="c"># Record the fact that we&#39;ve applied this rule.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_done</span><span class="p">[</span><span class="nb">next</span><span class="p">,</span> <span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">chart</span><span class="p">,</span> <span class="n">grammar</span><span class="p">)</span>

<span class="c">#////////////////////////////////////////////////////////////</span>
<span class="c"># Bottom-Up Prediction</span>
<span class="c">#////////////////////////////////////////////////////////////</span>
</div></div>
<div class="viewcode-block" id="BottomUpPredictRule"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.chart.BottomUpPredictRule">[docs]</a><span class="k">class</span> <span class="nc">BottomUpPredictRule</span><span class="p">(</span><span class="n">AbstractChartRule</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A rule licensing any edge corresponding to a production whose</span>
<span class="sd">    right-hand side begins with a complete edge&#39;s left-hand side.  In</span>
<span class="sd">    particular, this rule specifies that:</span>
<span class="sd">        - [A S{-&gt;} S{alpha} *]</span>
<span class="sd">    licenses the edge:</span>
<span class="sd">        - [B S{-&gt;} * A S{beta}]</span>
<span class="sd">    for each grammar production C{B S{-&gt;} A S{beta}}.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">NUM_EDGES</span> <span class="o">=</span> <span class="mi">1</span>
<div class="viewcode-block" id="BottomUpPredictRule.apply_iter"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.chart.BottomUpPredictRule.apply_iter">[docs]</a>    <span class="k">def</span> <span class="nf">apply_iter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chart</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span> <span class="n">edge</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">edge</span><span class="o">.</span><span class="n">is_incomplete</span><span class="p">():</span> <span class="k">return</span>
        <span class="k">for</span> <span class="n">prod</span> <span class="ow">in</span> <span class="n">grammar</span><span class="o">.</span><span class="n">productions</span><span class="p">(</span><span class="n">rhs</span><span class="o">=</span><span class="n">edge</span><span class="o">.</span><span class="n">lhs</span><span class="p">()):</span>
            <span class="n">new_edge</span> <span class="o">=</span> <span class="n">TreeEdge</span><span class="o">.</span><span class="n">from_production</span><span class="p">(</span><span class="n">prod</span><span class="p">,</span> <span class="n">edge</span><span class="o">.</span><span class="n">start</span><span class="p">())</span>
            <span class="k">if</span> <span class="n">chart</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">new_edge</span><span class="p">,</span> <span class="p">()):</span>
                <span class="k">yield</span> <span class="n">new_edge</span>
</div></div>
<div class="viewcode-block" id="BottomUpPredictCombineRule"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.chart.BottomUpPredictCombineRule">[docs]</a><span class="k">class</span> <span class="nc">BottomUpPredictCombineRule</span><span class="p">(</span><span class="n">BottomUpPredictRule</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A rule licensing any edge corresponding to a production whose</span>
<span class="sd">    right-hand side begins with a complete edge&#39;s left-hand side.  In</span>
<span class="sd">    particular, this rule specifies that:</span>
<span class="sd">        - [A S{-&gt;} S{alpha} *]</span>
<span class="sd">    licenses the edge:</span>
<span class="sd">        - [B S{-&gt;} A * S{beta}]</span>
<span class="sd">    for each grammar production C{B S{-&gt;} A S{beta}}.</span>
<span class="sd">    </span>
<span class="sd">    @note: This is like L{BottomUpPredictRule}, but it also applies</span>
<span class="sd">    the L{FundamentalRule} to the resulting edge.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">NUM_EDGES</span> <span class="o">=</span> <span class="mi">1</span>
<div class="viewcode-block" id="BottomUpPredictCombineRule.apply_iter"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.chart.BottomUpPredictCombineRule.apply_iter">[docs]</a>    <span class="k">def</span> <span class="nf">apply_iter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chart</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span> <span class="n">edge</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">edge</span><span class="o">.</span><span class="n">is_incomplete</span><span class="p">():</span> <span class="k">return</span>
        <span class="k">for</span> <span class="n">prod</span> <span class="ow">in</span> <span class="n">grammar</span><span class="o">.</span><span class="n">productions</span><span class="p">(</span><span class="n">rhs</span><span class="o">=</span><span class="n">edge</span><span class="o">.</span><span class="n">lhs</span><span class="p">()):</span>
            <span class="n">new_edge</span> <span class="o">=</span> <span class="n">TreeEdge</span><span class="p">(</span><span class="n">edge</span><span class="o">.</span><span class="n">span</span><span class="p">(),</span> <span class="n">prod</span><span class="o">.</span><span class="n">lhs</span><span class="p">(),</span> <span class="n">prod</span><span class="o">.</span><span class="n">rhs</span><span class="p">(),</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">chart</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">new_edge</span><span class="p">,</span> <span class="p">(</span><span class="n">edge</span><span class="p">,)):</span>
                <span class="k">yield</span> <span class="n">new_edge</span>
</div></div>
<div class="viewcode-block" id="EmptyPredictRule"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.chart.EmptyPredictRule">[docs]</a><span class="k">class</span> <span class="nc">EmptyPredictRule</span><span class="p">(</span><span class="n">AbstractChartRule</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A rule that inserts all empty productions as passive edges,</span>
<span class="sd">    in every position in the chart.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">NUM_EDGES</span> <span class="o">=</span> <span class="mi">0</span>
<div class="viewcode-block" id="EmptyPredictRule.apply_iter"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.chart.EmptyPredictRule.apply_iter">[docs]</a>    <span class="k">def</span> <span class="nf">apply_iter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chart</span><span class="p">,</span> <span class="n">grammar</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">prod</span> <span class="ow">in</span> <span class="n">grammar</span><span class="o">.</span><span class="n">productions</span><span class="p">(</span><span class="n">empty</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">chart</span><span class="o">.</span><span class="n">num_leaves</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">new_edge</span> <span class="o">=</span> <span class="n">TreeEdge</span><span class="o">.</span><span class="n">from_production</span><span class="p">(</span><span class="n">prod</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">chart</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">new_edge</span><span class="p">,</span> <span class="p">()):</span>
                    <span class="k">yield</span> <span class="n">new_edge</span>


<span class="c">########################################################################</span>
<span class="c">##  Filtered Bottom Up</span>
<span class="c">########################################################################</span>
</div></div>
<div class="viewcode-block" id="FilteredSingleEdgeFundamentalRule"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.chart.FilteredSingleEdgeFundamentalRule">[docs]</a><span class="k">class</span> <span class="nc">FilteredSingleEdgeFundamentalRule</span><span class="p">(</span><span class="n">SingleEdgeFundamentalRule</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">_apply_complete</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chart</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span> <span class="n">right_edge</span><span class="p">):</span>
        <span class="n">end</span> <span class="o">=</span> <span class="n">right_edge</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>
        <span class="n">nexttoken</span> <span class="o">=</span> <span class="n">end</span> <span class="o">&lt;</span> <span class="n">chart</span><span class="o">.</span><span class="n">num_leaves</span><span class="p">()</span> <span class="ow">and</span> <span class="n">chart</span><span class="o">.</span><span class="n">leaf</span><span class="p">(</span><span class="n">end</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">left_edge</span> <span class="ow">in</span> <span class="n">chart</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">end</span><span class="o">=</span><span class="n">right_edge</span><span class="o">.</span><span class="n">start</span><span class="p">(),</span> 
                                      <span class="n">is_complete</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                                      <span class="nb">next</span><span class="o">=</span><span class="n">right_edge</span><span class="o">.</span><span class="n">lhs</span><span class="p">()):</span>
            <span class="k">if</span> <span class="n">_bottomup_filter</span><span class="p">(</span><span class="n">grammar</span><span class="p">,</span> <span class="n">nexttoken</span><span class="p">,</span> <span class="n">left_edge</span><span class="o">.</span><span class="n">rhs</span><span class="p">(),</span> <span class="n">left_edge</span><span class="o">.</span><span class="n">dot</span><span class="p">()):</span> 
                <span class="n">new_edge</span> <span class="o">=</span> <span class="n">left_edge</span><span class="o">.</span><span class="n">move_dot_forward</span><span class="p">(</span><span class="n">right_edge</span><span class="o">.</span><span class="n">end</span><span class="p">())</span>
                <span class="k">if</span> <span class="n">chart</span><span class="o">.</span><span class="n">insert_with_backpointer</span><span class="p">(</span><span class="n">new_edge</span><span class="p">,</span> <span class="n">left_edge</span><span class="p">,</span> <span class="n">right_edge</span><span class="p">):</span>
                    <span class="k">yield</span> <span class="n">new_edge</span>

    <span class="k">def</span> <span class="nf">_apply_incomplete</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chart</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span> <span class="n">left_edge</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">right_edge</span> <span class="ow">in</span> <span class="n">chart</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="n">left_edge</span><span class="o">.</span><span class="n">end</span><span class="p">(),</span> 
                                       <span class="n">is_complete</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                                       <span class="n">lhs</span><span class="o">=</span><span class="n">left_edge</span><span class="o">.</span><span class="n">next</span><span class="p">()):</span>
            <span class="n">end</span> <span class="o">=</span> <span class="n">right_edge</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>
            <span class="n">nexttoken</span> <span class="o">=</span> <span class="n">end</span> <span class="o">&lt;</span> <span class="n">chart</span><span class="o">.</span><span class="n">num_leaves</span><span class="p">()</span> <span class="ow">and</span> <span class="n">chart</span><span class="o">.</span><span class="n">leaf</span><span class="p">(</span><span class="n">end</span><span class="p">)</span> 
            <span class="k">if</span> <span class="n">_bottomup_filter</span><span class="p">(</span><span class="n">grammar</span><span class="p">,</span> <span class="n">nexttoken</span><span class="p">,</span> <span class="n">left_edge</span><span class="o">.</span><span class="n">rhs</span><span class="p">(),</span> <span class="n">left_edge</span><span class="o">.</span><span class="n">dot</span><span class="p">()):</span> 
                <span class="n">new_edge</span> <span class="o">=</span> <span class="n">left_edge</span><span class="o">.</span><span class="n">move_dot_forward</span><span class="p">(</span><span class="n">right_edge</span><span class="o">.</span><span class="n">end</span><span class="p">())</span>
                <span class="k">if</span> <span class="n">chart</span><span class="o">.</span><span class="n">insert_with_backpointer</span><span class="p">(</span><span class="n">new_edge</span><span class="p">,</span> <span class="n">left_edge</span><span class="p">,</span> <span class="n">right_edge</span><span class="p">):</span>
                    <span class="k">yield</span> <span class="n">new_edge</span>
</div>
<div class="viewcode-block" id="FilteredBottomUpPredictCombineRule"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.chart.FilteredBottomUpPredictCombineRule">[docs]</a><span class="k">class</span> <span class="nc">FilteredBottomUpPredictCombineRule</span><span class="p">(</span><span class="n">BottomUpPredictCombineRule</span><span class="p">):</span>
<div class="viewcode-block" id="FilteredBottomUpPredictCombineRule.apply_iter"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.chart.FilteredBottomUpPredictCombineRule.apply_iter">[docs]</a>    <span class="k">def</span> <span class="nf">apply_iter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chart</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span> <span class="n">edge</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">edge</span><span class="o">.</span><span class="n">is_incomplete</span><span class="p">():</span> <span class="k">return</span>
        <span class="n">leftcorners</span> <span class="o">=</span> <span class="n">grammar</span><span class="o">.</span><span class="n">leftcorners</span>
        <span class="n">end</span> <span class="o">=</span> <span class="n">edge</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>
        <span class="n">nexttoken</span> <span class="o">=</span> <span class="n">end</span> <span class="o">&lt;</span> <span class="n">chart</span><span class="o">.</span><span class="n">num_leaves</span><span class="p">()</span> <span class="ow">and</span> <span class="n">chart</span><span class="o">.</span><span class="n">leaf</span><span class="p">(</span><span class="n">end</span><span class="p">)</span> 
        <span class="k">for</span> <span class="n">prod</span> <span class="ow">in</span> <span class="n">grammar</span><span class="o">.</span><span class="n">productions</span><span class="p">(</span><span class="n">rhs</span><span class="o">=</span><span class="n">edge</span><span class="o">.</span><span class="n">lhs</span><span class="p">()):</span>
            <span class="k">if</span> <span class="n">_bottomup_filter</span><span class="p">(</span><span class="n">grammar</span><span class="p">,</span> <span class="n">nexttoken</span><span class="p">,</span> <span class="n">prod</span><span class="o">.</span><span class="n">rhs</span><span class="p">()):</span>
                <span class="n">new_edge</span> <span class="o">=</span> <span class="n">TreeEdge</span><span class="p">(</span><span class="n">edge</span><span class="o">.</span><span class="n">span</span><span class="p">(),</span> <span class="n">prod</span><span class="o">.</span><span class="n">lhs</span><span class="p">(),</span> <span class="n">prod</span><span class="o">.</span><span class="n">rhs</span><span class="p">(),</span> <span class="mi">1</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">chart</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">new_edge</span><span class="p">,</span> <span class="p">(</span><span class="n">edge</span><span class="p">,)):</span>
                    <span class="k">yield</span> <span class="n">new_edge</span>
</div></div>
<span class="k">def</span> <span class="nf">_bottomup_filter</span><span class="p">(</span><span class="n">grammar</span><span class="p">,</span> <span class="n">nexttoken</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">dot</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">rhs</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">dot</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">True</span>
    <span class="nb">next</span> <span class="o">=</span> <span class="n">rhs</span><span class="p">[</span><span class="n">dot</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">is_terminal</span><span class="p">(</span><span class="nb">next</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">nexttoken</span> <span class="o">==</span> <span class="nb">next</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">grammar</span><span class="o">.</span><span class="n">is_leftcorner</span><span class="p">(</span><span class="nb">next</span><span class="p">,</span> <span class="n">nexttoken</span><span class="p">)</span>


<span class="c">########################################################################</span>
<span class="c">##  Generic Chart Parser</span>
<span class="c">########################################################################</span>

<span class="n">TD_STRATEGY</span> <span class="o">=</span> <span class="p">[</span><span class="n">LeafInitRule</span><span class="p">(),</span>
               <span class="n">TopDownInitRule</span><span class="p">(),</span> 
               <span class="n">CachedTopDownPredictRule</span><span class="p">(),</span> 
               <span class="n">SingleEdgeFundamentalRule</span><span class="p">()]</span>
<span class="n">BU_STRATEGY</span> <span class="o">=</span> <span class="p">[</span><span class="n">LeafInitRule</span><span class="p">(),</span>
               <span class="n">EmptyPredictRule</span><span class="p">(),</span>
               <span class="n">BottomUpPredictRule</span><span class="p">(),</span> 
               <span class="n">SingleEdgeFundamentalRule</span><span class="p">()]</span>
<span class="n">BU_LC_STRATEGY</span> <span class="o">=</span> <span class="p">[</span><span class="n">LeafInitRule</span><span class="p">(),</span>
                  <span class="n">EmptyPredictRule</span><span class="p">(),</span>
                  <span class="n">BottomUpPredictCombineRule</span><span class="p">(),</span>
                  <span class="n">SingleEdgeFundamentalRule</span><span class="p">()]</span>

<span class="n">LC_STRATEGY</span> <span class="o">=</span> <span class="p">[</span><span class="n">LeafInitRule</span><span class="p">(),</span>
               <span class="n">FilteredBottomUpPredictCombineRule</span><span class="p">(),</span>
               <span class="n">FilteredSingleEdgeFundamentalRule</span><span class="p">()]</span>

<div class="viewcode-block" id="ChartParser"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.chart.ChartParser">[docs]</a><span class="k">class</span> <span class="nc">ChartParser</span><span class="p">(</span><span class="n">ParserI</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A generic chart parser.  A X{strategy}, or list of</span>
<span class="sd">    L{ChartRules&lt;ChartRuleI&gt;}, is used to decide what edges to add to</span>
<span class="sd">    the chart.  In particular, C{ChartParser} uses the following</span>
<span class="sd">    algorithm to parse texts:</span>

<span class="sd">        - Until no new edges are added:</span>
<span class="sd">          - For each I{rule} in I{strategy}:</span>
<span class="sd">            - Apply I{rule} to any applicable edges in the chart.</span>
<span class="sd">        - Return any complete parses in the chart</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span> <span class="n">strategy</span><span class="o">=</span><span class="n">BU_LC_STRATEGY</span><span class="p">,</span> <span class="n">trace</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> 
                 <span class="n">trace_chart_width</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">use_agenda</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">chart_class</span><span class="o">=</span><span class="n">Chart</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new chart parser, that uses C{grammar} to parse</span>
<span class="sd">        texts.</span>

<span class="sd">        @type grammar: L{ContextFreeGrammar}</span>
<span class="sd">        @param grammar: The grammar used to parse texts.</span>
<span class="sd">        @type strategy: C{list} of L{ChartRuleI}</span>
<span class="sd">        @param strategy: A list of rules that should be used to decide</span>
<span class="sd">            what edges to add to the chart (top-down strategy by default).</span>
<span class="sd">        @type trace: C{int}</span>
<span class="sd">        @param trace: The level of tracing that should be used when</span>
<span class="sd">            parsing a text.  C{0} will generate no tracing output;</span>
<span class="sd">            and higher numbers will produce more verbose tracing</span>
<span class="sd">            output.</span>
<span class="sd">        @type trace_chart_width: C{int}</span>
<span class="sd">        @param trace_chart_width: The default total width reserved for </span>
<span class="sd">            the chart in trace output.  The remainder of each line will </span>
<span class="sd">            be used to display edges. </span>
<span class="sd">        @type use_agenda: C{bool}</span>
<span class="sd">        @param use_agenda: Use an optimized agenda-based algorithm, </span>
<span class="sd">            if possible. </span>
<span class="sd">        @param chart_class: The class that should be used to create</span>
<span class="sd">            the parse charts.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_grammar</span> <span class="o">=</span> <span class="n">grammar</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_strategy</span> <span class="o">=</span> <span class="n">strategy</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_trace</span> <span class="o">=</span> <span class="n">trace</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_trace_chart_width</span> <span class="o">=</span> <span class="n">trace_chart_width</span>
        <span class="c"># If the strategy only consists of axioms (NUM_EDGES==0) and</span>
        <span class="c"># inference rules (NUM_EDGES==1), we can use an agenda-based algorithm:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_use_agenda</span> <span class="o">=</span> <span class="n">use_agenda</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_chart_class</span> <span class="o">=</span> <span class="n">chart_class</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">_axioms</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_inference_rules</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">rule</span> <span class="ow">in</span> <span class="n">strategy</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">rule</span><span class="o">.</span><span class="n">NUM_EDGES</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_axioms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rule</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">rule</span><span class="o">.</span><span class="n">NUM_EDGES</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_inference_rules</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rule</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_use_agenda</span> <span class="o">=</span> <span class="bp">False</span>

<div class="viewcode-block" id="ChartParser.grammar"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.chart.ChartParser.grammar">[docs]</a>    <span class="k">def</span> <span class="nf">grammar</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grammar</span>
</div>
    <span class="k">def</span> <span class="nf">_trace_new_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chart</span><span class="p">,</span> <span class="n">rule</span><span class="p">,</span> <span class="n">new_edges</span><span class="p">,</span> <span class="n">trace</span><span class="p">,</span> <span class="n">edge_width</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">trace</span><span class="p">:</span> <span class="k">return</span>
        <span class="n">should_print_rule_header</span> <span class="o">=</span> <span class="n">trace</span> <span class="o">&gt;</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">new_edges</span><span class="p">:</span> 
            <span class="k">if</span> <span class="n">should_print_rule_header</span><span class="p">:</span> 
                <span class="k">print</span> <span class="s">&#39;</span><span class="si">%s</span><span class="s">:&#39;</span> <span class="o">%</span> <span class="n">rule</span>
                <span class="n">should_print_rule_header</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="k">print</span> <span class="n">chart</span><span class="o">.</span><span class="n">pp_edge</span><span class="p">(</span><span class="n">edge</span><span class="p">,</span> <span class="n">edge_width</span><span class="p">)</span>

<div class="viewcode-block" id="ChartParser.chart_parse"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.chart.ChartParser.chart_parse">[docs]</a>    <span class="k">def</span> <span class="nf">chart_parse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tokens</span><span class="p">,</span> <span class="n">trace</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        @return: The final parse L{Chart}, </span>
<span class="sd">        from which all possible parse trees can be extracted.</span>
<span class="sd">        </span>
<span class="sd">        @param tokens: The sentence to be parsed</span>
<span class="sd">        @type tokens: L{list} of L{string}</span>
<span class="sd">        @rtype: L{Chart}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">trace</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span> <span class="n">trace</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_trace</span>
        <span class="n">trace_new_edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_trace_new_edges</span>
        
        <span class="n">tokens</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_grammar</span><span class="o">.</span><span class="n">check_coverage</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span>
        <span class="n">chart</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_chart_class</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span>
        <span class="n">grammar</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grammar</span>

        <span class="c"># Width, for printing trace edges.</span>
        <span class="n">trace_edge_width</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_trace_chart_width</span> <span class="o">/</span> <span class="p">(</span><span class="n">chart</span><span class="o">.</span><span class="n">num_leaves</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">trace</span><span class="p">:</span> <span class="k">print</span> <span class="n">chart</span><span class="o">.</span><span class="n">pp_leaves</span><span class="p">(</span><span class="n">trace_edge_width</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_use_agenda</span><span class="p">:</span>
            <span class="c"># Use an agenda-based algorithm.</span>
            <span class="k">for</span> <span class="n">axiom</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_axioms</span><span class="p">:</span>
                <span class="n">new_edges</span> <span class="o">=</span> <span class="n">axiom</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">chart</span><span class="p">,</span> <span class="n">grammar</span><span class="p">)</span>
                <span class="n">trace_new_edges</span><span class="p">(</span><span class="n">chart</span><span class="p">,</span> <span class="n">axiom</span><span class="p">,</span> <span class="n">new_edges</span><span class="p">,</span> <span class="n">trace</span><span class="p">,</span> <span class="n">trace_edge_width</span><span class="p">)</span>
            
            <span class="n">inference_rules</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inference_rules</span>
            <span class="n">agenda</span> <span class="o">=</span> <span class="n">chart</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
            <span class="c"># We reverse the initial agenda, since it is a stack</span>
            <span class="c"># but chart.edges() functions as a queue.</span>
            <span class="n">agenda</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
            <span class="k">while</span> <span class="n">agenda</span><span class="p">:</span>
                <span class="n">edge</span> <span class="o">=</span> <span class="n">agenda</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">rule</span> <span class="ow">in</span> <span class="n">inference_rules</span><span class="p">:</span>
                    <span class="n">new_edges</span> <span class="o">=</span> <span class="n">rule</span><span class="o">.</span><span class="n">apply_iter</span><span class="p">(</span><span class="n">chart</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span> <span class="n">edge</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">trace</span><span class="p">:</span>
                        <span class="n">new_edges</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">new_edges</span><span class="p">)</span>
                        <span class="n">trace_new_edges</span><span class="p">(</span><span class="n">chart</span><span class="p">,</span> <span class="n">rule</span><span class="p">,</span> <span class="n">new_edges</span><span class="p">,</span> <span class="n">trace</span><span class="p">,</span> <span class="n">trace_edge_width</span><span class="p">)</span>
                    <span class="n">agenda</span> <span class="o">+=</span> <span class="n">new_edges</span>
        
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># Do not use an agenda-based algorithm.</span>
            <span class="n">edges_added</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">while</span> <span class="n">edges_added</span><span class="p">:</span>
                <span class="n">edges_added</span> <span class="o">=</span> <span class="bp">False</span>
                <span class="k">for</span> <span class="n">rule</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strategy</span><span class="p">:</span>
                    <span class="n">new_edges</span> <span class="o">=</span> <span class="n">rule</span><span class="o">.</span><span class="n">apply_everywhere</span><span class="p">(</span><span class="n">chart</span><span class="p">,</span> <span class="n">grammar</span><span class="p">)</span>
                    <span class="n">edges_added</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_edges</span><span class="p">)</span>
                    <span class="n">trace_new_edges</span><span class="p">(</span><span class="n">chart</span><span class="p">,</span> <span class="n">rule</span><span class="p">,</span> <span class="n">new_edges</span><span class="p">,</span> <span class="n">trace</span><span class="p">,</span> <span class="n">trace_edge_width</span><span class="p">)</span>

        <span class="c"># Return the final chart.</span>
        <span class="k">return</span> <span class="n">chart</span>
</div>
<div class="viewcode-block" id="ChartParser.nbest_parse"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.chart.ChartParser.nbest_parse">[docs]</a>    <span class="k">def</span> <span class="nf">nbest_parse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tokens</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">tree_class</span><span class="o">=</span><span class="n">Tree</span><span class="p">):</span>
        <span class="n">chart</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chart_parse</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span>
        <span class="c"># Return a list of complete parses.</span>
        <span class="k">return</span> <span class="n">chart</span><span class="o">.</span><span class="n">parses</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_grammar</span><span class="o">.</span><span class="n">start</span><span class="p">(),</span> <span class="n">tree_class</span><span class="o">=</span><span class="n">tree_class</span><span class="p">)[:</span><span class="n">n</span><span class="p">]</span>
</div></div>
<div class="viewcode-block" id="TopDownChartParser"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.chart.TopDownChartParser">[docs]</a><span class="k">class</span> <span class="nc">TopDownChartParser</span><span class="p">(</span><span class="n">ChartParser</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A L{ChartParser} using a top-down parsing strategy.</span>
<span class="sd">    See L{ChartParser} for more information.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span> <span class="o">**</span><span class="n">parser_args</span><span class="p">):</span> 
        <span class="n">ChartParser</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span> <span class="n">TD_STRATEGY</span><span class="p">,</span> <span class="o">**</span><span class="n">parser_args</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="BottomUpChartParser"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.chart.BottomUpChartParser">[docs]</a><span class="k">class</span> <span class="nc">BottomUpChartParser</span><span class="p">(</span><span class="n">ChartParser</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A L{ChartParser} using a bottom-up parsing strategy.</span>
<span class="sd">    See L{ChartParser} for more information.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span> <span class="o">**</span><span class="n">parser_args</span><span class="p">):</span> 
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">grammar</span><span class="p">,</span> <span class="n">WeightedGrammar</span><span class="p">):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;BottomUpChartParser only works for ContextFreeGrammar, &quot;</span>
                          <span class="s">&quot;use BottomUpProbabilisticChartParser instead&quot;</span><span class="p">,</span> 
                          <span class="n">category</span><span class="o">=</span><span class="ne">DeprecationWarning</span><span class="p">)</span>
        <span class="n">ChartParser</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span> <span class="n">BU_STRATEGY</span><span class="p">,</span> <span class="o">**</span><span class="n">parser_args</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="BottomUpLeftCornerChartParser"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.chart.BottomUpLeftCornerChartParser">[docs]</a><span class="k">class</span> <span class="nc">BottomUpLeftCornerChartParser</span><span class="p">(</span><span class="n">ChartParser</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A L{ChartParser} using a bottom-up left-corner parsing strategy.</span>
<span class="sd">    This strategy is often more efficient than standard bottom-up.</span>
<span class="sd">    See L{ChartParser} for more information.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span> <span class="o">**</span><span class="n">parser_args</span><span class="p">):</span> 
        <span class="n">ChartParser</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span> <span class="n">BU_LC_STRATEGY</span><span class="p">,</span> <span class="o">**</span><span class="n">parser_args</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="LeftCornerChartParser"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.chart.LeftCornerChartParser">[docs]</a><span class="k">class</span> <span class="nc">LeftCornerChartParser</span><span class="p">(</span><span class="n">ChartParser</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span> <span class="o">**</span><span class="n">parser_args</span><span class="p">):</span> 
        <span class="k">if</span> <span class="ow">not</span> <span class="n">grammar</span><span class="o">.</span><span class="n">is_nonempty</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;LeftCornerParser only works for grammars &quot;</span>
                             <span class="s">&quot;without empty productions.&quot;</span><span class="p">)</span>
        <span class="n">ChartParser</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span> <span class="n">LC_STRATEGY</span><span class="p">,</span> <span class="o">**</span><span class="n">parser_args</span><span class="p">)</span>

<span class="c">########################################################################</span>
<span class="c">##  Stepping Chart Parser</span>
<span class="c">########################################################################</span>
</div>
<div class="viewcode-block" id="SteppingChartParser"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.chart.SteppingChartParser">[docs]</a><span class="k">class</span> <span class="nc">SteppingChartParser</span><span class="p">(</span><span class="n">ChartParser</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A C{ChartParser} that allows you to step through the parsing</span>
<span class="sd">    process, adding a single edge at a time.  It also allows you to</span>
<span class="sd">    change the parser&#39;s strategy or grammar midway through parsing a</span>
<span class="sd">    text.</span>

<span class="sd">    The C{initialize} method is used to start parsing a text.  C{step}</span>
<span class="sd">    adds a single edge to the chart.  C{set_strategy} changes the</span>
<span class="sd">    strategy used by the chart parser.  C{parses} returns the set of</span>
<span class="sd">    parses that has been found by the chart parser.</span>

<span class="sd">    @ivar _restart: Records whether the parser&#39;s strategy, grammar,</span>
<span class="sd">        or chart has been changed.  If so, then L{step} must restart</span>
<span class="sd">        the parsing algorithm.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span> <span class="n">strategy</span><span class="o">=</span><span class="p">[],</span> <span class="n">trace</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_chart</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_current_chartrule</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_restart</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="n">ChartParser</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span> <span class="n">strategy</span><span class="p">,</span> <span class="n">trace</span><span class="p">)</span>

    <span class="c">#////////////////////////////////////////////////////////////</span>
    <span class="c"># Initialization</span>
    <span class="c">#////////////////////////////////////////////////////////////</span>

<div class="viewcode-block" id="SteppingChartParser.initialize"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.chart.SteppingChartParser.initialize">[docs]</a>    <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tokens</span><span class="p">):</span>
        <span class="s">&quot;Begin parsing the given tokens.&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_chart</span> <span class="o">=</span> <span class="n">Chart</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">tokens</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_restart</span> <span class="o">=</span> <span class="bp">True</span>

    <span class="c">#////////////////////////////////////////////////////////////</span>
    <span class="c"># Stepping</span>
    <span class="c">#////////////////////////////////////////////////////////////</span>
</div>
<div class="viewcode-block" id="SteppingChartParser.step"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.chart.SteppingChartParser.step">[docs]</a>    <span class="k">def</span> <span class="nf">step</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        @return: A generator that adds edges to the chart, one at a</span>
<span class="sd">        time.  Each time the generator is resumed, it adds a single</span>
<span class="sd">        edge and yields that edge.  If no more edges can be added,</span>
<span class="sd">        then it yields C{None}.</span>

<span class="sd">        If the parser&#39;s strategy, grammar, or chart is changed, then</span>
<span class="sd">        the generator will continue adding edges using the new</span>
<span class="sd">        strategy, grammar, or chart.</span>

<span class="sd">        Note that this generator never terminates, since the grammar</span>
<span class="sd">        or strategy might be changed to values that would add new</span>
<span class="sd">        edges.  Instead, it yields C{None} when no more edges can be</span>
<span class="sd">        added with the current strategy and grammar.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_chart</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">,</span> <span class="s">&#39;Parser must be initialized first&#39;</span>
        <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_restart</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="n">w</span> <span class="o">=</span> <span class="mi">50</span><span class="o">/</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_chart</span><span class="o">.</span><span class="n">num_leaves</span><span class="p">()</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
            
            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse</span><span class="p">():</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_trace</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span> <span class="k">print</span> <span class="bp">self</span><span class="o">.</span><span class="n">_current_chartrule</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_trace</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> <span class="k">print</span> <span class="bp">self</span><span class="o">.</span><span class="n">_chart</span><span class="o">.</span><span class="n">pp_edge</span><span class="p">(</span><span class="n">e</span><span class="p">,</span><span class="n">w</span><span class="p">)</span>
                <span class="k">yield</span> <span class="n">e</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_restart</span><span class="p">:</span> <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">yield</span> <span class="bp">None</span> <span class="c"># No more edges.</span>
</div>
    <span class="k">def</span> <span class="nf">_parse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A generator that implements the actual parsing algorithm.</span>
<span class="sd">        L{step} iterates through this generator, and restarts it</span>
<span class="sd">        whenever the parser&#39;s strategy, grammar, or chart is modified.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">chart</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_chart</span>
        <span class="n">grammar</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grammar</span>
        <span class="n">edges_added</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">while</span> <span class="n">edges_added</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">edges_added</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">rule</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strategy</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_current_chartrule</span> <span class="o">=</span> <span class="n">rule</span>
                <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">rule</span><span class="o">.</span><span class="n">apply_everywhere_iter</span><span class="p">(</span><span class="n">chart</span><span class="p">,</span> <span class="n">grammar</span><span class="p">):</span>
                    <span class="n">edges_added</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">yield</span> <span class="n">e</span>

    <span class="c">#////////////////////////////////////////////////////////////</span>
    <span class="c"># Accessors</span>
    <span class="c">#////////////////////////////////////////////////////////////</span>

<div class="viewcode-block" id="SteppingChartParser.strategy"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.chart.SteppingChartParser.strategy">[docs]</a>    <span class="k">def</span> <span class="nf">strategy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s">&quot;@return: The strategy used by this parser.&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strategy</span>
</div>
<div class="viewcode-block" id="SteppingChartParser.grammar"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.chart.SteppingChartParser.grammar">[docs]</a>    <span class="k">def</span> <span class="nf">grammar</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s">&quot;@return: The grammar used by this parser.&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grammar</span>
</div>
<div class="viewcode-block" id="SteppingChartParser.chart"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.chart.SteppingChartParser.chart">[docs]</a>    <span class="k">def</span> <span class="nf">chart</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s">&quot;@return: The chart that is used by this parser.&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_chart</span>
</div>
<div class="viewcode-block" id="SteppingChartParser.current_chartrule"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.chart.SteppingChartParser.current_chartrule">[docs]</a>    <span class="k">def</span> <span class="nf">current_chartrule</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s">&quot;@return: The chart rule used to generate the most recent edge.&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_current_chartrule</span>
</div>
<div class="viewcode-block" id="SteppingChartParser.parses"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.chart.SteppingChartParser.parses">[docs]</a>    <span class="k">def</span> <span class="nf">parses</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree_class</span><span class="o">=</span><span class="n">Tree</span><span class="p">):</span>
        <span class="s">&quot;@return: The parse trees currently contained in the chart.&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_chart</span><span class="o">.</span><span class="n">parses</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_grammar</span><span class="o">.</span><span class="n">start</span><span class="p">(),</span> <span class="n">tree_class</span><span class="p">)</span>
    
    <span class="c">#////////////////////////////////////////////////////////////</span>
    <span class="c"># Parser modification</span>
    <span class="c">#////////////////////////////////////////////////////////////</span>
</div>
<div class="viewcode-block" id="SteppingChartParser.set_strategy"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.chart.SteppingChartParser.set_strategy">[docs]</a>    <span class="k">def</span> <span class="nf">set_strategy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">strategy</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Change the startegy that the parser uses to decide which edges</span>
<span class="sd">        to add to the chart.</span>
<span class="sd">        @type strategy: C{list} of L{ChartRuleI}</span>
<span class="sd">        @param strategy: A list of rules that should be used to decide</span>
<span class="sd">            what edges to add to the chart.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">strategy</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strategy</span><span class="p">:</span> <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_strategy</span> <span class="o">=</span> <span class="n">strategy</span><span class="p">[:]</span> <span class="c"># Make a copy.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_restart</span> <span class="o">=</span> <span class="bp">True</span>
</div>
<div class="viewcode-block" id="SteppingChartParser.set_grammar"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.chart.SteppingChartParser.set_grammar">[docs]</a>    <span class="k">def</span> <span class="nf">set_grammar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grammar</span><span class="p">):</span>
        <span class="s">&quot;Change the grammar used by the parser.&quot;</span>
        <span class="k">if</span> <span class="n">grammar</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grammar</span><span class="p">:</span> <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_grammar</span> <span class="o">=</span> <span class="n">grammar</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_restart</span> <span class="o">=</span> <span class="bp">True</span>
</div>
<div class="viewcode-block" id="SteppingChartParser.set_chart"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.chart.SteppingChartParser.set_chart">[docs]</a>    <span class="k">def</span> <span class="nf">set_chart</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chart</span><span class="p">):</span>
        <span class="s">&quot;Load a given chart into the chart parser.&quot;</span>
        <span class="k">if</span> <span class="n">chart</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">_chart</span><span class="p">:</span> <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_chart</span> <span class="o">=</span> <span class="n">chart</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_restart</span> <span class="o">=</span> <span class="bp">True</span>

    <span class="c">#////////////////////////////////////////////////////////////</span>
    <span class="c"># Standard parser methods</span>
    <span class="c">#////////////////////////////////////////////////////////////</span>
</div>
<div class="viewcode-block" id="SteppingChartParser.nbest_parse"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.chart.SteppingChartParser.nbest_parse">[docs]</a>    <span class="k">def</span> <span class="nf">nbest_parse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tokens</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">tree_class</span><span class="o">=</span><span class="n">Tree</span><span class="p">):</span>
        <span class="n">tokens</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_grammar</span><span class="o">.</span><span class="n">check_coverage</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span>
        
        <span class="c"># Initialize ourselves.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initialize</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span>

        <span class="c"># Step until no more edges are generated.</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">step</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">e</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span> <span class="k">break</span>
            
        <span class="c"># Return a list of complete parses.</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parses</span><span class="p">(</span><span class="n">tree_class</span><span class="o">=</span><span class="n">tree_class</span><span class="p">)[:</span><span class="n">n</span><span class="p">]</span>

<span class="c">########################################################################</span>
<span class="c">##  Demo Code</span>
<span class="c">########################################################################</span>
</div></div>
<div class="viewcode-block" id="demo_grammar"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.chart.demo_grammar">[docs]</a><span class="k">def</span> <span class="nf">demo_grammar</span><span class="p">():</span>
    <span class="kn">from</span> <span class="nn">nltk.grammar</span> <span class="kn">import</span> <span class="n">parse_cfg</span>
    <span class="k">return</span> <span class="n">parse_cfg</span><span class="p">(</span><span class="s">&quot;&quot;&quot;</span>
<span class="s">S  -&gt; NP VP</span>
<span class="s">PP -&gt; &quot;with&quot; NP</span>
<span class="s">NP -&gt; NP PP</span>
<span class="s">VP -&gt; VP PP</span>
<span class="s">VP -&gt; Verb NP</span>
<span class="s">VP -&gt; Verb</span>
<span class="s">NP -&gt; Det Noun</span>
<span class="s">NP -&gt; &quot;John&quot;</span>
<span class="s">NP -&gt; &quot;I&quot;</span>
<span class="s">Det -&gt; &quot;the&quot;</span>
<span class="s">Det -&gt; &quot;my&quot;</span>
<span class="s">Det -&gt; &quot;a&quot;</span>
<span class="s">Noun -&gt; &quot;dog&quot;</span>
<span class="s">Noun -&gt; &quot;cookie&quot;</span>
<span class="s">Verb -&gt; &quot;ate&quot;</span>
<span class="s">Verb -&gt; &quot;saw&quot;</span>
<span class="s">Prep -&gt; &quot;with&quot;</span>
<span class="s">Prep -&gt; &quot;under&quot;</span>
<span class="s">&quot;&quot;&quot;</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="demo"><a class="viewcode-back" href="../../../api/nltk.parse.html#nltk.parse.chart.demo">[docs]</a><span class="k">def</span> <span class="nf">demo</span><span class="p">(</span><span class="n">choice</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
         <span class="n">should_print_times</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">should_print_grammar</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
         <span class="n">should_print_trees</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">trace</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
         <span class="n">sent</span><span class="o">=</span><span class="s">&#39;I saw John with a dog with my cookie&#39;</span><span class="p">,</span> <span class="n">numparses</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A demonstration of the chart parsers.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">sys</span><span class="o">,</span> <span class="nn">time</span>
    <span class="kn">from</span> <span class="nn">nltk</span> <span class="kn">import</span> <span class="n">nonterminals</span><span class="p">,</span> <span class="n">Production</span><span class="p">,</span> <span class="n">ContextFreeGrammar</span>

    <span class="c"># The grammar for ChartParser and SteppingChartParser:</span>
    <span class="n">grammar</span> <span class="o">=</span> <span class="n">demo_grammar</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">should_print_grammar</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">&quot;* Grammar&quot;</span>
        <span class="k">print</span> <span class="n">grammar</span>

    <span class="c"># Tokenize the sample sentence.</span>
    <span class="k">print</span> <span class="s">&quot;* Sentence:&quot;</span> 
    <span class="k">print</span> <span class="n">sent</span>
    <span class="n">tokens</span> <span class="o">=</span> <span class="n">sent</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
    <span class="k">print</span> <span class="n">tokens</span>
    <span class="k">print</span>

    <span class="c"># Ask the user which parser to test,</span>
    <span class="c"># if the parser wasn&#39;t provided as an argument</span>
    <span class="k">if</span> <span class="n">choice</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">&#39;  1: Top-down chart parser&#39;</span>
        <span class="k">print</span> <span class="s">&#39;  2: Bottom-up chart parser&#39;</span>
        <span class="k">print</span> <span class="s">&#39;  3: Bottom-up left-corner chart parser&#39;</span>
        <span class="k">print</span> <span class="s">&#39;  4: Left-corner chart parser with bottom-up filter&#39;</span>
        <span class="k">print</span> <span class="s">&#39;  5: Stepping chart parser (alternating top-down &amp; bottom-up)&#39;</span>
        <span class="k">print</span> <span class="s">&#39;  6: All parsers&#39;</span>
        <span class="k">print</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">Which parser (1-6)? &#39;</span><span class="p">,</span>
        <span class="n">choice</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdin</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="k">print</span>

    <span class="n">choice</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">choice</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">choice</span> <span class="ow">not</span> <span class="ow">in</span> <span class="s">&quot;123456&quot;</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">&#39;Bad parser number&#39;</span>
        <span class="k">return</span>

    <span class="c"># Keep track of how long each parser takes.</span>
    <span class="n">times</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="n">strategies</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;1&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s">&#39;Top-down&#39;</span><span class="p">,</span> <span class="n">TD_STRATEGY</span><span class="p">),</span>
                  <span class="s">&#39;2&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s">&#39;Bottom-up&#39;</span><span class="p">,</span> <span class="n">BU_STRATEGY</span><span class="p">),</span>
                  <span class="s">&#39;3&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s">&#39;Bottom-up left-corner&#39;</span><span class="p">,</span> <span class="n">BU_LC_STRATEGY</span><span class="p">),</span>
                  <span class="s">&#39;4&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s">&#39;Filtered left-corner&#39;</span><span class="p">,</span> <span class="n">LC_STRATEGY</span><span class="p">)}</span>
    <span class="n">choices</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">strategies</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="n">choice</span><span class="p">):</span> <span class="n">choices</span> <span class="o">=</span> <span class="p">[</span><span class="n">choice</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">choice</span><span class="o">==</span><span class="s">&#39;6&#39;</span><span class="p">:</span> <span class="n">choices</span> <span class="o">=</span> <span class="s">&quot;1234&quot;</span>

    <span class="c"># Run the requested chart parser(s), except the stepping parser.</span>
    <span class="k">for</span> <span class="n">strategy</span> <span class="ow">in</span> <span class="n">choices</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">&quot;* Strategy: &quot;</span> <span class="o">+</span> <span class="n">strategies</span><span class="p">[</span><span class="n">strategy</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">print</span>
        <span class="n">cp</span> <span class="o">=</span> <span class="n">ChartParser</span><span class="p">(</span><span class="n">grammar</span><span class="p">,</span> <span class="n">strategies</span><span class="p">[</span><span class="n">strategy</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">trace</span><span class="o">=</span><span class="n">trace</span><span class="p">)</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">chart</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">chart_parse</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span>
        <span class="n">parses</span> <span class="o">=</span> <span class="n">chart</span><span class="o">.</span><span class="n">parses</span><span class="p">(</span><span class="n">grammar</span><span class="o">.</span><span class="n">start</span><span class="p">())</span>
        <span class="n">times</span><span class="p">[</span><span class="n">strategies</span><span class="p">[</span><span class="n">strategy</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">t</span>
        <span class="k">print</span> <span class="s">&quot;Nr edges in chart:&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">chart</span><span class="o">.</span><span class="n">edges</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">numparses</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">parses</span><span class="p">)</span><span class="o">==</span><span class="n">numparses</span><span class="p">,</span> <span class="s">&#39;Not all parses found&#39;</span>
        <span class="k">if</span> <span class="n">should_print_trees</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">tree</span> <span class="ow">in</span> <span class="n">parses</span><span class="p">:</span> <span class="k">print</span> <span class="n">tree</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;Nr trees:&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">parses</span><span class="p">)</span>
        <span class="k">print</span>

    <span class="c"># Run the stepping parser, if requested.</span>
    <span class="k">if</span> <span class="n">choice</span> <span class="ow">in</span> <span class="s">&quot;56&quot;</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">&quot;* Strategy: Stepping (top-down vs bottom-up)&quot;</span>
        <span class="k">print</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">cp</span> <span class="o">=</span> <span class="n">SteppingChartParser</span><span class="p">(</span><span class="n">grammar</span><span class="p">,</span> <span class="n">trace</span><span class="o">=</span><span class="n">trace</span><span class="p">)</span>
        <span class="n">cp</span><span class="o">.</span><span class="n">initialize</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
            <span class="k">print</span> <span class="s">&#39;*** SWITCH TO TOP DOWN&#39;</span>
            <span class="n">cp</span><span class="o">.</span><span class="n">set_strategy</span><span class="p">(</span><span class="n">TD_STRATEGY</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">step</span><span class="p">()):</span>
                <span class="k">if</span> <span class="n">j</span><span class="o">&gt;</span><span class="mi">20</span> <span class="ow">or</span> <span class="n">e</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span> <span class="k">break</span>
            <span class="k">print</span> <span class="s">&#39;*** SWITCH TO BOTTOM UP&#39;</span>
            <span class="n">cp</span><span class="o">.</span><span class="n">set_strategy</span><span class="p">(</span><span class="n">BU_STRATEGY</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">step</span><span class="p">()):</span>
                <span class="k">if</span> <span class="n">j</span><span class="o">&gt;</span><span class="mi">20</span> <span class="ow">or</span> <span class="n">e</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span> <span class="k">break</span>
        <span class="n">times</span><span class="p">[</span><span class="s">&#39;Stepping&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">t</span>
        <span class="k">print</span> <span class="s">&quot;Nr edges in chart:&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">chart</span><span class="p">()</span><span class="o">.</span><span class="n">edges</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">numparses</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">parses</span><span class="p">())</span><span class="o">==</span><span class="n">numparses</span><span class="p">,</span> <span class="s">&#39;Not all parses found&#39;</span>
        <span class="k">if</span> <span class="n">should_print_trees</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">tree</span> <span class="ow">in</span> <span class="n">cp</span><span class="o">.</span><span class="n">parses</span><span class="p">():</span> <span class="k">print</span> <span class="n">tree</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;Nr trees:&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">parses</span><span class="p">())</span>
        <span class="k">print</span>

    <span class="c"># Print the times of all parsers:</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">should_print_times</span> <span class="ow">and</span> <span class="n">times</span><span class="p">):</span> <span class="k">return</span>
    <span class="k">print</span> <span class="s">&quot;* Parsing times&quot;</span>
    <span class="k">print</span>
    <span class="n">maxlen</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">times</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="n">format</span> <span class="o">=</span> <span class="s">&#39;%&#39;</span> <span class="o">+</span> <span class="sb">`maxlen`</span> <span class="o">+</span> <span class="s">&#39;s parser: </span><span class="si">%6.3f</span><span class="s">sec&#39;</span>
    <span class="n">times_items</span> <span class="o">=</span> <span class="n">times</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
    <span class="n">times_items</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="k">lambda</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">:</span><span class="nb">cmp</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">parser</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="ow">in</span> <span class="n">times_items</span><span class="p">:</span>
        <span class="k">print</span> <span class="n">format</span> <span class="o">%</span> <span class="p">(</span><span class="n">parser</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
            </div>
<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span> <span class="n">demo</span><span class="p">()</span>
</pre></div>

          </div>
        </div>
      </div>
        </div>
        <div class="sidebar">
          <h3>Table Of Contents</h3>
          <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../news.html">NLTK News</a></li>
</ul>

          <h3 style="margin-top: 1.5em;">Search</h3>
          <form class="search" action="../../../search.html" method="get">
            <input type="text" name="q" />
            <input type="submit" value="Go" />
            <input type="hidden" name="check_keywords" value="yes" />
            <input type="hidden" name="area" value="default" />
          </form>
          <p class="searchtip" style="font-size: 90%">
            Enter search terms or a module, class or function name.
          </p>
        </div>
        <div class="clearer"></div>
      </div>
    </div>

    <div class="footer-wrapper">
      <div class="footer">
        <div class="left">
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |
          <a href="../../../genindex.html" title="General Index"
             >index</a>
        </div>

        <div class="right">
          
    <div class="footer">
        &copy; Copyright 2011, Steven Bird.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.
    </div>
        </div>
        <div class="clearer"></div>
      </div>
    </div>

  </body>
</html>