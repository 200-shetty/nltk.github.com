<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.12: http://docutils.sourceforge.net/" />
<title>Feature Structures &amp; Unification</title>
<style type="text/css">

/*
:Author: David Goodger (goodger@python.org)
:Id: $Id: html4css1.css 7614 2013-02-21 15:55:51Z milde $
:Copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.

See http://docutils.sf.net/docs/howto/html-stylesheets.html for how to
customize this style sheet.
*/

/* used to remove borders from tables and images */
.borderless, table.borderless td, table.borderless th {
  border: 0 }

table.borderless td, table.borderless th {
  /* Override padding for "table.docutils td" with "! important".
     The right padding separates the table cells. */
  padding: 0 0.5em 0 0 ! important }

.first {
  /* Override more specific margin styles with "! important". */
  margin-top: 0 ! important }

.last, .with-subtitle {
  margin-bottom: 0 ! important }

.hidden {
  display: none }

a.toc-backref {
  text-decoration: none ;
  color: black }

blockquote.epigraph {
  margin: 2em 5em ; }

dl.docutils dd {
  margin-bottom: 0.5em }

object[type="image/svg+xml"], object[type="application/x-shockwave-flash"] {
  overflow: hidden;
}

/* Uncomment (and remove this text!) to get bold-faced definition list terms
dl.docutils dt {
  font-weight: bold }
*/

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.admonition, div.attention, div.caution, div.danger, div.error,
div.hint, div.important, div.note, div.tip, div.warning {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.admonition p.admonition-title, div.hint p.admonition-title,
div.important p.admonition-title, div.note p.admonition-title,
div.tip p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title, .code .error {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

/* Uncomment (and remove this text!) to get reduced vertical space in
   compound paragraphs.
div.compound .compound-first, div.compound .compound-middle {
  margin-bottom: 0.5em }

div.compound .compound-last, div.compound .compound-middle {
  margin-top: 0.5em }
*/

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em ;
  margin-right: 2em }

div.footer, div.header {
  clear: both;
  font-size: smaller }

div.line-block {
  display: block ;
  margin-top: 1em ;
  margin-bottom: 1em }

div.line-block div.line-block {
  margin-top: 0 ;
  margin-bottom: 0 ;
  margin-left: 1.5em }

div.sidebar {
  margin: 0 0 0.5em 1em ;
  border: medium outset ;
  padding: 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.section-subtitle, h2.section-subtitle, h3.section-subtitle,
h4.section-subtitle, h5.section-subtitle, h6.section-subtitle {
  margin-top: 0.4em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

hr.docutils {
  width: 75% }

img.align-left, .figure.align-left, object.align-left {
  clear: left ;
  float: left ;
  margin-right: 1em }

img.align-right, .figure.align-right, object.align-right {
  clear: right ;
  float: right ;
  margin-left: 1em }

img.align-center, .figure.align-center, object.align-center {
  display: block;
  margin-left: auto;
  margin-right: auto;
}

.align-left {
  text-align: left }

.align-center {
  clear: both ;
  text-align: center }

.align-right {
  text-align: right }

/* reset inner alignment in figures */
div.align-right {
  text-align: inherit }

/* div.align-center * { */
/*   text-align: left } */

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font: inherit }

pre.literal-block, pre.doctest-block, pre.math, pre.code {
  margin-left: 2em ;
  margin-right: 2em }

pre.code .ln { color: grey; } /* line numbers */
pre.code, code { background-color: #eeeeee }
pre.code .comment, code .comment { color: #5C6576 }
pre.code .keyword, code .keyword { color: #3B0D06; font-weight: bold }
pre.code .literal.string, code .literal.string { color: #0C5404 }
pre.code .name.builtin, code .name.builtin { color: #352B84 }
pre.code .deleted, code .deleted { background-color: #DEB0A1}
pre.code .inserted, code .inserted { background-color: #A3D289}

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

span.section-subtitle {
  /* font-size relative to parent (h1..h6 element) */
  font-size: 80% }

table.citation {
  border-left: solid 1px gray;
  margin-left: 1px }

table.docinfo {
  margin: 2em 4em }

table.docutils {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.footnote {
  border-left: solid 1px black;
  margin-left: 1px }

table.docutils td, table.docutils th,
table.docinfo td, table.docinfo th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

table.docutils th.field-name, table.docinfo th.docinfo-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap ;
  padding-left: 0 }

/* "booktabs" style (no vertical lines) */
table.docutils.booktabs {
  border: 0px;
  border-top: 2px solid;
  border-bottom: 2px solid;
  border-collapse: collapse;
}
table.docutils.booktabs * {
  border: 0px;
}
table.docutils.booktabs th {
  border-bottom: thin solid;
  text-align: left;
}

h1 tt.docutils, h2 tt.docutils, h3 tt.docutils,
h4 tt.docutils, h5 tt.docutils, h6 tt.docutils {
  font-size: 100% }

ul.auto-toc {
  list-style-type: none }

</style>
</head>
<body>
<div class="document" id="feature-structures-unification">
<h1 class="title">Feature Structures &amp; Unification</h1>

<!-- Copyright (C) 2001-2015 NLTK Project -->
<!-- For license information, see LICENSE.TXT -->
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from __future__ import print_function
&gt;&gt;&gt; from nltk.featstruct import FeatStruct
&gt;&gt;&gt; from nltk.sem.logic import Variable, VariableExpression, Expression
</pre>
</blockquote>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last">For now, featstruct uses the older lambdalogic semantics
module.  Eventually, it should be updated to use the new first
order predicate logic module.</p>
</div>
<div class="section" id="overview">
<h1>Overview</h1>
<p>A feature structure is a mapping from feature identifiers to feature
values, where feature values can be simple values (like strings or
ints), nested feature structures, or variables:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; fs1 = FeatStruct(number='singular', person=3)
&gt;&gt;&gt; print(fs1)
[ number = 'singular' ]
[ person = 3          ]
</pre>
</blockquote>
<p>Feature structure may be nested:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; fs2 = FeatStruct(type='NP', agr=fs1)
&gt;&gt;&gt; print(fs2)
[ agr  = [ number = 'singular' ] ]
[        [ person = 3          ] ]
[                                ]
[ type = 'NP'                    ]
</pre>
</blockquote>
<p>Variables are used to indicate that two features should be assigned
the same value.  For example, the following feature structure requires
that the feature fs3['agr']['number'] be bound to the same value as the
feature fs3['subj']['number'].</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; fs3 = FeatStruct(agr=FeatStruct(number=Variable('?n')),
...                  subj=FeatStruct(number=Variable('?n')))
&gt;&gt;&gt; print(fs3)
[ agr  = [ number = ?n ] ]
[                        ]
[ subj = [ number = ?n ] ]
</pre>
</blockquote>
<p>Feature structures are typically used to represent partial information
about objects.  A feature name that is not mapped to a value stands
for a feature whose value is unknown (<em>not</em> a feature without a
value).  Two feature structures that represent (potentially
overlapping) information about the same object can be combined by
<em>unification</em>.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; print(fs2.unify(fs3))
[ agr  = [ number = 'singular' ] ]
[        [ person = 3          ] ]
[                                ]
[ subj = [ number = 'singular' ] ]
[                                ]
[ type = 'NP'                    ]
</pre>
</blockquote>
<p>When two inconsistent feature structures are unified, the unification
fails and returns <tt class="docutils literal">None</tt>.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; fs4 = FeatStruct(agr=FeatStruct(person=1))
&gt;&gt;&gt; print(fs4.unify(fs2))
None
&gt;&gt;&gt; print(fs2.unify(fs4))
None
</pre>
</blockquote>
<!-- >>> del fs1, fs2, fs3, fs4 # clean-up -->
<div class="section" id="feature-structure-types">
<h2>Feature Structure Types</h2>
<p>There are actually two types of feature structure:</p>
<ul class="simple">
<li><em>feature dictionaries</em>, implemented by <cite>FeatDict</cite>, act like
Python dictionaries.  Feature identifiers may be strings or
instances of the <cite>Feature</cite> class.</li>
<li><em>feature lists</em>, implemented by <cite>FeatList</cite>, act like Python
lists.  Feature identifiers are integers.</li>
</ul>
<p>When you construct a feature structure using the <cite>FeatStruct</cite>
constructor, it will automatically decide which type is appropriate:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; type(FeatStruct(number='singular'))
&lt;class 'nltk.featstruct.FeatDict'&gt;
&gt;&gt;&gt; type(FeatStruct([1,2,3]))
&lt;class 'nltk.featstruct.FeatList'&gt;
</pre>
</blockquote>
<p>Usually, we will just use feature dictionaries; but sometimes feature
lists can be useful too.  Two feature lists will unify with each other
only if they have equal lengths, and all of their feature values
match.  If you wish to write a feature list that contains 'unknown'
values, you must use variables:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; fs1 = FeatStruct([1,2,Variable('?y')])
&gt;&gt;&gt; fs2 = FeatStruct([1,Variable('?x'),3])
&gt;&gt;&gt; fs1.unify(fs2)
[1, 2, 3]
</pre>
</blockquote>
<!-- >>> del fs1, fs2 # clean-up -->
</div>
<div class="section" id="parsing-feature-structure-strings">
<h2>Parsing Feature Structure Strings</h2>
<p>Feature structures can be constructed directly from strings.  Often,
this is more convenient than constructing them directly.  NLTK can
parse most feature strings to produce the corresponding feature
structures.  (But you must restrict your base feature values to
strings, ints, logic expressions (<cite>nltk.sem.logic.Expression</cite>), and a
few other types discussed below).</p>
<p>Feature dictionaries are written like Python dictionaries, except that
keys are not put in quotes; and square brackets (<tt class="docutils literal">[]</tt>) are used
instead of braces (<tt class="docutils literal">{}</tt>):</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; FeatStruct('[tense=&quot;past&quot;, agr=[number=&quot;sing&quot;, person=3]]')
[agr=[number='sing', person=3], tense='past']
</pre>
</blockquote>
<p>If a feature value is a single alphanumeric word, then it does not
need to be quoted -- it will be automatically treated as a string:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; FeatStruct('[tense=past, agr=[number=sing, person=3]]')
[agr=[number='sing', person=3], tense='past']
</pre>
</blockquote>
<p>Feature lists are written like python lists:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; FeatStruct('[1, 2, 3]')
[1, 2, 3]
</pre>
</blockquote>
<p>The expression <tt class="docutils literal">[]</tt> is treated as an empty feature dictionary, not
an empty feature list:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; type(FeatStruct('[]'))
&lt;class 'nltk.featstruct.FeatDict'&gt;
</pre>
</blockquote>
</div>
<div class="section" id="feature-paths">
<h2>Feature Paths</h2>
<p>Features can be specified using <em>feature paths</em>, or tuples of feature
identifiers that specify path through the nested feature structures to
a value.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; fs1 = FeatStruct('[x=1, y=[1,2,[z=3]]]')
&gt;&gt;&gt; fs1['y']
[1, 2, [z=3]]
&gt;&gt;&gt; fs1['y', 2]
[z=3]
&gt;&gt;&gt; fs1['y', 2, 'z']
3
</pre>
</blockquote>
<!-- >>> del fs1 # clean-up -->
</div>
<div class="section" id="reentrance">
<h2>Reentrance</h2>
<p>Feature structures may contain reentrant feature values.  A <em>reentrant
feature value</em> is a single feature structure that can be accessed via
multiple feature paths.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; fs1 = FeatStruct(x='val')
&gt;&gt;&gt; fs2 = FeatStruct(a=fs1, b=fs1)
&gt;&gt;&gt; print(fs2)
[ a = (1) [ x = 'val' ] ]
[                       ]
[ b -&gt; (1)              ]
&gt;&gt;&gt; fs2
[a=(1)[x='val'], b-&gt;(1)]
</pre>
</blockquote>
<p>As you can see, reentrane is displayed by marking a feature structure
with a unique identifier, in this case <tt class="docutils literal">(1)</tt>, the first time it is
encountered; and then using the special form <tt class="docutils literal">var <span class="pre">-&gt;</span> id</tt> whenever it
is encountered again.  You can use the same notation to directly
create reentrant feature structures from strings.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; FeatStruct('[a=(1)[], b-&gt;(1), c=[d-&gt;(1)]]')
[a=(1)[], b-&gt;(1), c=[d-&gt;(1)]]
</pre>
</blockquote>
<p>Reentrant feature structures may contain cycles:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; fs3 = FeatStruct('(1)[a-&gt;(1)]')
&gt;&gt;&gt; fs3['a', 'a', 'a', 'a']
(1)[a-&gt;(1)]
&gt;&gt;&gt; fs3['a', 'a', 'a', 'a'] is fs3
True
</pre>
</blockquote>
<p>Unification preserves the reentrance relations imposed by both of the
unified feature structures.  In the feature structure resulting from
unification, any modifications to a reentrant feature value will be
visible using any of its feature paths.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; fs3.unify(FeatStruct('[a=[b=12], c=33]'))
(1)[a-&gt;(1), b=12, c=33]
</pre>
</blockquote>
<!-- >>> del fs1, fs2, fs3 # clean-up -->
</div>
<div class="section" id="feature-structure-equality">
<h2>Feature Structure Equality</h2>
<p>Two feature structures are considered equal if they assign the same
values to all features, <em>and</em> they contain the same reentrances.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; fs1 = FeatStruct('[a=(1)[x=1], b-&gt;(1)]')
&gt;&gt;&gt; fs2 = FeatStruct('[a=(1)[x=1], b-&gt;(1)]')
&gt;&gt;&gt; fs3 = FeatStruct('[a=[x=1], b=[x=1]]')
&gt;&gt;&gt; fs1 == fs1, fs1 is fs1
(True, True)
&gt;&gt;&gt; fs1 == fs2, fs1 is fs2
(True, False)
&gt;&gt;&gt; fs1 == fs3, fs1 is fs3
(False, False)
</pre>
</blockquote>
<p>Note that this differs from how Python dictionaries and lists define
equality -- in particular, Python dictionaries and lists ignore
reentrance relations.  To test two feature structures for equality
while ignoring reentrance relations, use the <cite>equal_values()</cite> method:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; fs1.equal_values(fs1)
True
&gt;&gt;&gt; fs1.equal_values(fs2)
True
&gt;&gt;&gt; fs1.equal_values(fs3)
True
</pre>
</blockquote>
<!-- >>> del fs1, fs2, fs3 # clean-up -->
</div>
<div class="section" id="feature-value-sets-feature-value-tuples">
<h2>Feature Value Sets &amp; Feature Value Tuples</h2>
<p><cite>nltk.featstruct</cite> defines two new data types that are intended to be
used as feature values: <cite>FeatureValueTuple</cite> and <cite>FeatureValueSet</cite>.
Both of these types are considered base values -- i.e., unification
does <em>not</em> apply to them.  However, variable binding <em>does</em> apply to
any values that they contain.</p>
<p>Feature value tuples are written with parentheses:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; fs1 = FeatStruct('[x=(?x, ?y)]')
&gt;&gt;&gt; fs1
[x=(?x, ?y)]
&gt;&gt;&gt; fs1.substitute_bindings({Variable('?x'): 1, Variable('?y'): 2})
[x=(1, 2)]
</pre>
</blockquote>
<p>Feature sets are written with braces:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; fs1 = FeatStruct('[x={?x, ?y}]')
&gt;&gt;&gt; fs1
[x={?x, ?y}]
&gt;&gt;&gt; fs1.substitute_bindings({Variable('?x'): 1, Variable('?y'): 2})
[x={1, 2}]
</pre>
</blockquote>
<p>In addition to the basic feature value tuple &amp; set classes, nltk
defines feature value unions (for sets) and feature value
concatenations (for tuples).  These are written using '+', and can be
used to combine sets &amp; tuples:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; fs1 = FeatStruct('[x=((1, 2)+?z), z=?z]')
&gt;&gt;&gt; fs1
[x=((1, 2)+?z), z=?z]
&gt;&gt;&gt; fs1.unify(FeatStruct('[z=(3, 4, 5)]'))
[x=(1, 2, 3, 4, 5), z=(3, 4, 5)]
</pre>
</blockquote>
<p>Thus, feature value tuples and sets can be used to build up tuples
and sets of values over the corse of unification.  For example, when
parsing sentences using a semantic feature grammar, feature sets or
feature tuples can be used to build a list of semantic predicates as
the sentence is parsed.</p>
<p>As was mentioned above, unification does not apply to feature value
tuples and sets.  One reason for this that it's impossible to define a
single correct answer for unification when concatenation is used.
Consider the following example:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; fs1 = FeatStruct('[x=(1, 2, 3, 4)]')
&gt;&gt;&gt; fs2 = FeatStruct('[x=(?a+?b), a=?a, b=?b]')
</pre>
</blockquote>
<p>If unification applied to feature tuples, then the unification
algorithm would have to arbitrarily choose how to divide the tuple
(1,2,3,4) into two parts.  Instead, the unification algorithm refuses
to make this decision, and simply unifies based on value.  Because
(1,2,3,4) is not equal to (?a+?b), fs1 and fs2 will not unify:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; print(fs1.unify(fs2))
None
</pre>
</blockquote>
<p>If you need a list-like structure that unification does apply to, use
<cite>FeatList</cite>.</p>
<!-- >>> del fs1, fs2 # clean-up -->
</div>
<div class="section" id="light-weight-feature-structures">
<h2>Light-weight Feature Structures</h2>
<p>Many of the functions defined by <cite>nltk.featstruct</cite> can be applied
directly to simple Python dictionaries and lists, rather than to
full-fledged <cite>FeatDict</cite> and <cite>FeatList</cite> objects.  In other words,
Python <tt class="docutils literal">dicts</tt> and <tt class="docutils literal">lists</tt> can be used as &quot;light-weight&quot; feature
structures.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; # Note: pprint prints dicts sorted
&gt;&gt;&gt; from pprint import pprint
&gt;&gt;&gt; from nltk.featstruct import unify
&gt;&gt;&gt; pprint(unify(dict(x=1, y=dict()), dict(a='a', y=dict(b='b'))))
{'a': 'a', 'x': 1, 'y': {'b': 'b'}}
</pre>
</blockquote>
<p>However, you should keep in mind the following caveats:</p>
<ul class="simple">
<li>Python dictionaries &amp; lists ignore reentrance when checking for
equality between values.  But two FeatStructs with different
reentrances are considered nonequal, even if all their base
values are equal.</li>
<li>FeatStructs can be easily frozen, allowing them to be used as
keys in hash tables.  Python dictionaries and lists can not.</li>
<li>FeatStructs display reentrance in their string representations;
Python dictionaries and lists do not.</li>
<li>FeatStructs may <em>not</em> be mixed with Python dictionaries and lists
(e.g., when performing unification).</li>
<li>FeatStructs provide a number of useful methods, such as <cite>walk()</cite>
and <cite>cyclic()</cite>, which are not available for Python dicts &amp; lists.</li>
</ul>
<p>In general, if your feature structures will contain any reentrances,
or if you plan to use them as dictionary keys, it is strongly
recommended that you use full-fledged <cite>FeatStruct</cite> objects.</p>
</div>
<div class="section" id="custom-feature-values">
<h2>Custom Feature Values</h2>
<p>The abstract base class <cite>CustomFeatureValue</cite> can be used to define new
base value types that have custom unification methods.  For example,
the following feature value type encodes a range, and defines
unification as taking the intersection on the ranges:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from nltk.compat import total_ordering
&gt;&gt;&gt; from nltk.featstruct import CustomFeatureValue, UnificationFailure
&gt;&gt;&gt; &#64;total_ordering
... class Range(CustomFeatureValue):
...     def __init__(self, low, high):
...         assert low &lt;= high
...         self.low = low
...         self.high = high
...     def unify(self, other):
...         if not isinstance(other, Range):
...             return UnificationFailure
...         low = max(self.low, other.low)
...         high = min(self.high, other.high)
...         if low &lt;= high: return Range(low, high)
...         else: return UnificationFailure
...     def __repr__(self):
...         return '(%s&lt;x&lt;%s)' % (self.low, self.high)
...     def __eq__(self, other):
...         if not isinstance(other, Range):
...             return False
...         return (self.low == other.low) and (self.high == other.high)
...     def __lt__(self, other):
...         if not isinstance(other, Range):
...             return True
...         return (self.low, self.high) &lt; (other.low, other.high)
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; fs1 = FeatStruct(x=Range(5,8), y=FeatStruct(z=Range(7,22)))
&gt;&gt;&gt; print(fs1.unify(FeatStruct(x=Range(6, 22))))
[ x = (6&lt;x&lt;8)          ]
[                      ]
[ y = [ z = (7&lt;x&lt;22) ] ]
&gt;&gt;&gt; print(fs1.unify(FeatStruct(x=Range(9, 12))))
None
&gt;&gt;&gt; print(fs1.unify(FeatStruct(x=12)))
None
&gt;&gt;&gt; print(fs1.unify(FeatStruct('[x=?x, y=[z=?x]]')))
[ x = (7&lt;x&lt;8)         ]
[                     ]
[ y = [ z = (7&lt;x&lt;8) ] ]
</pre>
</blockquote>
</div>
</div>
<div class="section" id="regression-tests">
<h1>Regression Tests</h1>
<div class="section" id="dictionary-access-methods-non-mutating">
<h2>Dictionary access methods (non-mutating)</h2>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; fs1 = FeatStruct(a=1, b=2, c=3)
&gt;&gt;&gt; fs2 = FeatStruct(x=fs1, y='x')
</pre>
</blockquote>
<p>Feature structures support all dictionary methods (excluding the class
method <cite>dict.fromkeys()</cite>).  Non-mutating methods:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; sorted(fs2.keys())                               # keys()
['x', 'y']
&gt;&gt;&gt; sorted(fs2.values())                             # values()
[[a=1, b=2, c=3], 'x']
&gt;&gt;&gt; sorted(fs2.items())                              # items()
[('x', [a=1, b=2, c=3]), ('y', 'x')]
&gt;&gt;&gt; sorted(fs2)                                      # __iter__()
['x', 'y']
&gt;&gt;&gt; 'a' in fs2, 'x' in fs2                           # __contains__()
(False, True)
&gt;&gt;&gt; fs2.has_key('a'), fs2.has_key('x')               # has_key()
(False, True)
&gt;&gt;&gt; fs2['x'], fs2['y']                               # __getitem__()
([a=1, b=2, c=3], 'x')
&gt;&gt;&gt; fs2['a']                                         # __getitem__()
Traceback (most recent call last):
  . . .
KeyError: 'a'
&gt;&gt;&gt; fs2.get('x'), fs2.get('y'), fs2.get('a')         # get()
([a=1, b=2, c=3], 'x', None)
&gt;&gt;&gt; fs2.get('x', 'hello'), fs2.get('a', 'hello')     # get()
([a=1, b=2, c=3], 'hello')
&gt;&gt;&gt; len(fs1), len(fs2)                               # __len__
(3, 2)
&gt;&gt;&gt; fs2.copy()                                       # copy()
[x=[a=1, b=2, c=3], y='x']
&gt;&gt;&gt; fs2.copy() is fs2                                # copy()
False
</pre>
</blockquote>
<p>Note: by default, <cite>FeatStruct.copy()</cite> does a deep copy.  Use
<cite>FeatStruct.copy(deep=False)</cite> for a shallow copy.</p>
<!-- >>> del fs1, fs2 # clean-up. -->
</div>
<div class="section" id="dictionary-access-methods-mutating">
<h2>Dictionary access methods (mutating)</h2>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; fs1 = FeatStruct(a=1, b=2, c=3)
&gt;&gt;&gt; fs2 = FeatStruct(x=fs1, y='x')
</pre>
</blockquote>
<p>Setting features (<cite>__setitem__()</cite>)</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; fs1['c'] = 5
&gt;&gt;&gt; fs1
[a=1, b=2, c=5]
&gt;&gt;&gt; fs1['x'] = 12
&gt;&gt;&gt; fs1
[a=1, b=2, c=5, x=12]
&gt;&gt;&gt; fs2['x', 'a'] = 2
&gt;&gt;&gt; fs2
[x=[a=2, b=2, c=5, x=12], y='x']
&gt;&gt;&gt; fs1
[a=2, b=2, c=5, x=12]
</pre>
</blockquote>
<p>Deleting features (<cite>__delitem__()</cite>)</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; del fs1['x']
&gt;&gt;&gt; fs1
[a=2, b=2, c=5]
&gt;&gt;&gt; del fs2['x', 'a']
&gt;&gt;&gt; fs1
[b=2, c=5]
</pre>
</blockquote>
<p><cite>setdefault()</cite>:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; fs1.setdefault('b', 99)
2
&gt;&gt;&gt; fs1
[b=2, c=5]
&gt;&gt;&gt; fs1.setdefault('x', 99)
99
&gt;&gt;&gt; fs1
[b=2, c=5, x=99]
</pre>
</blockquote>
<p><cite>update()</cite>:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; fs2.update({'a':'A', 'b':'B'}, c='C')
&gt;&gt;&gt; fs2
[a='A', b='B', c='C', x=[b=2, c=5, x=99], y='x']
</pre>
</blockquote>
<p><cite>pop()</cite>:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; fs2.pop('a')
'A'
&gt;&gt;&gt; fs2
[b='B', c='C', x=[b=2, c=5, x=99], y='x']
&gt;&gt;&gt; fs2.pop('a')
Traceback (most recent call last):
  . . .
KeyError: 'a'
&gt;&gt;&gt; fs2.pop('a', 'foo')
'foo'
&gt;&gt;&gt; fs2
[b='B', c='C', x=[b=2, c=5, x=99], y='x']
</pre>
</blockquote>
<p><cite>clear()</cite>:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; fs1.clear()
&gt;&gt;&gt; fs1
[]
&gt;&gt;&gt; fs2
[b='B', c='C', x=[], y='x']
</pre>
</blockquote>
<p><cite>popitem()</cite>:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; sorted([fs2.popitem() for i in range(len(fs2))])
[('b', 'B'), ('c', 'C'), ('x', []), ('y', 'x')]
&gt;&gt;&gt; fs2
[]
</pre>
</blockquote>
<p>Once a feature structure has been frozen, it may not be mutated.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; fs1 = FeatStruct('[x=1, y=2, z=[a=3]]')
&gt;&gt;&gt; fs1.freeze()
&gt;&gt;&gt; fs1.frozen()
True
&gt;&gt;&gt; fs1['z'].frozen()
True
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; fs1['x'] = 5
Traceback (most recent call last):
  . . .
ValueError: Frozen FeatStructs may not be modified.
&gt;&gt;&gt; del fs1['x']
Traceback (most recent call last):
  . . .
ValueError: Frozen FeatStructs may not be modified.
&gt;&gt;&gt; fs1.clear()
Traceback (most recent call last):
  . . .
ValueError: Frozen FeatStructs may not be modified.
&gt;&gt;&gt; fs1.pop('x')
Traceback (most recent call last):
  . . .
ValueError: Frozen FeatStructs may not be modified.
&gt;&gt;&gt; fs1.popitem()
Traceback (most recent call last):
  . . .
ValueError: Frozen FeatStructs may not be modified.
&gt;&gt;&gt; fs1.setdefault('x')
Traceback (most recent call last):
  . . .
ValueError: Frozen FeatStructs may not be modified.
&gt;&gt;&gt; fs1.update(z=22)
Traceback (most recent call last):
  . . .
ValueError: Frozen FeatStructs may not be modified.
</pre>
</blockquote>
<!-- >>> del fs1, fs2 # clean-up. -->
</div>
<div class="section" id="id1">
<h2>Feature Paths</h2>
<p>Make sure that __getitem__ with feature paths works as intended:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; fs1 = FeatStruct(a=1, b=2,
...                 c=FeatStruct(
...                     d=FeatStruct(e=12),
...                     f=FeatStruct(g=55, h='hello')))
&gt;&gt;&gt; fs1[()]
[a=1, b=2, c=[d=[e=12], f=[g=55, h='hello']]]
&gt;&gt;&gt; fs1['a'], fs1[('a',)]
(1, 1)
&gt;&gt;&gt; fs1['c','d','e']
12
&gt;&gt;&gt; fs1['c','f','g']
55
</pre>
</blockquote>
<p>Feature paths that select unknown features raise KeyError:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; fs1['c', 'f', 'e']
Traceback (most recent call last):
  . . .
KeyError: ('c', 'f', 'e')
&gt;&gt;&gt; fs1['q', 'p']
Traceback (most recent call last):
  . . .
KeyError: ('q', 'p')
</pre>
</blockquote>
<p>Feature paths that try to go 'through' a feature that's not a feature
structure raise KeyError:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; fs1['a', 'b']
Traceback (most recent call last):
  . . .
KeyError: ('a', 'b')
</pre>
</blockquote>
<p>Feature paths can go through reentrant structures:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; fs2 = FeatStruct('(1)[a=[b=[c-&gt;(1), d=5], e=11]]')
&gt;&gt;&gt; fs2['a', 'b', 'c', 'a', 'e']
11
&gt;&gt;&gt; fs2['a', 'b', 'c', 'a', 'b', 'd']
5
&gt;&gt;&gt; fs2[tuple('abcabcabcabcabcabcabcabcabcabca')]
(1)[b=[c=[a-&gt;(1)], d=5], e=11]
</pre>
</blockquote>
<p>Indexing requires strings, <cite>Feature</cite>s, or tuples; other types raise a
TypeError:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; fs2[12]
Traceback (most recent call last):
  . . .
TypeError: Expected feature name or path.  Got 12.
&gt;&gt;&gt; fs2[list('abc')]
Traceback (most recent call last):
  . . .
TypeError: Expected feature name or path.  Got ['a', 'b', 'c'].
</pre>
</blockquote>
<p>Feature paths can also be used with <cite>get()</cite>, <cite>has_key()</cite>, and
<cite>__contains__()</cite>.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; fpath1 = tuple('abcabc')
&gt;&gt;&gt; fpath2 = tuple('abcabz')
&gt;&gt;&gt; fs2.get(fpath1), fs2.get(fpath2)
((1)[a=[b=[c-&gt;(1), d=5], e=11]], None)
&gt;&gt;&gt; fpath1 in fs2, fpath2 in fs2
(True, False)
&gt;&gt;&gt; fs2.has_key(fpath1), fs2.has_key(fpath2)
(True, False)
</pre>
</blockquote>
<!-- >>> del fs1, fs2 # clean-up -->
</div>
<div class="section" id="reading-feature-structures">
<h2>Reading Feature Structures</h2>
<p>Empty feature struct:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; FeatStruct('[]')
[]
</pre>
</blockquote>
<p>Test features with integer values:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; FeatStruct('[a=12, b=-33, c=0]')
[a=12, b=-33, c=0]
</pre>
</blockquote>
<p>Test features with string values.  Either single or double quotes may
be used.  Strings are evaluated just like python strings -- in
particular, you can use escape sequences and 'u' and 'r' prefixes, and
triple-quoted strings.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; FeatStruct('[a=&quot;&quot;, b=&quot;hello&quot;, c=&quot;\'&quot;, d=\'\', e=\'&quot;\']')
[a='', b='hello', c=&quot;'&quot;, d='', e='&quot;']
&gt;&gt;&gt; FeatStruct(r'[a=&quot;\\&quot;, b=&quot;\&quot;&quot;, c=&quot;\x6f\\y&quot;, d=&quot;12&quot;]')
[a='\\', b='&quot;', c='o\\y', d='12']
&gt;&gt;&gt; FeatStruct(r'[b=r&quot;a\b\c&quot;]')
[b='a\\b\\c']
&gt;&gt;&gt; FeatStruct('[x=&quot;&quot;&quot;a&quot;&quot;&quot;]')
[x='a']
</pre>
</blockquote>
<p>Test parsing of reentrant feature structures.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; FeatStruct('[a=(1)[], b-&gt;(1)]')
[a=(1)[], b-&gt;(1)]
&gt;&gt;&gt; FeatStruct('[a=(1)[x=1, y=2], b-&gt;(1)]')
[a=(1)[x=1, y=2], b-&gt;(1)]
</pre>
</blockquote>
<p>Test parsing of cyclic feature structures.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; FeatStruct('[a=(1)[b-&gt;(1)]]')
[a=(1)[b-&gt;(1)]]
&gt;&gt;&gt; FeatStruct('(1)[a=[b=[c-&gt;(1)]]]')
(1)[a=[b=[c-&gt;(1)]]]
</pre>
</blockquote>
<p>Strings of the form &quot;+name&quot; and &quot;-name&quot; may be used to specify boolean
values.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; FeatStruct('[-bar, +baz, +foo]')
[-bar, +baz, +foo]
</pre>
</blockquote>
<p>None, True, and False are recognized as values:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; FeatStruct('[bar=True, baz=False, foo=None]')
[+bar, -baz, foo=None]
</pre>
</blockquote>
<p>Special features:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; FeatStruct('NP/VP')
NP[]/VP[]
&gt;&gt;&gt; FeatStruct('?x/?x')
?x[]/?x[]
&gt;&gt;&gt; print(FeatStruct('VP[+fin, agr=?x, tense=past]/NP[+pl, agr=?x]'))
[ *type*  = 'VP'              ]
[                             ]
[           [ *type* = 'NP' ] ]
[ *slash* = [ agr    = ?x   ] ]
[           [ pl     = True ] ]
[                             ]
[ agr     = ?x                ]
[ fin     = True              ]
[ tense   = 'past'            ]
</pre>
</blockquote>
<dl class="docutils">
<dt>Here the slash feature gets coerced:</dt>
<dd><pre class="first doctest-block">
&gt;&gt;&gt; FeatStruct('[*slash*=a, x=b, *type*=&quot;NP&quot;]')
NP[x='b']/a[]
</pre>
<pre class="last doctest-block">
&gt;&gt;&gt; FeatStruct('NP[sem=&lt;bob&gt;]/NP')
NP[sem=&lt;bob&gt;]/NP[]
&gt;&gt;&gt; FeatStruct('S[sem=&lt;walk(bob)&gt;]')
S[sem=&lt;walk(bob)&gt;]
&gt;&gt;&gt; print(FeatStruct('NP[sem=&lt;bob&gt;]/NP'))
[ *type*  = 'NP'              ]
[                             ]
[ *slash* = [ *type* = 'NP' ] ]
[                             ]
[ sem     = &lt;bob&gt;             ]
</pre>
</dd>
</dl>
<p>Playing with ranges:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from nltk.featstruct import RangeFeature, FeatStructReader
&gt;&gt;&gt; width = RangeFeature('width')
&gt;&gt;&gt; reader = FeatStructReader([width])
&gt;&gt;&gt; fs1 = reader.fromstring('[*width*=-5:12]')
&gt;&gt;&gt; fs2 = reader.fromstring('[*width*=2:123]')
&gt;&gt;&gt; fs3 = reader.fromstring('[*width*=-7:-2]')
&gt;&gt;&gt; fs1.unify(fs2)
[*width*=(2, 12)]
&gt;&gt;&gt; fs1.unify(fs3)
[*width*=(-5, -2)]
&gt;&gt;&gt; print(fs2.unify(fs3)) # no overlap in width.
None
</pre>
</blockquote>
<p>The slash feature has a default value of 'False':</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; print(FeatStruct('NP[]/VP').unify(FeatStruct('NP[]'), trace=1))
&lt;BLANKLINE&gt;
Unification trace:
   / NP[]/VP[]
  |\ NP[]
  |
  | Unify feature: *type*
  |    / 'NP'
  |   |\ 'NP'
  |   |
  |   +--&gt;'NP'
  |
  | Unify feature: *slash*
  |    / VP[]
  |   |\ False
  |   |
  X   X &lt;-- FAIL
None
</pre>
</blockquote>
<p>The demo structures from category.py.  They all parse, but they don't
do quite the right thing, -- ?x vs x.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; FeatStruct(pos='n', agr=FeatStruct(number='pl', gender='f'))
[agr=[gender='f', number='pl'], pos='n']
&gt;&gt;&gt; FeatStruct(r'NP[sem=&lt;bob&gt;]/NP')
NP[sem=&lt;bob&gt;]/NP[]
&gt;&gt;&gt; FeatStruct(r'S[sem=&lt;app(?x, ?y)&gt;]')
S[sem=&lt;?x(?y)&gt;]
&gt;&gt;&gt; FeatStruct('?x/?x')
?x[]/?x[]
&gt;&gt;&gt; FeatStruct('VP[+fin, agr=?x, tense=past]/NP[+pl, agr=?x]')
VP[agr=?x, +fin, tense='past']/NP[agr=?x, +pl]
&gt;&gt;&gt; FeatStruct('S[sem = &lt;app(?subj, ?vp)&gt;]')
S[sem=&lt;?subj(?vp)&gt;]
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; FeatStruct('S')
S[]
</pre>
</blockquote>
<p>The parser also includes support for reading sets and tuples.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; FeatStruct('[x={1,2,2,2}, y={/}]')
[x={1, 2}, y={/}]
&gt;&gt;&gt; FeatStruct('[x=(1,2,2,2), y=()]')
[x=(1, 2, 2, 2), y=()]
&gt;&gt;&gt; print(FeatStruct('[x=(1,[z=(1,2,?x)],?z,{/})]'))
[ x = (1, [ z = (1, 2, ?x) ], ?z, {/}) ]
</pre>
</blockquote>
<p>Note that we can't put a featstruct inside a tuple, because doing so
would hash it, and it's not frozen yet:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; print(FeatStruct('[x={[]}]'))
Traceback (most recent call last):
  . . .
TypeError: FeatStructs must be frozen before they can be hashed.
</pre>
</blockquote>
<p>There's a special syntax for taking the union of sets: &quot;{...+...}&quot;.
The elements should only be variables or sets.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; FeatStruct('[x={?a+?b+{1,2,3}}]')
[x={?a+?b+{1, 2, 3}}]
</pre>
</blockquote>
<p>There's a special syntax for taking the concatenation of tuples:
&quot;(...+...)&quot;.  The elements should only be variables or tuples.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; FeatStruct('[x=(?a+?b+(1,2,3))]')
[x=(?a+?b+(1, 2, 3))]
</pre>
</blockquote>
<p>Parsing gives helpful messages if your string contains an error.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; FeatStruct('[a=, b=5]]')
Traceback (most recent call last):
  . . .
ValueError: Error parsing feature structure
    [a=, b=5]]
       ^ Expected value
&gt;&gt;&gt; FeatStruct('[a=12 22, b=33]')
Traceback (most recent call last):
  . . .
ValueError: Error parsing feature structure
    [a=12 22, b=33]
         ^ Expected comma
&gt;&gt;&gt; FeatStruct('[a=5] [b=6]')
Traceback (most recent call last):
  . . .
ValueError: Error parsing feature structure
    [a=5] [b=6]
          ^ Expected end of string
&gt;&gt;&gt; FeatStruct(' *++*')
Traceback (most recent call last):
  . . .
ValueError: Error parsing feature structure
    *++*
    ^ Expected open bracket or identifier
&gt;&gt;&gt; FeatStruct('[x-&gt;(1)]')
Traceback (most recent call last):
  . . .
ValueError: Error parsing feature structure
    [x-&gt;(1)]
        ^ Expected bound identifier
&gt;&gt;&gt; FeatStruct('[x-&gt;y]')
Traceback (most recent call last):
  . . .
ValueError: Error parsing feature structure
    [x-&gt;y]
        ^ Expected identifier
&gt;&gt;&gt; FeatStruct('')
Traceback (most recent call last):
  . . .
ValueError: Error parsing feature structure
&lt;BLANKLINE&gt;
    ^ Expected open bracket or identifier
</pre>
</blockquote>
</div>
<div class="section" id="unification">
<h2>Unification</h2>
<p>Very simple unifications give the expected results:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; FeatStruct().unify(FeatStruct())
[]
&gt;&gt;&gt; FeatStruct(number='singular').unify(FeatStruct())
[number='singular']
&gt;&gt;&gt; FeatStruct().unify(FeatStruct(number='singular'))
[number='singular']
&gt;&gt;&gt; FeatStruct(number='singular').unify(FeatStruct(person=3))
[number='singular', person=3]
</pre>
</blockquote>
<p>Merging nested structures:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; fs1 = FeatStruct('[A=[B=b]]')
&gt;&gt;&gt; fs2 = FeatStruct('[A=[C=c]]')
&gt;&gt;&gt; fs1.unify(fs2)
[A=[B='b', C='c']]
&gt;&gt;&gt; fs2.unify(fs1)
[A=[B='b', C='c']]
</pre>
</blockquote>
<p>A basic case of reentrant unification</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; fs4 = FeatStruct('[A=(1)[B=b], E=[F-&gt;(1)]]')
&gt;&gt;&gt; fs5 = FeatStruct(&quot;[A=[C='c'], E=[F=[D='d']]]&quot;)
&gt;&gt;&gt; fs4.unify(fs5)
[A=(1)[B='b', C='c', D='d'], E=[F-&gt;(1)]]
&gt;&gt;&gt; fs5.unify(fs4)
[A=(1)[B='b', C='c', D='d'], E=[F-&gt;(1)]]
</pre>
</blockquote>
<p>More than 2 paths to a value</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; fs1 = FeatStruct(&quot;[a=[],b=[],c=[],d=[]]&quot;)
&gt;&gt;&gt; fs2 = FeatStruct('[a=(1)[], b-&gt;(1), c-&gt;(1), d-&gt;(1)]')
&gt;&gt;&gt; fs1.unify(fs2)
[a=(1)[], b-&gt;(1), c-&gt;(1), d-&gt;(1)]
</pre>
</blockquote>
<p>fs1[a] gets unified with itself</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; fs1 = FeatStruct('[x=(1)[], y-&gt;(1)]')
&gt;&gt;&gt; fs2 = FeatStruct('[x=(1)[], y-&gt;(1)]')
&gt;&gt;&gt; fs1.unify(fs2)
[x=(1)[], y-&gt;(1)]
</pre>
</blockquote>
<p>Bound variables should get forwarded appropriately</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; fs1 = FeatStruct('[A=(1)[X=x], B-&gt;(1), C=?cvar, D=?dvar]')
&gt;&gt;&gt; fs2 = FeatStruct('[A=(1)[Y=y], B=(2)[Z=z], C-&gt;(1), D-&gt;(2)]')
&gt;&gt;&gt; fs1.unify(fs2)
[A=(1)[X='x', Y='y', Z='z'], B-&gt;(1), C-&gt;(1), D-&gt;(1)]
&gt;&gt;&gt; fs2.unify(fs1)
[A=(1)[X='x', Y='y', Z='z'], B-&gt;(1), C-&gt;(1), D-&gt;(1)]
</pre>
</blockquote>
<p>Cyclic structure created by unification.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; fs1 = FeatStruct('[F=(1)[], G-&gt;(1)]')
&gt;&gt;&gt; fs2 = FeatStruct('[F=[H=(2)[]], G-&gt;(2)]')
&gt;&gt;&gt; fs3 = fs1.unify(fs2)
&gt;&gt;&gt; fs3
[F=(1)[H-&gt;(1)], G-&gt;(1)]
&gt;&gt;&gt; fs3['F'] is fs3['G']
True
&gt;&gt;&gt; fs3['F'] is fs3['G']['H']
True
&gt;&gt;&gt; fs3['F'] is fs3['G']['H']['H']
True
&gt;&gt;&gt; fs3['F'] is fs3['F']['H']['H']['H']['H']['H']['H']['H']['H']
True
</pre>
</blockquote>
<p>Cyclic structure created w/ variables.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; fs1 = FeatStruct('[F=[H=?x]]')
&gt;&gt;&gt; fs2 = FeatStruct('[F=?x]')
&gt;&gt;&gt; fs3 = fs1.unify(fs2, rename_vars=False)
&gt;&gt;&gt; fs3
[F=(1)[H-&gt;(1)]]
&gt;&gt;&gt; fs3['F'] is fs3['F']['H']
True
&gt;&gt;&gt; fs3['F'] is fs3['F']['H']['H']
True
&gt;&gt;&gt; fs3['F'] is fs3['F']['H']['H']['H']['H']['H']['H']['H']['H']
True
</pre>
</blockquote>
<p>Unifying w/ a cyclic feature structure.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; fs4 = FeatStruct('[F=[H=[H=[H=(1)[]]]], K-&gt;(1)]')
&gt;&gt;&gt; fs3.unify(fs4)
[F=(1)[H-&gt;(1)], K-&gt;(1)]
&gt;&gt;&gt; fs4.unify(fs3)
[F=(1)[H-&gt;(1)], K-&gt;(1)]
</pre>
</blockquote>
<p>Variable bindings should preserve reentrance.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; bindings = {}
&gt;&gt;&gt; fs1 = FeatStruct(&quot;[a=?x]&quot;)
&gt;&gt;&gt; fs2 = fs1.unify(FeatStruct(&quot;[a=[]]&quot;), bindings)
&gt;&gt;&gt; fs2['a'] is bindings[Variable('?x')]
True
&gt;&gt;&gt; fs2.unify(FeatStruct(&quot;[b=?x]&quot;), bindings)
[a=(1)[], b-&gt;(1)]
</pre>
</blockquote>
<p>Aliased variable tests</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; fs1 = FeatStruct(&quot;[a=?x, b=?x]&quot;)
&gt;&gt;&gt; fs2 = FeatStruct(&quot;[b=?y, c=?y]&quot;)
&gt;&gt;&gt; bindings = {}
&gt;&gt;&gt; fs3 = fs1.unify(fs2, bindings)
&gt;&gt;&gt; fs3
[a=?x, b=?x, c=?x]
&gt;&gt;&gt; bindings
{Variable('?y'): Variable('?x')}
&gt;&gt;&gt; fs3.unify(FeatStruct(&quot;[a=1]&quot;))
[a=1, b=1, c=1]
</pre>
</blockquote>
<p>If we keep track of the bindings, then we can use the same variable
over multiple calls to unify.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; bindings = {}
&gt;&gt;&gt; fs1 = FeatStruct('[a=?x]')
&gt;&gt;&gt; fs2 = fs1.unify(FeatStruct('[a=[]]'), bindings)
&gt;&gt;&gt; fs2.unify(FeatStruct('[b=?x]'), bindings)
[a=(1)[], b-&gt;(1)]
&gt;&gt;&gt; bindings
{Variable('?x'): []}
</pre>
</blockquote>
<!-- >>> del fs1, fs2, fs3, fs4, fs5 # clean-up -->
</div>
<div class="section" id="unification-bindings">
<h2>Unification Bindings</h2>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; bindings = {}
&gt;&gt;&gt; fs1 = FeatStruct('[a=?x]')
&gt;&gt;&gt; fs2 = FeatStruct('[a=12]')
&gt;&gt;&gt; fs3 = FeatStruct('[b=?x]')
&gt;&gt;&gt; fs1.unify(fs2, bindings)
[a=12]
&gt;&gt;&gt; bindings
{Variable('?x'): 12}
&gt;&gt;&gt; fs3.substitute_bindings(bindings)
[b=12]
&gt;&gt;&gt; fs3 # substitute_bindings didn't mutate fs3.
[b=?x]
&gt;&gt;&gt; fs2.unify(fs3, bindings)
[a=12, b=12]
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; bindings = {}
&gt;&gt;&gt; fs1 = FeatStruct('[a=?x, b=1]')
&gt;&gt;&gt; fs2 = FeatStruct('[a=5, b=?x]')
&gt;&gt;&gt; fs1.unify(fs2, bindings)
[a=5, b=1]
&gt;&gt;&gt; sorted(bindings.items())
[(Variable('?x'), 5), (Variable('?x2'), 1)]
</pre>
</blockquote>
<!-- >>> del fs1, fs2, fs3 # clean-up -->
</div>
<div class="section" id="expressions">
<h2>Expressions</h2>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; e = Expression.fromstring('\\P y.P(z,y)')
&gt;&gt;&gt; fs1 = FeatStruct(x=e, y=Variable('z'))
&gt;&gt;&gt; fs2 = FeatStruct(y=VariableExpression(Variable('John')))
&gt;&gt;&gt; fs1.unify(fs2)
[x=&lt;\P y.P(John,y)&gt;, y=&lt;John&gt;]
</pre>
</blockquote>
</div>
<div class="section" id="remove-variables">
<h2>Remove Variables</h2>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; FeatStruct('[a=?x, b=12, c=[d=?y]]').remove_variables()
[b=12, c=[]]
&gt;&gt;&gt; FeatStruct('(1)[a=[b=?x,c-&gt;(1)]]').remove_variables()
(1)[a=[c-&gt;(1)]]
</pre>
</blockquote>
</div>
<div class="section" id="equality-hashing">
<h2>Equality &amp; Hashing</h2>
<p>The <cite>equal_values</cite> method checks whether two feature structures assign
the same value to every feature.  If the optional argument
<tt class="docutils literal">check_reentrances</tt> is supplied, then it also returns false if there
is any difference in the reentrances.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; a = FeatStruct('(1)[x-&gt;(1)]')
&gt;&gt;&gt; b = FeatStruct('(1)[x-&gt;(1)]')
&gt;&gt;&gt; c = FeatStruct('(1)[x=[x-&gt;(1)]]')
&gt;&gt;&gt; d = FeatStruct('[x=(1)[x-&gt;(1)]]')
&gt;&gt;&gt; e = FeatStruct('(1)[x=[x-&gt;(1), y=1], y=1]')
&gt;&gt;&gt; def compare(x,y):
...     assert x.equal_values(y, True) == y.equal_values(x, True)
...     assert x.equal_values(y, False) == y.equal_values(x, False)
...     if x.equal_values(y, True):
...         assert x.equal_values(y, False)
...         print('equal values, same reentrance')
...     elif x.equal_values(y, False):
...         print('equal values, different reentrance')
...     else:
...         print('different values')
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; compare(a, a)
equal values, same reentrance
&gt;&gt;&gt; compare(a, b)
equal values, same reentrance
&gt;&gt;&gt; compare(a, c)
equal values, different reentrance
&gt;&gt;&gt; compare(a, d)
equal values, different reentrance
&gt;&gt;&gt; compare(c, d)
equal values, different reentrance
&gt;&gt;&gt; compare(a, e)
different values
&gt;&gt;&gt; compare(c, e)
different values
&gt;&gt;&gt; compare(d, e)
different values
&gt;&gt;&gt; compare(e, e)
equal values, same reentrance
</pre>
</blockquote>
<p>Feature structures may not be hashed until they are frozen:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; hash(a)
Traceback (most recent call last):
  . . .
TypeError: FeatStructs must be frozen before they can be hashed.
&gt;&gt;&gt; a.freeze()
&gt;&gt;&gt; v = hash(a)
</pre>
</blockquote>
<p>Feature structures define hash consistently.  The following example
looks at the hash value for each (fs1,fs2) pair; if their hash values
are not equal, then they must not be equal.  If their hash values are
equal, then display a message, and indicate whether their values are
indeed equal.  Note that c and d currently have the same hash value,
even though they are not equal.  That is not a bug, strictly speaking,
but it wouldn't be a bad thing if it changed.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; for fstruct in (a, b, c, d, e):
...     fstruct.freeze()
&gt;&gt;&gt; for fs1_name in 'abcde':
...     for fs2_name in 'abcde':
...         fs1 = locals()[fs1_name]
...         fs2 = locals()[fs2_name]
...         if hash(fs1) != hash(fs2):
...             assert fs1 != fs2
...         else:
...             print('%s and %s have the same hash value,' %
...                    (fs1_name, fs2_name))
...             if fs1 == fs2: print('and are equal')
...             else: print('and are not equal')
a and a have the same hash value, and are equal
a and b have the same hash value, and are equal
b and a have the same hash value, and are equal
b and b have the same hash value, and are equal
c and c have the same hash value, and are equal
c and d have the same hash value, and are not equal
d and c have the same hash value, and are not equal
d and d have the same hash value, and are equal
e and e have the same hash value, and are equal
</pre>
</blockquote>
<!-- >>> del a, b, c, d, e, v # clean-up -->
</div>
<div class="section" id="tracing">
<h2>Tracing</h2>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; fs1 = FeatStruct('[a=[b=(1)[], c=?x], d-&gt;(1), e=[f=?x]]')
&gt;&gt;&gt; fs2 = FeatStruct('[a=(1)[c=&quot;C&quot;], e=[g-&gt;(1)]]')
&gt;&gt;&gt; fs1.unify(fs2, trace=True)
&lt;BLANKLINE&gt;
Unification trace:
   / [a=[b=(1)[], c=?x], d-&gt;(1), e=[f=?x]]
  |\ [a=(1)[c='C'], e=[g-&gt;(1)]]
  |
  | Unify feature: a
  |    / [b=[], c=?x]
  |   |\ [c='C']
  |   |
  |   | Unify feature: a.c
  |   |    / ?x
  |   |   |\ 'C'
  |   |   |
  |   |   +--&gt;Variable('?x')
  |   |
  |   +--&gt;[b=[], c=?x]
  |       Bindings: {?x: 'C'}
  |
  | Unify feature: e
  |    / [f=?x]
  |   |\ [g=[c='C']]
  |   |
  |   +--&gt;[f=?x, g=[b=[], c=?x]]
  |       Bindings: {?x: 'C'}
  |
  +--&gt;[a=(1)[b=(2)[], c='C'], d-&gt;(2), e=[f='C', g-&gt;(1)]]
      Bindings: {?x: 'C'}
[a=(1)[b=(2)[], c='C'], d-&gt;(2), e=[f='C', g-&gt;(1)]]
&gt;&gt;&gt;
&gt;&gt;&gt; fs1 = FeatStruct('[a=?x, b=?z, c=?z]')
&gt;&gt;&gt; fs2 = FeatStruct('[a=?y, b=?y, c=?q]')
&gt;&gt;&gt; #fs1.unify(fs2, trace=True)
&gt;&gt;&gt;
</pre>
</blockquote>
<!-- >>> del fs1, fs2 # clean-up -->
</div>
<div class="section" id="unification-on-dicts-lists">
<h2>Unification on Dicts &amp; Lists</h2>
<p>It's possible to do unification on dictionaries:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from nltk.featstruct import unify
&gt;&gt;&gt; pprint(unify(dict(x=1, y=dict(z=2)), dict(x=1, q=5)), width=1)
{'q': 5, 'x': 1, 'y': {'z': 2}}
</pre>
</blockquote>
<p>It's possible to do unification on lists as well:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; unify([1, 2, 3], [1, Variable('x'), 3])
[1, 2, 3]
</pre>
</blockquote>
<p>Mixing dicts and lists is fine:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; pprint(unify([dict(x=1, y=dict(z=2)),3], [dict(x=1, q=5),3]),
...               width=1)
[{'q': 5, 'x': 1, 'y': {'z': 2}}, 3]
</pre>
</blockquote>
<p>Mixing dicts and FeatStructs is discouraged:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; unify(dict(x=1), FeatStruct(x=1))
Traceback (most recent call last):
  . . .
ValueError: Mixing FeatStruct objects with Python dicts and lists is not supported.
</pre>
</blockquote>
<p>But you can do it if you really want, by explicitly stating that both
dictionaries and FeatStructs should be treated as feature structures:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; unify(dict(x=1), FeatStruct(x=1), fs_class=(dict, FeatStruct))
{'x': 1}
</pre>
</blockquote>
</div>
<div class="section" id="finding-conflicts">
<h2>Finding Conflicts</h2>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from nltk.featstruct import conflicts
&gt;&gt;&gt; fs1 = FeatStruct('[a=[b=(1)[c=2], d-&gt;(1), e=[f-&gt;(1)]]]')
&gt;&gt;&gt; fs2 = FeatStruct('[a=[b=[c=[x=5]], d=[c=2], e=[f=[c=3]]]]')
&gt;&gt;&gt; for path in conflicts(fs1, fs2):
...     print('%-8s: %r vs %r' % ('.'.join(path), fs1[path], fs2[path]))
a.b.c   : 2 vs [x=5]
a.e.f.c : 2 vs 3
</pre>
</blockquote>
<!-- >>> del fs1, fs2 # clean-up -->
</div>
<div class="section" id="retracting-bindings">
<h2>Retracting Bindings</h2>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from nltk.featstruct import retract_bindings
&gt;&gt;&gt; bindings = {}
&gt;&gt;&gt; fs1 = FeatStruct('[a=?x, b=[c=?y]]')
&gt;&gt;&gt; fs2 = FeatStruct('[a=(1)[c=[d=1]], b-&gt;(1)]')
&gt;&gt;&gt; fs3 = fs1.unify(fs2, bindings)
&gt;&gt;&gt; print(fs3)
[ a = (1) [ c = [ d = 1 ] ] ]
[                           ]
[ b -&gt; (1)                  ]
&gt;&gt;&gt; pprint(bindings)
{Variable('?x'): [c=[d=1]], Variable('?y'): [d=1]}
&gt;&gt;&gt; retract_bindings(fs3, bindings)
[a=?x, b=?x]
&gt;&gt;&gt; pprint(bindings)
{Variable('?x'): [c=?y], Variable('?y'): [d=1]}
</pre>
</blockquote>
</div>
</div>
<div class="section" id="squashed-bugs">
<h1>Squashed Bugs</h1>
<p>In svn rev 5167, unifying two feature structures that used the same
variable would cause those variables to become aliased in the output.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; fs1 = FeatStruct('[a=?x]')
&gt;&gt;&gt; fs2 = FeatStruct('[b=?x]')
&gt;&gt;&gt; fs1.unify(fs2)
[a=?x, b=?x2]
</pre>
</blockquote>
<p>There was a bug in svn revision 5172 that caused <cite>rename_variables</cite> to
rename variables to names that are already used.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; FeatStruct('[a=?x, b=?x2]').rename_variables(
...     vars=[Variable('?x')])
[a=?x3, b=?x2]
&gt;&gt;&gt; fs1 = FeatStruct('[a=?x]')
&gt;&gt;&gt; fs2 = FeatStruct('[a=?x, b=?x2]')
&gt;&gt;&gt; fs1.unify(fs2)
[a=?x, b=?x2]
</pre>
</blockquote>
<p>There was a bug in svn rev 5167 that caused us to get the following
example wrong.  Basically the problem was that we only followed
'forward' pointers for other, not self, when unifying two feature
structures.  (nb: this test assumes that features are unified in
alphabetical order -- if they are not, it might pass even if the bug
is present.)</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; fs1 = FeatStruct('[a=[x=1], b=?x, c=?x]')
&gt;&gt;&gt; fs2 = FeatStruct('[a=(1)[], b-&gt;(1), c=[x=2]]')
&gt;&gt;&gt; print(fs1.unify(fs2))
None
</pre>
</blockquote>
<!-- >>> del fs1, fs2 # clean-up -->
</div>
</div>
</body>
</html>
