<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.11: http://docutils.sourceforge.net/" />
<title>Logical Inference and Model Building</title>
<style type="text/css">

/*
:Author: David Goodger (goodger@python.org)
:Id: $Id: html4css1.css 7614 2013-02-21 15:55:51Z milde $
:Copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.

See http://docutils.sf.net/docs/howto/html-stylesheets.html for how to
customize this style sheet.
*/

/* used to remove borders from tables and images */
.borderless, table.borderless td, table.borderless th {
  border: 0 }

table.borderless td, table.borderless th {
  /* Override padding for "table.docutils td" with "! important".
     The right padding separates the table cells. */
  padding: 0 0.5em 0 0 ! important }

.first {
  /* Override more specific margin styles with "! important". */
  margin-top: 0 ! important }

.last, .with-subtitle {
  margin-bottom: 0 ! important }

.hidden {
  display: none }

a.toc-backref {
  text-decoration: none ;
  color: black }

blockquote.epigraph {
  margin: 2em 5em ; }

dl.docutils dd {
  margin-bottom: 0.5em }

object[type="image/svg+xml"], object[type="application/x-shockwave-flash"] {
  overflow: hidden;
}

/* Uncomment (and remove this text!) to get bold-faced definition list terms
dl.docutils dt {
  font-weight: bold }
*/

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.admonition, div.attention, div.caution, div.danger, div.error,
div.hint, div.important, div.note, div.tip, div.warning {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.admonition p.admonition-title, div.hint p.admonition-title,
div.important p.admonition-title, div.note p.admonition-title,
div.tip p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title, .code .error {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

/* Uncomment (and remove this text!) to get reduced vertical space in
   compound paragraphs.
div.compound .compound-first, div.compound .compound-middle {
  margin-bottom: 0.5em }

div.compound .compound-last, div.compound .compound-middle {
  margin-top: 0.5em }
*/

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em ;
  margin-right: 2em }

div.footer, div.header {
  clear: both;
  font-size: smaller }

div.line-block {
  display: block ;
  margin-top: 1em ;
  margin-bottom: 1em }

div.line-block div.line-block {
  margin-top: 0 ;
  margin-bottom: 0 ;
  margin-left: 1.5em }

div.sidebar {
  margin: 0 0 0.5em 1em ;
  border: medium outset ;
  padding: 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.section-subtitle, h2.section-subtitle, h3.section-subtitle,
h4.section-subtitle, h5.section-subtitle, h6.section-subtitle {
  margin-top: 0.4em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

hr.docutils {
  width: 75% }

img.align-left, .figure.align-left, object.align-left {
  clear: left ;
  float: left ;
  margin-right: 1em }

img.align-right, .figure.align-right, object.align-right {
  clear: right ;
  float: right ;
  margin-left: 1em }

img.align-center, .figure.align-center, object.align-center {
  display: block;
  margin-left: auto;
  margin-right: auto;
}

.align-left {
  text-align: left }

.align-center {
  clear: both ;
  text-align: center }

.align-right {
  text-align: right }

/* reset inner alignment in figures */
div.align-right {
  text-align: inherit }

/* div.align-center * { */
/*   text-align: left } */

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font: inherit }

pre.literal-block, pre.doctest-block, pre.math, pre.code {
  margin-left: 2em ;
  margin-right: 2em }

pre.code .ln { color: grey; } /* line numbers */
pre.code, code { background-color: #eeeeee }
pre.code .comment, code .comment { color: #5C6576 }
pre.code .keyword, code .keyword { color: #3B0D06; font-weight: bold }
pre.code .literal.string, code .literal.string { color: #0C5404 }
pre.code .name.builtin, code .name.builtin { color: #352B84 }
pre.code .deleted, code .deleted { background-color: #DEB0A1}
pre.code .inserted, code .inserted { background-color: #A3D289}

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

span.section-subtitle {
  /* font-size relative to parent (h1..h6 element) */
  font-size: 80% }

table.citation {
  border-left: solid 1px gray;
  margin-left: 1px }

table.docinfo {
  margin: 2em 4em }

table.docutils {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.footnote {
  border-left: solid 1px black;
  margin-left: 1px }

table.docutils td, table.docutils th,
table.docinfo td, table.docinfo th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

table.docutils th.field-name, table.docinfo th.docinfo-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap ;
  padding-left: 0 }

/* "booktabs" style (no vertical lines) */
table.docutils.booktabs {
  border: 0px;
  border-top: 2px solid;
  border-bottom: 2px solid;
  border-collapse: collapse;
}
table.docutils.booktabs * {
  border: 0px;
}
table.docutils.booktabs th {
  border-bottom: thin solid;
  text-align: left;
}

h1 tt.docutils, h2 tt.docutils, h3 tt.docutils,
h4 tt.docutils, h5 tt.docutils, h6 tt.docutils {
  font-size: 100% }

ul.auto-toc {
  list-style-type: none }

</style>
</head>
<body>
<div class="document" id="logical-inference-and-model-building">
<h1 class="title">Logical Inference and Model Building</h1>

<!-- Copyright (C) 2001-2013 NLTK Project -->
<!-- For license information, see LICENSE.TXT -->
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from nltk import *
&gt;&gt;&gt; from nltk.sem.drt import DrtParser
&gt;&gt;&gt; from nltk.sem import logic
&gt;&gt;&gt; logic._counter._value = 0
</pre>
</blockquote>
<div class="section" id="introduction">
<h1>Introduction</h1>
<p>Within the area of automated reasoning, first order theorem proving
and model building (or model generation) have both received much
attention, and have given rise to highly sophisticated techniques. We
focus therefore on providing an NLTK interface to third party tools
for these tasks.  In particular, the module <tt class="docutils literal">nltk.inference</tt> can be
used to access both theorem provers and model builders.</p>
</div>
<div class="section" id="nltk-interface-to-theorem-provers">
<h1>NLTK Interface to Theorem Provers</h1>
<p>The main class used to interface with a theorem prover is the <tt class="docutils literal">Prover</tt>
class, found in <tt class="docutils literal">nltk.api</tt>.  The <tt class="docutils literal">prove()</tt> method takes three optional
arguments: a goal, a list of assumptions, and a <tt class="docutils literal">verbose</tt> boolean to
indicate whether the proof should be printed to the console.  The proof goal
and any assumptions need to be instances of the <tt class="docutils literal">Expression</tt> class
specified by <tt class="docutils literal">nltk.sem.logic</tt>.  There are currently three theorem provers
included with NLTK: <tt class="docutils literal">Prover9</tt>, <tt class="docutils literal">TableauProver</tt>, and
<tt class="docutils literal">ResolutionProver</tt>.  The first is an off-the-shelf prover, while the other
two are written in Python and included in the <tt class="docutils literal">nltk.inference</tt> package.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; lp = LogicParser()
&gt;&gt;&gt; p1 = lp.parse('man(socrates)')
&gt;&gt;&gt; p2 = lp.parse('all x.(man(x) -&gt; mortal(x))')
&gt;&gt;&gt; c  = lp.parse('mortal(socrates)')
&gt;&gt;&gt; Prover9().prove(c, [p1,p2])
True
&gt;&gt;&gt; TableauProver().prove(c, [p1,p2])
True
&gt;&gt;&gt; ResolutionProver().prove(c, [p1,p2], verbose=True)
[1] {-mortal(socrates)}     A
[2] {man(socrates)}         A
[3] {-man(z2), mortal(z2)}  A
[4] {-man(socrates)}        (1, 3)
[5] {mortal(socrates)}      (2, 3)
[6] {}                      (1, 5)
&lt;BLANKLINE&gt;
True
</pre>
</blockquote>
</div>
<div class="section" id="the-provercommand">
<h1>The <tt class="docutils literal">ProverCommand</tt></h1>
<p>A <tt class="docutils literal">ProverCommand</tt> is a stateful holder for a theorem
prover.  The command stores a theorem prover instance (of type <tt class="docutils literal">Prover</tt>),
a goal, a list of assumptions, the result of the proof, and a string version
of the entire proof.  Corresponding to the three included <tt class="docutils literal">Prover</tt>
implementations, there are three <tt class="docutils literal">ProverCommand</tt> implementations:
<tt class="docutils literal">Prover9Command</tt>, <tt class="docutils literal">TableauProverCommand</tt>, and
<tt class="docutils literal">ResolutionProverCommand</tt>.</p>
<p>The <tt class="docutils literal">ProverCommand</tt>'s constructor takes its goal and assumptions.  The
<tt class="docutils literal">prove()</tt> command executes the <tt class="docutils literal">Prover</tt> and <tt class="docutils literal">proof()</tt>
returns a String form of the proof
If the <tt class="docutils literal">prove()</tt> method has not been called,
then the prover command will be unable to display a proof.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; prover = ResolutionProverCommand(c, [p1,p2])
&gt;&gt;&gt; print(prover.proof()) # doctest: +ELLIPSIS
Traceback (most recent call last):
  File &quot;...&quot;, line 1212, in __run
    compileflags, 1) in test.globs
  File &quot;&lt;doctest nltk/test/inference.doctest[10]&gt;&quot;, line 1, in &lt;module&gt;
  File &quot;...&quot;, line ..., in proof
    raise LookupError(&quot;You have to call prove() first to get a proof!&quot;)
LookupError: You have to call prove() first to get a proof!
&gt;&gt;&gt; prover.prove()
True
&gt;&gt;&gt; print(prover.proof())
[1] {-mortal(socrates)}     A
[2] {man(socrates)}         A
[3] {-man(z4), mortal(z4)}  A
[4] {-man(socrates)}        (1, 3)
[5] {mortal(socrates)}      (2, 3)
[6] {}                      (1, 5)
&lt;BLANKLINE&gt;
</pre>
</blockquote>
<p>The prover command stores the result of proving so that if <tt class="docutils literal">prove()</tt> is
called again, then the command can return the result without executing the
prover again.  This allows the user to access the result of the proof without
wasting time re-computing what it already knows.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; prover.prove()
True
&gt;&gt;&gt; prover.prove()
True
</pre>
</blockquote>
<p>The assumptions and goal may be accessed using the <tt class="docutils literal">assumptions()</tt> and
<tt class="docutils literal">goal()</tt> methods, respectively.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; prover.assumptions()
[&lt;ApplicationExpression man(socrates)&gt;, &lt;AllExpression all x.(man(x) -&gt; mortal(x))&gt;]
&gt;&gt;&gt; prover.goal()
&lt;ApplicationExpression mortal(socrates)&gt;
</pre>
</blockquote>
<p>The assumptions list may be modified using the <tt class="docutils literal">add_assumptions()</tt> and
<tt class="docutils literal">retract_assumptions()</tt> methods.  Both methods take a list of <tt class="docutils literal">Expression</tt>
objects.  Since adding or removing assumptions may change the result of the
proof, the stored result is cleared when either of these methods are called.
That means that <tt class="docutils literal">proof()</tt> will be unavailable until <tt class="docutils literal">prove()</tt> is called and
a call to <tt class="docutils literal">prove()</tt> will execute the theorem prover.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; prover.retract_assumptions([lp.parse('man(socrates)')])
&gt;&gt;&gt; print(prover.proof()) # doctest: +ELLIPSIS
Traceback (most recent call last):
  File &quot;...&quot;, line 1212, in __run
    compileflags, 1) in test.globs
  File &quot;&lt;doctest nltk/test/inference.doctest[10]&gt;&quot;, line 1, in &lt;module&gt;
  File &quot;...&quot;, line ..., in proof
    raise LookupError(&quot;You have to call prove() first to get a proof!&quot;)
LookupError: You have to call prove() first to get a proof!
&gt;&gt;&gt; prover.prove()
False
&gt;&gt;&gt; print(prover.proof())
[1] {-mortal(socrates)}     A
[2] {-man(z6), mortal(z6)}  A
[3] {-man(socrates)}        (1, 2)
&lt;BLANKLINE&gt;
&gt;&gt;&gt; prover.add_assumptions([lp.parse('man(socrates)')])
&gt;&gt;&gt; prover.prove()
True
</pre>
</blockquote>
</div>
<div class="section" id="prover9">
<h1>Prover9</h1>
<div class="section" id="prover9-installation">
<h2>Prover9 Installation</h2>
<p>You can download Prover9 from <a class="reference external" href="http://www.cs.unm.edu/~mccune/prover9/">http://www.cs.unm.edu/~mccune/prover9/</a>.</p>
<p>Extract the source code into a suitable directory and follow the
instructions in the Prover9 <tt class="docutils literal">README.make</tt> file to compile the executables.
Install these into an appropriate location; the
<tt class="docutils literal">prover9_search</tt> variable is currently configured to look in the
following locations:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; p = Prover9()
&gt;&gt;&gt; p.binary_locations() # doctest: +NORMALIZE_WHITESPACE
['/usr/local/bin/prover9',
 '/usr/local/bin/prover9/bin',
 '/usr/local/bin',
 '/usr/bin',
 '/usr/local/prover9',
 '/usr/local/share/prover9']
</pre>
</blockquote>
<p>Alternatively, the environment variable <tt class="docutils literal">PROVER9HOME</tt> may be configured with
the binary's location.</p>
<p>The path to the correct directory can be set manually in the following
manner:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; config_prover9(path='/usr/local/bin') # doctest: +SKIP
[Found prover9: /usr/local/bin/prover9]
</pre>
</blockquote>
<p>If the executables cannot be found, <tt class="docutils literal">Prover9</tt> will issue a warning message:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; p.prove() # doctest: +SKIP
Traceback (most recent call last):
  ...
LookupError:
===========================================================================
  NLTK was unable to find the prover9 executable!  Use config_prover9() or
  set the PROVER9HOME environment variable.
&lt;BLANKLINE&gt;
    &gt;&gt; config_prover9('/path/to/prover9')
&lt;BLANKLINE&gt;
  For more information, on prover9, see:
    &lt;http://www.cs.unm.edu/~mccune/prover9/&gt;
===========================================================================
</pre>
</blockquote>
</div>
<div class="section" id="using-prover9">
<h2>Using Prover9</h2>
<p>The general case in theorem proving is to determine whether <tt class="docutils literal">S |- g</tt>
holds, where <tt class="docutils literal">S</tt> is a possibly empty set of assumptions, and <tt class="docutils literal">g</tt>
is a proof goal.</p>
<p>As mentioned earlier, NLTK input to <tt class="docutils literal">Prover9</tt> must be
<tt class="docutils literal">Expression</tt>s of <tt class="docutils literal">nltk.sem.logic</tt>. A <tt class="docutils literal">Prover9</tt> instance is
initialized with a proof goal and, possibly, some assumptions. The
<tt class="docutils literal">prove()</tt> method attempts to find a proof of the goal, given the
list of assumptions (in this case, none).</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; goal = lp.parse('(man(x) &lt;-&gt; --man(x))')
&gt;&gt;&gt; prover = Prover9Command(goal)
&gt;&gt;&gt; prover.prove()
True
</pre>
</blockquote>
<p>Given a <tt class="docutils literal">ProverCommand</tt> instance <tt class="docutils literal">prover</tt>, the method
<tt class="docutils literal">prover.proof()</tt> will return a String of the extensive proof information
provided by Prover9, shown in abbreviated form here:</p>
<pre class="literal-block">
============================== Prover9 ===============================
Prover9 (32) version ...
Process ... was started by ... on ...
...
The command was &quot;.../prover9 -f ...&quot;.
============================== end of head ===========================

============================== INPUT =================================

% Reading from file /var/...


formulas(goals).
(all x (man(x) -&gt; man(x))).
end_of_list.

...
============================== end of search =========================

THEOREM PROVED

Exiting with 1 proof.

Process 6317 exit (max_proofs) Mon Jan 21 15:23:28 2008
</pre>
<p>As mentioned earlier, we may want to list some assumptions for
the proof, as shown here.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; g = lp.parse('mortal(socrates)')
&gt;&gt;&gt; a1 = lp.parse('all x.(man(x) -&gt; mortal(x))')
&gt;&gt;&gt; prover = Prover9Command(g, assumptions=[a1])
&gt;&gt;&gt; prover.print_assumptions()
all x.(man(x) -&gt; mortal(x))
</pre>
</blockquote>
<p>However, the assumptions are not sufficient to derive the goal:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; print(prover.prove())
False
</pre>
</blockquote>
<p>So let's add another assumption:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; a2 = lp.parse('man(socrates)')
&gt;&gt;&gt; prover.add_assumptions([a2])
&gt;&gt;&gt; prover.print_assumptions()
all x.(man(x) -&gt; mortal(x))
man(socrates)
&gt;&gt;&gt; print(prover.prove())
True
</pre>
</blockquote>
<p>We can also show the assumptions in <tt class="docutils literal">Prover9</tt> format.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; prover.print_assumptions(output_format='Prover9')
all x (man(x) -&gt; mortal(x))
man(socrates)
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; prover.print_assumptions(output_format='Spass')
Traceback (most recent call last):
  . . .
NameError: Unrecognized value for 'output_format': Spass
</pre>
</blockquote>
<p>Assumptions can be retracted from the list of assumptions.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; prover.retract_assumptions([a1])
&gt;&gt;&gt; prover.print_assumptions()
man(socrates)
&gt;&gt;&gt; prover.retract_assumptions([a1])
</pre>
</blockquote>
<p>Statements can be loaded from a file and parsed. We can then add these
statements as new assumptions.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; g = lp.parse('all x.(boxer(x) -&gt; -boxerdog(x))')
&gt;&gt;&gt; prover = Prover9Command(g)
&gt;&gt;&gt; prover.prove()
False
&gt;&gt;&gt; import nltk.data
&gt;&gt;&gt; new = nltk.data.load('grammars/sample_grammars/background0.fol')
&gt;&gt;&gt; for a in new:
...     print(a)
all x.(boxerdog(x) -&gt; dog(x))
all x.(boxer(x) -&gt; person(x))
all x.-(dog(x) &amp; person(x))
exists x.boxer(x)
exists x.boxerdog(x)
&gt;&gt;&gt; prover.add_assumptions(new)
&gt;&gt;&gt; print(prover.prove())
True
&gt;&gt;&gt; print(prover.proof()) # doctest: +ELLIPSIS
============================== prooftrans ============================
Prover9 (...) version ...
Process ... was started by ... on ...
...
The command was &quot;.../prover9&quot;.
============================== end of head ===========================
&lt;BLANKLINE&gt;
============================== end of input ==========================
&lt;BLANKLINE&gt;
============================== PROOF =================================
&lt;BLANKLINE&gt;
% -------- Comments from original proof --------
% Proof 1 at ... seconds.
% Length of proof is 13.
% Level of proof is 4.
% Maximum clause weight is 0.000.
% Given clauses 0.
&lt;BLANKLINE&gt;
&lt;BLANKLINE&gt;
1 (all x (boxerdog(x) -&gt; dog(x))).  [assumption].
2 (all x (boxer(x) -&gt; person(x))).  [assumption].
3 (all x -(dog(x) &amp; person(x))).  [assumption].
6 (all x (boxer(x) -&gt; -boxerdog(x))).  [goal].
8 -boxerdog(x) | dog(x).  [clausify(1)].
9 boxerdog(c3).  [deny(6)].
11 -boxer(x) | person(x).  [clausify(2)].
12 boxer(c3).  [deny(6)].
14 -dog(x) | -person(x).  [clausify(3)].
15 dog(c3).  [resolve(9,a,8,a)].
18 person(c3).  [resolve(12,a,11,a)].
19 -person(c3).  [resolve(15,a,14,a)].
20 $F.  [resolve(19,a,18,a)].
&lt;BLANKLINE&gt;
============================== end of proof ==========================
</pre>
</blockquote>
</div>
</div>
<div class="section" id="the-equiv-method">
<h1>The equiv() method</h1>
<p>One application of the theorem prover functionality is to check if
two Expressions have the same meaning.
The <tt class="docutils literal">equiv()</tt> method calls a theorem prover to determine whether two
Expressions are logically equivalent.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; a = lp.parse(r'exists x.(man(x) &amp; walks(x))')
&gt;&gt;&gt; b = lp.parse(r'exists x.(walks(x) &amp; man(x))')
&gt;&gt;&gt; print(a.equiv(b))
True
</pre>
</blockquote>
<p>The same method can be used on Discourse Representation Structures (DRSs).
In this case, each DRS is converted to a first order logic form, and then
passed to the theorem prover.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; dp = DrtParser()
&gt;&gt;&gt; a = dp.parse(r'([x],[man(x), walks(x)])')
&gt;&gt;&gt; b = dp.parse(r'([x],[walks(x), man(x)])')
&gt;&gt;&gt; print(a.equiv(b))
True
</pre>
</blockquote>
</div>
<div class="section" id="nltk-interface-to-model-builders">
<h1>NLTK Interface to Model Builders</h1>
<p>The top-level to model builders is parallel to that for
theorem-provers. The <tt class="docutils literal">ModelBuilder</tt> interface is located
in <tt class="docutils literal">nltk.inference.api</tt>.  It is currently only implemented by
<tt class="docutils literal">Mace</tt>, which interfaces with the Mace4 model builder.</p>
<p>Typically we use a model builder to show that some set of formulas has
a model, and is therefore consistent. One way of doing this is by
treating our candidate set of sentences as assumptions, and leaving
the goal unspecified.
Thus, the following interaction shows how both <tt class="docutils literal">{a, c1}</tt> and <tt class="docutils literal">{a, c2}</tt>
are consistent sets, since Mace succeeds in a building a
model for each of them, while <tt class="docutils literal">{c1, c2}</tt> is inconsistent.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; a3 = lp.parse('exists x.(man(x) and walks(x))')
&gt;&gt;&gt; c1 = lp.parse('mortal(socrates)')
&gt;&gt;&gt; c2 = lp.parse('-mortal(socrates)')
&gt;&gt;&gt; mace = Mace()
&gt;&gt;&gt; print(mace.build_model(None, [a3, c1]))
True
&gt;&gt;&gt; print(mace.build_model(None, [a3, c2]))
True
</pre>
</blockquote>
<p>We can also use the model builder as an adjunct to theorem prover.
Let's suppose we are trying to prove <tt class="docutils literal">S |- g</tt>, i.e. that <tt class="docutils literal">g</tt>
is logically entailed by assumptions <tt class="docutils literal">S = {s1, s2, <span class="pre">...,</span> sn}</tt>.
We can this same input to Mace4, and the model builder will try to
find a counterexample, that is, to show that <tt class="docutils literal">g</tt> does <em>not</em> follow
from <tt class="docutils literal">S</tt>. So, given this input, Mace4 will try to find a model for
the set <tt class="docutils literal">S' = {s1, s2, <span class="pre">...,</span> sn, (not g)}</tt>. If <tt class="docutils literal">g</tt> fails to follow
from <tt class="docutils literal">S</tt>, then Mace4 may well return with a counterexample faster
than Prover9 concludes that it cannot find the required proof.
Conversely, if <tt class="docutils literal">g</tt> <em>is</em> provable from <tt class="docutils literal">S</tt>, Mace4 may take a long
time unsuccessfully trying to find a counter model, and will eventually give up.</p>
<p>In the following example, we see that the model builder does succeed
in building a model of the assumptions together with the negation of
the goal. That is, it succeeds in finding a model
where there is a woman that every man loves; Adam is a man; Eve is a
woman; but Adam does not love Eve.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; a4 = lp.parse('exists y. (woman(y) &amp; all x. (man(x) -&gt; love(x,y)))')
&gt;&gt;&gt; a5 = lp.parse('man(adam)')
&gt;&gt;&gt; a6 = lp.parse('woman(eve)')
&gt;&gt;&gt; g = lp.parse('love(adam,eve)')
&gt;&gt;&gt; print(mace.build_model(g, [a4, a5, a6]))
True
</pre>
</blockquote>
<p>The Model Builder will fail to find a model if the assumptions do entail
the goal.  Mace will continue to look for models of ever-increasing sizes
until the end_size number is reached.  By default, end_size is 500,
but it can be set manually for quicker response time.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; a7 = lp.parse('all x.(man(x) -&gt; mortal(x))')
&gt;&gt;&gt; a8 = lp.parse('man(socrates)')
&gt;&gt;&gt; g2 = lp.parse('mortal(socrates)')
&gt;&gt;&gt; print(Mace(end_size=50).build_model(g2, [a7, a8]))
False
</pre>
</blockquote>
<p>There is also a <tt class="docutils literal">ModelBuilderCommand</tt> class that, like <tt class="docutils literal">ProverCommand</tt>,
stores a <tt class="docutils literal">ModelBuilder</tt>, a goal, assumptions, a result, and a model.  The
only implementation in NLTK is <tt class="docutils literal">MaceCommand</tt>.</p>
</div>
<div class="section" id="mace4">
<h1>Mace4</h1>
<div class="section" id="mace4-installation">
<h2>Mace4 Installation</h2>
<p>Mace4 is packaged with Prover9, and can be downloaded from the same
source, namely <a class="reference external" href="http://www.cs.unm.edu/~mccune/prover9/">http://www.cs.unm.edu/~mccune/prover9/</a>. It is installed
in the same manner as Prover9.</p>
</div>
<div class="section" id="using-mace4">
<h2>Using Mace4</h2>
<p>Check whether Mace4 can find a model.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; a = lp.parse('(see(mary,john) &amp; -(mary = john))')
&gt;&gt;&gt; mb = MaceCommand(assumptions=[a])
&gt;&gt;&gt; mb.build_model()
True
</pre>
</blockquote>
<p>Show the model in 'tabular' format.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; print(mb.model(format='tabular'))
% number = 1
% seconds = 0
&lt;BLANKLINE&gt;
% Interpretation of size 2
&lt;BLANKLINE&gt;
 john : 0
&lt;BLANKLINE&gt;
 mary : 1
&lt;BLANKLINE&gt;
 see :
       | 0 1
    ---+----
     0 | 0 0
     1 | 1 0
&lt;BLANKLINE&gt;
</pre>
</blockquote>
<p>Show the model in 'tabular' format.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; print(mb.model(format='cooked'))
% number = 1
% seconds = 0
&lt;BLANKLINE&gt;
% Interpretation of size 2
&lt;BLANKLINE&gt;
john = 0.
&lt;BLANKLINE&gt;
mary = 1.
&lt;BLANKLINE&gt;
- see(0,0).
- see(0,1).
  see(1,0).
- see(1,1).
&lt;BLANKLINE&gt;
</pre>
</blockquote>
<p>The property <tt class="docutils literal">valuation</tt> accesses the stored <tt class="docutils literal">Valuation</tt>.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; print(mb.valuation)
{'john': 'a', 'mary': 'b', 'see': set([('b', 'a')])}
</pre>
</blockquote>
<p>We can return to our earlier example and inspect the model:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; mb = MaceCommand(g, assumptions=[a4, a5, a6])
&gt;&gt;&gt; m = mb.build_model()
&gt;&gt;&gt; print(mb.model(format='cooked'))
% number = 1
% seconds = 0
&lt;BLANKLINE&gt;
% Interpretation of size 2
&lt;BLANKLINE&gt;
adam = 0.
&lt;BLANKLINE&gt;
eve = 0.
&lt;BLANKLINE&gt;
c1 = 1.
&lt;BLANKLINE&gt;
  man(0).
- man(1).
&lt;BLANKLINE&gt;
  woman(0).
  woman(1).
&lt;BLANKLINE&gt;
- love(0,0).
  love(0,1).
- love(1,0).
- love(1,1).
&lt;BLANKLINE&gt;
</pre>
</blockquote>
<p>Here, we can see that <tt class="docutils literal">adam</tt> and <tt class="docutils literal">eve</tt> have been assigned the same
individual, namely <tt class="docutils literal">0</tt> as value; <tt class="docutils literal">0</tt> is both a man and a woman; a second
individual <tt class="docutils literal">1</tt> is also a woman; and <tt class="docutils literal">0</tt> loves <tt class="docutils literal">1</tt>. Thus, this is
an interpretation in which there is a woman that every man loves but
Adam doesn't love Eve.</p>
<p>Mace can also be used with propositional logic.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; p = lp.parse('P')
&gt;&gt;&gt; q = lp.parse('Q')
&gt;&gt;&gt; mb = MaceCommand(q, [p, p&gt;-q])
&gt;&gt;&gt; mb.build_model()
True
&gt;&gt;&gt; mb.valuation
{'Q': False, 'P': True}
</pre>
</blockquote>
</div>
</div>
</div>
</body>
</html>
