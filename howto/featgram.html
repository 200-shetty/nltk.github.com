<?xml version="1.0" encoding="ascii" ?>

<script language="javascript" type="text/javascript">

function astext(node)
{
    return node.innerHTML.replace(/(<([^>]+)>)/ig,"")
                         .replace(/&gt;/ig, ">")
                         .replace(/&lt;/ig, "<")
                         .replace(/&quot;/ig, '"')
                         .replace(/&amp;/ig, "&");
}

function copy_notify(node, bar_color, data)
{
    // The outer box: relative + inline positioning.
    var box1 = document.createElement("div");
    box1.style.position = "relative";
    box1.style.display = "inline";
    box1.style.top = "2em";
    box1.style.left = "1em";
  
    // A shadow for fun
    var shadow = document.createElement("div");
    shadow.style.position = "absolute";
    shadow.style.left = "-1.3em";
    shadow.style.top = "-1.3em";
    shadow.style.background = "#404040";
    
    // The inner box: absolute positioning.
    var box2 = document.createElement("div");
    box2.style.position = "relative";
    box2.style.border = "1px solid #a0a0a0";
    box2.style.left = "-.2em";
    box2.style.top = "-.2em";
    box2.style.background = "white";
    box2.style.padding = ".3em .4em .3em .4em";
    box2.style.fontStyle = "normal";
    box2.style.background = "#f0e0e0";

    node.insertBefore(box1, node.childNodes.item(0));
    box1.appendChild(shadow);
    shadow.appendChild(box2);
    box2.innerHTML="Copied&nbsp;to&nbsp;the&nbsp;clipboard: " +
                   "<pre class='copy-notify'>"+
                   data+"</pre>";
    setTimeout(function() { node.removeChild(box1); }, 1000);

    var elt = node.parentNode.firstChild;
    elt.style.background = "#ffc0c0";
    setTimeout(function() { elt.style.background = bar_color; }, 200);
}

function copy_codeblock_to_clipboard(node)
{
    var data = astext(node)+"\n";
    if (copy_text_to_clipboard(data)) {
        copy_notify(node, "#40a060", data);
    }
}

function copy_doctest_to_clipboard(node)
{
    var s = astext(node)+"\n   ";
    var data = "";

    var start = 0;
    var end = s.indexOf("\n");
    while (end >= 0) {
        if (s.substring(start, start+4) == ">>> ") {
            data += s.substring(start+4, end+1);
        }
        else if (s.substring(start, start+4) == "... ") {
            data += s.substring(start+4, end+1);
        }
        /*
        else if (end-start > 1) {
            data += "# " + s.substring(start, end+1);
        }*/
        // Grab the next line.
        start = end+1;
        end = s.indexOf("\n", start);
    }
    
    if (copy_text_to_clipboard(data)) {
        copy_notify(node, "#4060a0", data);
    }
}
    
function copy_text_to_clipboard(data)
{
    if (window.clipboardData) {
        window.clipboardData.setData("Text", data);
        return true;
     }
    else if (window.netscape) {
        // w/ default firefox settings, permission will be denied for this:
        netscape.security.PrivilegeManager
                      .enablePrivilege("UniversalXPConnect");
    
        var clip = Components.classes["@mozilla.org/widget/clipboard;1"]
                      .createInstance(Components.interfaces.nsIClipboard);
        if (!clip) return;
    
        var trans = Components.classes["@mozilla.org/widget/transferable;1"]
                       .createInstance(Components.interfaces.nsITransferable);
        if (!trans) return;
    
        trans.addDataFlavor("text/unicode");
    
        var str = new Object();
        var len = new Object();
    
        var str = Components.classes["@mozilla.org/supports-string;1"]
                     .createInstance(Components.interfaces.nsISupportsString);
        var datacopy=data;
        str.data=datacopy;
        trans.setTransferData("text/unicode",str,datacopy.length*2);
        var clipid=Components.interfaces.nsIClipboard;
    
        if (!clip) return false;
    
        clip.setData(trans,null,clipid.kGlobalClipboard);
        return true;
    }
    return false;
}
//-->
</script>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ascii" />
<meta name="generator" content="Docutils 0.12: http://docutils.sourceforge.net/" />
<title>Feature Grammar Parsing</title>
<style type="text/css">

/*
:Author: Edward Loper, James Curran
:Copyright: This stylesheet has been placed in the public domain.

Stylesheet for use with Docutils.

This stylesheet defines new css classes used by NLTK.

It uses a Python syntax highlighting scheme that matches
the colour scheme used by IDLE, which makes it easier for
beginners to check they are typing things in correctly.
*/

/* Include the standard docutils stylesheet. */
@import url(default.css);

/* Custom inline roles */
span.placeholder    { font-style: italic; font-family: monospace; }
span.example        { font-style: italic; }
span.emphasis       { font-style: italic; }
span.termdef        { font-weight: bold; }
/*span.term           { font-style: italic; }*/
span.category       { font-variant: small-caps; }
span.feature        { font-variant: small-caps; }
span.fval           { font-style: italic; }
span.math           { font-style: italic; }
span.mathit         { font-style: italic; }
span.lex            { font-variant: small-caps; }
span.guide-linecount{ text-align: right; display: block;}

/* Python souce code listings */
span.pysrc-prompt   { color: #9b0000; }
span.pysrc-more     { color: #9b00ff; }
span.pysrc-keyword  { color: #e06000; }
span.pysrc-builtin  { color: #940094; }
span.pysrc-string   { color: #00aa00; }
span.pysrc-comment  { color: #ff0000; }
span.pysrc-output   { color: #0000ff; }
span.pysrc-except   { color: #ff0000; }
span.pysrc-defname  { color: #008080; }


/* Doctest blocks */
pre.doctest         { margin: 0; padding: 0; font-weight: bold; }
div.doctest         { margin: 0 1em 1em 1em; padding: 0; }
table.doctest       { margin: 0; padding: 0;
                      border-top: 1px solid gray;
                      border-bottom: 1px solid gray; }
pre.copy-notify     { margin: 0; padding: 0.2em; font-weight: bold;
                      background-color: #ffffff; }

/* Python source listings */
div.pylisting       { margin: 0 1em 1em 1em; padding: 0; }
table.pylisting     { margin: 0; padding: 0;
                      border-top: 1px solid gray; }
td.caption { border-top: 1px solid black; margin: 0; padding: 0; }
.caption-label { font-weight: bold;  }
td.caption p { margin: 0; padding: 0; font-style: normal;}

table tr td.codeblock { 
  padding: 0.2em ! important; margin: 0;
  border-left: 1px solid gray;
  border-right: 2px solid gray;
  border-top: 0px solid gray;
  border-bottom: 1px solid gray;
  font-weight: bold; background-color: #eeffee;
}

table tr td.doctest  { 
  padding: 0.2em; margin: 0;
  border-left: 1px solid gray;
  border-right: 2px solid gray;
  border-top: 0px solid gray;
  border-bottom: 1px solid gray;
  font-weight: bold; background-color: #eeeeff;
}

td.codeblock table tr td.copybar {
    background: #40a060; border: 1px solid gray;
    font-family: monospace; padding: 0; margin: 0; }
td.doctest table tr td.copybar {
    background: #4060a0; border: 1px solid gray;
    font-family: monospace; padding: 0; margin: 0; }

td.pysrc { padding-left: 0.5em; }

img.callout { border-width: 0px; }

table.docutils {
    border-style: solid;
    border-width: 1px;
    margin-top: 6px;
    border-color: grey;
    border-collapse: collapse; }

table.docutils th {
    border-style: none;
    border-width: 1px;
    border-color: grey;
    padding: 0 .5em 0 .5em; }

table.docutils td {
    border-style: none;
    border-width: 1px;
    border-color: grey; 
    padding: 0 .5em 0 .5em; }

table.footnote td { padding: 0; }
table.footnote { border-width: 0; }
table.footnote td { border-width: 0; }
table.footnote th { border-width: 0; }

table.noborder { border-width: 0; }

table.example pre { margin-top: 4px; margin-bottom: 0; }

/* For figures & tables */
p.caption { margin-bottom: 0; }
div.figure { text-align: center; }

/* The index */
div.index { border: 1px solid black;
            background-color: #eeeeee; }
div.index h1 { padding-left: 0.5em; margin-top: 0.5ex;
               border-bottom: 1px solid black; }
ul.index { margin-left: 0.5em; padding-left: 0; }
li.index { list-style-type: none; }
p.index-heading { font-size: 120%; font-style: italic; margin: 0; }
li.index ul { margin-left: 2em; padding-left: 0; }

/* 'Note' callouts */
div.note
{
  border-right:   #87ceeb 1px solid;
  padding-right: 4px;
  border-top: #87ceeb 1px solid;
  padding-left: 4px;
  padding-bottom: 4px;
  margin: 2px 5% 10px;
  border-left: #87ceeb 1px solid;
  padding-top: 4px;
  border-bottom: #87ceeb 1px solid;
  font-style: normal;
  font-family: verdana, arial;
  background-color: #b0c4de;
}

table.avm { border: 0px solid black; width: 0; }
table.avm tbody tr {border: 0px solid black; }
table.avm tbody tr td { padding: 2px; }
table.avm tbody tr td.avm-key { padding: 5px; font-variant: small-caps; }
table.avm tbody tr td.avm-eq { padding: 5px; }
table.avm tbody tr td.avm-val { padding: 5px; font-style: italic; }
p.avm-empty { font-style: normal; }
table.avm colgroup col { border: 0px solid black; }
table.avm tbody tr td.avm-topleft 
    { border-left: 2px solid #000080; border-top: 2px solid #000080; }
table.avm tbody tr td.avm-botleft 
    { border-left: 2px solid #000080; border-bottom: 2px solid #000080; }
table.avm tbody tr td.avm-topright
    { border-right: 2px solid #000080; border-top: 2px solid #000080; }
table.avm tbody tr td.avm-botright
    { border-right: 2px solid #000080; border-bottom: 2px solid #000080; }
table.avm tbody tr td.avm-left
    { border-left: 2px solid #000080; }
table.avm tbody tr td.avm-right
    { border-right: 2px solid #000080; }
table.avm tbody tr td.avm-topbotleft
    { border: 2px solid #000080; border-right: 0px solid black; }
table.avm tbody tr td.avm-topbotright
    { border: 2px solid #000080; border-left: 0px solid black; }
table.avm tbody tr td.avm-ident
    { font-size: 80%; padding: 0; padding-left: 2px; vertical-align: top; }
.avm-pointer
{ border: 1px solid #008000; padding: 1px; color: #008000; 
  background: #c0ffc0; font-style: normal; }

table.gloss { border: 0px solid black; width: 0; }
table.gloss tbody tr { border: 0px solid black; }
table.gloss tbody tr td { border: 0px solid black; }
table.gloss colgroup col { border: 0px solid black; }
table.gloss p { margin: 0; padding: 0; }

table.rst-example { border: 1px solid black; }
table.rst-example tbody tr td { background: #eeeeee; }
table.rst-example thead tr th { background: #c0ffff; }
td.rst-raw { width: 0; }

/* Used by nltk.org/doc/test: */
div.doctest-list { text-align: center; }
table.doctest-list { border: 1px solid black;
  margin-left: auto; margin-right: auto;
}
table.doctest-list tbody tr td { background: #eeeeee;
  border: 1px solid #cccccc; text-align: left; }
table.doctest-list thead tr th { background: #304050; color: #ffffff;
  border: 1px solid #000000;}
table.doctest-list thead tr a { color: #ffffff; }
span.doctest-passed { color: #008000; }
span.doctest-failed { color: #800000; }

</style>
</head>
<body>
<div class="document" id="feature-grammar-parsing">
<h1 class="title">Feature Grammar Parsing</h1>

<!-- Copyright (C) 2001-2014 NLTK Project -->
<!-- For license information, see LICENSE.TXT -->
<!-- -*- mode: rst -*- -->
<!-- CAP abbreviations (map to small caps in LaTeX) -->
<!-- Other candidates for global consistency -->
<!-- PTB removed since it must be indexed -->
<!-- WN removed since it must be indexed -->
<!-- misc & punctuation -->
<!-- cdots was unicode U+22EF but not working -->
<!-- exercise meta-tags -->
<!-- Unicode tests -->
<!-- phonetic -->
<!-- misc -->
<!-- used in Unicode section -->
<!-- arrows -->
<!-- unification stuff -->
<!-- Math & Logic -->
<!-- sets -->
<!-- Greek -->
<!-- Chinese -->
<!-- URLs -->
<!-- Python example - a snippet of code in running text -->
<!-- PlaceHolder example -  something that should be replaced by actual code -->
<!-- Linguistic eXample - cited form in running text -->
<!-- Emphasized (more declarative than just using *) -->
<!-- Grammatical Category - e.g. NP and verb as technical terms
.. role:: gc
   :class: category -->
<!-- Math expression - e.g. especially for variables -->
<!-- Textual Math expression - for words 'inside' a math environment -->
<!-- Feature (or attribute) -->
<!-- Raw LaTeX -->
<!-- Raw HTML -->
<!-- Feature-value -->
<!-- Lexemes -->
<!-- Replacements that rely on previous definitions :-) -->
<p>Grammars can be parsed from strings.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">from</span> __future__ <span class="pysrc-keyword">import</span> print_function
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">import</span> nltk
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">from</span> nltk <span class="pysrc-keyword">import</span> grammar, parse
<span class="pysrc-prompt">&gt;&gt;&gt; </span>g = <span class="pysrc-string">&quot;&quot;&quot;</span>
<span class="pysrc-more">... </span><span class="pysrc-string">% start DP</span>
<span class="pysrc-more">... </span><span class="pysrc-string">DP[AGR=?a] -&gt; D[AGR=?a] N[AGR=?a]</span>
<span class="pysrc-more">... </span><span class="pysrc-string">D[AGR=[NUM='sg', PERS=3]] -&gt; 'this' | 'that'</span>
<span class="pysrc-more">... </span><span class="pysrc-string">D[AGR=[NUM='pl', PERS=3]] -&gt; 'these' | 'those'</span>
<span class="pysrc-more">... </span><span class="pysrc-string">D[AGR=[NUM='pl', PERS=1]] -&gt; 'we'</span>
<span class="pysrc-more">... </span><span class="pysrc-string">D[AGR=[PERS=2]] -&gt; 'you'</span>
<span class="pysrc-more">... </span><span class="pysrc-string">N[AGR=[NUM='sg', GND='m']] -&gt; 'boy'</span>
<span class="pysrc-more">... </span><span class="pysrc-string">N[AGR=[NUM='pl', GND='m']] -&gt; 'boys'</span>
<span class="pysrc-more">... </span><span class="pysrc-string">N[AGR=[NUM='sg', GND='f']] -&gt; 'girl'</span>
<span class="pysrc-more">... </span><span class="pysrc-string">N[AGR=[NUM='pl', GND='f']] -&gt; 'girls'</span>
<span class="pysrc-more">... </span><span class="pysrc-string">N[AGR=[NUM='sg']] -&gt; 'student'</span>
<span class="pysrc-more">... </span><span class="pysrc-string">N[AGR=[NUM='pl']] -&gt; 'students'</span>
<span class="pysrc-more">... </span><span class="pysrc-string">&quot;&quot;&quot;</span>
<span class="pysrc-prompt">&gt;&gt;&gt; </span>grammar = grammar.FeatureGrammar.fromstring(g)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>tokens = <span class="pysrc-string">'these girls'</span>.split()
<span class="pysrc-prompt">&gt;&gt;&gt; </span>parser = parse.FeatureEarleyChartParser(grammar)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>trees = parser.parse(tokens)
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">for</span> tree <span class="pysrc-keyword">in</span> trees: <span class="pysrc-keyword">print</span>(tree)
<span class="pysrc-output">(DP[AGR=[GND='f', NUM='pl', PERS=3]]</span>
<span class="pysrc-output">  (D[AGR=[NUM='pl', PERS=3]] these)</span>
<span class="pysrc-output">  (N[AGR=[GND='f', NUM='pl']] girls))</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>In general, when we are trying to develop even a very small grammar,
it is convenient to put the rules in a file where they can be edited,
tested and revised. Let's assume that we have saved <a class="reference external" href="http://nltk.svn.sourceforge.net/svnroot/nltk/trunk/nltk/data/grammars/feat0.fcfg">feat0cfg</a> as a file named
<tt class="doctest"><span class="pre"><span class="pysrc-string">'feat0.fcfg'</span></span></tt> and placed it in the NLTK <tt class="doctest"><span class="pre">data</span></tt> directory. We can
inspect it as follows:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>nltk.data.show_cfg(<span class="pysrc-string">'grammars/book_grammars/feat0.fcfg'</span>)
<span class="pysrc-output">% start S</span>
<span class="pysrc-output"># ###################</span>
<span class="pysrc-output"># Grammar Productions</span>
<span class="pysrc-output"># ###################</span>
<span class="pysrc-output"># S expansion productions</span>
<span class="pysrc-output">S -&gt; NP[NUM=?n] VP[NUM=?n]</span>
<span class="pysrc-output"># NP expansion productions</span>
<span class="pysrc-output">NP[NUM=?n] -&gt; N[NUM=?n]</span>
<span class="pysrc-output">NP[NUM=?n] -&gt; PropN[NUM=?n]</span>
<span class="pysrc-output">NP[NUM=?n] -&gt; Det[NUM=?n] N[NUM=?n]</span>
<span class="pysrc-output">NP[NUM=pl] -&gt; N[NUM=pl]</span>
<span class="pysrc-output"># VP expansion productions</span>
<span class="pysrc-output">VP[TENSE=?t, NUM=?n] -&gt; IV[TENSE=?t, NUM=?n]</span>
<span class="pysrc-output">VP[TENSE=?t, NUM=?n] -&gt; TV[TENSE=?t, NUM=?n] NP</span>
<span class="pysrc-output"># ###################</span>
<span class="pysrc-output"># Lexical Productions</span>
<span class="pysrc-output"># ###################</span>
<span class="pysrc-output">Det[NUM=sg] -&gt; 'this' | 'every'</span>
<span class="pysrc-output">Det[NUM=pl] -&gt; 'these' | 'all'</span>
<span class="pysrc-output">Det -&gt; 'the' | 'some' | 'several'</span>
<span class="pysrc-output">PropN[NUM=sg]-&gt; 'Kim' | 'Jody'</span>
<span class="pysrc-output">N[NUM=sg] -&gt; 'dog' | 'girl' | 'car' | 'child'</span>
<span class="pysrc-output">N[NUM=pl] -&gt; 'dogs' | 'girls' | 'cars' | 'children'</span>
<span class="pysrc-output">IV[TENSE=pres,  NUM=sg] -&gt; 'disappears' | 'walks'</span>
<span class="pysrc-output">TV[TENSE=pres, NUM=sg] -&gt; 'sees' | 'likes'</span>
<span class="pysrc-output">IV[TENSE=pres,  NUM=pl] -&gt; 'disappear' | 'walk'</span>
<span class="pysrc-output">TV[TENSE=pres, NUM=pl] -&gt; 'see' | 'like'</span>
<span class="pysrc-output">IV[TENSE=past] -&gt; 'disappeared' | 'walked'</span>
<span class="pysrc-output">TV[TENSE=past] -&gt; 'saw' | 'liked'</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Assuming we have saved <a class="reference external" href="http://nltk.svn.sourceforge.net/svnroot/nltk/trunk/nltk/data/grammars/feat0.fcfg">feat0cfg</a> as a file named
<tt class="doctest"><span class="pre"><span class="pysrc-string">'feat0.fcfg'</span></span></tt>, the function <tt class="doctest"><span class="pre">parse.load_parser</span></tt> allows us to
read the grammar into NLTK, ready for use in parsing.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>cp = parse.load_parser(<span class="pysrc-string">'grammars/book_grammars/feat0.fcfg'</span>, trace=1)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>sent = <span class="pysrc-string">'Kim likes children'</span>
<span class="pysrc-prompt">&gt;&gt;&gt; </span>tokens = sent.split()
<span class="pysrc-prompt">&gt;&gt;&gt; </span>tokens
<span class="pysrc-output">['Kim', 'likes', 'children']</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>trees = cp.parse(tokens)
<span class="pysrc-output">|.Kim .like.chil.|</span>
<span class="pysrc-output">|[----]    .    .| [0:1] 'Kim'</span>
<span class="pysrc-output">|.    [----]    .| [1:2] 'likes'</span>
<span class="pysrc-output">|.    .    [----]| [2:3] 'children'</span>
<span class="pysrc-output">|[----]    .    .| [0:1] PropN[NUM='sg'] -&gt; 'Kim' *</span>
<span class="pysrc-output">|[----]    .    .| [0:1] NP[NUM='sg'] -&gt; PropN[NUM='sg'] *</span>
<span class="pysrc-output">|[----&gt;    .    .| [0:1] S[] -&gt; NP[NUM=?n] * VP[NUM=?n] {?n: 'sg'}</span>
<span class="pysrc-output">|.    [----]    .| [1:2] TV[NUM='sg', TENSE='pres'] -&gt; 'likes' *</span>
<span class="pysrc-output">|.    [----&gt;    .| [1:2] VP[NUM=?n, TENSE=?t] -&gt; TV[NUM=?n, TENSE=?t] * NP[] {?n: 'sg', ?t: 'pres'}</span>
<span class="pysrc-output">|.    .    [----]| [2:3] N[NUM='pl'] -&gt; 'children' *</span>
<span class="pysrc-output">|.    .    [----]| [2:3] NP[NUM='pl'] -&gt; N[NUM='pl'] *</span>
<span class="pysrc-output">|.    .    [----&gt;| [2:3] S[] -&gt; NP[NUM=?n] * VP[NUM=?n] {?n: 'pl'}</span>
<span class="pysrc-output">|.    [---------]| [1:3] VP[NUM='sg', TENSE='pres'] -&gt; TV[NUM='sg', TENSE='pres'] NP[] *</span>
<span class="pysrc-output">|[==============]| [0:3] S[] -&gt; NP[NUM='sg'] VP[NUM='sg'] *</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">for</span> tree <span class="pysrc-keyword">in</span> trees: <span class="pysrc-keyword">print</span>(tree)
<span class="pysrc-output">(S[]</span>
<span class="pysrc-output">  (NP[NUM='sg'] (PropN[NUM='sg'] Kim))</span>
<span class="pysrc-output">  (VP[NUM='sg', TENSE='pres']</span>
<span class="pysrc-output">    (TV[NUM='sg', TENSE='pres'] likes)</span>
<span class="pysrc-output">    (NP[NUM='pl'] (N[NUM='pl'] children))))</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>The parser works directly with
the underspecified productions given by the grammar. That is, the
Predictor rule does not attempt to compile out all admissible feature
combinations before trying to expand the non-terminals on the left hand
side of a production. However, when the Scanner matches an input word
against a lexical production that has been predicted, the new edge will
typically contain fully specified features; e.g., the edge
[PropN[<span class="feature">num</span> = <span class="fval">sg</span>] &#8594; 'Kim', (0, 1)]. Recall from
Chapter 8 that the Fundamental (or Completer) Rule in
standard CFGs is used to combine an incomplete edge that's expecting a
nonterminal <em>B</em> with a following, complete edge whose left hand side
matches <em>B</em>. In our current setting, rather than checking for a
complete match, we test whether the expected category <em>B</em> will
<a name="unify_index_term" /><span class="termdef">unify</span> with the left hand side <em>B'</em> of a following complete
edge. We will explain in more detail in Section 9.2 how
unification works; for the moment, it is enough to know that as a
result of unification, any variable values of features in <em>B</em> will be
instantiated by constant values in the corresponding feature structure
in <em>B'</em>, and these instantiated values will be used in the new edge
added by the Completer. This instantiation can be seen, for example,
in the edge
[NP [<span class="feature">num</span>=<span class="fval">sg</span>] &#8594; PropN[<span class="feature">num</span>=<span class="fval">sg</span>] &#8226;, (0, 1)]
in Example 9.2, where the feature <span class="feature">num</span> has been assigned the value <span class="fval">sg</span>.</p>
<p>Feature structures in NLTK are ... Atomic feature values can be strings or
integers.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>fs1 = nltk.FeatStruct(TENSE=<span class="pysrc-string">'past'</span>, NUM=<span class="pysrc-string">'sg'</span>)
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">print</span>(fs1)
<span class="pysrc-output">[ NUM   = 'sg'   ]</span>
<span class="pysrc-output">[ TENSE = 'past' ]</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>We can think of a feature structure as being like a Python dictionary,
and access its values by indexing in the usual way.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>fs1 = nltk.FeatStruct(PER=3, NUM=<span class="pysrc-string">'pl'</span>, GND=<span class="pysrc-string">'fem'</span>)
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">print</span>(fs1[<span class="pysrc-string">'GND'</span>])
<span class="pysrc-output">fem</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>We can also define feature structures which have complex values, as
discussed earlier.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>fs2 = nltk.FeatStruct(POS=<span class="pysrc-string">'N'</span>, AGR=fs1)
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">print</span>(fs2)
<span class="pysrc-output">[       [ GND = 'fem' ] ]</span>
<span class="pysrc-output">[ AGR = [ NUM = 'pl'  ] ]</span>
<span class="pysrc-output">[       [ PER = 3     ] ]</span>
<span class="pysrc-output">[                       ]</span>
<span class="pysrc-output">[ POS = 'N'             ]</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">print</span>(fs2[<span class="pysrc-string">'AGR'</span>])
<span class="pysrc-output">[ GND = 'fem' ]</span>
<span class="pysrc-output">[ NUM = 'pl'  ]</span>
<span class="pysrc-output">[ PER = 3     ]</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">print</span>(fs2[<span class="pysrc-string">'AGR'</span>][<span class="pysrc-string">'PER'</span>])
<span class="pysrc-output">3</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Feature structures can also be constructed using the <tt class="doctest"><span class="pre">parse()</span></tt>
method of the <tt class="doctest"><span class="pre">nltk.FeatStruct</span></tt> class. Note that in this case, atomic
feature values do not need to be enclosed in quotes.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>f1 = nltk.FeatStruct(<span class="pysrc-string">&quot;[NUMBER = sg]&quot;</span>)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>f2 = nltk.FeatStruct(<span class="pysrc-string">&quot;[PERSON = 3]&quot;</span>)
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">print</span>(nltk.unify(f1, f2))
<span class="pysrc-output">[ NUMBER = 'sg' ]</span>
<span class="pysrc-output">[ PERSON = 3    ]</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>f1 = nltk.FeatStruct(<span class="pysrc-string">&quot;[A = [B = b, D = d]]&quot;</span>)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>f2 = nltk.FeatStruct(<span class="pysrc-string">&quot;[A = [C = c, D = d]]&quot;</span>)
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">print</span>(nltk.unify(f1, f2))
<span class="pysrc-output">[     [ B = 'b' ] ]</span>
<span class="pysrc-output">[ A = [ C = 'c' ] ]</span>
<span class="pysrc-output">[     [ D = 'd' ] ]</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<div class="section" id="feature-structures-as-graphs">
<h1>1&nbsp;&nbsp;&nbsp;Feature Structures as Graphs</h1>
<p>Feature structures are not inherently tied to linguistic objects; they are
general purpose structures for representing knowledge. For example, we
could encode information about a person in a feature structure:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>person01 = nltk.FeatStruct(<span class="pysrc-string">&quot;[NAME=Lee, TELNO='01 27 86 42 96',AGE=33]&quot;</span>)
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">print</span>(person01)
<span class="pysrc-output">[ AGE   = 33               ]</span>
<span class="pysrc-output">[ NAME  = 'Lee'            ]</span>
<span class="pysrc-output">[ TELNO = '01 27 86 42 96' ]</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>There are a number of notations for representing reentrancy in
matrix-style representations of feature structures. In NLTK, we adopt
the following convention: the first occurrence of a shared feature structure
is prefixed with an integer in parentheses, such as <tt class="doctest"><span class="pre">(1)</span></tt>, and any
subsequent reference to that structure uses the notation
<tt class="doctest"><span class="pre">-&gt;(1)</span></tt>, as shown below.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>fs = nltk.FeatStruct(<span class="pysrc-string">&quot;&quot;&quot;[NAME=Lee, ADDRESS=(1)[NUMBER=74, STREET='rue Pascal'],</span>
<span class="pysrc-more">... </span><span class="pysrc-string">                              SPOUSE=[NAME=Kim, ADDRESS-&gt;(1)]]&quot;&quot;&quot;</span>)
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">print</span>(fs)
<span class="pysrc-output">[ ADDRESS = (1) [ NUMBER = 74           ] ]</span>
<span class="pysrc-output">[               [ STREET = 'rue Pascal' ] ]</span>
<span class="pysrc-output">[                                         ]</span>
<span class="pysrc-output">[ NAME    = 'Lee'                         ]</span>
<span class="pysrc-output">[                                         ]</span>
<span class="pysrc-output">[ SPOUSE  = [ ADDRESS -&gt; (1)  ]           ]</span>
<span class="pysrc-output">[           [ NAME    = 'Kim' ]           ]</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>There can be any number of tags within a single feature structure.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>fs3 = nltk.FeatStruct(<span class="pysrc-string">&quot;[A=(1)[B=b], C=(2)[], D-&gt;(1), E-&gt;(2)]&quot;</span>)
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">print</span>(fs3)
<span class="pysrc-output">[ A = (1) [ B = 'b' ] ]</span>
<span class="pysrc-output">[                     ]</span>
<span class="pysrc-output">[ C = (2) []          ]</span>
<span class="pysrc-output">[                     ]</span>
<span class="pysrc-output">[ D -&gt; (1)            ]</span>
<span class="pysrc-output">[ E -&gt; (2)            ]</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>fs1 = nltk.FeatStruct(NUMBER=74, STREET=<span class="pysrc-string">'rue Pascal'</span>)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>fs2 = nltk.FeatStruct(CITY=<span class="pysrc-string">'Paris'</span>)
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">print</span>(nltk.unify(fs1, fs2))
<span class="pysrc-output">[ CITY   = 'Paris'      ]</span>
<span class="pysrc-output">[ NUMBER = 74           ]</span>
<span class="pysrc-output">[ STREET = 'rue Pascal' ]</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Unification is symmetric:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>nltk.unify(fs1, fs2) == nltk.unify(fs2, fs1)
<span class="pysrc-output">True</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Unification is commutative:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>fs3 = nltk.FeatStruct(TELNO=<span class="pysrc-string">'01 27 86 42 96'</span>)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>nltk.unify(nltk.unify(fs1, fs2), fs3) == nltk.unify(fs1, nltk.unify(fs2, fs3))
<span class="pysrc-output">True</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Unification between <span class="math">FS</span><sub>0</sub> and <span class="math">FS</span><sub>1</sub> will fail if the two feature structures share a path &#960;,
but the value of &#960; in <span class="math">FS</span><sub>0</sub> is a distinct
atom from the value of &#960; in <span class="math">FS</span><sub>1</sub>. In NLTK,
this is implemented by setting the result of unification to be
<tt class="doctest"><span class="pre">None</span></tt>.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>fs0 = nltk.FeatStruct(A=<span class="pysrc-string">'a'</span>)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>fs1 = nltk.FeatStruct(A=<span class="pysrc-string">'b'</span>)
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">print</span>(nltk.unify(fs0, fs1))
<span class="pysrc-output">None</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Now, if we look at how unification interacts with structure-sharing,
things become really interesting.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>fs0 = nltk.FeatStruct(<span class="pysrc-string">&quot;&quot;&quot;[NAME=Lee,</span>
<span class="pysrc-more">... </span><span class="pysrc-string">                               ADDRESS=[NUMBER=74,</span>
<span class="pysrc-more">... </span><span class="pysrc-string">                                        STREET='rue Pascal'],</span>
<span class="pysrc-more">... </span><span class="pysrc-string">                               SPOUSE= [NAME=Kim,</span>
<span class="pysrc-more">... </span><span class="pysrc-string">                                        ADDRESS=[NUMBER=74,</span>
<span class="pysrc-more">... </span><span class="pysrc-string">                                                 STREET='rue Pascal']]]&quot;&quot;&quot;</span>)
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">print</span>(fs0)
<span class="pysrc-output">[ ADDRESS = [ NUMBER = 74           ]               ]</span>
<span class="pysrc-output">[           [ STREET = 'rue Pascal' ]               ]</span>
<span class="pysrc-output">[                                                   ]</span>
<span class="pysrc-output">[ NAME    = 'Lee'                                   ]</span>
<span class="pysrc-output">[                                                   ]</span>
<span class="pysrc-output">[           [ ADDRESS = [ NUMBER = 74           ] ] ]</span>
<span class="pysrc-output">[ SPOUSE  = [           [ STREET = 'rue Pascal' ] ] ]</span>
<span class="pysrc-output">[           [                                     ] ]</span>
<span class="pysrc-output">[           [ NAME    = 'Kim'                     ] ]</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>fs1 = nltk.FeatStruct(<span class="pysrc-string">&quot;[SPOUSE=[ADDRESS=[CITY=Paris]]]&quot;</span>)
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">print</span>(nltk.unify(fs0, fs1))
<span class="pysrc-output">[ ADDRESS = [ NUMBER = 74           ]               ]</span>
<span class="pysrc-output">[           [ STREET = 'rue Pascal' ]               ]</span>
<span class="pysrc-output">[                                                   ]</span>
<span class="pysrc-output">[ NAME    = 'Lee'                                   ]</span>
<span class="pysrc-output">[                                                   ]</span>
<span class="pysrc-output">[           [           [ CITY   = 'Paris'      ] ] ]</span>
<span class="pysrc-output">[           [ ADDRESS = [ NUMBER = 74           ] ] ]</span>
<span class="pysrc-output">[ SPOUSE  = [           [ STREET = 'rue Pascal' ] ] ]</span>
<span class="pysrc-output">[           [                                     ] ]</span>
<span class="pysrc-output">[           [ NAME    = 'Kim'                     ] ]</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>fs2 = nltk.FeatStruct(<span class="pysrc-string">&quot;&quot;&quot;[NAME=Lee, ADDRESS=(1)[NUMBER=74, STREET='rue Pascal'],</span>
<span class="pysrc-more">... </span><span class="pysrc-string">                               SPOUSE=[NAME=Kim, ADDRESS-&gt;(1)]]&quot;&quot;&quot;</span>)</pre>
</td>
</tr></table></td></tr>
</table></div>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">print</span>(fs2)
<span class="pysrc-output">[ ADDRESS = (1) [ NUMBER = 74           ] ]</span>
<span class="pysrc-output">[               [ STREET = 'rue Pascal' ] ]</span>
<span class="pysrc-output">[                                         ]</span>
<span class="pysrc-output">[ NAME    = 'Lee'                         ]</span>
<span class="pysrc-output">[                                         ]</span>
<span class="pysrc-output">[ SPOUSE  = [ ADDRESS -&gt; (1)  ]           ]</span>
<span class="pysrc-output">[           [ NAME    = 'Kim' ]           ]</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">print</span>(nltk.unify(fs2, fs1))
<span class="pysrc-output">[               [ CITY   = 'Paris'      ] ]</span>
<span class="pysrc-output">[ ADDRESS = (1) [ NUMBER = 74           ] ]</span>
<span class="pysrc-output">[               [ STREET = 'rue Pascal' ] ]</span>
<span class="pysrc-output">[                                         ]</span>
<span class="pysrc-output">[ NAME    = 'Lee'                         ]</span>
<span class="pysrc-output">[                                         ]</span>
<span class="pysrc-output">[ SPOUSE  = [ ADDRESS -&gt; (1)  ]           ]</span>
<span class="pysrc-output">[           [ NAME    = 'Kim' ]           ]</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>fs1 = nltk.FeatStruct(<span class="pysrc-string">&quot;[ADDRESS1=[NUMBER=74, STREET='rue Pascal']]&quot;</span>)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>fs2 = nltk.FeatStruct(<span class="pysrc-string">&quot;[ADDRESS1=?x, ADDRESS2=?x]&quot;</span>)
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">print</span>(fs2)
<span class="pysrc-output">[ ADDRESS1 = ?x ]</span>
<span class="pysrc-output">[ ADDRESS2 = ?x ]</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">print</span>(nltk.unify(fs1, fs2))
<span class="pysrc-output">[ ADDRESS1 = (1) [ NUMBER = 74           ] ]</span>
<span class="pysrc-output">[                [ STREET = 'rue Pascal' ] ]</span>
<span class="pysrc-output">[                                          ]</span>
<span class="pysrc-output">[ ADDRESS2 -&gt; (1)                          ]</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>sent = <span class="pysrc-string">'who do you claim that you like'</span>
<span class="pysrc-prompt">&gt;&gt;&gt; </span>tokens = sent.split()
<span class="pysrc-prompt">&gt;&gt;&gt; </span>cp = parse.load_parser(<span class="pysrc-string">'grammars/book_grammars/feat1.fcfg'</span>, trace=1)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>trees = cp.parse(tokens)
<span class="pysrc-output">|.w.d.y.c.t.y.l.|</span>
<span class="pysrc-output">|[-] . . . . . .| [0:1] 'who'</span>
<span class="pysrc-output">|. [-] . . . . .| [1:2] 'do'</span>
<span class="pysrc-output">|. . [-] . . . .| [2:3] 'you'</span>
<span class="pysrc-output">|. . . [-] . . .| [3:4] 'claim'</span>
<span class="pysrc-output">|. . . . [-] . .| [4:5] 'that'</span>
<span class="pysrc-output">|. . . . . [-] .| [5:6] 'you'</span>
<span class="pysrc-output">|. . . . . . [-]| [6:7] 'like'</span>
<span class="pysrc-output">|# . . . . . . .| [0:0] NP[]/NP[] -&gt; *</span>
<span class="pysrc-output">|. # . . . . . .| [1:1] NP[]/NP[] -&gt; *</span>
<span class="pysrc-output">|. . # . . . . .| [2:2] NP[]/NP[] -&gt; *</span>
<span class="pysrc-output">|. . . # . . . .| [3:3] NP[]/NP[] -&gt; *</span>
<span class="pysrc-output">|. . . . # . . .| [4:4] NP[]/NP[] -&gt; *</span>
<span class="pysrc-output">|. . . . . # . .| [5:5] NP[]/NP[] -&gt; *</span>
<span class="pysrc-output">|. . . . . . # .| [6:6] NP[]/NP[] -&gt; *</span>
<span class="pysrc-output">|. . . . . . . #| [7:7] NP[]/NP[] -&gt; *</span>
<span class="pysrc-output">|[-] . . . . . .| [0:1] NP[+WH] -&gt; 'who' *</span>
<span class="pysrc-output">|[-&gt; . . . . . .| [0:1] S[-INV] -&gt; NP[] * VP[] {}</span>
<span class="pysrc-output">|[-&gt; . . . . . .| [0:1] S[-INV]/?x[] -&gt; NP[] * VP[]/?x[] {}</span>
<span class="pysrc-output">|[-&gt; . . . . . .| [0:1] S[-INV] -&gt; NP[] * S[]/NP[] {}</span>
<span class="pysrc-output">|. [-] . . . . .| [1:2] V[+AUX] -&gt; 'do' *</span>
<span class="pysrc-output">|. [-&gt; . . . . .| [1:2] S[+INV] -&gt; V[+AUX] * NP[] VP[] {}</span>
<span class="pysrc-output">|. [-&gt; . . . . .| [1:2] S[+INV]/?x[] -&gt; V[+AUX] * NP[] VP[]/?x[] {}</span>
<span class="pysrc-output">|. [-&gt; . . . . .| [1:2] VP[] -&gt; V[+AUX] * VP[] {}</span>
<span class="pysrc-output">|. [-&gt; . . . . .| [1:2] VP[]/?x[] -&gt; V[+AUX] * VP[]/?x[] {}</span>
<span class="pysrc-output">|. . [-] . . . .| [2:3] NP[-WH] -&gt; 'you' *</span>
<span class="pysrc-output">|. . [-&gt; . . . .| [2:3] S[-INV] -&gt; NP[] * VP[] {}</span>
<span class="pysrc-output">|. . [-&gt; . . . .| [2:3] S[-INV]/?x[] -&gt; NP[] * VP[]/?x[] {}</span>
<span class="pysrc-output">|. . [-&gt; . . . .| [2:3] S[-INV] -&gt; NP[] * S[]/NP[] {}</span>
<span class="pysrc-output">|. [---&gt; . . . .| [1:3] S[+INV] -&gt; V[+AUX] NP[] * VP[] {}</span>
<span class="pysrc-output">|. [---&gt; . . . .| [1:3] S[+INV]/?x[] -&gt; V[+AUX] NP[] * VP[]/?x[] {}</span>
<span class="pysrc-output">|. . . [-] . . .| [3:4] V[-AUX, SUBCAT='clause'] -&gt; 'claim' *</span>
<span class="pysrc-output">|. . . [-&gt; . . .| [3:4] VP[] -&gt; V[-AUX, SUBCAT='clause'] * SBar[] {}</span>
<span class="pysrc-output">|. . . [-&gt; . . .| [3:4] VP[]/?x[] -&gt; V[-AUX, SUBCAT='clause'] * SBar[]/?x[] {}</span>
<span class="pysrc-output">|. . . . [-] . .| [4:5] Comp[] -&gt; 'that' *</span>
<span class="pysrc-output">|. . . . [-&gt; . .| [4:5] SBar[] -&gt; Comp[] * S[-INV] {}</span>
<span class="pysrc-output">|. . . . [-&gt; . .| [4:5] SBar[]/?x[] -&gt; Comp[] * S[-INV]/?x[] {}</span>
<span class="pysrc-output">|. . . . . [-] .| [5:6] NP[-WH] -&gt; 'you' *</span>
<span class="pysrc-output">|. . . . . [-&gt; .| [5:6] S[-INV] -&gt; NP[] * VP[] {}</span>
<span class="pysrc-output">|. . . . . [-&gt; .| [5:6] S[-INV]/?x[] -&gt; NP[] * VP[]/?x[] {}</span>
<span class="pysrc-output">|. . . . . [-&gt; .| [5:6] S[-INV] -&gt; NP[] * S[]/NP[] {}</span>
<span class="pysrc-output">|. . . . . . [-]| [6:7] V[-AUX, SUBCAT='trans'] -&gt; 'like' *</span>
<span class="pysrc-output">|. . . . . . [-&gt;| [6:7] VP[] -&gt; V[-AUX, SUBCAT='trans'] * NP[] {}</span>
<span class="pysrc-output">|. . . . . . [-&gt;| [6:7] VP[]/?x[] -&gt; V[-AUX, SUBCAT='trans'] * NP[]/?x[] {}</span>
<span class="pysrc-output">|. . . . . . [-]| [6:7] VP[]/NP[] -&gt; V[-AUX, SUBCAT='trans'] NP[]/NP[] *</span>
<span class="pysrc-output">|. . . . . [---]| [5:7] S[-INV]/NP[] -&gt; NP[] VP[]/NP[] *</span>
<span class="pysrc-output">|. . . . [-----]| [4:7] SBar[]/NP[] -&gt; Comp[] S[-INV]/NP[] *</span>
<span class="pysrc-output">|. . . [-------]| [3:7] VP[]/NP[] -&gt; V[-AUX, SUBCAT='clause'] SBar[]/NP[] *</span>
<span class="pysrc-output">|. . [---------]| [2:7] S[-INV]/NP[] -&gt; NP[] VP[]/NP[] *</span>
<span class="pysrc-output">|. [-----------]| [1:7] S[+INV]/NP[] -&gt; V[+AUX] NP[] VP[]/NP[] *</span>
<span class="pysrc-output">|[=============]| [0:7] S[-INV] -&gt; NP[] S[]/NP[] *</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>trees = list(trees)
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">for</span> tree <span class="pysrc-keyword">in</span> trees: <span class="pysrc-keyword">print</span>(tree)
<span class="pysrc-output">(S[-INV]</span>
<span class="pysrc-output">  (NP[+WH] who)</span>
<span class="pysrc-output">  (S[+INV]/NP[]</span>
<span class="pysrc-output">    (V[+AUX] do)</span>
<span class="pysrc-output">    (NP[-WH] you)</span>
<span class="pysrc-output">    (VP[]/NP[]</span>
<span class="pysrc-output">      (V[-AUX, SUBCAT='clause'] claim)</span>
<span class="pysrc-output">      (SBar[]/NP[]</span>
<span class="pysrc-output">        (Comp[] that)</span>
<span class="pysrc-output">        (S[-INV]/NP[]</span>
<span class="pysrc-output">          (NP[-WH] you)</span>
<span class="pysrc-output">          (VP[]/NP[] (V[-AUX, SUBCAT='trans'] like) (NP[]/NP[] )))))))</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>A different parser should give the same parse trees, but perhaps in a different order:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>cp2 = parse.load_parser(<span class="pysrc-string">'grammars/book_grammars/feat1.fcfg'</span>, trace=1,
<span class="pysrc-more">... </span>                        parser=parse.FeatureEarleyChartParser)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>trees2 = cp2.parse(tokens)
<span class="pysrc-output">|.w.d.y.c.t.y.l.|</span>
<span class="pysrc-output">|[-] . . . . . .| [0:1] 'who'</span>
<span class="pysrc-output">|. [-] . . . . .| [1:2] 'do'</span>
<span class="pysrc-output">|. . [-] . . . .| [2:3] 'you'</span>
<span class="pysrc-output">|. . . [-] . . .| [3:4] 'claim'</span>
<span class="pysrc-output">|. . . . [-] . .| [4:5] 'that'</span>
<span class="pysrc-output">|. . . . . [-] .| [5:6] 'you'</span>
<span class="pysrc-output">|. . . . . . [-]| [6:7] 'like'</span>
<span class="pysrc-output">|&gt; . . . . . . .| [0:0] S[-INV] -&gt; * NP[] VP[] {}</span>
<span class="pysrc-output">|&gt; . . . . . . .| [0:0] S[-INV]/?x[] -&gt; * NP[] VP[]/?x[] {}</span>
<span class="pysrc-output">|&gt; . . . . . . .| [0:0] S[-INV] -&gt; * NP[] S[]/NP[] {}</span>
<span class="pysrc-output">|&gt; . . . . . . .| [0:0] S[-INV] -&gt; * Adv[+NEG] S[+INV] {}</span>
<span class="pysrc-output">|&gt; . . . . . . .| [0:0] S[+INV] -&gt; * V[+AUX] NP[] VP[] {}</span>
<span class="pysrc-output">|&gt; . . . . . . .| [0:0] S[+INV]/?x[] -&gt; * V[+AUX] NP[] VP[]/?x[] {}</span>
<span class="pysrc-output">|&gt; . . . . . . .| [0:0] NP[+WH] -&gt; * 'who' {}</span>
<span class="pysrc-output">|[-] . . . . . .| [0:1] NP[+WH] -&gt; 'who' *</span>
<span class="pysrc-output">|[-&gt; . . . . . .| [0:1] S[-INV] -&gt; NP[] * VP[] {}</span>
<span class="pysrc-output">|[-&gt; . . . . . .| [0:1] S[-INV]/?x[] -&gt; NP[] * VP[]/?x[] {}</span>
<span class="pysrc-output">|[-&gt; . . . . . .| [0:1] S[-INV] -&gt; NP[] * S[]/NP[] {}</span>
<span class="pysrc-output">|. &gt; . . . . . .| [1:1] S[-INV]/?x[] -&gt; * NP[] VP[]/?x[] {}</span>
<span class="pysrc-output">|. &gt; . . . . . .| [1:1] S[+INV]/?x[] -&gt; * V[+AUX] NP[] VP[]/?x[] {}</span>
<span class="pysrc-output">|. &gt; . . . . . .| [1:1] V[+AUX] -&gt; * 'do' {}</span>
<span class="pysrc-output">|. &gt; . . . . . .| [1:1] VP[]/?x[] -&gt; * V[-AUX, SUBCAT='trans'] NP[]/?x[] {}</span>
<span class="pysrc-output">|. &gt; . . . . . .| [1:1] VP[]/?x[] -&gt; * V[-AUX, SUBCAT='clause'] SBar[]/?x[] {}</span>
<span class="pysrc-output">|. &gt; . . . . . .| [1:1] VP[]/?x[] -&gt; * V[+AUX] VP[]/?x[] {}</span>
<span class="pysrc-output">|. &gt; . . . . . .| [1:1] VP[] -&gt; * V[-AUX, SUBCAT='intrans'] {}</span>
<span class="pysrc-output">|. &gt; . . . . . .| [1:1] VP[] -&gt; * V[-AUX, SUBCAT='trans'] NP[] {}</span>
<span class="pysrc-output">|. &gt; . . . . . .| [1:1] VP[] -&gt; * V[-AUX, SUBCAT='clause'] SBar[] {}</span>
<span class="pysrc-output">|. &gt; . . . . . .| [1:1] VP[] -&gt; * V[+AUX] VP[] {}</span>
<span class="pysrc-output">|. [-] . . . . .| [1:2] V[+AUX] -&gt; 'do' *</span>
<span class="pysrc-output">|. [-&gt; . . . . .| [1:2] S[+INV]/?x[] -&gt; V[+AUX] * NP[] VP[]/?x[] {}</span>
<span class="pysrc-output">|. [-&gt; . . . . .| [1:2] VP[]/?x[] -&gt; V[+AUX] * VP[]/?x[] {}</span>
<span class="pysrc-output">|. [-&gt; . . . . .| [1:2] VP[] -&gt; V[+AUX] * VP[] {}</span>
<span class="pysrc-output">|. . &gt; . . . . .| [2:2] VP[] -&gt; * V[-AUX, SUBCAT='intrans'] {}</span>
<span class="pysrc-output">|. . &gt; . . . . .| [2:2] VP[] -&gt; * V[-AUX, SUBCAT='trans'] NP[] {}</span>
<span class="pysrc-output">|. . &gt; . . . . .| [2:2] VP[] -&gt; * V[-AUX, SUBCAT='clause'] SBar[] {}</span>
<span class="pysrc-output">|. . &gt; . . . . .| [2:2] VP[] -&gt; * V[+AUX] VP[] {}</span>
<span class="pysrc-output">|. . &gt; . . . . .| [2:2] VP[]/?x[] -&gt; * V[-AUX, SUBCAT='trans'] NP[]/?x[] {}</span>
<span class="pysrc-output">|. . &gt; . . . . .| [2:2] VP[]/?x[] -&gt; * V[-AUX, SUBCAT='clause'] SBar[]/?x[] {}</span>
<span class="pysrc-output">|. . &gt; . . . . .| [2:2] VP[]/?x[] -&gt; * V[+AUX] VP[]/?x[] {}</span>
<span class="pysrc-output">|. . &gt; . . . . .| [2:2] NP[-WH] -&gt; * 'you' {}</span>
<span class="pysrc-output">|. . [-] . . . .| [2:3] NP[-WH] -&gt; 'you' *</span>
<span class="pysrc-output">|. [---&gt; . . . .| [1:3] S[+INV]/?x[] -&gt; V[+AUX] NP[] * VP[]/?x[] {}</span>
<span class="pysrc-output">|. . . &gt; . . . .| [3:3] VP[]/?x[] -&gt; * V[-AUX, SUBCAT='trans'] NP[]/?x[] {}</span>
<span class="pysrc-output">|. . . &gt; . . . .| [3:3] VP[]/?x[] -&gt; * V[-AUX, SUBCAT='clause'] SBar[]/?x[] {}</span>
<span class="pysrc-output">|. . . &gt; . . . .| [3:3] VP[]/?x[] -&gt; * V[+AUX] VP[]/?x[] {}</span>
<span class="pysrc-output">|. . . &gt; . . . .| [3:3] V[-AUX, SUBCAT='clause'] -&gt; * 'claim' {}</span>
<span class="pysrc-output">|. . . [-] . . .| [3:4] V[-AUX, SUBCAT='clause'] -&gt; 'claim' *</span>
<span class="pysrc-output">|. . . [-&gt; . . .| [3:4] VP[]/?x[] -&gt; V[-AUX, SUBCAT='clause'] * SBar[]/?x[] {}</span>
<span class="pysrc-output">|. . . . &gt; . . .| [4:4] SBar[]/?x[] -&gt; * Comp[] S[-INV]/?x[] {}</span>
<span class="pysrc-output">|. . . . &gt; . . .| [4:4] Comp[] -&gt; * 'that' {}</span>
<span class="pysrc-output">|. . . . [-] . .| [4:5] Comp[] -&gt; 'that' *</span>
<span class="pysrc-output">|. . . . [-&gt; . .| [4:5] SBar[]/?x[] -&gt; Comp[] * S[-INV]/?x[] {}</span>
<span class="pysrc-output">|. . . . . &gt; . .| [5:5] S[-INV]/?x[] -&gt; * NP[] VP[]/?x[] {}</span>
<span class="pysrc-output">|. . . . . &gt; . .| [5:5] NP[-WH] -&gt; * 'you' {}</span>
<span class="pysrc-output">|. . . . . [-] .| [5:6] NP[-WH] -&gt; 'you' *</span>
<span class="pysrc-output">|. . . . . [-&gt; .| [5:6] S[-INV]/?x[] -&gt; NP[] * VP[]/?x[] {}</span>
<span class="pysrc-output">|. . . . . . &gt; .| [6:6] VP[]/?x[] -&gt; * V[-AUX, SUBCAT='trans'] NP[]/?x[] {}</span>
<span class="pysrc-output">|. . . . . . &gt; .| [6:6] VP[]/?x[] -&gt; * V[-AUX, SUBCAT='clause'] SBar[]/?x[] {}</span>
<span class="pysrc-output">|. . . . . . &gt; .| [6:6] VP[]/?x[] -&gt; * V[+AUX] VP[]/?x[] {}</span>
<span class="pysrc-output">|. . . . . . &gt; .| [6:6] V[-AUX, SUBCAT='trans'] -&gt; * 'like' {}</span>
<span class="pysrc-output">|. . . . . . [-]| [6:7] V[-AUX, SUBCAT='trans'] -&gt; 'like' *</span>
<span class="pysrc-output">|. . . . . . [-&gt;| [6:7] VP[]/?x[] -&gt; V[-AUX, SUBCAT='trans'] * NP[]/?x[] {}</span>
<span class="pysrc-output">|. . . . . . . #| [7:7] NP[]/NP[] -&gt; *</span>
<span class="pysrc-output">|. . . . . . [-]| [6:7] VP[]/NP[] -&gt; V[-AUX, SUBCAT='trans'] NP[]/NP[] *</span>
<span class="pysrc-output">|. . . . . [---]| [5:7] S[-INV]/NP[] -&gt; NP[] VP[]/NP[] *</span>
<span class="pysrc-output">|. . . . [-----]| [4:7] SBar[]/NP[] -&gt; Comp[] S[-INV]/NP[] *</span>
<span class="pysrc-output">|. . . [-------]| [3:7] VP[]/NP[] -&gt; V[-AUX, SUBCAT='clause'] SBar[]/NP[] *</span>
<span class="pysrc-output">|. [-----------]| [1:7] S[+INV]/NP[] -&gt; V[+AUX] NP[] VP[]/NP[] *</span>
<span class="pysrc-output">|[=============]| [0:7] S[-INV] -&gt; NP[] S[]/NP[] *</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>sorted(trees) == sorted(trees2)
<span class="pysrc-output">True</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Let's load a German grammar:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>cp = parse.load_parser(<span class="pysrc-string">'grammars/book_grammars/german.fcfg'</span>, trace=0)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>sent = <span class="pysrc-string">'die Katze sieht den Hund'</span>
<span class="pysrc-prompt">&gt;&gt;&gt; </span>tokens = sent.split()
<span class="pysrc-prompt">&gt;&gt;&gt; </span>trees = cp.parse(tokens)
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">for</span> tree <span class="pysrc-keyword">in</span> trees: <span class="pysrc-keyword">print</span>(tree)
<span class="pysrc-output">(S[]</span>
<span class="pysrc-output">  (NP[AGR=[GND='fem', NUM='sg', PER=3], CASE='nom']</span>
<span class="pysrc-output">    (Det[AGR=[GND='fem', NUM='sg', PER=3], CASE='nom'] die)</span>
<span class="pysrc-output">    (N[AGR=[GND='fem', NUM='sg', PER=3]] Katze))</span>
<span class="pysrc-output">  (VP[AGR=[NUM='sg', PER=3]]</span>
<span class="pysrc-output">    (TV[AGR=[NUM='sg', PER=3], OBJCASE='acc'] sieht)</span>
<span class="pysrc-output">    (NP[AGR=[GND='masc', NUM='sg', PER=3], CASE='acc']</span>
<span class="pysrc-output">      (Det[AGR=[GND='masc', NUM='sg', PER=3], CASE='acc'] den)</span>
<span class="pysrc-output">      (N[AGR=[GND='masc', NUM='sg', PER=3]] Hund))))</span></pre>
</td>
</tr></table></td></tr>
</table></div>
</div>
<div class="section" id="grammar-with-binding-operators">
<h1>2&nbsp;&nbsp;&nbsp;Grammar with Binding Operators</h1>
<p>The <a class="reference external" href="http://nltk.svn.sourceforge.net/svnroot/nltk/trunk/nltk/data/grammars/bindop.fcfg">bindop.fcfg</a> grammar is a semantic grammar that uses lambda
calculus.  Each element has a core semantics, which is a single lambda
calculus expression; and a set of binding operators, which bind
variables.</p>
<p>In order to make the binding operators work right, they need to
instantiate their bound variable every time they are added to the
chart.  To do this, we use a special subclass of <cite>Chart</cite>, called
<cite>InstantiateVarsChart</cite>.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">from</span> nltk.parse.featurechart <span class="pysrc-keyword">import</span> InstantiateVarsChart
<span class="pysrc-prompt">&gt;&gt;&gt; </span>cp = parse.load_parser(<span class="pysrc-string">'grammars/sample_grammars/bindop.fcfg'</span>, trace=1,
<span class="pysrc-more">... </span>                       chart_class=InstantiateVarsChart)
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">print</span>(cp.grammar())
<span class="pysrc-output">Grammar with 15 productions (start state = S[])</span>
<span class="pysrc-output">    S[SEM=[BO={?b1+?b2}, CORE=&lt;?vp(?subj)&gt;]] -&gt; NP[SEM=[BO=?b1, CORE=?subj]] VP[SEM=[BO=?b2, CORE=?vp]]</span>
<span class="pysrc-output">    VP[SEM=[BO={?b1+?b2}, CORE=&lt;?v(?obj)&gt;]] -&gt; TV[SEM=[BO=?b1, CORE=?v]] NP[SEM=[BO=?b2, CORE=?obj]]</span>
<span class="pysrc-output">    VP[SEM=?s] -&gt; IV[SEM=?s]</span>
<span class="pysrc-output">    NP[SEM=[BO={?b1+?b2+{bo(?det(?n),&#64;x)}}, CORE=&lt;&#64;x&gt;]] -&gt; Det[SEM=[BO=?b1, CORE=?det]] N[SEM=[BO=?b2, CORE=?n]]</span>
<span class="pysrc-output">    Det[SEM=[BO={/}, CORE=&lt;\Q P.exists x.(Q(x) &amp; P(x))&gt;]] -&gt; 'a'</span>
<span class="pysrc-output">    N[SEM=[BO={/}, CORE=&lt;dog&gt;]] -&gt; 'dog'</span>
<span class="pysrc-output">    N[SEM=[BO={/}, CORE=&lt;dog&gt;]] -&gt; 'cat'</span>
<span class="pysrc-output">    N[SEM=[BO={/}, CORE=&lt;dog&gt;]] -&gt; 'mouse'</span>
<span class="pysrc-output">    IV[SEM=[BO={/}, CORE=&lt;\x.bark(x)&gt;]] -&gt; 'barks'</span>
<span class="pysrc-output">    IV[SEM=[BO={/}, CORE=&lt;\x.bark(x)&gt;]] -&gt; 'eats'</span>
<span class="pysrc-output">    IV[SEM=[BO={/}, CORE=&lt;\x.bark(x)&gt;]] -&gt; 'walks'</span>
<span class="pysrc-output">    TV[SEM=[BO={/}, CORE=&lt;\x y.feed(y,x)&gt;]] -&gt; 'feeds'</span>
<span class="pysrc-output">    TV[SEM=[BO={/}, CORE=&lt;\x y.feed(y,x)&gt;]] -&gt; 'walks'</span>
<span class="pysrc-output">    NP[SEM=[BO={bo(\P.P(John),&#64;x)}, CORE=&lt;&#64;x&gt;]] -&gt; 'john'</span>
<span class="pysrc-output">    NP[SEM=[BO={bo(\P.P(John),&#64;x)}, CORE=&lt;&#64;x&gt;]] -&gt; 'alex'</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>A simple intransitive sentence:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">from</span> nltk.sem <span class="pysrc-keyword">import</span> logic
<span class="pysrc-prompt">&gt;&gt;&gt; </span>logic._counter._value = 100</pre>
</td>
</tr></table></td></tr>
</table></div>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>trees = cp.parse(<span class="pysrc-string">'john barks'</span>.split())
<span class="pysrc-output">|. john.barks.|</span>
<span class="pysrc-output">|[-----]     .| [0:1] 'john'</span>
<span class="pysrc-output">|.     [-----]| [1:2] 'barks'</span>
<span class="pysrc-output">|[-----]     .| [0:1] NP[SEM=[BO={bo(\P.P(John),z101)}, CORE=&lt;z101&gt;]] -&gt; 'john' *</span>
<span class="pysrc-output">|[-----&gt;     .| [0:1] S[SEM=[BO={?b1+?b2}, CORE=&lt;?vp(?subj)&gt;]] -&gt; NP[SEM=[BO=?b1, CORE=?subj]] * VP[SEM=[BO=?b2, CORE=?vp]] {?b1: {bo(\P.P(John),z2)}, ?subj: &lt;IndividualVariableExpression z2&gt;}</span>
<span class="pysrc-output">|.     [-----]| [1:2] IV[SEM=[BO={/}, CORE=&lt;\x.bark(x)&gt;]] -&gt; 'barks' *</span>
<span class="pysrc-output">|.     [-----]| [1:2] VP[SEM=[BO={/}, CORE=&lt;\x.bark(x)&gt;]] -&gt; IV[SEM=[BO={/}, CORE=&lt;\x.bark(x)&gt;]] *</span>
<span class="pysrc-output">|[===========]| [0:2] S[SEM=[BO={bo(\P.P(John),z2)}, CORE=&lt;bark(z2)&gt;]] -&gt; NP[SEM=[BO={bo(\P.P(John),z2)}, CORE=&lt;z2&gt;]] VP[SEM=[BO={/}, CORE=&lt;\x.bark(x)&gt;]] *</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">for</span> tree <span class="pysrc-keyword">in</span> trees: <span class="pysrc-keyword">print</span>(tree)
<span class="pysrc-output">(S[SEM=[BO={bo(\P.P(John),z2)}, CORE=&lt;bark(z2)&gt;]]</span>
<span class="pysrc-output">  (NP[SEM=[BO={bo(\P.P(John),z101)}, CORE=&lt;z101&gt;]] john)</span>
<span class="pysrc-output">  (VP[SEM=[BO={/}, CORE=&lt;\x.bark(x)&gt;]]</span>
<span class="pysrc-output">    (IV[SEM=[BO={/}, CORE=&lt;\x.bark(x)&gt;]] barks)))</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>A transitive sentence:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>trees = cp.parse(<span class="pysrc-string">'john feeds a dog'</span>.split())
<span class="pysrc-output">|.joh.fee. a .dog.|</span>
<span class="pysrc-output">|[---]   .   .   .| [0:1] 'john'</span>
<span class="pysrc-output">|.   [---]   .   .| [1:2] 'feeds'</span>
<span class="pysrc-output">|.   .   [---]   .| [2:3] 'a'</span>
<span class="pysrc-output">|.   .   .   [---]| [3:4] 'dog'</span>
<span class="pysrc-output">|[---]   .   .   .| [0:1] NP[SEM=[BO={bo(\P.P(John),z102)}, CORE=&lt;z102&gt;]] -&gt; 'john' *</span>
<span class="pysrc-output">|[---&gt;   .   .   .| [0:1] S[SEM=[BO={?b1+?b2}, CORE=&lt;?vp(?subj)&gt;]] -&gt; NP[SEM=[BO=?b1, CORE=?subj]] * VP[SEM=[BO=?b2, CORE=?vp]] {?b1: {bo(\P.P(John),z2)}, ?subj: &lt;IndividualVariableExpression z2&gt;}</span>
<span class="pysrc-output">|.   [---]   .   .| [1:2] TV[SEM=[BO={/}, CORE=&lt;\x y.feed(y,x)&gt;]] -&gt; 'feeds' *</span>
<span class="pysrc-output">|.   [---&gt;   .   .| [1:2] VP[SEM=[BO={?b1+?b2}, CORE=&lt;?v(?obj)&gt;]] -&gt; TV[SEM=[BO=?b1, CORE=?v]] * NP[SEM=[BO=?b2, CORE=?obj]] {?b1: {/}, ?v: &lt;LambdaExpression \x y.feed(y,x)&gt;}</span>
<span class="pysrc-output">|.   .   [---]   .| [2:3] Det[SEM=[BO={/}, CORE=&lt;\Q P.exists x.(Q(x) &amp; P(x))&gt;]] -&gt; 'a' *</span>
<span class="pysrc-output">|.   .   [---&gt;   .| [2:3] NP[SEM=[BO={?b1+?b2+{bo(?det(?n),&#64;x)}}, CORE=&lt;&#64;x&gt;]] -&gt; Det[SEM=[BO=?b1, CORE=?det]] * N[SEM=[BO=?b2, CORE=?n]] {?b1: {/}, ?det: &lt;LambdaExpression \Q P.exists x.(Q(x) &amp; P(x))&gt;}</span>
<span class="pysrc-output">|.   .   .   [---]| [3:4] N[SEM=[BO={/}, CORE=&lt;dog&gt;]] -&gt; 'dog' *</span>
<span class="pysrc-output">|.   .   [-------]| [2:4] NP[SEM=[BO={bo(\P.exists x.(dog(x) &amp; P(x)),z103)}, CORE=&lt;z103&gt;]] -&gt; Det[SEM=[BO={/}, CORE=&lt;\Q P.exists x.(Q(x) &amp; P(x))&gt;]] N[SEM=[BO={/}, CORE=&lt;dog&gt;]] *</span>
<span class="pysrc-output">|.   .   [-------&gt;| [2:4] S[SEM=[BO={?b1+?b2}, CORE=&lt;?vp(?subj)&gt;]] -&gt; NP[SEM=[BO=?b1, CORE=?subj]] * VP[SEM=[BO=?b2, CORE=?vp]] {?b1: {bo(\P.exists x.(dog(x) &amp; P(x)),z2)}, ?subj: &lt;IndividualVariableExpression z2&gt;}</span>
<span class="pysrc-output">|.   [-----------]| [1:4] VP[SEM=[BO={bo(\P.exists x.(dog(x) &amp; P(x)),z2)}, CORE=&lt;\y.feed(y,z2)&gt;]] -&gt; TV[SEM=[BO={/}, CORE=&lt;\x y.feed(y,x)&gt;]] NP[SEM=[BO={bo(\P.exists x.(dog(x) &amp; P(x)),z2)}, CORE=&lt;z2&gt;]] *</span>
<span class="pysrc-output">|[===============]| [0:4] S[SEM=[BO={bo(\P.P(John),z2), bo(\P.exists x.(dog(x) &amp; P(x)),z3)}, CORE=&lt;feed(z2,z3)&gt;]] -&gt; NP[SEM=[BO={bo(\P.P(John),z2)}, CORE=&lt;z2&gt;]] VP[SEM=[BO={bo(\P.exists x.(dog(x) &amp; P(x)),z3)}, CORE=&lt;\y.feed(y,z3)&gt;]] *</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">for</span> tree <span class="pysrc-keyword">in</span> trees: <span class="pysrc-keyword">print</span>(tree)
<span class="pysrc-output">(S[SEM=[BO={bo(\P.P(John),z2), bo(\P.exists x.(dog(x) &amp; P(x)),z3)}, CORE=&lt;feed(z2,z3)&gt;]]</span>
<span class="pysrc-output">  (NP[SEM=[BO={bo(\P.P(John),z102)}, CORE=&lt;z102&gt;]] john)</span>
<span class="pysrc-output">  (VP[SEM=[BO={bo(\P.exists x.(dog(x) &amp; P(x)),z2)}, CORE=&lt;\y.feed(y,z2)&gt;]]</span>
<span class="pysrc-output">    (TV[SEM=[BO={/}, CORE=&lt;\x y.feed(y,x)&gt;]] feeds)</span>
<span class="pysrc-output">    (NP[SEM=[BO={bo(\P.exists x.(dog(x) &amp; P(x)),z103)}, CORE=&lt;z103&gt;]]</span>
<span class="pysrc-output">      (Det[SEM=[BO={/}, CORE=&lt;\Q P.exists x.(Q(x) &amp; P(x))&gt;]] a)</span>
<span class="pysrc-output">      (N[SEM=[BO={/}, CORE=&lt;dog&gt;]] dog))))</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Turn down the verbosity:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>cp = parse.load_parser(<span class="pysrc-string">'grammars/sample_grammars/bindop.fcfg'</span>, trace=0,
<span class="pysrc-more">... </span>                      chart_class=InstantiateVarsChart)</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Reuse the same lexical item twice:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>trees = cp.parse(<span class="pysrc-string">'john feeds john'</span>.split())
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">for</span> tree <span class="pysrc-keyword">in</span> trees: <span class="pysrc-keyword">print</span>(tree)
<span class="pysrc-output">(S[SEM=[BO={bo(\P.P(John),z2), bo(\P.P(John),z3)}, CORE=&lt;feed(z2,z3)&gt;]]</span>
<span class="pysrc-output">  (NP[SEM=[BO={bo(\P.P(John),z104)}, CORE=&lt;z104&gt;]] john)</span>
<span class="pysrc-output">  (VP[SEM=[BO={bo(\P.P(John),z2)}, CORE=&lt;\y.feed(y,z2)&gt;]]</span>
<span class="pysrc-output">    (TV[SEM=[BO={/}, CORE=&lt;\x y.feed(y,x)&gt;]] feeds)</span>
<span class="pysrc-output">    (NP[SEM=[BO={bo(\P.P(John),z105)}, CORE=&lt;z105&gt;]] john)))</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>trees = cp.parse(<span class="pysrc-string">'a dog feeds a dog'</span>.split())
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">for</span> tree <span class="pysrc-keyword">in</span> trees: <span class="pysrc-keyword">print</span>(tree)
<span class="pysrc-output">(S[SEM=[BO={bo(\P.exists x.(dog(x) &amp; P(x)),z2), bo(\P.exists x.(dog(x) &amp; P(x)),z3)}, CORE=&lt;feed(z2,z3)&gt;]]</span>
<span class="pysrc-output">  (NP[SEM=[BO={bo(\P.exists x.(dog(x) &amp; P(x)),z106)}, CORE=&lt;z106&gt;]]</span>
<span class="pysrc-output">    (Det[SEM=[BO={/}, CORE=&lt;\Q P.exists x.(Q(x) &amp; P(x))&gt;]] a)</span>
<span class="pysrc-output">    (N[SEM=[BO={/}, CORE=&lt;dog&gt;]] dog))</span>
<span class="pysrc-output">  (VP[SEM=[BO={bo(\P.exists x.(dog(x) &amp; P(x)),z2)}, CORE=&lt;\y.feed(y,z2)&gt;]]</span>
<span class="pysrc-output">    (TV[SEM=[BO={/}, CORE=&lt;\x y.feed(y,x)&gt;]] feeds)</span>
<span class="pysrc-output">    (NP[SEM=[BO={bo(\P.exists x.(dog(x) &amp; P(x)),z107)}, CORE=&lt;z107&gt;]]</span>
<span class="pysrc-output">      (Det[SEM=[BO={/}, CORE=&lt;\Q P.exists x.(Q(x) &amp; P(x))&gt;]] a)</span>
<span class="pysrc-output">      (N[SEM=[BO={/}, CORE=&lt;dog&gt;]] dog))))</span></pre>
</td>
</tr></table></td></tr>
</table></div>
</div>
</div>
</body>
</html>
