<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.11: http://docutils.sourceforge.net/" />
<title>Feature Grammar Parsing</title>
<style type="text/css">

/*
:Author: David Goodger (goodger@python.org)
:Id: $Id: html4css1.css 7614 2013-02-21 15:55:51Z milde $
:Copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.

See http://docutils.sf.net/docs/howto/html-stylesheets.html for how to
customize this style sheet.
*/

/* used to remove borders from tables and images */
.borderless, table.borderless td, table.borderless th {
  border: 0 }

table.borderless td, table.borderless th {
  /* Override padding for "table.docutils td" with "! important".
     The right padding separates the table cells. */
  padding: 0 0.5em 0 0 ! important }

.first {
  /* Override more specific margin styles with "! important". */
  margin-top: 0 ! important }

.last, .with-subtitle {
  margin-bottom: 0 ! important }

.hidden {
  display: none }

a.toc-backref {
  text-decoration: none ;
  color: black }

blockquote.epigraph {
  margin: 2em 5em ; }

dl.docutils dd {
  margin-bottom: 0.5em }

object[type="image/svg+xml"], object[type="application/x-shockwave-flash"] {
  overflow: hidden;
}

/* Uncomment (and remove this text!) to get bold-faced definition list terms
dl.docutils dt {
  font-weight: bold }
*/

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.admonition, div.attention, div.caution, div.danger, div.error,
div.hint, div.important, div.note, div.tip, div.warning {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.admonition p.admonition-title, div.hint p.admonition-title,
div.important p.admonition-title, div.note p.admonition-title,
div.tip p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title, .code .error {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

/* Uncomment (and remove this text!) to get reduced vertical space in
   compound paragraphs.
div.compound .compound-first, div.compound .compound-middle {
  margin-bottom: 0.5em }

div.compound .compound-last, div.compound .compound-middle {
  margin-top: 0.5em }
*/

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em ;
  margin-right: 2em }

div.footer, div.header {
  clear: both;
  font-size: smaller }

div.line-block {
  display: block ;
  margin-top: 1em ;
  margin-bottom: 1em }

div.line-block div.line-block {
  margin-top: 0 ;
  margin-bottom: 0 ;
  margin-left: 1.5em }

div.sidebar {
  margin: 0 0 0.5em 1em ;
  border: medium outset ;
  padding: 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.section-subtitle, h2.section-subtitle, h3.section-subtitle,
h4.section-subtitle, h5.section-subtitle, h6.section-subtitle {
  margin-top: 0.4em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

hr.docutils {
  width: 75% }

img.align-left, .figure.align-left, object.align-left {
  clear: left ;
  float: left ;
  margin-right: 1em }

img.align-right, .figure.align-right, object.align-right {
  clear: right ;
  float: right ;
  margin-left: 1em }

img.align-center, .figure.align-center, object.align-center {
  display: block;
  margin-left: auto;
  margin-right: auto;
}

.align-left {
  text-align: left }

.align-center {
  clear: both ;
  text-align: center }

.align-right {
  text-align: right }

/* reset inner alignment in figures */
div.align-right {
  text-align: inherit }

/* div.align-center * { */
/*   text-align: left } */

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font: inherit }

pre.literal-block, pre.doctest-block, pre.math, pre.code {
  margin-left: 2em ;
  margin-right: 2em }

pre.code .ln { color: grey; } /* line numbers */
pre.code, code { background-color: #eeeeee }
pre.code .comment, code .comment { color: #5C6576 }
pre.code .keyword, code .keyword { color: #3B0D06; font-weight: bold }
pre.code .literal.string, code .literal.string { color: #0C5404 }
pre.code .name.builtin, code .name.builtin { color: #352B84 }
pre.code .deleted, code .deleted { background-color: #DEB0A1}
pre.code .inserted, code .inserted { background-color: #A3D289}

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

span.section-subtitle {
  /* font-size relative to parent (h1..h6 element) */
  font-size: 80% }

table.citation {
  border-left: solid 1px gray;
  margin-left: 1px }

table.docinfo {
  margin: 2em 4em }

table.docutils {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.footnote {
  border-left: solid 1px black;
  margin-left: 1px }

table.docutils td, table.docutils th,
table.docinfo td, table.docinfo th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

table.docutils th.field-name, table.docinfo th.docinfo-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap ;
  padding-left: 0 }

/* "booktabs" style (no vertical lines) */
table.docutils.booktabs {
  border: 0px;
  border-top: 2px solid;
  border-bottom: 2px solid;
  border-collapse: collapse;
}
table.docutils.booktabs * {
  border: 0px;
}
table.docutils.booktabs th {
  border-bottom: thin solid;
  text-align: left;
}

h1 tt.docutils, h2 tt.docutils, h3 tt.docutils,
h4 tt.docutils, h5 tt.docutils, h6 tt.docutils {
  font-size: 100% }

ul.auto-toc {
  list-style-type: none }

</style>
<style type="text/css">

/*
*   math2html: convert LaTeX equations to HTML output.
*
*   Copyright (C) 2009,2010 Alex Fern√°ndez
*
*   Released under the terms of the `2-Clause BSD license'_, in short:
*   Copying and distribution of this file, with or without modification,
*   are permitted in any medium without royalty provided the copyright
*   notice and this notice are preserved.
*   This file is offered as-is, without any warranty.
*
* .. _2-Clause BSD license: http://www.spdx.org/licenses/BSD-2-Clause
*
*   Based on eLyXer: convert LyX source files to HTML output.
*   http://elyxer.nongnu.org/
*/
/* --end--
* CSS file for LaTeX formulas.
*/

/* Formulas */
.formula {
	text-align: center;
	font-family: "Droid Serif", "DejaVu Serif", "STIX", serif;
	margin: 1.2em 0;
}
span.formula {
	white-space: nowrap;
}
div.formula {
	padding: 0.5ex;
	margin-left: auto;
	margin-right: auto;
}

/* Basic features */
a.eqnumber {
	display: inline-block;
	float: right;
	clear: right;
	font-weight: bold;
}
span.unknown {
	color: #800000;
}
span.ignored, span.arraydef {
	display: none;
}
.formula i {
	letter-spacing: 0.1ex;
}

/* Alignment */
.align-left, .align-l {
	text-align: left;
}
.align-right, .align-r {
	text-align: right;
}
.align-center, .align-c {
	text-align: center;
}

/* Structures */
span.overline, span.bar {
	text-decoration: overline;
}
.fraction, .fullfraction {
	display: inline-block;
	vertical-align: middle;
	text-align: center;
}
.fraction .fraction {
	font-size: 80%;
	line-height: 100%;
}
span.numerator {
	display: block;
}
span.denominator {
	display: block;
	padding: 0ex;
	border-top: thin solid;
}
sup.numerator, sup.unit {
	font-size: 70%;
	vertical-align: 80%;
}
sub.denominator, sub.unit {
	font-size: 70%;
	vertical-align: -20%;
}
span.sqrt {
	display: inline-block;
	vertical-align: middle;
	padding: 0.1ex;
}
sup.root {
	font-size: 70%;
	position: relative;
	left: 1.4ex;
}
span.radical {
	display: inline-block;
	padding: 0ex;
	font-size: 150%;
	vertical-align: top;
}
span.root {
	display: inline-block;
	border-top: thin solid;
	padding: 0ex;
	vertical-align: middle;
}
span.symbol {
	line-height: 125%;
	font-size: 125%;
}
span.bigsymbol {
	line-height: 150%;
	font-size: 150%;
}
span.largesymbol {
	font-size: 175%;
}
span.hugesymbol {
	font-size: 200%;
}
span.scripts {
	display: inline-table;
	vertical-align: middle;
}
.script {
	display: table-row;
	text-align: left;
	line-height: 150%;
}
span.limits {
	display: inline-table;
	vertical-align: middle;
}
.limit {
	display: table-row;
	line-height: 99%;
}
sup.limit, sub.limit {
	line-height: 100%;
}
span.symbolover {
	display: inline-block;
	text-align: center;
	position: relative;
	float: right;
	right: 100%;
	bottom: 0.5em;
	width: 0px;
}
span.withsymbol {
	display: inline-block;
}
span.symbolunder {
	display: inline-block;
	text-align: center;
	position: relative;
	float: right;
	right: 80%;
	top: 0.3em;
	width: 0px;
}

/* Environments */
span.array, span.bracketcases, span.binomial, span.environment {
	display: inline-table;
	text-align: center;
	border-collapse: collapse;
	margin: 0em;
	vertical-align: middle;
}
span.arrayrow, span.binomrow {
	display: table-row;
	padding: 0ex;
	border: 0ex;
}
span.arraycell, span.bracket, span.case, span.binomcell, span.environmentcell {
	display: table-cell;
	padding: 0ex 0.2ex;
	line-height: 99%;
	border: 0ex;
}
/*
* CSS file for LaTeX formulas, extra stuff:
* binomials, vertical braces, stackrel, fonts and colors.
*/

/* Inline binomials */
span.binom {
	display: inline-block;
	vertical-align: middle;
	text-align: center;
	font-size: 80%;
}
span.binomstack {
	display: block;
	padding: 0em;
}

/* Over- and underbraces */
span.overbrace {
	border-top: 2pt solid;
}
span.underbrace {
	border-bottom: 2pt solid;
}

/* Stackrel */
span.stackrel {
	display: inline-block;
	text-align: center;
}
span.upstackrel {
	display: block;
	padding: 0em;
	font-size: 80%;
	line-height: 64%;
	position: relative;
	top: 0.15em;

}
span.downstackrel {
	display: block;
	vertical-align: bottom;
	padding: 0em;
}

/* Fonts */
span.mathsf, span.textsf {
	font-style: normal;
	font-family: sans-serif;
}
span.mathrm, span.textrm {
	font-style: normal;
	font-family: serif;
}
span.text, span.textnormal {
	font-style: normal;
}
span.textipa {
	color: #008080;
}
span.fraktur {
	font-family: "Lucida Blackletter", eufm10, blackletter;
}
span.blackboard {
	font-family: Blackboard, msbm10, serif;
}
span.scriptfont {
	font-family: "Monotype Corsiva", "Apple Chancery", "URW Chancery L", cursive;
	font-style: italic;
}

/* Colors */
span.colorbox {
	display: inline-block;
	padding: 5px;
}
span.fbox {
	display: inline-block;
	border: thin solid black;
	padding: 2px;
}
span.boxed, span.framebox {
	display: inline-block;
	border: thin solid black;
	padding: 5px;
}


</style>
</head>
<body>
<div class="document" id="feature-grammar-parsing">
<h1 class="title">Feature Grammar Parsing</h1>

<!-- Copyright (C) 2001-2013 NLTK Project -->
<!-- For license information, see LICENSE.TXT -->
<!-- -*- mode: rst -*- -->
<div class="system-message">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">../../../nltk_book/definitions.rst</tt>, line 3)</p>
<p>Unknown directive type &quot;ifndef&quot;.</p>
<pre class="literal-block">
.. ifndef:: definitions

  .. def:: definitions

  .. |version| replace:: 2.0.1rc1
  .. |copyrightinfo| replace:: 2001-2012 the authors
  .. |license| replace:: Creative Commons Attribution-Noncommercial-No Derivative Works 3.0 United States License

  .. CAP abbreviations (map to small caps in LaTeX)

  .. |CFG| replace:: CFG
  .. |DRT| replace:: DRT
  .. |DRS| replace:: DRS
  .. |CoNLL| replace:: CoNLL
  .. |CYK| replace:: CYK
  .. |FOL| replace:: first-order logic
  .. |FSRL| replace:: FSRL
  .. |HTML| replace:: HTML
  .. |IDLE| replace:: IDLE
  .. |LF| replace:: LF
  .. |NE|  replace:: NE
  .. |NLP|  replace:: NLP
  .. |NLTK| replace:: NLTK
  .. |URL| replace:: URL
  .. |WFST| replace:: WFST
  .. |XML| replace:: XML

  .. Other candidates for global consistency

  .. |fol| replace:: first-order logic
  .. |Fol| replace:: First-order logic
  .. PTB removed since it must be indexed
  .. WN removed since it must be indexed
  .. |TRY| replace:: **Your Turn:**
  .. |IMPORTANT| replace:: **Important:**

  .. misc &amp; punctuation
  .. cdots was unicode U+22EF but not working
  .. |dots| unicode:: U+2026 .. horizontal dots, ellipsis
  .. |copy| unicode:: 0xA9 .. copyright sign
  .. |dot| unicode:: U+2022 .. bullet
  .. |mdash| unicode:: U+02014 .. em dash (for between words)
  .. |ndash| unicode:: U+02013 .. en dash (for numeric ranges)
  .. |tilde| unicode:: U+007E

  .. exercise meta-tags

  .. |easy| unicode:: U+263C .. sun
  .. |soso| unicode:: U+25D1 .. &quot;moon&quot;
  .. |hard| unicode:: U+2605 .. black star
  .. |talk| unicode:: U+263A .. smiley face

  .. |blackstar| unicode:: U+2605
  .. |whitestar| unicode:: U+2606
  .. |blacksmiley| unicode:: U+263B
  .. |blackdiamond| unicode:: U+25C6

  .. Unicode tests
  .. |test0| unicode:: U+2690
  .. |test1| unicode:: U+2691
  .. |test2| unicode:: U+2692
  .. |test3| unicode:: U+2693
  .. |test4| unicode:: U+2694
  .. |test5| unicode:: U+2695
  .. |test6| unicode:: U+2696
  .. |test7| unicode:: U+2697
  .. |test8| unicode:: U+2698
  .. |test9| unicode:: U+2699
  .. |testa| unicode:: U+269A
  .. |testb| unicode:: U+269B
  .. |testc| unicode:: U+269C
  .. |testd| unicode:: U+269D
  .. |teste| unicode:: U+269E
  .. |testf| unicode:: U+269F

  .. phonetic
  .. |ae| unicode:: U+00E6 ..  small ae digraph
  .. |schwa| unicode:: U+0259 ..  schwa
  .. |eth| unicode:: U+00F0 ..  eth
  .. |length| unicode:: U+02D0 ..  length

  .. misc
  .. |aumlaut| unicode:: U+00E4 .. a umlaut
  .. |eacute| unicode:: U+00E9 .. e acute
  .. |eogonek| unicode:: U+1119 .. e ogonek
  .. |ncaron| unicode:: U+0148 .. n caron
  .. |ntilde| unicode:: U+00F1 .. n tilde
  .. |odacute| unicode:: U+0151 .. o double acute
  .. |oslash| unicode:: U+00F8 .. o slash
  .. |uumlaut| unicode:: U+00FC .. u umlaut
  .. |ecircumflex| unicode:: U+00EA .. e circumflex
  .. |space| unicode:: U+23E1 .. bottom tortoise shell bracket

  .. used in Unicode section
  .. |nacute| unicode:: U+0144
  .. |oacute| unicode:: U+00f3
  .. |sacute| unicode:: U+015b
  .. |Sacute| unicode:: U+015a
  .. |aogonek| unicode:: U+0105
  .. |lstroke| unicode:: U+0142

  .. |CJK-4EBA| unicode:: U+4eba
  .. |CJK-4EE5| unicode:: U+4ee5
  .. |CJK-732B| unicode:: U+732b
  .. |CJK-751A| unicode:: U+751a
  .. |CJK-81F3| unicode:: U+81f3
  .. |CJK-8D35| unicode:: U+8d35

  .. arrows
  .. |DoubleRightArrow| unicode:: U+021D2 .. rightwards double arrow
  .. |rarr| unicode:: U+2192 .. right arrow
  .. |rdarr| unicode:: U+21D2 .. right double arrow
  .. |reduce| unicode:: U+219D .. curly right arrow
  .. |lrarr| unicode:: U+2194 .. left-right arrow
  .. |larr| unicode:: U+2190 .. left arrow


  .. unification stuff
  .. |SquareIntersectionX| unicode:: U+02293 .. square cap
  .. |SquareSubsetEqual| unicode:: U+02291 .. square image of or equal to
  .. |SquareSubset| unicode:: U+0228F .. square image of
  .. |SquareSupersetEqual| unicode:: U+02292 .. square original of or equal to
  .. |SquareSuperset| unicode:: U+02290 .. square original of
  .. |SquareUnion| unicode:: U+02294 .. square cup

  .. Math &amp; Logic
  .. |tf| replace:: {*True*, *False*}

  .. |exists| unicode:: U+2203 .. existential quantifier
  .. |forall| unicode:: U+2200 .. universal quantifier
  .. |geq| unicode:: U+2265 .. greater than or equal
  .. |iff| unicode:: U+2261 .. triple bars
  .. |langle| unicode:: U+02329 .. left angle-bracket
  .. |leq| unicode:: U+2264 .. less than or equals
  .. |l| unicode:: U+00AB .. left chevron
  .. |neg| unicode:: U+00AC .. negation symbol
  .. |rangle| unicode:: U+0232A .. right angle-bracket
  .. |r| unicode:: U+00BB .. right chevron
  .. |times| unicode:: U+00D7 .. multiplication
  .. |vee| unicode:: U+2228 .. or
  .. |wedge| unicode:: U+2227 .. and
  .. |prod| replace:: Prod
  .. |minus| unicode:: U+2212 .. minus

  .. sets
  .. |cup| unicode:: U+0222A .. union
  .. |diff| unicode:: U+2212 .. set-theoretical complement
  .. |element| unicode:: U+2208 .. set-theoretical membership
  .. |empty| unicode:: U+2205 .. empty set
  .. |intersect| unicode:: U+2229 .. set-theoretical intersection
  .. |in| unicode:: U+2208 .. element of
  .. |mapsto| unicode:: U+2192 .. maps to
  .. |nelement| unicode:: U+2209 .. set-theoretical membership
  .. |pipe| unicode:: U+2223 .. vertical pipe
  .. |power| unicode:: U+2118 .. powerset
  .. |propsubset| unicode:: U+2282 .. proper subset
  .. |subset| unicode:: U+2286 .. subset
  .. |union| unicode:: U+222A .. set-theoretical union


  .. Greek
  .. |alpha| unicode:: U+03B1
  .. |beta| unicode:: U+03B2
  .. |gamma| unicode:: U+03B3
  .. |Gamma| unicode:: U+0393
  .. |kappaX| unicode:: U+03BA
  .. |kappa| replace:: K
  .. |lambda| unicode:: U+03BB
  .. |mu| unicode:: U+03BC
  .. |pi| unicode:: U+03C0
  .. |phi| unicode:: U+03C6
  .. |psi| unicode:: U+03C8
  .. |sigma| unicode:: U+03C3
  .. |tau| unicode:: U+03C4
  .. |rho| unicode:: U+03C1
  .. |Sigma| unicode:: U+03A3
  .. |sum| unicode:: U+03A3
  .. |Omega| unicode:: U+03A9

  .. Chinese
  .. |ai4| unicode:: U+7231 .. zh ai (love)
  .. |guo3| unicode:: U+56FD .. zh guo (country)
  .. |ren2| unicode:: U+4EBA .. zh ren (person)

  .. URLs
  .. |StevenBird| replace:: `Steven Bird &lt;http://www.csse.unimelb.edu.au/~sb/&gt;`__
  .. |EwanKlein| replace:: `Ewan Klein &lt;http://www.ltg.ed.ac.uk/~ewan/&gt;`__
  .. |EdwardLoper| replace:: `Edward Loper &lt;http://www.cis.upenn.edu/~edloper/&gt;`__
  .. |PYTHON-URL| replace:: ``http://python.org/``
  .. |PYTHON-DOCS| replace:: ``http://docs.python.org/``
  .. |NLTK-URL| replace:: ``http://www.nltk.org/``
  .. |NLTK-HOWTO-URL| replace:: ``http://www.nltk.org/howto``
  .. |OLAC-URL| replace:: ``http://www.language-archives.org/``

  .. Python example - a snippet of code in running text
  .. role:: py
     :class: python

  .. PlaceHolder example -  something that should be replaced by actual code
  .. role:: ph
     :class: placeholder

  .. Linguistic eXample - cited form in running text
  .. role:: lx
     :class: example

  .. Emphasized (more declarative than just using *)
  .. role:: em
     :class: emphasis

  .. Grammatical Category - e.g. NP and verb as technical terms
     .. role:: gc
        :class: category

  .. Math expression - e.g. especially for variables
  .. role:: math
     :class: math

  .. Textual Math expression - for words 'inside' a math environment
  .. role:: mathit
     :class: mathit

  .. Feature (or attribute)
  .. role:: feat
     :class: feature

  .. Raw LaTeX
  .. role:: raw-latex(raw)
     :format: latex

  .. Raw HTML
  .. role:: raw-html(raw)
     :format: html

  .. Feature-value
  .. role:: fval
     :class: fval

  .. Lexemes
  .. role:: lex
     :class: lex

  .. Replacements that rely on previous definitions :-)

  .. |nopar| replace:: :raw-latex:`{\noindent}`
  .. |seef| replace:: `see`:mathit:\ :sub:`f`
  .. |seeR| replace:: `see`:mathit:\ :sub:`R`
  .. |walkf| replace:: `walk`:mathit:\ :sub:`f`
  .. |walkR| replace:: `walk`:mathit:\ :sub:`R`


  .. |SquareIntersection| replace:: :raw-latex:`$\sqcap$`:raw-html:`&amp;#8851;`


</pre>
</div>
<p>Grammars can be parsed from strings.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from __future__ import print_function
&gt;&gt;&gt; import nltk
&gt;&gt;&gt; from nltk import grammar, parse
&gt;&gt;&gt; g = &quot;&quot;&quot;
... % start DP
... DP[AGR=?a] -&gt; D[AGR=?a] N[AGR=?a]
... D[AGR=[NUM='sg', PERS=3]] -&gt; 'this' | 'that'
... D[AGR=[NUM='pl', PERS=3]] -&gt; 'these' | 'those'
... D[AGR=[NUM='pl', PERS=1]] -&gt; 'we'
... D[AGR=[PERS=2]] -&gt; 'you'
... N[AGR=[NUM='sg', GND='m']] -&gt; 'boy'
... N[AGR=[NUM='pl', GND='m']] -&gt; 'boys'
... N[AGR=[NUM='sg', GND='f']] -&gt; 'girl'
... N[AGR=[NUM='pl', GND='f']] -&gt; 'girls'
... N[AGR=[NUM='sg']] -&gt; 'student'
... N[AGR=[NUM='pl']] -&gt; 'students'
... &quot;&quot;&quot;
&gt;&gt;&gt; grammar = grammar.parse_fcfg(g)
&gt;&gt;&gt; tokens = 'these girls'.split()
&gt;&gt;&gt; parser = parse.FeatureEarleyChartParser(grammar)
&gt;&gt;&gt; trees = parser.nbest_parse(tokens)
&gt;&gt;&gt; for tree in trees: print(tree)
(DP[AGR=[GND='f', NUM='pl', PERS=3]]
  (D[AGR=[NUM='pl', PERS=3]] these)
  (N[AGR=[GND='f', NUM='pl']] girls))
</pre>
</blockquote>
<p>In general, when we are trying to develop even a very small grammar,
it is convenient to put the rules in a file where they can be edited,
tested and revised. Let's assume that we have saved <a class="reference external" href="http://nltk.svn.sourceforge.net/svnroot/nltk/trunk/nltk/data/grammars/feat0.fcfg">feat0cfg</a> as a file named
<tt class="docutils literal">'feat0.fcfg'</tt> and placed it in the NLTK <tt class="docutils literal">data</tt> directory. We can
inspect it as follows:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; nltk.data.show_cfg('grammars/book_grammars/feat0.fcfg')
% start S
# ###################
# Grammar Productions
# ###################
# S expansion productions
S -&gt; NP[NUM=?n] VP[NUM=?n]
# NP expansion productions
NP[NUM=?n] -&gt; N[NUM=?n]
NP[NUM=?n] -&gt; PropN[NUM=?n]
NP[NUM=?n] -&gt; Det[NUM=?n] N[NUM=?n]
NP[NUM=pl] -&gt; N[NUM=pl]
# VP expansion productions
VP[TENSE=?t, NUM=?n] -&gt; IV[TENSE=?t, NUM=?n]
VP[TENSE=?t, NUM=?n] -&gt; TV[TENSE=?t, NUM=?n] NP
# ###################
# Lexical Productions
# ###################
Det[NUM=sg] -&gt; 'this' | 'every'
Det[NUM=pl] -&gt; 'these' | 'all'
Det -&gt; 'the' | 'some' | 'several'
PropN[NUM=sg]-&gt; 'Kim' | 'Jody'
N[NUM=sg] -&gt; 'dog' | 'girl' | 'car' | 'child'
N[NUM=pl] -&gt; 'dogs' | 'girls' | 'cars' | 'children'
IV[TENSE=pres,  NUM=sg] -&gt; 'disappears' | 'walks'
TV[TENSE=pres, NUM=sg] -&gt; 'sees' | 'likes'
IV[TENSE=pres,  NUM=pl] -&gt; 'disappear' | 'walk'
TV[TENSE=pres, NUM=pl] -&gt; 'see' | 'like'
IV[TENSE=past] -&gt; 'disappeared' | 'walked'
TV[TENSE=past] -&gt; 'saw' | 'liked'
</pre>
</blockquote>
<p>Assuming we have saved <a class="reference external" href="http://nltk.svn.sourceforge.net/svnroot/nltk/trunk/nltk/data/grammars/feat0.fcfg">feat0cfg</a> as a file named
<tt class="docutils literal">'feat0.fcfg'</tt>, the function <tt class="docutils literal">parse.load_parser</tt> allows us to
read the grammar into NLTK, ready for use in parsing.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; cp = parse.load_parser('grammars/book_grammars/feat0.fcfg', trace=1)
&gt;&gt;&gt; sent = 'Kim likes children'
&gt;&gt;&gt; tokens = sent.split()
&gt;&gt;&gt; tokens
['Kim', 'likes', 'children']
&gt;&gt;&gt; trees = cp.nbest_parse(tokens)
|.Kim .like.chil.|
|[----]    .    .| [0:1] 'Kim'
|.    [----]    .| [1:2] 'likes'
|.    .    [----]| [2:3] 'children'
|[----]    .    .| [0:1] PropN[NUM='sg'] -&gt; 'Kim' *
|[----]    .    .| [0:1] NP[NUM='sg'] -&gt; PropN[NUM='sg'] *
|[----&gt;    .    .| [0:1] S[] -&gt; NP[NUM=?n] * VP[NUM=?n] {?n: 'sg'}
|.    [----]    .| [1:2] TV[NUM='sg', TENSE='pres'] -&gt; 'likes' *
|.    [----&gt;    .| [1:2] VP[NUM=?n, TENSE=?t] -&gt; TV[NUM=?n, TENSE=?t] * NP[] {?n: 'sg', ?t: 'pres'}
|.    .    [----]| [2:3] N[NUM='pl'] -&gt; 'children' *
|.    .    [----]| [2:3] NP[NUM='pl'] -&gt; N[NUM='pl'] *
|.    .    [----&gt;| [2:3] S[] -&gt; NP[NUM=?n] * VP[NUM=?n] {?n: 'pl'}
|.    [---------]| [1:3] VP[NUM='sg', TENSE='pres'] -&gt; TV[NUM='sg', TENSE='pres'] NP[] *
|[==============]| [0:3] S[] -&gt; NP[NUM='sg'] VP[NUM='sg'] *
&gt;&gt;&gt; for tree in trees: print(tree)
(S[]
  (NP[NUM='sg'] (PropN[NUM='sg'] Kim))
  (VP[NUM='sg', TENSE='pres']
    (TV[NUM='sg', TENSE='pres'] likes)
    (NP[NUM='pl'] (N[NUM='pl'] children))))
</pre>
</blockquote>
<p>The parser works directly with
the underspecified productions given by the grammar. That is, the
Predictor rule does not attempt to compile out all admissible feature
combinations before trying to expand the non-terminals on the left hand
side of a production. However, when the Scanner matches an input word
against a lexical production that has been predicted, the new edge will
typically contain fully specified features; e.g., the edge
[PropN[<a href="#id1"><span class="problematic" id="id2">`num`:feat:</span></a> = <a href="#id3"><span class="problematic" id="id4">`sg`:fval:</span></a>] <a href="#id19"><span class="problematic" id="id20">|rarr|</span></a> 'Kim', (0, 1)]. Recall from
Chapter 8 that the Fundamental (or Completer) Rule in
standard CFGs is used to combine an incomplete edge that's expecting a
nonterminal <em>B</em> with a following, complete edge whose left hand side
matches <em>B</em>. In our current setting, rather than checking for a
complete match, we test whether the expected category <em>B</em> will
<a href="#id5"><span class="problematic" id="id6">`unify`:dt:</span></a> with the left hand side <em>B'</em> of a following complete
edge. We will explain in more detail in Section 9.2 how
unification works; for the moment, it is enough to know that as a
result of unification, any variable values of features in <em>B</em> will be
instantiated by constant values in the corresponding feature structure
in <em>B'</em>, and these instantiated values will be used in the new edge
added by the Completer. This instantiation can be seen, for example,
in the edge
[NP [<a href="#id7"><span class="problematic" id="id8">`num`:feat:</span></a>=<a href="#id9"><span class="problematic" id="id10">`sg`:fval:</span></a>] <a href="#id21"><span class="problematic" id="id22">|rarr|</span></a> PropN[<a href="#id11"><span class="problematic" id="id12">`num`:feat:</span></a>=<a href="#id13"><span class="problematic" id="id14">`sg`:fval:</span></a>] <a href="#id23"><span class="problematic" id="id24">|dot|</span></a>, (0, 1)]
in Example 9.2, where the feature <a href="#id15"><span class="problematic" id="id16">`num`:feat:</span></a> has been assigned the value <a href="#id17"><span class="problematic" id="id18">`sg`:fval:</span></a>.</p>
<div class="system-message" id="id1">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">featgram.doctest</tt>, line 109); <em><a href="#id2">backlink</a></em></p>
Unknown interpreted text role &quot;feat&quot;.</div>
<div class="system-message" id="id3">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">featgram.doctest</tt>, line 109); <em><a href="#id4">backlink</a></em></p>
Unknown interpreted text role &quot;fval&quot;.</div>
<div class="system-message" id="id5">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">featgram.doctest</tt>, line 109); <em><a href="#id6">backlink</a></em></p>
Unknown interpreted text role &quot;dt&quot;.</div>
<div class="system-message" id="id7">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">featgram.doctest</tt>, line 109); <em><a href="#id8">backlink</a></em></p>
Unknown interpreted text role &quot;feat&quot;.</div>
<div class="system-message" id="id9">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">featgram.doctest</tt>, line 109); <em><a href="#id10">backlink</a></em></p>
Unknown interpreted text role &quot;fval&quot;.</div>
<div class="system-message" id="id11">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">featgram.doctest</tt>, line 109); <em><a href="#id12">backlink</a></em></p>
Unknown interpreted text role &quot;feat&quot;.</div>
<div class="system-message" id="id13">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">featgram.doctest</tt>, line 109); <em><a href="#id14">backlink</a></em></p>
Unknown interpreted text role &quot;fval&quot;.</div>
<div class="system-message" id="id15">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">featgram.doctest</tt>, line 109); <em><a href="#id16">backlink</a></em></p>
Unknown interpreted text role &quot;feat&quot;.</div>
<div class="system-message" id="id17">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">featgram.doctest</tt>, line 109); <em><a href="#id18">backlink</a></em></p>
Unknown interpreted text role &quot;fval&quot;.</div>
<p>Feature structures in NLTK are ... Atomic feature values can be strings or
integers.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; fs1 = nltk.FeatStruct(TENSE='past', NUM='sg')
&gt;&gt;&gt; print(fs1)
[ NUM   = 'sg'   ]
[ TENSE = 'past' ]
</pre>
</blockquote>
<p>We can think of a feature structure as being like a Python dictionary,
and access its values by indexing in the usual way.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; fs1 = nltk.FeatStruct(PER=3, NUM='pl', GND='fem')
&gt;&gt;&gt; print(fs1['GND'])
fem
</pre>
</blockquote>
<p>We can also define feature structures which have complex values, as
discussed earlier.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; fs2 = nltk.FeatStruct(POS='N', AGR=fs1)
&gt;&gt;&gt; print(fs2)
[       [ GND = 'fem' ] ]
[ AGR = [ NUM = 'pl'  ] ]
[       [ PER = 3     ] ]
[                       ]
[ POS = 'N'             ]
&gt;&gt;&gt; print(fs2['AGR'])
[ GND = 'fem' ]
[ NUM = 'pl'  ]
[ PER = 3     ]
&gt;&gt;&gt; print(fs2['AGR']['PER'])
3
</pre>
</blockquote>
<p>Feature structures can also be constructed using the <tt class="docutils literal">parse()</tt>
method of the <tt class="docutils literal">nltk.FeatStruct</tt> class. Note that in this case, atomic
feature values do not need to be enclosed in quotes.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; f1 = nltk.FeatStruct(&quot;[NUMBER = sg]&quot;)
&gt;&gt;&gt; f2 = nltk.FeatStruct(&quot;[PERSON = 3]&quot;)
&gt;&gt;&gt; print(nltk.unify(f1, f2))
[ NUMBER = 'sg' ]
[ PERSON = 3    ]
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; f1 = nltk.FeatStruct(&quot;[A = [B = b, D = d]]&quot;)
&gt;&gt;&gt; f2 = nltk.FeatStruct(&quot;[A = [C = c, D = d]]&quot;)
&gt;&gt;&gt; print(nltk.unify(f1, f2))
[     [ B = 'b' ] ]
[ A = [ C = 'c' ] ]
[     [ D = 'd' ] ]
</pre>
</blockquote>
<div class="section" id="feature-structures-as-graphs">
<h1>Feature Structures as Graphs</h1>
<p>Feature structures are not inherently tied to linguistic objects; they are
general purpose structures for representing knowledge. For example, we
could encode information about a person in a feature structure:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; person01 = nltk.FeatStruct(&quot;[NAME=Lee, TELNO='01 27 86 42 96',AGE=33]&quot;)
&gt;&gt;&gt; print(person01)
[ AGE   = 33               ]
[ NAME  = 'Lee'            ]
[ TELNO = '01 27 86 42 96' ]
</pre>
</blockquote>
<p>There are a number of notations for representing reentrancy in
matrix-style representations of feature structures. In NLTK, we adopt
the following convention: the first occurrence of a shared feature structure
is prefixed with an integer in parentheses, such as <tt class="docutils literal">(1)</tt>, and any
subsequent reference to that structure uses the notation
<tt class="docutils literal"><span class="pre">-&gt;(1)</span></tt>, as shown below.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; fs = nltk.FeatStruct(&quot;&quot;&quot;[NAME=Lee, ADDRESS=(1)[NUMBER=74, STREET='rue Pascal'],
...                               SPOUSE=[NAME=Kim, ADDRESS-&gt;(1)]]&quot;&quot;&quot;)
&gt;&gt;&gt; print(fs)
[ ADDRESS = (1) [ NUMBER = 74           ] ]
[               [ STREET = 'rue Pascal' ] ]
[                                         ]
[ NAME    = 'Lee'                         ]
[                                         ]
[ SPOUSE  = [ ADDRESS -&gt; (1)  ]           ]
[           [ NAME    = 'Kim' ]           ]
</pre>
</blockquote>
<p>There can be any number of tags within a single feature structure.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; fs3 = nltk.FeatStruct(&quot;[A=(1)[B=b], C=(2)[], D-&gt;(1), E-&gt;(2)]&quot;)
&gt;&gt;&gt; print(fs3)
[ A = (1) [ B = 'b' ] ]
[                     ]
[ C = (2) []          ]
[                     ]
[ D -&gt; (1)            ]
[ E -&gt; (2)            ]
&gt;&gt;&gt; fs1 = nltk.FeatStruct(NUMBER=74, STREET='rue Pascal')
&gt;&gt;&gt; fs2 = nltk.FeatStruct(CITY='Paris')
&gt;&gt;&gt; print(nltk.unify(fs1, fs2))
[ CITY   = 'Paris'      ]
[ NUMBER = 74           ]
[ STREET = 'rue Pascal' ]
</pre>
</blockquote>
<p>Unification is symmetric:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; nltk.unify(fs1, fs2) == nltk.unify(fs2, fs1)
True
</pre>
</blockquote>
<p>Unification is commutative:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; fs3 = nltk.FeatStruct(TELNO='01 27 86 42 96')
&gt;&gt;&gt; nltk.unify(nltk.unify(fs1, fs2), fs3) == nltk.unify(fs1, nltk.unify(fs2, fs3))
True
</pre>
</blockquote>
<p>Unification between <span class="formula"><i>FS</i></span>
<sub>0</sub> and <span class="formula"><i>FS</i></span>
<sub>1</sub> will fail if the two feature structures share a path <a href="#id25"><span class="problematic" id="id26">|pi|</span></a>,
but the value of <a href="#id27"><span class="problematic" id="id28">|pi|</span></a> in <span class="formula"><i>FS</i></span>
<sub>0</sub> is a distinct
atom from the value of <a href="#id29"><span class="problematic" id="id30">|pi|</span></a> in <span class="formula"><i>FS</i></span>
<sub>1</sub>. In NLTK,
this is implemented by setting the result of unification to be
<tt class="docutils literal">None</tt>.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; fs0 = nltk.FeatStruct(A='a')
&gt;&gt;&gt; fs1 = nltk.FeatStruct(A='b')
&gt;&gt;&gt; print(nltk.unify(fs0, fs1))
None
</pre>
</blockquote>
<p>Now, if we look at how unification interacts with structure-sharing,
things become really interesting.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; fs0 = nltk.FeatStruct(&quot;&quot;&quot;[NAME=Lee,
...                                ADDRESS=[NUMBER=74,
...                                         STREET='rue Pascal'],
...                                SPOUSE= [NAME=Kim,
...                                         ADDRESS=[NUMBER=74,
...                                                  STREET='rue Pascal']]]&quot;&quot;&quot;)
&gt;&gt;&gt; print(fs0)
[ ADDRESS = [ NUMBER = 74           ]               ]
[           [ STREET = 'rue Pascal' ]               ]
[                                                   ]
[ NAME    = 'Lee'                                   ]
[                                                   ]
[           [ ADDRESS = [ NUMBER = 74           ] ] ]
[ SPOUSE  = [           [ STREET = 'rue Pascal' ] ] ]
[           [                                     ] ]
[           [ NAME    = 'Kim'                     ] ]
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; fs1 = nltk.FeatStruct(&quot;[SPOUSE=[ADDRESS=[CITY=Paris]]]&quot;)
&gt;&gt;&gt; print(nltk.unify(fs0, fs1))
[ ADDRESS = [ NUMBER = 74           ]               ]
[           [ STREET = 'rue Pascal' ]               ]
[                                                   ]
[ NAME    = 'Lee'                                   ]
[                                                   ]
[           [           [ CITY   = 'Paris'      ] ] ]
[           [ ADDRESS = [ NUMBER = 74           ] ] ]
[ SPOUSE  = [           [ STREET = 'rue Pascal' ] ] ]
[           [                                     ] ]
[           [ NAME    = 'Kim'                     ] ]
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; fs2 = nltk.FeatStruct(&quot;&quot;&quot;[NAME=Lee, ADDRESS=(1)[NUMBER=74, STREET='rue Pascal'],
...                                SPOUSE=[NAME=Kim, ADDRESS-&gt;(1)]]&quot;&quot;&quot;)
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; print(fs2)
[ ADDRESS = (1) [ NUMBER = 74           ] ]
[               [ STREET = 'rue Pascal' ] ]
[                                         ]
[ NAME    = 'Lee'                         ]
[                                         ]
[ SPOUSE  = [ ADDRESS -&gt; (1)  ]           ]
[           [ NAME    = 'Kim' ]           ]
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; print(nltk.unify(fs2, fs1))
[               [ CITY   = 'Paris'      ] ]
[ ADDRESS = (1) [ NUMBER = 74           ] ]
[               [ STREET = 'rue Pascal' ] ]
[                                         ]
[ NAME    = 'Lee'                         ]
[                                         ]
[ SPOUSE  = [ ADDRESS -&gt; (1)  ]           ]
[           [ NAME    = 'Kim' ]           ]
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; fs1 = nltk.FeatStruct(&quot;[ADDRESS1=[NUMBER=74, STREET='rue Pascal']]&quot;)
&gt;&gt;&gt; fs2 = nltk.FeatStruct(&quot;[ADDRESS1=?x, ADDRESS2=?x]&quot;)
&gt;&gt;&gt; print(fs2)
[ ADDRESS1 = ?x ]
[ ADDRESS2 = ?x ]
&gt;&gt;&gt; print(nltk.unify(fs1, fs2))
[ ADDRESS1 = (1) [ NUMBER = 74           ] ]
[                [ STREET = 'rue Pascal' ] ]
[                                          ]
[ ADDRESS2 -&gt; (1)                          ]
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; sent = 'who do you claim that you like'
&gt;&gt;&gt; tokens = sent.split()
&gt;&gt;&gt; cp = parse.load_parser('grammars/book_grammars/feat1.fcfg', trace=1)
&gt;&gt;&gt; trees = cp.nbest_parse(tokens)
|.w.d.y.c.t.y.l.|
|[-] . . . . . .| [0:1] 'who'
|. [-] . . . . .| [1:2] 'do'
|. . [-] . . . .| [2:3] 'you'
|. . . [-] . . .| [3:4] 'claim'
|. . . . [-] . .| [4:5] 'that'
|. . . . . [-] .| [5:6] 'you'
|. . . . . . [-]| [6:7] 'like'
|# . . . . . . .| [0:0] NP[]/NP[] -&gt; *
|. # . . . . . .| [1:1] NP[]/NP[] -&gt; *
|. . # . . . . .| [2:2] NP[]/NP[] -&gt; *
|. . . # . . . .| [3:3] NP[]/NP[] -&gt; *
|. . . . # . . .| [4:4] NP[]/NP[] -&gt; *
|. . . . . # . .| [5:5] NP[]/NP[] -&gt; *
|. . . . . . # .| [6:6] NP[]/NP[] -&gt; *
|. . . . . . . #| [7:7] NP[]/NP[] -&gt; *
|[-] . . . . . .| [0:1] NP[+WH] -&gt; 'who' *
|[-&gt; . . . . . .| [0:1] S[-INV] -&gt; NP[] * VP[] {}
|[-&gt; . . . . . .| [0:1] S[-INV]/?x[] -&gt; NP[] * VP[]/?x[] {}
|[-&gt; . . . . . .| [0:1] S[-INV] -&gt; NP[] * S[]/NP[] {}
|. [-] . . . . .| [1:2] V[+AUX] -&gt; 'do' *
|. [-&gt; . . . . .| [1:2] S[+INV] -&gt; V[+AUX] * NP[] VP[] {}
|. [-&gt; . . . . .| [1:2] S[+INV]/?x[] -&gt; V[+AUX] * NP[] VP[]/?x[] {}
|. [-&gt; . . . . .| [1:2] VP[] -&gt; V[+AUX] * VP[] {}
|. [-&gt; . . . . .| [1:2] VP[]/?x[] -&gt; V[+AUX] * VP[]/?x[] {}
|. . [-] . . . .| [2:3] NP[-WH] -&gt; 'you' *
|. . [-&gt; . . . .| [2:3] S[-INV] -&gt; NP[] * VP[] {}
|. . [-&gt; . . . .| [2:3] S[-INV]/?x[] -&gt; NP[] * VP[]/?x[] {}
|. . [-&gt; . . . .| [2:3] S[-INV] -&gt; NP[] * S[]/NP[] {}
|. [---&gt; . . . .| [1:3] S[+INV] -&gt; V[+AUX] NP[] * VP[] {}
|. [---&gt; . . . .| [1:3] S[+INV]/?x[] -&gt; V[+AUX] NP[] * VP[]/?x[] {}
|. . . [-] . . .| [3:4] V[-AUX, SUBCAT='clause'] -&gt; 'claim' *
|. . . [-&gt; . . .| [3:4] VP[] -&gt; V[-AUX, SUBCAT='clause'] * SBar[] {}
|. . . [-&gt; . . .| [3:4] VP[]/?x[] -&gt; V[-AUX, SUBCAT='clause'] * SBar[]/?x[] {}
|. . . . [-] . .| [4:5] Comp[] -&gt; 'that' *
|. . . . [-&gt; . .| [4:5] SBar[] -&gt; Comp[] * S[-INV] {}
|. . . . [-&gt; . .| [4:5] SBar[]/?x[] -&gt; Comp[] * S[-INV]/?x[] {}
|. . . . . [-] .| [5:6] NP[-WH] -&gt; 'you' *
|. . . . . [-&gt; .| [5:6] S[-INV] -&gt; NP[] * VP[] {}
|. . . . . [-&gt; .| [5:6] S[-INV]/?x[] -&gt; NP[] * VP[]/?x[] {}
|. . . . . [-&gt; .| [5:6] S[-INV] -&gt; NP[] * S[]/NP[] {}
|. . . . . . [-]| [6:7] V[-AUX, SUBCAT='trans'] -&gt; 'like' *
|. . . . . . [-&gt;| [6:7] VP[] -&gt; V[-AUX, SUBCAT='trans'] * NP[] {}
|. . . . . . [-&gt;| [6:7] VP[]/?x[] -&gt; V[-AUX, SUBCAT='trans'] * NP[]/?x[] {}
|. . . . . . [-]| [6:7] VP[]/NP[] -&gt; V[-AUX, SUBCAT='trans'] NP[]/NP[] *
|. . . . . [---]| [5:7] S[-INV]/NP[] -&gt; NP[] VP[]/NP[] *
|. . . . [-----]| [4:7] SBar[]/NP[] -&gt; Comp[] S[-INV]/NP[] *
|. . . [-------]| [3:7] VP[]/NP[] -&gt; V[-AUX, SUBCAT='clause'] SBar[]/NP[] *
|. . [---------]| [2:7] S[-INV]/NP[] -&gt; NP[] VP[]/NP[] *
|. [-----------]| [1:7] S[+INV]/NP[] -&gt; V[+AUX] NP[] VP[]/NP[] *
|[=============]| [0:7] S[-INV] -&gt; NP[] S[]/NP[] *
&gt;&gt;&gt; for tree in trees: print(tree)
(S[-INV]
  (NP[+WH] who)
  (S[+INV]/NP[]
    (V[+AUX] do)
    (NP[-WH] you)
    (VP[]/NP[]
      (V[-AUX, SUBCAT='clause'] claim)
      (SBar[]/NP[]
        (Comp[] that)
        (S[-INV]/NP[]
          (NP[-WH] you)
          (VP[]/NP[] (V[-AUX, SUBCAT='trans'] like) (NP[]/NP[] )))))))
</pre>
</blockquote>
<p>A different parser should give the same parse trees, but perhaps in a different order:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; cp2 = parse.load_parser('grammars/book_grammars/feat1.fcfg', trace=1,
...                         parser=parse.FeatureEarleyChartParser)
&gt;&gt;&gt; trees2 = cp2.nbest_parse(tokens)
|.w.d.y.c.t.y.l.|
|[-] . . . . . .| [0:1] 'who'
|. [-] . . . . .| [1:2] 'do'
|. . [-] . . . .| [2:3] 'you'
|. . . [-] . . .| [3:4] 'claim'
|. . . . [-] . .| [4:5] 'that'
|. . . . . [-] .| [5:6] 'you'
|. . . . . . [-]| [6:7] 'like'
|&gt; . . . . . . .| [0:0] S[-INV] -&gt; * NP[] VP[] {}
|&gt; . . . . . . .| [0:0] S[-INV]/?x[] -&gt; * NP[] VP[]/?x[] {}
|&gt; . . . . . . .| [0:0] S[-INV] -&gt; * NP[] S[]/NP[] {}
|&gt; . . . . . . .| [0:0] S[-INV] -&gt; * Adv[+NEG] S[+INV] {}
|&gt; . . . . . . .| [0:0] S[+INV] -&gt; * V[+AUX] NP[] VP[] {}
|&gt; . . . . . . .| [0:0] S[+INV]/?x[] -&gt; * V[+AUX] NP[] VP[]/?x[] {}
|&gt; . . . . . . .| [0:0] NP[+WH] -&gt; * 'who' {}
|[-] . . . . . .| [0:1] NP[+WH] -&gt; 'who' *
|[-&gt; . . . . . .| [0:1] S[-INV] -&gt; NP[] * VP[] {}
|[-&gt; . . . . . .| [0:1] S[-INV]/?x[] -&gt; NP[] * VP[]/?x[] {}
|[-&gt; . . . . . .| [0:1] S[-INV] -&gt; NP[] * S[]/NP[] {}
|. &gt; . . . . . .| [1:1] S[-INV]/?x[] -&gt; * NP[] VP[]/?x[] {}
|. &gt; . . . . . .| [1:1] S[+INV]/?x[] -&gt; * V[+AUX] NP[] VP[]/?x[] {}
|. &gt; . . . . . .| [1:1] V[+AUX] -&gt; * 'do' {}
|. &gt; . . . . . .| [1:1] VP[]/?x[] -&gt; * V[-AUX, SUBCAT='trans'] NP[]/?x[] {}
|. &gt; . . . . . .| [1:1] VP[]/?x[] -&gt; * V[-AUX, SUBCAT='clause'] SBar[]/?x[] {}
|. &gt; . . . . . .| [1:1] VP[]/?x[] -&gt; * V[+AUX] VP[]/?x[] {}
|. &gt; . . . . . .| [1:1] VP[] -&gt; * V[-AUX, SUBCAT='intrans'] {}
|. &gt; . . . . . .| [1:1] VP[] -&gt; * V[-AUX, SUBCAT='trans'] NP[] {}
|. &gt; . . . . . .| [1:1] VP[] -&gt; * V[-AUX, SUBCAT='clause'] SBar[] {}
|. &gt; . . . . . .| [1:1] VP[] -&gt; * V[+AUX] VP[] {}
|. [-] . . . . .| [1:2] V[+AUX] -&gt; 'do' *
|. [-&gt; . . . . .| [1:2] S[+INV]/?x[] -&gt; V[+AUX] * NP[] VP[]/?x[] {}
|. [-&gt; . . . . .| [1:2] VP[]/?x[] -&gt; V[+AUX] * VP[]/?x[] {}
|. [-&gt; . . . . .| [1:2] VP[] -&gt; V[+AUX] * VP[] {}
|. . &gt; . . . . .| [2:2] VP[] -&gt; * V[-AUX, SUBCAT='intrans'] {}
|. . &gt; . . . . .| [2:2] VP[] -&gt; * V[-AUX, SUBCAT='trans'] NP[] {}
|. . &gt; . . . . .| [2:2] VP[] -&gt; * V[-AUX, SUBCAT='clause'] SBar[] {}
|. . &gt; . . . . .| [2:2] VP[] -&gt; * V[+AUX] VP[] {}
|. . &gt; . . . . .| [2:2] VP[]/?x[] -&gt; * V[-AUX, SUBCAT='trans'] NP[]/?x[] {}
|. . &gt; . . . . .| [2:2] VP[]/?x[] -&gt; * V[-AUX, SUBCAT='clause'] SBar[]/?x[] {}
|. . &gt; . . . . .| [2:2] VP[]/?x[] -&gt; * V[+AUX] VP[]/?x[] {}
|. . &gt; . . . . .| [2:2] NP[-WH] -&gt; * 'you' {}
|. . [-] . . . .| [2:3] NP[-WH] -&gt; 'you' *
|. [---&gt; . . . .| [1:3] S[+INV]/?x[] -&gt; V[+AUX] NP[] * VP[]/?x[] {}
|. . . &gt; . . . .| [3:3] VP[]/?x[] -&gt; * V[-AUX, SUBCAT='trans'] NP[]/?x[] {}
|. . . &gt; . . . .| [3:3] VP[]/?x[] -&gt; * V[-AUX, SUBCAT='clause'] SBar[]/?x[] {}
|. . . &gt; . . . .| [3:3] VP[]/?x[] -&gt; * V[+AUX] VP[]/?x[] {}
|. . . &gt; . . . .| [3:3] V[-AUX, SUBCAT='clause'] -&gt; * 'claim' {}
|. . . [-] . . .| [3:4] V[-AUX, SUBCAT='clause'] -&gt; 'claim' *
|. . . [-&gt; . . .| [3:4] VP[]/?x[] -&gt; V[-AUX, SUBCAT='clause'] * SBar[]/?x[] {}
|. . . . &gt; . . .| [4:4] SBar[]/?x[] -&gt; * Comp[] S[-INV]/?x[] {}
|. . . . &gt; . . .| [4:4] Comp[] -&gt; * 'that' {}
|. . . . [-] . .| [4:5] Comp[] -&gt; 'that' *
|. . . . [-&gt; . .| [4:5] SBar[]/?x[] -&gt; Comp[] * S[-INV]/?x[] {}
|. . . . . &gt; . .| [5:5] S[-INV]/?x[] -&gt; * NP[] VP[]/?x[] {}
|. . . . . &gt; . .| [5:5] NP[-WH] -&gt; * 'you' {}
|. . . . . [-] .| [5:6] NP[-WH] -&gt; 'you' *
|. . . . . [-&gt; .| [5:6] S[-INV]/?x[] -&gt; NP[] * VP[]/?x[] {}
|. . . . . . &gt; .| [6:6] VP[]/?x[] -&gt; * V[-AUX, SUBCAT='trans'] NP[]/?x[] {}
|. . . . . . &gt; .| [6:6] VP[]/?x[] -&gt; * V[-AUX, SUBCAT='clause'] SBar[]/?x[] {}
|. . . . . . &gt; .| [6:6] VP[]/?x[] -&gt; * V[+AUX] VP[]/?x[] {}
|. . . . . . &gt; .| [6:6] V[-AUX, SUBCAT='trans'] -&gt; * 'like' {}
|. . . . . . [-]| [6:7] V[-AUX, SUBCAT='trans'] -&gt; 'like' *
|. . . . . . [-&gt;| [6:7] VP[]/?x[] -&gt; V[-AUX, SUBCAT='trans'] * NP[]/?x[] {}
|. . . . . . . #| [7:7] NP[]/NP[] -&gt; *
|. . . . . . [-]| [6:7] VP[]/NP[] -&gt; V[-AUX, SUBCAT='trans'] NP[]/NP[] *
|. . . . . [---]| [5:7] S[-INV]/NP[] -&gt; NP[] VP[]/NP[] *
|. . . . [-----]| [4:7] SBar[]/NP[] -&gt; Comp[] S[-INV]/NP[] *
|. . . [-------]| [3:7] VP[]/NP[] -&gt; V[-AUX, SUBCAT='clause'] SBar[]/NP[] *
|. [-----------]| [1:7] S[+INV]/NP[] -&gt; V[+AUX] NP[] VP[]/NP[] *
|[=============]| [0:7] S[-INV] -&gt; NP[] S[]/NP[] *
&gt;&gt;&gt; sorted(trees) == sorted(trees2)
True
</pre>
</blockquote>
<p>Let's load a German grammar:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; cp = parse.load_parser('grammars/book_grammars/german.fcfg', trace=0)
&gt;&gt;&gt; sent = 'die Katze sieht den Hund'
&gt;&gt;&gt; tokens = sent.split()
&gt;&gt;&gt; trees = cp.nbest_parse(tokens)
&gt;&gt;&gt; for tree in trees: print(tree)
(S[]
  (NP[AGR=[GND='fem', NUM='sg', PER=3], CASE='nom']
    (Det[AGR=[GND='fem', NUM='sg', PER=3], CASE='nom'] die)
    (N[AGR=[GND='fem', NUM='sg', PER=3]] Katze))
  (VP[AGR=[NUM='sg', PER=3]]
    (TV[AGR=[NUM='sg', PER=3], OBJCASE='acc'] sieht)
    (NP[AGR=[GND='masc', NUM='sg', PER=3], CASE='acc']
      (Det[AGR=[GND='masc', NUM='sg', PER=3], CASE='acc'] den)
      (N[AGR=[GND='masc', NUM='sg', PER=3]] Hund))))
</pre>
</blockquote>
</div>
<div class="section" id="grammar-with-binding-operators">
<h1>Grammar with Binding Operators</h1>
<p>The <a class="reference external" href="http://nltk.svn.sourceforge.net/svnroot/nltk/trunk/nltk/data/grammars/bindop.fcfg">bindop.fcfg</a> grammar is a semantic grammar that uses lambda
calculus.  Each element has a core semantics, which is a single lambda
calculus expression; and a set of binding operators, which bind
variables.</p>
<p>In order to make the binding operators work right, they need to
instantiate their bound variable every time they are added to the
chart.  To do this, we use a special subclass of <cite>Chart</cite>, called
<cite>InstantiateVarsChart</cite>.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from nltk.parse.featurechart import InstantiateVarsChart
&gt;&gt;&gt; cp = parse.load_parser('grammars/sample_grammars/bindop.fcfg', trace=1,
...                        chart_class=InstantiateVarsChart)
&gt;&gt;&gt; print(cp.grammar())
Grammar with 15 productions (start state = S[])
    S[SEM=[BO={?b1+?b2}, CORE=&lt;?vp(?subj)&gt;]] -&gt; NP[SEM=[BO=?b1, CORE=?subj]] VP[SEM=[BO=?b2, CORE=?vp]]
    VP[SEM=[BO={?b1+?b2}, CORE=&lt;?v(?obj)&gt;]] -&gt; TV[SEM=[BO=?b1, CORE=?v]] NP[SEM=[BO=?b2, CORE=?obj]]
    VP[SEM=?s] -&gt; IV[SEM=?s]
    NP[SEM=[BO={?b1+?b2+{bo(?det(?n),&#64;x)}}, CORE=&lt;&#64;x&gt;]] -&gt; Det[SEM=[BO=?b1, CORE=?det]] N[SEM=[BO=?b2, CORE=?n]]
    Det[SEM=[BO={/}, CORE=&lt;\Q P.exists x.(Q(x) &amp; P(x))&gt;]] -&gt; 'a'
    N[SEM=[BO={/}, CORE=&lt;dog&gt;]] -&gt; 'dog'
    N[SEM=[BO={/}, CORE=&lt;dog&gt;]] -&gt; 'cat'
    N[SEM=[BO={/}, CORE=&lt;dog&gt;]] -&gt; 'mouse'
    IV[SEM=[BO={/}, CORE=&lt;\x.bark(x)&gt;]] -&gt; 'barks'
    IV[SEM=[BO={/}, CORE=&lt;\x.bark(x)&gt;]] -&gt; 'eats'
    IV[SEM=[BO={/}, CORE=&lt;\x.bark(x)&gt;]] -&gt; 'walks'
    TV[SEM=[BO={/}, CORE=&lt;\x y.feed(y,x)&gt;]] -&gt; 'feeds'
    TV[SEM=[BO={/}, CORE=&lt;\x y.feed(y,x)&gt;]] -&gt; 'walks'
    NP[SEM=[BO={bo(\P.P(John),&#64;x)}, CORE=&lt;&#64;x&gt;]] -&gt; 'john'
    NP[SEM=[BO={bo(\P.P(John),&#64;x)}, CORE=&lt;&#64;x&gt;]] -&gt; 'alex'
</pre>
</blockquote>
<p>A simple intransitive sentence:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from nltk.sem import logic
&gt;&gt;&gt; logic._counter._value = 100
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; trees = cp.nbest_parse('john barks'.split())
|. john.barks.|
|[-----]     .| [0:1] 'john'
|.     [-----]| [1:2] 'barks'
|[-----]     .| [0:1] NP[SEM=[BO={bo(\P.P(John),z101)}, CORE=&lt;z101&gt;]] -&gt; 'john' *
|[-----&gt;     .| [0:1] S[SEM=[BO={?b1+?b2}, CORE=&lt;?vp(?subj)&gt;]] -&gt; NP[SEM=[BO=?b1, CORE=?subj]] * VP[SEM=[BO=?b2, CORE=?vp]] {?b1: {bo(\P.P(John),z2)}, ?subj: &lt;IndividualVariableExpression z2&gt;}
|.     [-----]| [1:2] IV[SEM=[BO={/}, CORE=&lt;\x.bark(x)&gt;]] -&gt; 'barks' *
|.     [-----]| [1:2] VP[SEM=[BO={/}, CORE=&lt;\x.bark(x)&gt;]] -&gt; IV[SEM=[BO={/}, CORE=&lt;\x.bark(x)&gt;]] *
|[===========]| [0:2] S[SEM=[BO={bo(\P.P(John),z2)}, CORE=&lt;bark(z2)&gt;]] -&gt; NP[SEM=[BO={bo(\P.P(John),z2)}, CORE=&lt;z2&gt;]] VP[SEM=[BO={/}, CORE=&lt;\x.bark(x)&gt;]] *
&gt;&gt;&gt; for tree in trees: print(tree)
(S[SEM=[BO={bo(\P.P(John),z2)}, CORE=&lt;bark(z2)&gt;]]
  (NP[SEM=[BO={bo(\P.P(John),z101)}, CORE=&lt;z101&gt;]] john)
  (VP[SEM=[BO={/}, CORE=&lt;\x.bark(x)&gt;]]
    (IV[SEM=[BO={/}, CORE=&lt;\x.bark(x)&gt;]] barks)))
</pre>
</blockquote>
<p>A transitive sentence:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; trees = cp.nbest_parse('john feeds a dog'.split())
|.joh.fee. a .dog.|
|[---]   .   .   .| [0:1] 'john'
|.   [---]   .   .| [1:2] 'feeds'
|.   .   [---]   .| [2:3] 'a'
|.   .   .   [---]| [3:4] 'dog'
|[---]   .   .   .| [0:1] NP[SEM=[BO={bo(\P.P(John),z102)}, CORE=&lt;z102&gt;]] -&gt; 'john' *
|[---&gt;   .   .   .| [0:1] S[SEM=[BO={?b1+?b2}, CORE=&lt;?vp(?subj)&gt;]] -&gt; NP[SEM=[BO=?b1, CORE=?subj]] * VP[SEM=[BO=?b2, CORE=?vp]] {?b1: {bo(\P.P(John),z2)}, ?subj: &lt;IndividualVariableExpression z2&gt;}
|.   [---]   .   .| [1:2] TV[SEM=[BO={/}, CORE=&lt;\x y.feed(y,x)&gt;]] -&gt; 'feeds' *
|.   [---&gt;   .   .| [1:2] VP[SEM=[BO={?b1+?b2}, CORE=&lt;?v(?obj)&gt;]] -&gt; TV[SEM=[BO=?b1, CORE=?v]] * NP[SEM=[BO=?b2, CORE=?obj]] {?b1: {/}, ?v: &lt;LambdaExpression \x y.feed(y,x)&gt;}
|.   .   [---]   .| [2:3] Det[SEM=[BO={/}, CORE=&lt;\Q P.exists x.(Q(x) &amp; P(x))&gt;]] -&gt; 'a' *
|.   .   [---&gt;   .| [2:3] NP[SEM=[BO={?b1+?b2+{bo(?det(?n),&#64;x)}}, CORE=&lt;&#64;x&gt;]] -&gt; Det[SEM=[BO=?b1, CORE=?det]] * N[SEM=[BO=?b2, CORE=?n]] {?b1: {/}, ?det: &lt;LambdaExpression \Q P.exists x.(Q(x) &amp; P(x))&gt;}
|.   .   .   [---]| [3:4] N[SEM=[BO={/}, CORE=&lt;dog&gt;]] -&gt; 'dog' *
|.   .   [-------]| [2:4] NP[SEM=[BO={bo(\P.exists x.(dog(x) &amp; P(x)),z103)}, CORE=&lt;z103&gt;]] -&gt; Det[SEM=[BO={/}, CORE=&lt;\Q P.exists x.(Q(x) &amp; P(x))&gt;]] N[SEM=[BO={/}, CORE=&lt;dog&gt;]] *
|.   .   [-------&gt;| [2:4] S[SEM=[BO={?b1+?b2}, CORE=&lt;?vp(?subj)&gt;]] -&gt; NP[SEM=[BO=?b1, CORE=?subj]] * VP[SEM=[BO=?b2, CORE=?vp]] {?b1: {bo(\P.exists x.(dog(x) &amp; P(x)),z2)}, ?subj: &lt;IndividualVariableExpression z2&gt;}
|.   [-----------]| [1:4] VP[SEM=[BO={bo(\P.exists x.(dog(x) &amp; P(x)),z2)}, CORE=&lt;\y.feed(y,z2)&gt;]] -&gt; TV[SEM=[BO={/}, CORE=&lt;\x y.feed(y,x)&gt;]] NP[SEM=[BO={bo(\P.exists x.(dog(x) &amp; P(x)),z2)}, CORE=&lt;z2&gt;]] *
|[===============]| [0:4] S[SEM=[BO={bo(\P.P(John),z2), bo(\P.exists x.(dog(x) &amp; P(x)),z3)}, CORE=&lt;feed(z2,z3)&gt;]] -&gt; NP[SEM=[BO={bo(\P.P(John),z2)}, CORE=&lt;z2&gt;]] VP[SEM=[BO={bo(\P.exists x.(dog(x) &amp; P(x)),z3)}, CORE=&lt;\y.feed(y,z3)&gt;]] *
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; for tree in trees: print(tree)
(S[SEM=[BO={bo(\P.P(John),z2), bo(\P.exists x.(dog(x) &amp; P(x)),z3)}, CORE=&lt;feed(z2,z3)&gt;]]
  (NP[SEM=[BO={bo(\P.P(John),z102)}, CORE=&lt;z102&gt;]] john)
  (VP[SEM=[BO={bo(\P.exists x.(dog(x) &amp; P(x)),z2)}, CORE=&lt;\y.feed(y,z2)&gt;]]
    (TV[SEM=[BO={/}, CORE=&lt;\x y.feed(y,x)&gt;]] feeds)
    (NP[SEM=[BO={bo(\P.exists x.(dog(x) &amp; P(x)),z103)}, CORE=&lt;z103&gt;]]
      (Det[SEM=[BO={/}, CORE=&lt;\Q P.exists x.(Q(x) &amp; P(x))&gt;]] a)
      (N[SEM=[BO={/}, CORE=&lt;dog&gt;]] dog))))
</pre>
</blockquote>
<p>Turn down the verbosity:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; cp = parse.load_parser('grammars/sample_grammars/bindop.fcfg', trace=0,
...                       chart_class=InstantiateVarsChart)
</pre>
</blockquote>
<p>Reuse the same lexical item twice:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; trees = cp.nbest_parse('john feeds john'.split())
&gt;&gt;&gt; for tree in trees: print(tree)
(S[SEM=[BO={bo(\P.P(John),z2), bo(\P.P(John),z3)}, CORE=&lt;feed(z2,z3)&gt;]]
  (NP[SEM=[BO={bo(\P.P(John),z104)}, CORE=&lt;z104&gt;]] john)
  (VP[SEM=[BO={bo(\P.P(John),z2)}, CORE=&lt;\y.feed(y,z2)&gt;]]
    (TV[SEM=[BO={/}, CORE=&lt;\x y.feed(y,x)&gt;]] feeds)
    (NP[SEM=[BO={bo(\P.P(John),z105)}, CORE=&lt;z105&gt;]] john)))
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; trees = cp.nbest_parse('a dog feeds a dog'.split())
&gt;&gt;&gt; for tree in trees: print(tree)
(S[SEM=[BO={bo(\P.exists x.(dog(x) &amp; P(x)),z2), bo(\P.exists x.(dog(x) &amp; P(x)),z3)}, CORE=&lt;feed(z2,z3)&gt;]]
  (NP[SEM=[BO={bo(\P.exists x.(dog(x) &amp; P(x)),z106)}, CORE=&lt;z106&gt;]]
    (Det[SEM=[BO={/}, CORE=&lt;\Q P.exists x.(Q(x) &amp; P(x))&gt;]] a)
    (N[SEM=[BO={/}, CORE=&lt;dog&gt;]] dog))
  (VP[SEM=[BO={bo(\P.exists x.(dog(x) &amp; P(x)),z2)}, CORE=&lt;\y.feed(y,z2)&gt;]]
    (TV[SEM=[BO={/}, CORE=&lt;\x y.feed(y,x)&gt;]] feeds)
    (NP[SEM=[BO={bo(\P.exists x.(dog(x) &amp; P(x)),z107)}, CORE=&lt;z107&gt;]]
      (Det[SEM=[BO={/}, CORE=&lt;\Q P.exists x.(Q(x) &amp; P(x))&gt;]] a)
      (N[SEM=[BO={/}, CORE=&lt;dog&gt;]] dog))))
</pre>
</blockquote>
</div>
<div class="system-messages section">
<h1>Docutils System Messages</h1>
<div class="system-message" id="id19">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">featgram.doctest</tt>, line 109); <em><a href="#id20">backlink</a></em></p>
Undefined substitution referenced: &quot;rarr&quot;.</div>
<div class="system-message" id="id21">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">featgram.doctest</tt>, line 109); <em><a href="#id22">backlink</a></em></p>
Undefined substitution referenced: &quot;rarr&quot;.</div>
<div class="system-message" id="id23">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">featgram.doctest</tt>, line 109); <em><a href="#id24">backlink</a></em></p>
Undefined substitution referenced: &quot;dot&quot;.</div>
<div class="system-message" id="id25">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">featgram.doctest</tt>, line 243); <em><a href="#id26">backlink</a></em></p>
Undefined substitution referenced: &quot;pi&quot;.</div>
<div class="system-message" id="id27">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">featgram.doctest</tt>, line 243); <em><a href="#id28">backlink</a></em></p>
Undefined substitution referenced: &quot;pi&quot;.</div>
<div class="system-message" id="id29">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">featgram.doctest</tt>, line 243); <em><a href="#id30">backlink</a></em></p>
Undefined substitution referenced: &quot;pi&quot;.</div>
</div>
</div>
</body>
</html>
