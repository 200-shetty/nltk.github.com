<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.12: http://docutils.sourceforge.net/" />
<title>Logic &amp; Lambda Calculus</title>
<style type="text/css">

/*
:Author: David Goodger (goodger@python.org)
:Id: $Id: html4css1.css 7614 2013-02-21 15:55:51Z milde $
:Copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.

See http://docutils.sf.net/docs/howto/html-stylesheets.html for how to
customize this style sheet.
*/

/* used to remove borders from tables and images */
.borderless, table.borderless td, table.borderless th {
  border: 0 }

table.borderless td, table.borderless th {
  /* Override padding for "table.docutils td" with "! important".
     The right padding separates the table cells. */
  padding: 0 0.5em 0 0 ! important }

.first {
  /* Override more specific margin styles with "! important". */
  margin-top: 0 ! important }

.last, .with-subtitle {
  margin-bottom: 0 ! important }

.hidden {
  display: none }

a.toc-backref {
  text-decoration: none ;
  color: black }

blockquote.epigraph {
  margin: 2em 5em ; }

dl.docutils dd {
  margin-bottom: 0.5em }

object[type="image/svg+xml"], object[type="application/x-shockwave-flash"] {
  overflow: hidden;
}

/* Uncomment (and remove this text!) to get bold-faced definition list terms
dl.docutils dt {
  font-weight: bold }
*/

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.admonition, div.attention, div.caution, div.danger, div.error,
div.hint, div.important, div.note, div.tip, div.warning {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.admonition p.admonition-title, div.hint p.admonition-title,
div.important p.admonition-title, div.note p.admonition-title,
div.tip p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title, .code .error {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

/* Uncomment (and remove this text!) to get reduced vertical space in
   compound paragraphs.
div.compound .compound-first, div.compound .compound-middle {
  margin-bottom: 0.5em }

div.compound .compound-last, div.compound .compound-middle {
  margin-top: 0.5em }
*/

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em ;
  margin-right: 2em }

div.footer, div.header {
  clear: both;
  font-size: smaller }

div.line-block {
  display: block ;
  margin-top: 1em ;
  margin-bottom: 1em }

div.line-block div.line-block {
  margin-top: 0 ;
  margin-bottom: 0 ;
  margin-left: 1.5em }

div.sidebar {
  margin: 0 0 0.5em 1em ;
  border: medium outset ;
  padding: 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.section-subtitle, h2.section-subtitle, h3.section-subtitle,
h4.section-subtitle, h5.section-subtitle, h6.section-subtitle {
  margin-top: 0.4em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

hr.docutils {
  width: 75% }

img.align-left, .figure.align-left, object.align-left {
  clear: left ;
  float: left ;
  margin-right: 1em }

img.align-right, .figure.align-right, object.align-right {
  clear: right ;
  float: right ;
  margin-left: 1em }

img.align-center, .figure.align-center, object.align-center {
  display: block;
  margin-left: auto;
  margin-right: auto;
}

.align-left {
  text-align: left }

.align-center {
  clear: both ;
  text-align: center }

.align-right {
  text-align: right }

/* reset inner alignment in figures */
div.align-right {
  text-align: inherit }

/* div.align-center * { */
/*   text-align: left } */

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font: inherit }

pre.literal-block, pre.doctest-block, pre.math, pre.code {
  margin-left: 2em ;
  margin-right: 2em }

pre.code .ln { color: grey; } /* line numbers */
pre.code, code { background-color: #eeeeee }
pre.code .comment, code .comment { color: #5C6576 }
pre.code .keyword, code .keyword { color: #3B0D06; font-weight: bold }
pre.code .literal.string, code .literal.string { color: #0C5404 }
pre.code .name.builtin, code .name.builtin { color: #352B84 }
pre.code .deleted, code .deleted { background-color: #DEB0A1}
pre.code .inserted, code .inserted { background-color: #A3D289}

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

span.section-subtitle {
  /* font-size relative to parent (h1..h6 element) */
  font-size: 80% }

table.citation {
  border-left: solid 1px gray;
  margin-left: 1px }

table.docinfo {
  margin: 2em 4em }

table.docutils {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.footnote {
  border-left: solid 1px black;
  margin-left: 1px }

table.docutils td, table.docutils th,
table.docinfo td, table.docinfo th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

table.docutils th.field-name, table.docinfo th.docinfo-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap ;
  padding-left: 0 }

/* "booktabs" style (no vertical lines) */
table.docutils.booktabs {
  border: 0px;
  border-top: 2px solid;
  border-bottom: 2px solid;
  border-collapse: collapse;
}
table.docutils.booktabs * {
  border: 0px;
}
table.docutils.booktabs th {
  border-bottom: thin solid;
  text-align: left;
}

h1 tt.docutils, h2 tt.docutils, h3 tt.docutils,
h4 tt.docutils, h5 tt.docutils, h6 tt.docutils {
  font-size: 100% }

ul.auto-toc {
  list-style-type: none }

</style>
</head>
<body>
<div class="document" id="logic-lambda-calculus">
<h1 class="title">Logic &amp; Lambda Calculus</h1>

<!-- Copyright (C) 2001-2015 NLTK Project -->
<!-- For license information, see LICENSE.TXT -->
<p>The <cite>nltk.logic</cite> package allows expressions of First-Order Logic (FOL) to be
parsed into <tt class="docutils literal">Expression</tt> objects. In addition to FOL, the parser
handles lambda-abstraction with variables of higher order.</p>
<div class="section" id="overview">
<h1>Overview</h1>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from nltk.sem.logic import *
</pre>
</blockquote>
<p>The default inventory of logical constants is the following:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; boolean_ops() # doctest: +NORMALIZE_WHITESPACE
negation           -
conjunction        &amp;
disjunction        |
implication        -&gt;
equivalence        &lt;-&gt;
&gt;&gt;&gt; equality_preds() # doctest: +NORMALIZE_WHITESPACE
equality           =
inequality         !=
&gt;&gt;&gt; binding_ops() # doctest: +NORMALIZE_WHITESPACE
existential        exists
universal          all
lambda             \
</pre>
</blockquote>
</div>
<div class="section" id="regression-tests">
<h1>Regression Tests</h1>
<div class="section" id="untyped-logic">
<h2>Untyped Logic</h2>
<p>Process logical expressions conveniently:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; read_expr = Expression.fromstring
</pre>
</blockquote>
<div class="section" id="test-for-equality-under-alpha-conversion">
<h3>Test for equality under alpha-conversion</h3>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; e1 = read_expr('exists x.P(x)')
&gt;&gt;&gt; print(e1)
exists x.P(x)
&gt;&gt;&gt; e2 = e1.alpha_convert(Variable('z'))
&gt;&gt;&gt; print(e2)
exists z.P(z)
&gt;&gt;&gt; e1 == e2
True
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; l = read_expr(r'\X.\X.X(X)(1)').simplify()
&gt;&gt;&gt; id = read_expr(r'\X.X(X)')
&gt;&gt;&gt; l == id
True
</pre>
</blockquote>
</div>
<div class="section" id="test-numerals">
<h3>Test numerals</h3>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; zero = read_expr(r'\F x.x')
&gt;&gt;&gt; one = read_expr(r'\F x.F(x)')
&gt;&gt;&gt; two = read_expr(r'\F x.F(F(x))')
&gt;&gt;&gt; three = read_expr(r'\F x.F(F(F(x)))')
&gt;&gt;&gt; four = read_expr(r'\F x.F(F(F(F(x))))')
&gt;&gt;&gt; succ = read_expr(r'\N F x.F(N(F,x))')
&gt;&gt;&gt; plus = read_expr(r'\M N F x.M(F,N(F,x))')
&gt;&gt;&gt; mult = read_expr(r'\M N F.M(N(F))')
&gt;&gt;&gt; pred = read_expr(r'\N F x.(N(\G H.H(G(F)))(\u.x)(\u.u))')
&gt;&gt;&gt; v1 = ApplicationExpression(succ, zero).simplify()
&gt;&gt;&gt; v1 == one
True
&gt;&gt;&gt; v2 = ApplicationExpression(succ, v1).simplify()
&gt;&gt;&gt; v2 == two
True
&gt;&gt;&gt; v3 = ApplicationExpression(ApplicationExpression(plus, v1), v2).simplify()
&gt;&gt;&gt; v3 == three
True
&gt;&gt;&gt; v4 = ApplicationExpression(ApplicationExpression(mult, v2), v2).simplify()
&gt;&gt;&gt; v4 == four
True
&gt;&gt;&gt; v5 = ApplicationExpression(pred, ApplicationExpression(pred, v4)).simplify()
&gt;&gt;&gt; v5 == two
True
</pre>
</blockquote>
<p>Overloaded operators also exist, for convenience.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; print(succ(zero).simplify() == one)
True
&gt;&gt;&gt; print(plus(one,two).simplify() == three)
True
&gt;&gt;&gt; print(mult(two,two).simplify() == four)
True
&gt;&gt;&gt; print(pred(pred(four)).simplify() == two)
True
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; john = read_expr(r'john')
&gt;&gt;&gt; man = read_expr(r'\x.man(x)')
&gt;&gt;&gt; walk = read_expr(r'\x.walk(x)')
&gt;&gt;&gt; man(john).simplify()
&lt;ApplicationExpression man(john)&gt;
&gt;&gt;&gt; print(-walk(john).simplify())
-walk(john)
&gt;&gt;&gt; print((man(john) &amp; walk(john)).simplify())
(man(john) &amp; walk(john))
&gt;&gt;&gt; print((man(john) | walk(john)).simplify())
(man(john) | walk(john))
&gt;&gt;&gt; print((man(john) &gt; walk(john)).simplify())
(man(john) -&gt; walk(john))
&gt;&gt;&gt; print((man(john) &lt; walk(john)).simplify())
(man(john) &lt;-&gt; walk(john))
</pre>
</blockquote>
<p>Python's built-in lambda operator can also be used with Expressions</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; john = VariableExpression(Variable('john'))
&gt;&gt;&gt; run_var = VariableExpression(Variable('run'))
&gt;&gt;&gt; run = lambda x: run_var(x)
&gt;&gt;&gt; run(john)
&lt;ApplicationExpression run(john)&gt;
</pre>
</blockquote>
<div class="section" id="betaconversiontestsuite-pl">
<h4><tt class="docutils literal">betaConversionTestSuite.pl</tt></h4>
<p>Tests based on Blackburn &amp; Bos' book, <em>Representation and Inference
for Natural Language</em>.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; x1 = read_expr(r'\P.P(mia)(\x.walk(x))').simplify()
&gt;&gt;&gt; x2 = read_expr(r'walk(mia)').simplify()
&gt;&gt;&gt; x1 == x2
True
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; x1 = read_expr(r'exists x.(man(x) &amp; ((\P.exists x.(woman(x) &amp; P(x)))(\y.love(x,y))))').simplify()
&gt;&gt;&gt; x2 = read_expr(r'exists x.(man(x) &amp; exists y.(woman(y) &amp; love(x,y)))').simplify()
&gt;&gt;&gt; x1 == x2
True
&gt;&gt;&gt; x1 = read_expr(r'\a.sleep(a)(mia)').simplify()
&gt;&gt;&gt; x2 = read_expr(r'sleep(mia)').simplify()
&gt;&gt;&gt; x1 == x2
True
&gt;&gt;&gt; x1 = read_expr(r'\a.\b.like(b,a)(mia)').simplify()
&gt;&gt;&gt; x2 = read_expr(r'\b.like(b,mia)').simplify()
&gt;&gt;&gt; x1 == x2
True
&gt;&gt;&gt; x1 = read_expr(r'\a.(\b.like(b,a)(vincent))').simplify()
&gt;&gt;&gt; x2 = read_expr(r'\a.like(vincent,a)').simplify()
&gt;&gt;&gt; x1 == x2
True
&gt;&gt;&gt; x1 = read_expr(r'\a.((\b.like(b,a)(vincent)) &amp; sleep(a))').simplify()
&gt;&gt;&gt; x2 = read_expr(r'\a.(like(vincent,a) &amp; sleep(a))').simplify()
&gt;&gt;&gt; x1 == x2
True
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; x1 = read_expr(r'(\a.\b.like(b,a)(mia)(vincent))').simplify()
&gt;&gt;&gt; x2 = read_expr(r'like(vincent,mia)').simplify()
&gt;&gt;&gt; x1 == x2
True
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; x1 = read_expr(r'P((\a.sleep(a)(vincent)))').simplify()
&gt;&gt;&gt; x2 = read_expr(r'P(sleep(vincent))').simplify()
&gt;&gt;&gt; x1 == x2
True
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; x1 = read_expr(r'\A.A((\b.sleep(b)(vincent)))').simplify()
&gt;&gt;&gt; x2 = read_expr(r'\A.A(sleep(vincent))').simplify()
&gt;&gt;&gt; x1 == x2
True
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; x1 = read_expr(r'\A.A(sleep(vincent))').simplify()
&gt;&gt;&gt; x2 = read_expr(r'\A.A(sleep(vincent))').simplify()
&gt;&gt;&gt; x1 == x2
True
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; x1 = read_expr(r'(\A.A(vincent)(\b.sleep(b)))').simplify()
&gt;&gt;&gt; x2 = read_expr(r'sleep(vincent)').simplify()
&gt;&gt;&gt; x1 == x2
True
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; x1 = read_expr(r'\A.believe(mia,A(vincent))(\b.sleep(b))').simplify()
&gt;&gt;&gt; x2 = read_expr(r'believe(mia,sleep(vincent))').simplify()
&gt;&gt;&gt; x1 == x2
True
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; x1 = read_expr(r'(\A.(A(vincent) &amp; A(mia)))(\b.sleep(b))').simplify()
&gt;&gt;&gt; x2 = read_expr(r'(sleep(vincent) &amp; sleep(mia))').simplify()
&gt;&gt;&gt; x1 == x2
True
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; x1 = read_expr(r'\A.\B.(\C.C(A(vincent))(\d.probably(d)) &amp; (\C.C(B(mia))(\d.improbably(d))))(\f.walk(f))(\f.talk(f))').simplify()
&gt;&gt;&gt; x2 = read_expr(r'(probably(walk(vincent)) &amp; improbably(talk(mia)))').simplify()
&gt;&gt;&gt; x1 == x2
True
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; x1 = read_expr(r'(\a.\b.(\C.C(a,b)(\d.\f.love(d,f))))(jules)(mia)').simplify()
&gt;&gt;&gt; x2 = read_expr(r'love(jules,mia)').simplify()
&gt;&gt;&gt; x1 == x2
True
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; x1 = read_expr(r'(\A.\B.exists c.(A(c) &amp; B(c)))(\d.boxer(d),\d.sleep(d))').simplify()
&gt;&gt;&gt; x2 = read_expr(r'exists c.(boxer(c) &amp; sleep(c))').simplify()
&gt;&gt;&gt; x1 == x2
True
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; x1 = read_expr(r'\A.Z(A)(\c.\a.like(a,c))').simplify()
&gt;&gt;&gt; x2 = read_expr(r'Z(\c.\a.like(a,c))').simplify()
&gt;&gt;&gt; x1 == x2
True
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; x1 = read_expr(r'\A.\b.A(b)(\c.\b.like(b,c))').simplify()
&gt;&gt;&gt; x2 = read_expr(r'\b.(\c.\b.like(b,c)(b))').simplify()
&gt;&gt;&gt; x1 == x2
True
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; x1 = read_expr(r'(\a.\b.(\C.C(a,b)(\b.\a.loves(b,a))))(jules)(mia)').simplify()
&gt;&gt;&gt; x2 = read_expr(r'loves(jules,mia)').simplify()
&gt;&gt;&gt; x1 == x2
True
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; x1 = read_expr(r'(\A.\b.(exists b.A(b) &amp; A(b)))(\c.boxer(c))(vincent)').simplify()
&gt;&gt;&gt; x2 = read_expr(r'((exists b.boxer(b)) &amp; boxer(vincent))').simplify()
&gt;&gt;&gt; x1 == x2
True
</pre>
</blockquote>
</div>
</div>
<div class="section" id="test-parser">
<h3>Test Parser</h3>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; print(read_expr(r'john'))
john
&gt;&gt;&gt; print(read_expr(r'x'))
x
&gt;&gt;&gt; print(read_expr(r'-man(x)'))
-man(x)
&gt;&gt;&gt; print(read_expr(r'--man(x)'))
--man(x)
&gt;&gt;&gt; print(read_expr(r'(man(x))'))
man(x)
&gt;&gt;&gt; print(read_expr(r'((man(x)))'))
man(x)
&gt;&gt;&gt; print(read_expr(r'man(x) &lt;-&gt; tall(x)'))
(man(x) &lt;-&gt; tall(x))
&gt;&gt;&gt; print(read_expr(r'(man(x) &lt;-&gt; tall(x))'))
(man(x) &lt;-&gt; tall(x))
&gt;&gt;&gt; print(read_expr(r'(man(x) &amp; tall(x) &amp; walks(x))'))
(man(x) &amp; tall(x) &amp; walks(x))
&gt;&gt;&gt; print(read_expr(r'(man(x) &amp; tall(x) &amp; walks(x))').first)
(man(x) &amp; tall(x))
&gt;&gt;&gt; print(read_expr(r'man(x) | tall(x) &amp; walks(x)'))
(man(x) | (tall(x) &amp; walks(x)))
&gt;&gt;&gt; print(read_expr(r'((man(x) &amp; tall(x)) | walks(x))'))
((man(x) &amp; tall(x)) | walks(x))
&gt;&gt;&gt; print(read_expr(r'man(x) &amp; (tall(x) | walks(x))'))
(man(x) &amp; (tall(x) | walks(x)))
&gt;&gt;&gt; print(read_expr(r'(man(x) &amp; (tall(x) | walks(x)))'))
(man(x) &amp; (tall(x) | walks(x)))
&gt;&gt;&gt; print(read_expr(r'P(x) -&gt; Q(x) &lt;-&gt; R(x) | S(x) &amp; T(x)'))
((P(x) -&gt; Q(x)) &lt;-&gt; (R(x) | (S(x) &amp; T(x))))
&gt;&gt;&gt; print(read_expr(r'exists x.man(x)'))
exists x.man(x)
&gt;&gt;&gt; print(read_expr(r'exists x.(man(x) &amp; tall(x))'))
exists x.(man(x) &amp; tall(x))
&gt;&gt;&gt; print(read_expr(r'exists x.(man(x) &amp; tall(x) &amp; walks(x))'))
exists x.(man(x) &amp; tall(x) &amp; walks(x))
&gt;&gt;&gt; print(read_expr(r'-P(x) &amp; Q(x)'))
(-P(x) &amp; Q(x))
&gt;&gt;&gt; read_expr(r'-P(x) &amp; Q(x)') == read_expr(r'(-P(x)) &amp; Q(x)')
True
&gt;&gt;&gt; print(read_expr(r'\x.man(x)'))
\x.man(x)
&gt;&gt;&gt; print(read_expr(r'\x.man(x)(john)'))
\x.man(x)(john)
&gt;&gt;&gt; print(read_expr(r'\x.man(x)(john) &amp; tall(x)'))
(\x.man(x)(john) &amp; tall(x))
&gt;&gt;&gt; print(read_expr(r'\x.\y.sees(x,y)'))
\x y.sees(x,y)
&gt;&gt;&gt; print(read_expr(r'\x  y.sees(x,y)'))
\x y.sees(x,y)
&gt;&gt;&gt; print(read_expr(r'\x.\y.sees(x,y)(a)'))
(\x y.sees(x,y))(a)
&gt;&gt;&gt; print(read_expr(r'\x  y.sees(x,y)(a)'))
(\x y.sees(x,y))(a)
&gt;&gt;&gt; print(read_expr(r'\x.\y.sees(x,y)(a)(b)'))
((\x y.sees(x,y))(a))(b)
&gt;&gt;&gt; print(read_expr(r'\x  y.sees(x,y)(a)(b)'))
((\x y.sees(x,y))(a))(b)
&gt;&gt;&gt; print(read_expr(r'\x.\y.sees(x,y)(a,b)'))
((\x y.sees(x,y))(a))(b)
&gt;&gt;&gt; print(read_expr(r'\x  y.sees(x,y)(a,b)'))
((\x y.sees(x,y))(a))(b)
&gt;&gt;&gt; print(read_expr(r'((\x.\y.sees(x,y))(a))(b)'))
((\x y.sees(x,y))(a))(b)
&gt;&gt;&gt; print(read_expr(r'P(x)(y)(z)'))
P(x,y,z)
&gt;&gt;&gt; print(read_expr(r'P(Q)'))
P(Q)
&gt;&gt;&gt; print(read_expr(r'P(Q(x))'))
P(Q(x))
&gt;&gt;&gt; print(read_expr(r'(\x.exists y.walks(x,y))(x)'))
(\x.exists y.walks(x,y))(x)
&gt;&gt;&gt; print(read_expr(r'exists x.(x = john)'))
exists x.(x = john)
&gt;&gt;&gt; print(read_expr(r'((\P.\Q.exists x.(P(x) &amp; Q(x)))(\x.dog(x)))(\x.bark(x))'))
((\P Q.exists x.(P(x) &amp; Q(x)))(\x.dog(x)))(\x.bark(x))
&gt;&gt;&gt; a = read_expr(r'exists c.exists b.A(b,c) &amp; A(b,c)')
&gt;&gt;&gt; b = read_expr(r'(exists c.(exists b.A(b,c))) &amp; A(b,c)')
&gt;&gt;&gt; print(a == b)
True
&gt;&gt;&gt; a = read_expr(r'exists c.(exists b.A(b,c) &amp; A(b,c))')
&gt;&gt;&gt; b = read_expr(r'exists c.((exists b.A(b,c)) &amp; A(b,c))')
&gt;&gt;&gt; print(a == b)
True
&gt;&gt;&gt; print(read_expr(r'exists x.x = y'))
exists x.(x = y)
&gt;&gt;&gt; print(read_expr('A(B)(C)'))
A(B,C)
&gt;&gt;&gt; print(read_expr('(A(B))(C)'))
A(B,C)
&gt;&gt;&gt; print(read_expr('A((B)(C))'))
A(B(C))
&gt;&gt;&gt; print(read_expr('A(B(C))'))
A(B(C))
&gt;&gt;&gt; print(read_expr('(A)(B(C))'))
A(B(C))
&gt;&gt;&gt; print(read_expr('(((A)))(((B))(((C))))'))
A(B(C))
&gt;&gt;&gt; print(read_expr(r'A != B'))
-(A = B)
&gt;&gt;&gt; print(read_expr('P(x) &amp; x=y &amp; P(y)'))
(P(x) &amp; (x = y) &amp; P(y))
&gt;&gt;&gt; try: print(read_expr(r'\walk.walk(x)'))
... except LogicalExpressionException as e: print(e)
'walk' is an illegal variable name.  Constants may not be abstracted.
\walk.walk(x)
 ^
&gt;&gt;&gt; try: print(read_expr(r'all walk.walk(john)'))
... except LogicalExpressionException as e: print(e)
'walk' is an illegal variable name.  Constants may not be quantified.
all walk.walk(john)
    ^
&gt;&gt;&gt; try: print(read_expr(r'x(john)'))
... except LogicalExpressionException as e: print(e)
'x' is an illegal predicate name.  Individual variables may not be used as predicates.
x(john)
^
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; from nltk.sem.logic import LogicParser # hack to give access to custom quote chars
&gt;&gt;&gt; lpq = LogicParser()
&gt;&gt;&gt; lpq.quote_chars = [(&quot;'&quot;, &quot;'&quot;, &quot;\\&quot;, False)]
&gt;&gt;&gt; print(lpq.parse(r&quot;(man(x) &amp; 'tall\'s,' (x) &amp; walks (x) )&quot;))
(man(x) &amp; tall's,(x) &amp; walks(x))
&gt;&gt;&gt; lpq.quote_chars = [(&quot;'&quot;, &quot;'&quot;, &quot;\\&quot;, True)]
&gt;&gt;&gt; print(lpq.parse(r&quot;'tall\'s,'&quot;))
'tall\'s,'
&gt;&gt;&gt; print(lpq.parse(r&quot;'spaced name(x)'&quot;))
'spaced name(x)'
&gt;&gt;&gt; print(lpq.parse(r&quot;-'tall\'s,'(x)&quot;))
-'tall\'s,'(x)
&gt;&gt;&gt; print(lpq.parse(r&quot;(man(x) &amp; 'tall\'s,' (x) &amp; walks (x) )&quot;))
(man(x) &amp; 'tall\'s,'(x) &amp; walks(x))
</pre>
</blockquote>
</div>
<div class="section" id="simplify">
<h3>Simplify</h3>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; print(read_expr(r'\x.man(x)(john)').simplify())
man(john)
&gt;&gt;&gt; print(read_expr(r'\x.((man(x)))(john)').simplify())
man(john)
&gt;&gt;&gt; print(read_expr(r'\x.\y.sees(x,y)(john, mary)').simplify())
sees(john,mary)
&gt;&gt;&gt; print(read_expr(r'\x  y.sees(x,y)(john, mary)').simplify())
sees(john,mary)
&gt;&gt;&gt; print(read_expr(r'\x.\y.sees(x,y)(john)(mary)').simplify())
sees(john,mary)
&gt;&gt;&gt; print(read_expr(r'\x  y.sees(x,y)(john)(mary)').simplify())
sees(john,mary)
&gt;&gt;&gt; print(read_expr(r'\x.\y.sees(x,y)(john)').simplify())
\y.sees(john,y)
&gt;&gt;&gt; print(read_expr(r'\x  y.sees(x,y)(john)').simplify())
\y.sees(john,y)
&gt;&gt;&gt; print(read_expr(r'(\x.\y.sees(x,y)(john))(mary)').simplify())
sees(john,mary)
&gt;&gt;&gt; print(read_expr(r'(\x  y.sees(x,y)(john))(mary)').simplify())
sees(john,mary)
&gt;&gt;&gt; print(read_expr(r'exists x.(man(x) &amp; (\x.exists y.walks(x,y))(x))').simplify())
exists x.(man(x) &amp; exists y.walks(x,y))
&gt;&gt;&gt; e1 = read_expr(r'exists x.(man(x) &amp; (\x.exists y.walks(x,y))(y))').simplify()
&gt;&gt;&gt; e2 = read_expr(r'exists x.(man(x) &amp; exists z1.walks(y,z1))')
&gt;&gt;&gt; e1 == e2
True
&gt;&gt;&gt; print(read_expr(r'(\P Q.exists x.(P(x) &amp; Q(x)))(\x.dog(x))').simplify())
\Q.exists x.(dog(x) &amp; Q(x))
&gt;&gt;&gt; print(read_expr(r'((\P.\Q.exists x.(P(x) &amp; Q(x)))(\x.dog(x)))(\x.bark(x))').simplify())
exists x.(dog(x) &amp; bark(x))
&gt;&gt;&gt; print(read_expr(r'\P.(P(x)(y))(\a b.Q(a,b))').simplify())
Q(x,y)
</pre>
</blockquote>
</div>
<div class="section" id="replace">
<h3>Replace</h3>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; a = read_expr(r'a')
&gt;&gt;&gt; x = read_expr(r'x')
&gt;&gt;&gt; y = read_expr(r'y')
&gt;&gt;&gt; z = read_expr(r'z')
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; print(read_expr(r'man(x)').replace(x.variable, a, False))
man(a)
&gt;&gt;&gt; print(read_expr(r'(man(x) &amp; tall(x))').replace(x.variable, a, False))
(man(a) &amp; tall(a))
&gt;&gt;&gt; print(read_expr(r'exists x.man(x)').replace(x.variable, a, False))
exists x.man(x)
&gt;&gt;&gt; print(read_expr(r'exists x.man(x)').replace(x.variable, a, True))
exists a.man(a)
&gt;&gt;&gt; print(read_expr(r'exists x.give(x,y,z)').replace(y.variable, a, False))
exists x.give(x,a,z)
&gt;&gt;&gt; print(read_expr(r'exists x.give(x,y,z)').replace(y.variable, a, True))
exists x.give(x,a,z)
&gt;&gt;&gt; e1 = read_expr(r'exists x.give(x,y,z)').replace(y.variable, x, False)
&gt;&gt;&gt; e2 = read_expr(r'exists z1.give(z1,x,z)')
&gt;&gt;&gt; e1 == e2
True
&gt;&gt;&gt; e1 = read_expr(r'exists x.give(x,y,z)').replace(y.variable, x, True)
&gt;&gt;&gt; e2 = read_expr(r'exists z1.give(z1,x,z)')
&gt;&gt;&gt; e1 == e2
True
&gt;&gt;&gt; print(read_expr(r'\x y z.give(x,y,z)').replace(y.variable, a, False))
\x y z.give(x,y,z)
&gt;&gt;&gt; print(read_expr(r'\x y z.give(x,y,z)').replace(y.variable, a, True))
\x a z.give(x,a,z)
&gt;&gt;&gt; print(read_expr(r'\x.\y.give(x,y,z)').replace(z.variable, a, False))
\x y.give(x,y,a)
&gt;&gt;&gt; print(read_expr(r'\x.\y.give(x,y,z)').replace(z.variable, a, True))
\x y.give(x,y,a)
&gt;&gt;&gt; e1 = read_expr(r'\x.\y.give(x,y,z)').replace(z.variable, x, False)
&gt;&gt;&gt; e2 = read_expr(r'\z1.\y.give(z1,y,x)')
&gt;&gt;&gt; e1 == e2
True
&gt;&gt;&gt; e1 = read_expr(r'\x.\y.give(x,y,z)').replace(z.variable, x, True)
&gt;&gt;&gt; e2 = read_expr(r'\z1.\y.give(z1,y,x)')
&gt;&gt;&gt; e1 == e2
True
&gt;&gt;&gt; print(read_expr(r'\x.give(x,y,z)').replace(z.variable, y, False))
\x.give(x,y,y)
&gt;&gt;&gt; print(read_expr(r'\x.give(x,y,z)').replace(z.variable, y, True))
\x.give(x,y,y)
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; from nltk.sem import logic
&gt;&gt;&gt; logic._counter._value = 0
&gt;&gt;&gt; e1 = read_expr('e1')
&gt;&gt;&gt; e2 = read_expr('e2')
&gt;&gt;&gt; print(read_expr('exists e1 e2.(walk(e1) &amp; talk(e2))').replace(e1.variable, e2, True))
exists e2 e01.(walk(e2) &amp; talk(e01))
</pre>
</blockquote>
</div>
<div class="section" id="variables-free">
<h3>Variables / Free</h3>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; examples = [r'walk(john)',
...             r'walk(x)',
...             r'?vp(?np)',
...             r'see(john,mary)',
...             r'exists x.walk(x)',
...             r'\x.see(john,x)',
...             r'\x.see(john,x)(mary)',
...             r'P(x)',
...             r'\P.P(x)',
...             r'aa(x,bb(y),cc(z),P(w),u)',
...             r'bo(?det(?n),&#64;x)']
&gt;&gt;&gt; examples = [read_expr(e) for e in examples]
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; for e in examples:
...     print('%-25s' % e, sorted(e.free()))
walk(john)                []
walk(x)                   [Variable('x')]
?vp(?np)                  []
see(john,mary)            []
exists x.walk(x)          []
\x.see(john,x)            []
(\x.see(john,x))(mary)    []
P(x)                      [Variable('P'), Variable('x')]
\P.P(x)                   [Variable('x')]
aa(x,bb(y),cc(z),P(w),u)  [Variable('P'), Variable('u'), Variable('w'), Variable('x'), Variable('y'), Variable('z')]
bo(?det(?n),&#64;x)           []
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; for e in examples:
...     print('%-25s' % e, sorted(e.constants()))
walk(john)                [Variable('john')]
walk(x)                   []
?vp(?np)                  [Variable('?np')]
see(john,mary)            [Variable('john'), Variable('mary')]
exists x.walk(x)          []
\x.see(john,x)            [Variable('john')]
(\x.see(john,x))(mary)    [Variable('john'), Variable('mary')]
P(x)                      []
\P.P(x)                   []
aa(x,bb(y),cc(z),P(w),u)  []
bo(?det(?n),&#64;x)           [Variable('?n'), Variable('&#64;x')]
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; for e in examples:
...     print('%-25s' % e, sorted(e.predicates()))
walk(john)                [Variable('walk')]
walk(x)                   [Variable('walk')]
?vp(?np)                  [Variable('?vp')]
see(john,mary)            [Variable('see')]
exists x.walk(x)          [Variable('walk')]
\x.see(john,x)            [Variable('see')]
(\x.see(john,x))(mary)    [Variable('see')]
P(x)                      []
\P.P(x)                   []
aa(x,bb(y),cc(z),P(w),u)  [Variable('aa'), Variable('bb'), Variable('cc')]
bo(?det(?n),&#64;x)           [Variable('?det'), Variable('bo')]
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; for e in examples:
...     print('%-25s' % e, sorted(e.variables()))
walk(john)                []
walk(x)                   [Variable('x')]
?vp(?np)                  [Variable('?np'), Variable('?vp')]
see(john,mary)            []
exists x.walk(x)          []
\x.see(john,x)            []
(\x.see(john,x))(mary)    []
P(x)                      [Variable('P'), Variable('x')]
\P.P(x)                   [Variable('x')]
aa(x,bb(y),cc(z),P(w),u)  [Variable('P'), Variable('u'), Variable('w'), Variable('x'), Variable('y'), Variable('z')]
bo(?det(?n),&#64;x)           [Variable('?det'), Variable('?n'), Variable('&#64;x')]
</pre>
</blockquote>
<dl class="docutils">
<dt><cite>normalize</cite></dt>
<dd><pre class="first last doctest-block">
&gt;&gt;&gt; print(read_expr(r'\e083.(walk(e083, z472) &amp; talk(e092, z938))').normalize())
\e01.(walk(e01,z3) &amp; talk(e02,z4))
</pre>
</dd>
</dl>
</div>
</div>
<div class="section" id="typed-logic">
<h2>Typed Logic</h2>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from nltk.sem.logic import LogicParser
&gt;&gt;&gt; tlp = LogicParser(True)
&gt;&gt;&gt; print(tlp.parse(r'man(x)').type)
?
&gt;&gt;&gt; print(tlp.parse(r'walk(angus)').type)
?
&gt;&gt;&gt; print(tlp.parse(r'-man(x)').type)
t
&gt;&gt;&gt; print(tlp.parse(r'(man(x) &lt;-&gt; tall(x))').type)
t
&gt;&gt;&gt; print(tlp.parse(r'exists x.(man(x) &amp; tall(x))').type)
t
&gt;&gt;&gt; print(tlp.parse(r'\x.man(x)').type)
&lt;e,?&gt;
&gt;&gt;&gt; print(tlp.parse(r'john').type)
e
&gt;&gt;&gt; print(tlp.parse(r'\x y.sees(x,y)').type)
&lt;e,&lt;e,?&gt;&gt;
&gt;&gt;&gt; print(tlp.parse(r'\x.man(x)(john)').type)
?
&gt;&gt;&gt; print(tlp.parse(r'\x.\y.sees(x,y)(john)').type)
&lt;e,?&gt;
&gt;&gt;&gt; print(tlp.parse(r'\x.\y.sees(x,y)(john)(mary)').type)
?
&gt;&gt;&gt; print(tlp.parse(r'\P.\Q.exists x.(P(x) &amp; Q(x))').type)
&lt;&lt;e,t&gt;,&lt;&lt;e,t&gt;,t&gt;&gt;
&gt;&gt;&gt; print(tlp.parse(r'\x.y').type)
&lt;?,e&gt;
&gt;&gt;&gt; print(tlp.parse(r'\P.P(x)').type)
&lt;&lt;e,?&gt;,?&gt;
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; parsed = tlp.parse('see(john,mary)')
&gt;&gt;&gt; print(parsed.type)
?
&gt;&gt;&gt; print(parsed.function)
see(john)
&gt;&gt;&gt; print(parsed.function.type)
&lt;e,?&gt;
&gt;&gt;&gt; print(parsed.function.function)
see
&gt;&gt;&gt; print(parsed.function.function.type)
&lt;e,&lt;e,?&gt;&gt;
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; parsed = tlp.parse('P(x,y)')
&gt;&gt;&gt; print(parsed)
P(x,y)
&gt;&gt;&gt; print(parsed.type)
?
&gt;&gt;&gt; print(parsed.function)
P(x)
&gt;&gt;&gt; print(parsed.function.type)
&lt;e,?&gt;
&gt;&gt;&gt; print(parsed.function.function)
P
&gt;&gt;&gt; print(parsed.function.function.type)
&lt;e,&lt;e,?&gt;&gt;
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; print(tlp.parse(r'P').type)
?
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; print(tlp.parse(r'P', {'P': 't'}).type)
t
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; a = tlp.parse(r'P(x)')
&gt;&gt;&gt; print(a.type)
?
&gt;&gt;&gt; print(a.function.type)
&lt;e,?&gt;
&gt;&gt;&gt; print(a.argument.type)
e
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; a = tlp.parse(r'-P(x)')
&gt;&gt;&gt; print(a.type)
t
&gt;&gt;&gt; print(a.term.type)
t
&gt;&gt;&gt; print(a.term.function.type)
&lt;e,t&gt;
&gt;&gt;&gt; print(a.term.argument.type)
e
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; a = tlp.parse(r'P &amp; Q')
&gt;&gt;&gt; print(a.type)
t
&gt;&gt;&gt; print(a.first.type)
t
&gt;&gt;&gt; print(a.second.type)
t
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; a = tlp.parse(r'(P(x) &amp; Q(x))')
&gt;&gt;&gt; print(a.type)
t
&gt;&gt;&gt; print(a.first.type)
t
&gt;&gt;&gt; print(a.first.function.type)
&lt;e,t&gt;
&gt;&gt;&gt; print(a.first.argument.type)
e
&gt;&gt;&gt; print(a.second.type)
t
&gt;&gt;&gt; print(a.second.function.type)
&lt;e,t&gt;
&gt;&gt;&gt; print(a.second.argument.type)
e
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; a = tlp.parse(r'\x.P(x)')
&gt;&gt;&gt; print(a.type)
&lt;e,?&gt;
&gt;&gt;&gt; print(a.term.function.type)
&lt;e,?&gt;
&gt;&gt;&gt; print(a.term.argument.type)
e
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; a = tlp.parse(r'\P.P(x)')
&gt;&gt;&gt; print(a.type)
&lt;&lt;e,?&gt;,?&gt;
&gt;&gt;&gt; print(a.term.function.type)
&lt;e,?&gt;
&gt;&gt;&gt; print(a.term.argument.type)
e
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; a = tlp.parse(r'(\x.P(x)(john)) &amp; Q(x)')
&gt;&gt;&gt; print(a.type)
t
&gt;&gt;&gt; print(a.first.type)
t
&gt;&gt;&gt; print(a.first.function.type)
&lt;e,t&gt;
&gt;&gt;&gt; print(a.first.function.term.function.type)
&lt;e,t&gt;
&gt;&gt;&gt; print(a.first.function.term.argument.type)
e
&gt;&gt;&gt; print(a.first.argument.type)
e
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; a = tlp.parse(r'\x y.P(x,y)(john)(mary) &amp; Q(x)')
&gt;&gt;&gt; print(a.type)
t
&gt;&gt;&gt; print(a.first.type)
t
&gt;&gt;&gt; print(a.first.function.type)
&lt;e,t&gt;
&gt;&gt;&gt; print(a.first.function.function.type)
&lt;e,&lt;e,t&gt;&gt;
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; a = tlp.parse(r'--P')
&gt;&gt;&gt; print(a.type)
t
&gt;&gt;&gt; print(a.term.type)
t
&gt;&gt;&gt; print(a.term.term.type)
t
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; tlp.parse(r'\x y.P(x,y)').type
&lt;e,&lt;e,?&gt;&gt;
&gt;&gt;&gt; tlp.parse(r'\x y.P(x,y)', {'P': '&lt;e,&lt;e,t&gt;&gt;'}).type
&lt;e,&lt;e,t&gt;&gt;
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; a = tlp.parse(r'\P y.P(john,y)(\x y.see(x,y))')
&gt;&gt;&gt; a.type
&lt;e,?&gt;
&gt;&gt;&gt; a.function.type
&lt;&lt;e,&lt;e,?&gt;&gt;,&lt;e,?&gt;&gt;
&gt;&gt;&gt; a.function.term.term.function.function.type
&lt;e,&lt;e,?&gt;&gt;
&gt;&gt;&gt; a.argument.type
&lt;e,&lt;e,?&gt;&gt;
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; a = tlp.parse(r'exists c f.(father(c) = f)')
&gt;&gt;&gt; a.type
t
&gt;&gt;&gt; a.term.term.type
t
&gt;&gt;&gt; a.term.term.first.type
e
&gt;&gt;&gt; a.term.term.first.function.type
&lt;e,e&gt;
&gt;&gt;&gt; a.term.term.second.type
e
</pre>
</blockquote>
<p>typecheck()</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; a = tlp.parse('P(x)')
&gt;&gt;&gt; b = tlp.parse('Q(x)')
&gt;&gt;&gt; a.type
?
&gt;&gt;&gt; c = a &amp; b
&gt;&gt;&gt; c.first.type
?
&gt;&gt;&gt; c.typecheck() # doctest: +ELLIPSIS
{...}
&gt;&gt;&gt; c.first.type
t
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; a = tlp.parse('P(x)')
&gt;&gt;&gt; b = tlp.parse('P(x) &amp; Q(x)')
&gt;&gt;&gt; a.type
?
&gt;&gt;&gt; typecheck([a,b]) # doctest: +ELLIPSIS
{...}
&gt;&gt;&gt; a.type
t
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; e = tlp.parse(r'man(x)')
&gt;&gt;&gt; print(dict((k,str(v)) for k,v in e.typecheck().items()) == {'x': 'e', 'man': '&lt;e,?&gt;'})
True
&gt;&gt;&gt; sig = {'man': '&lt;e, t&gt;'}
&gt;&gt;&gt; e = tlp.parse(r'man(x)', sig)
&gt;&gt;&gt; print(e.function.type)
&lt;e,t&gt;
&gt;&gt;&gt; print(dict((k,str(v)) for k,v in e.typecheck().items()) == {'x': 'e', 'man': '&lt;e,t&gt;'})
True
&gt;&gt;&gt; print(e.function.type)
&lt;e,t&gt;
&gt;&gt;&gt; print(dict((k,str(v)) for k,v in e.typecheck(sig).items()) == {'x': 'e', 'man': '&lt;e,t&gt;'})
True
</pre>
</blockquote>
<p>findtype()</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; print(tlp.parse(r'man(x)').findtype(Variable('man')))
&lt;e,?&gt;
&gt;&gt;&gt; print(tlp.parse(r'see(x,y)').findtype(Variable('see')))
&lt;e,&lt;e,?&gt;&gt;
&gt;&gt;&gt; print(tlp.parse(r'P(Q(R(x)))').findtype(Variable('Q')))
?
</pre>
</blockquote>
<p>reading types from strings</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; Type.fromstring('e')
e
&gt;&gt;&gt; Type.fromstring('&lt;e,t&gt;')
&lt;e,t&gt;
&gt;&gt;&gt; Type.fromstring('&lt;&lt;e,t&gt;,&lt;e,t&gt;&gt;')
&lt;&lt;e,t&gt;,&lt;e,t&gt;&gt;
&gt;&gt;&gt; Type.fromstring('&lt;&lt;e,?&gt;,?&gt;')
&lt;&lt;e,?&gt;,?&gt;
</pre>
</blockquote>
<p>alternative type format</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; Type.fromstring('e').str()
'IND'
&gt;&gt;&gt; Type.fromstring('&lt;e,?&gt;').str()
'(IND -&gt; ANY)'
&gt;&gt;&gt; Type.fromstring('&lt;&lt;e,t&gt;,t&gt;').str()
'((IND -&gt; BOOL) -&gt; BOOL)'
</pre>
</blockquote>
<p>Type.__eq__()</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from nltk.sem.logic import *
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; e = ENTITY_TYPE
&gt;&gt;&gt; t = TRUTH_TYPE
&gt;&gt;&gt; a = ANY_TYPE
&gt;&gt;&gt; et = ComplexType(e,t)
&gt;&gt;&gt; eet = ComplexType(e,ComplexType(e,t))
&gt;&gt;&gt; at = ComplexType(a,t)
&gt;&gt;&gt; ea = ComplexType(e,a)
&gt;&gt;&gt; aa = ComplexType(a,a)
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; e == e
True
&gt;&gt;&gt; t == t
True
&gt;&gt;&gt; e == t
False
&gt;&gt;&gt; a == t
False
&gt;&gt;&gt; t == a
False
&gt;&gt;&gt; a == a
True
&gt;&gt;&gt; et == et
True
&gt;&gt;&gt; a == et
False
&gt;&gt;&gt; et == a
False
&gt;&gt;&gt; a == ComplexType(a,aa)
True
&gt;&gt;&gt; ComplexType(a,aa) == a
True
</pre>
</blockquote>
<p>matches()</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; e.matches(t)
False
&gt;&gt;&gt; a.matches(t)
True
&gt;&gt;&gt; t.matches(a)
True
&gt;&gt;&gt; a.matches(et)
True
&gt;&gt;&gt; et.matches(a)
True
&gt;&gt;&gt; ea.matches(eet)
True
&gt;&gt;&gt; eet.matches(ea)
True
&gt;&gt;&gt; aa.matches(et)
True
&gt;&gt;&gt; aa.matches(t)
True
</pre>
</blockquote>
<div class="section" id="type-error-during-parsing">
<h3>Type error during parsing</h3>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; try: print(tlp.parse(r'exists x y.(P(x) &amp; P(x,y))'))
... except InconsistentTypeHierarchyException as e: print(e)
The variable 'P' was found in multiple places with different types.
&gt;&gt;&gt; try: tlp.parse(r'\x y.see(x,y)(\x.man(x))')
... except TypeException as e: print(e)
The function '\x y.see(x,y)' is of type '&lt;e,&lt;e,?&gt;&gt;' and cannot be applied to '\x.man(x)' of type '&lt;e,?&gt;'.  Its argument must match type 'e'.
&gt;&gt;&gt; try: tlp.parse(r'\P x y.-P(x,y)(\x.-man(x))')
... except TypeException as e: print(e)
The function '\P x y.-P(x,y)' is of type '&lt;&lt;e,&lt;e,t&gt;&gt;,&lt;e,&lt;e,t&gt;&gt;&gt;' and cannot be applied to '\x.-man(x)' of type '&lt;e,t&gt;'.  Its argument must match type '&lt;e,&lt;e,t&gt;&gt;'.
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; a = tlp.parse(r'-talk(x)')
&gt;&gt;&gt; signature = a.typecheck()
&gt;&gt;&gt; try: print(tlp.parse(r'-talk(x,y)', signature))
... except InconsistentTypeHierarchyException as e: print(e)
The variable 'talk' was found in multiple places with different types.
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; a = tlp.parse(r'-P(x)')
&gt;&gt;&gt; b = tlp.parse(r'-P(x,y)')
&gt;&gt;&gt; a.typecheck() # doctest: +ELLIPSIS
{...}
&gt;&gt;&gt; b.typecheck() # doctest: +ELLIPSIS
{...}
&gt;&gt;&gt; try: typecheck([a,b])
... except InconsistentTypeHierarchyException as e: print(e)
The variable 'P' was found in multiple places with different types.
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; a = tlp.parse(r'P(x)')
&gt;&gt;&gt; b = tlp.parse(r'P(x,y)')
&gt;&gt;&gt; signature = {'P': '&lt;e,t&gt;'}
&gt;&gt;&gt; a.typecheck(signature) # doctest: +ELLIPSIS
{...}
&gt;&gt;&gt; try: typecheck([a,b], signature)
... except InconsistentTypeHierarchyException as e: print(e)
The variable 'P' was found in multiple places with different types.
</pre>
</blockquote>
</div>
<div class="section" id="parse-errors">
<h3>Parse errors</h3>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; try: read_expr(r'')
... except LogicalExpressionException as e: print(e)
End of input found.  Expression expected.
&lt;BLANKLINE&gt;
^
&gt;&gt;&gt; try: read_expr(r'(')
... except LogicalExpressionException as e: print(e)
End of input found.  Expression expected.
(
 ^
&gt;&gt;&gt; try: read_expr(r')')
... except LogicalExpressionException as e: print(e)
Unexpected token: ')'.  Expression expected.
)
^
&gt;&gt;&gt; try: read_expr(r'()')
... except LogicalExpressionException as e: print(e)
Unexpected token: ')'.  Expression expected.
()
 ^
&gt;&gt;&gt; try: read_expr(r'(P(x) &amp; Q(x)')
... except LogicalExpressionException as e: print(e)
End of input found.  Expected token ')'.
(P(x) &amp; Q(x)
            ^
&gt;&gt;&gt; try: read_expr(r'(P(x) &amp;')
... except LogicalExpressionException as e: print(e)
End of input found.  Expression expected.
(P(x) &amp;
       ^
&gt;&gt;&gt; try: read_expr(r'(P(x) | )')
... except LogicalExpressionException as e: print(e)
Unexpected token: ')'.  Expression expected.
(P(x) | )
        ^
&gt;&gt;&gt; try: read_expr(r'P(x) -&gt;')
... except LogicalExpressionException as e: print(e)
End of input found.  Expression expected.
P(x) -&gt;
       ^
&gt;&gt;&gt; try: read_expr(r'P(x')
... except LogicalExpressionException as e: print(e)
End of input found.  Expected token ')'.
P(x
   ^
&gt;&gt;&gt; try: read_expr(r'P(x,')
... except LogicalExpressionException as e: print(e)
End of input found.  Expression expected.
P(x,
    ^
&gt;&gt;&gt; try: read_expr(r'P(x,)')
... except LogicalExpressionException as e: print(e)
Unexpected token: ')'.  Expression expected.
P(x,)
    ^
&gt;&gt;&gt; try: read_expr(r'exists')
... except LogicalExpressionException as e: print(e)
End of input found.  Variable and Expression expected following quantifier 'exists'.
exists
       ^
&gt;&gt;&gt; try: read_expr(r'exists x')
... except LogicalExpressionException as e: print(e)
End of input found.  Expression expected.
exists x
         ^
&gt;&gt;&gt; try: read_expr(r'exists x.')
... except LogicalExpressionException as e: print(e)
End of input found.  Expression expected.
exists x.
         ^
&gt;&gt;&gt; try: read_expr(r'\  ')
... except LogicalExpressionException as e: print(e)
End of input found.  Variable and Expression expected following lambda operator.
\
  ^
&gt;&gt;&gt; try: read_expr(r'\ x')
... except LogicalExpressionException as e: print(e)
End of input found.  Expression expected.
\ x
    ^
&gt;&gt;&gt; try: read_expr(r'\ x y')
... except LogicalExpressionException as e: print(e)
End of input found.  Expression expected.
\ x y
      ^
&gt;&gt;&gt; try: read_expr(r'\ x.')
... except LogicalExpressionException as e: print(e)
End of input found.  Expression expected.
\ x.
    ^
&gt;&gt;&gt; try: read_expr(r'P(x)Q(x)')
... except LogicalExpressionException as e: print(e)
Unexpected token: 'Q'.
P(x)Q(x)
    ^
&gt;&gt;&gt; try: read_expr(r'(P(x)Q(x)')
... except LogicalExpressionException as e: print(e)
Unexpected token: 'Q'.  Expected token ')'.
(P(x)Q(x)
     ^
&gt;&gt;&gt; try: read_expr(r'exists x y')
... except LogicalExpressionException as e: print(e)
End of input found.  Expression expected.
exists x y
           ^
&gt;&gt;&gt; try: read_expr(r'exists x y.')
... except LogicalExpressionException as e: print(e)
End of input found.  Expression expected.
exists x y.
           ^
&gt;&gt;&gt; try: read_expr(r'exists x -&gt; y')
... except LogicalExpressionException as e: print(e)
Unexpected token: '-&gt;'.  Expression expected.
exists x -&gt; y
         ^
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; try: read_expr(r'A -&gt; ((P(x) &amp; Q(x)) -&gt; Z')
... except LogicalExpressionException as e: print(e)
End of input found.  Expected token ')'.
A -&gt; ((P(x) &amp; Q(x)) -&gt; Z
                        ^
&gt;&gt;&gt; try: read_expr(r'A -&gt; ((P(x) &amp;) -&gt; Z')
... except LogicalExpressionException as e: print(e)
Unexpected token: ')'.  Expression expected.
A -&gt; ((P(x) &amp;) -&gt; Z
             ^
&gt;&gt;&gt; try: read_expr(r'A -&gt; ((P(x) | )) -&gt; Z')
... except LogicalExpressionException as e: print(e)
Unexpected token: ')'.  Expression expected.
A -&gt; ((P(x) | )) -&gt; Z
              ^
&gt;&gt;&gt; try: read_expr(r'A -&gt; (P(x) -&gt;) -&gt; Z')
... except LogicalExpressionException as e: print(e)
Unexpected token: ')'.  Expression expected.
A -&gt; (P(x) -&gt;) -&gt; Z
             ^
&gt;&gt;&gt; try: read_expr(r'A -&gt; (P(x) -&gt; Z')
... except LogicalExpressionException as e: print(e)
End of input found.  Expected token ')'.
A -&gt; (P(x) -&gt; Z
               ^
&gt;&gt;&gt; try: read_expr(r'A -&gt; (P(x,) -&gt; Z')
... except LogicalExpressionException as e: print(e)
Unexpected token: ')'.  Expression expected.
A -&gt; (P(x,) -&gt; Z
          ^
&gt;&gt;&gt; try: read_expr(r'A -&gt; (P(x,)) -&gt; Z')
... except LogicalExpressionException as e: print(e)
Unexpected token: ')'.  Expression expected.
A -&gt; (P(x,)) -&gt; Z
          ^
&gt;&gt;&gt; try: read_expr(r'A -&gt; (exists) -&gt; Z')
... except LogicalExpressionException as e: print(e)
')' is an illegal variable name.  Constants may not be quantified.
A -&gt; (exists) -&gt; Z
            ^
&gt;&gt;&gt; try: read_expr(r'A -&gt; (exists x) -&gt; Z')
... except LogicalExpressionException as e: print(e)
Unexpected token: ')'.  Expression expected.
A -&gt; (exists x) -&gt; Z
              ^
&gt;&gt;&gt; try: read_expr(r'A -&gt; (exists x.) -&gt; Z')
... except LogicalExpressionException as e: print(e)
Unexpected token: ')'.  Expression expected.
A -&gt; (exists x.) -&gt; Z
               ^
&gt;&gt;&gt; try: read_expr(r'A -&gt; (\  ) -&gt; Z')
... except LogicalExpressionException as e: print(e)
')' is an illegal variable name.  Constants may not be abstracted.
A -&gt; (\  ) -&gt; Z
         ^
&gt;&gt;&gt; try: read_expr(r'A -&gt; (\ x) -&gt; Z')
... except LogicalExpressionException as e: print(e)
Unexpected token: ')'.  Expression expected.
A -&gt; (\ x) -&gt; Z
         ^
&gt;&gt;&gt; try: read_expr(r'A -&gt; (\ x y) -&gt; Z')
... except LogicalExpressionException as e: print(e)
Unexpected token: ')'.  Expression expected.
A -&gt; (\ x y) -&gt; Z
           ^
&gt;&gt;&gt; try: read_expr(r'A -&gt; (\ x.) -&gt; Z')
... except LogicalExpressionException as e: print(e)
Unexpected token: ')'.  Expression expected.
A -&gt; (\ x.) -&gt; Z
          ^
&gt;&gt;&gt; try: read_expr(r'A -&gt; (P(x)Q(x)) -&gt; Z')
... except LogicalExpressionException as e: print(e)
Unexpected token: 'Q'.  Expected token ')'.
A -&gt; (P(x)Q(x)) -&gt; Z
          ^
&gt;&gt;&gt; try: read_expr(r'A -&gt; ((P(x)Q(x)) -&gt; Z')
... except LogicalExpressionException as e: print(e)
Unexpected token: 'Q'.  Expected token ')'.
A -&gt; ((P(x)Q(x)) -&gt; Z
           ^
&gt;&gt;&gt; try: read_expr(r'A -&gt; (all x y) -&gt; Z')
... except LogicalExpressionException as e: print(e)
Unexpected token: ')'.  Expression expected.
A -&gt; (all x y) -&gt; Z
             ^
&gt;&gt;&gt; try: read_expr(r'A -&gt; (exists x y.) -&gt; Z')
... except LogicalExpressionException as e: print(e)
Unexpected token: ')'.  Expression expected.
A -&gt; (exists x y.) -&gt; Z
                 ^
&gt;&gt;&gt; try: read_expr(r'A -&gt; (exists x -&gt; y) -&gt; Z')
... except LogicalExpressionException as e: print(e)
Unexpected token: '-&gt;'.  Expression expected.
A -&gt; (exists x -&gt; y) -&gt; Z
               ^
</pre>
</blockquote>
</div>
</div>
</div>
</div>
</body>
</html>
