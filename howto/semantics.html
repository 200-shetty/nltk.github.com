<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.11: http://docutils.sourceforge.net/" />
<title>Semantics</title>
<style type="text/css">

/*
:Author: David Goodger (goodger@python.org)
:Id: $Id: html4css1.css 7614 2013-02-21 15:55:51Z milde $
:Copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.

See http://docutils.sf.net/docs/howto/html-stylesheets.html for how to
customize this style sheet.
*/

/* used to remove borders from tables and images */
.borderless, table.borderless td, table.borderless th {
  border: 0 }

table.borderless td, table.borderless th {
  /* Override padding for "table.docutils td" with "! important".
     The right padding separates the table cells. */
  padding: 0 0.5em 0 0 ! important }

.first {
  /* Override more specific margin styles with "! important". */
  margin-top: 0 ! important }

.last, .with-subtitle {
  margin-bottom: 0 ! important }

.hidden {
  display: none }

a.toc-backref {
  text-decoration: none ;
  color: black }

blockquote.epigraph {
  margin: 2em 5em ; }

dl.docutils dd {
  margin-bottom: 0.5em }

object[type="image/svg+xml"], object[type="application/x-shockwave-flash"] {
  overflow: hidden;
}

/* Uncomment (and remove this text!) to get bold-faced definition list terms
dl.docutils dt {
  font-weight: bold }
*/

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.admonition, div.attention, div.caution, div.danger, div.error,
div.hint, div.important, div.note, div.tip, div.warning {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.admonition p.admonition-title, div.hint p.admonition-title,
div.important p.admonition-title, div.note p.admonition-title,
div.tip p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title, .code .error {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

/* Uncomment (and remove this text!) to get reduced vertical space in
   compound paragraphs.
div.compound .compound-first, div.compound .compound-middle {
  margin-bottom: 0.5em }

div.compound .compound-last, div.compound .compound-middle {
  margin-top: 0.5em }
*/

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em ;
  margin-right: 2em }

div.footer, div.header {
  clear: both;
  font-size: smaller }

div.line-block {
  display: block ;
  margin-top: 1em ;
  margin-bottom: 1em }

div.line-block div.line-block {
  margin-top: 0 ;
  margin-bottom: 0 ;
  margin-left: 1.5em }

div.sidebar {
  margin: 0 0 0.5em 1em ;
  border: medium outset ;
  padding: 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.section-subtitle, h2.section-subtitle, h3.section-subtitle,
h4.section-subtitle, h5.section-subtitle, h6.section-subtitle {
  margin-top: 0.4em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

hr.docutils {
  width: 75% }

img.align-left, .figure.align-left, object.align-left {
  clear: left ;
  float: left ;
  margin-right: 1em }

img.align-right, .figure.align-right, object.align-right {
  clear: right ;
  float: right ;
  margin-left: 1em }

img.align-center, .figure.align-center, object.align-center {
  display: block;
  margin-left: auto;
  margin-right: auto;
}

.align-left {
  text-align: left }

.align-center {
  clear: both ;
  text-align: center }

.align-right {
  text-align: right }

/* reset inner alignment in figures */
div.align-right {
  text-align: inherit }

/* div.align-center * { */
/*   text-align: left } */

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font: inherit }

pre.literal-block, pre.doctest-block, pre.math, pre.code {
  margin-left: 2em ;
  margin-right: 2em }

pre.code .ln { color: grey; } /* line numbers */
pre.code, code { background-color: #eeeeee }
pre.code .comment, code .comment { color: #5C6576 }
pre.code .keyword, code .keyword { color: #3B0D06; font-weight: bold }
pre.code .literal.string, code .literal.string { color: #0C5404 }
pre.code .name.builtin, code .name.builtin { color: #352B84 }
pre.code .deleted, code .deleted { background-color: #DEB0A1}
pre.code .inserted, code .inserted { background-color: #A3D289}

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

span.section-subtitle {
  /* font-size relative to parent (h1..h6 element) */
  font-size: 80% }

table.citation {
  border-left: solid 1px gray;
  margin-left: 1px }

table.docinfo {
  margin: 2em 4em }

table.docutils {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.footnote {
  border-left: solid 1px black;
  margin-left: 1px }

table.docutils td, table.docutils th,
table.docinfo td, table.docinfo th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

table.docutils th.field-name, table.docinfo th.docinfo-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap ;
  padding-left: 0 }

/* "booktabs" style (no vertical lines) */
table.docutils.booktabs {
  border: 0px;
  border-top: 2px solid;
  border-bottom: 2px solid;
  border-collapse: collapse;
}
table.docutils.booktabs * {
  border: 0px;
}
table.docutils.booktabs th {
  border-bottom: thin solid;
  text-align: left;
}

h1 tt.docutils, h2 tt.docutils, h3 tt.docutils,
h4 tt.docutils, h5 tt.docutils, h6 tt.docutils {
  font-size: 100% }

ul.auto-toc {
  list-style-type: none }

</style>
</head>
<body>
<div class="document" id="semantics">
<h1 class="title">Semantics</h1>

<!-- Copyright (C) 2001-2013 NLTK Project -->
<!-- For license information, see LICENSE.TXT -->
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; import nltk
&gt;&gt;&gt; from nltk.sem import Valuation, Model
&gt;&gt;&gt; v = [('adam', 'b1'), ('betty', 'g1'), ('fido', 'd1'),
... ('girl', set(['g1', 'g2'])), ('boy', set(['b1', 'b2'])),
... ('dog', set(['d1'])),
... ('love', set([('b1', 'g1'), ('b2', 'g2'), ('g1', 'b1'), ('g2', 'b1')]))]
&gt;&gt;&gt; val = Valuation(v)
&gt;&gt;&gt; dom = val.domain
&gt;&gt;&gt; m = Model(dom, val)
</pre>
</blockquote>
<div class="section" id="evaluation">
<h1>Evaluation</h1>
<p>The top-level method of a <tt class="docutils literal">Model</tt> instance is <tt class="docutils literal">evaluate()</tt>, which
assigns a semantic value to expressions of the <tt class="docutils literal">logic</tt> module, under
an assignment <tt class="docutils literal">g</tt>:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; dom = val.domain
&gt;&gt;&gt; g = nltk.sem.Assignment(dom)
&gt;&gt;&gt; m.evaluate('all x.(boy(x) -&gt; - girl(x))', g)
True
</pre>
</blockquote>
<p><tt class="docutils literal">evaluate()</tt> calls a recursive function <tt class="docutils literal">satisfy()</tt>, which in turn
calls a function <tt class="docutils literal">i()</tt> to interpret non-logical constants and
individual variables. <tt class="docutils literal">i()</tt> delegates the interpretation of these to
the the model's <tt class="docutils literal">Valuation</tt> and the variable assignment <tt class="docutils literal">g</tt>
respectively. Any atomic expression which cannot be assigned a value
by <tt class="docutils literal">i</tt> raises an <tt class="docutils literal">Undefined</tt> exception; this is caught by
<tt class="docutils literal">evaluate</tt>, which returns the string <tt class="docutils literal">'Undefined'</tt>.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; m.evaluate('walk(adam)', g, trace=2)
&lt;BLANKLINE&gt;
'walk(adam)' is undefined under M, g
'Undefined'
</pre>
</blockquote>
</div>
<div class="section" id="batch-processing">
<h1>Batch Processing</h1>
<p>The utility functions <tt class="docutils literal">batch_interpret()</tt> and <tt class="docutils literal">batch_evaluate()</tt> are intended to
help with processing multiple sentences. Here's an example of the first of these:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; sents = ['Mary walks']
&gt;&gt;&gt; results = nltk.sem.batch_interpret(sents, 'grammars/sample_grammars/sem2.fcfg')
&gt;&gt;&gt; for result in results:
...     for (synrep, semrep) in result:
...         print(synrep)
(S[SEM=&lt;walk(mary)&gt;]
  (NP[-LOC, NUM='sg', SEM=&lt;\P.P(mary)&gt;]
    (PropN[-LOC, NUM='sg', SEM=&lt;\P.P(mary)&gt;] Mary))
  (VP[NUM='sg', SEM=&lt;\x.walk(x)&gt;]
    (IV[NUM='sg', SEM=&lt;\x.walk(x)&gt;, TNS='pres'] walks)))
</pre>
</blockquote>
<p>In order to provide backwards compatibility with 'legacy' grammars where the semantics value
is specified with a lowercase
<tt class="docutils literal">sem</tt> feature, the relevant feature name can be passed to the function using the
<tt class="docutils literal">semkey</tt> parameter, as shown here:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; sents = ['raining']
&gt;&gt;&gt; g = nltk.parse_fcfg(&quot;&quot;&quot;
... % start S
... S[sem=&lt;raining&gt;] -&gt; 'raining'
... &quot;&quot;&quot;)
&gt;&gt;&gt; results = nltk.sem.batch_interpret(sents, g, semkey='sem')
&gt;&gt;&gt; for result in results:
...     for (synrep, semrep) in result:
...         print(semrep)
raining
</pre>
</blockquote>
<p>The function <tt class="docutils literal">batch_evaluate()</tt> works in a similar manner, but also needs to be
passed a <tt class="docutils literal">Model</tt> against which the semantic representations are evaluated.</p>
<div class="section" id="unit-tests">
<h2>Unit Tests</h2>
</div>
</div>
<div class="section" id="unit-tests-for-relations-and-valuations">
<h1>Unit tests for relations and valuations</h1>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from nltk.sem import *
</pre>
</blockquote>
<p>Relations are sets of tuples, all of the same length.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; s1 = set([('d1', 'd2'), ('d1', 'd1'), ('d2', 'd1')])
&gt;&gt;&gt; is_rel(s1)
True
&gt;&gt;&gt; s2 = set([('d1', 'd2'), ('d1', 'd2'), ('d1',)])
&gt;&gt;&gt; is_rel(s2)
Traceback (most recent call last):
  . . .
ValueError: Set set([('d1', 'd2'), ('d1',)]) contains sequences of different lengths
&gt;&gt;&gt; s3 = set(['d1', 'd2'])
&gt;&gt;&gt; is_rel(s3)
Traceback (most recent call last):
  . . .
ValueError: Set set(['d2', 'd1']) contains sequences of different lengths
&gt;&gt;&gt; s4 = set2rel(s3)
&gt;&gt;&gt; is_rel(s4)
True
&gt;&gt;&gt; is_rel(set())
True
&gt;&gt;&gt; null_binary_rel = set([(None, None)])
&gt;&gt;&gt; is_rel(null_binary_rel)
True
</pre>
</blockquote>
<p>Sets of entities are converted into sets of singleton tuples
(containing strings).</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; sorted(set2rel(s3))
[('d1',), ('d2',)]
&gt;&gt;&gt; sorted(set2rel(set([1,3,5,])))
['1', '3', '5']
&gt;&gt;&gt; set2rel(set()) == set()
True
&gt;&gt;&gt; set2rel(set2rel(s3)) == set2rel(s3)
True
</pre>
</blockquote>
<p>Predication is evaluated by set membership.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; ('d1', 'd2') in s1
True
&gt;&gt;&gt; ('d2', 'd2') in s1
False
&gt;&gt;&gt; ('d1',) in s1
False
&gt;&gt;&gt; 'd2' in s1
False
&gt;&gt;&gt; ('d1',) in s4
True
&gt;&gt;&gt; ('d1',) in set()
False
&gt;&gt;&gt; 'd1' in  null_binary_rel
False
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; val = Valuation([('Fido', 'd1'), ('dog', set(['d1', 'd2'])), ('walk', set())])
&gt;&gt;&gt; sorted(val['dog'])
[('d1',), ('d2',)]
&gt;&gt;&gt; val.domain == set(['d1', 'd2'])
True
&gt;&gt;&gt; print(val.symbols)
['Fido', 'dog', 'walk']
</pre>
</blockquote>
<p>Parse a valuation from a string.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; v = &quot;&quot;&quot;
... john =&gt; b1
... mary =&gt; g1
... suzie =&gt; g2
... fido =&gt; d1
... tess =&gt; d2
... noosa =&gt; n
... girl =&gt; {g1, g2}
... boy =&gt; {b1, b2}
... dog =&gt; {d1, d2}
... bark =&gt; {d1, d2}
... walk =&gt; {b1, g2, d1}
... chase =&gt; {(b1, g1), (b2, g1), (g1, d1), (g2, d2)}
... see =&gt; {(b1, g1), (b2, d2), (g1, b1),(d2, b1), (g2, n)}
... in =&gt; {(b1, n), (b2, n), (d2, n)}
... with =&gt; {(b1, g1), (g1, b1), (d1, b1), (b1, d1)}
... &quot;&quot;&quot;
&gt;&gt;&gt; val = parse_valuation(v)
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; print(val) # doctest: +SKIP
{'bark': set([('d1',), ('d2',)]),
 'boy': set([('b1',), ('b2',)]),
 'chase': set([('b1', 'g1'), ('g2', 'd2'), ('g1', 'd1'), ('b2', 'g1')]),
 'dog': set([('d1',), ('d2',)]),
 'fido': 'd1',
 'girl': set([('g2',), ('g1',)]),
 'in': set([('d2', 'n'), ('b1', 'n'), ('b2', 'n')]),
 'john': 'b1',
 'mary': 'g1',
 'noosa': 'n',
 'see': set([('b1', 'g1'), ('b2', 'd2'), ('d2', 'b1'), ('g2', 'n'), ('g1', 'b1')]),
 'suzie': 'g2',
 'tess': 'd2',
 'walk': set([('d1',), ('b1',), ('g2',)]),
 'with': set([('b1', 'g1'), ('d1', 'b1'), ('b1', 'd1'), ('g1', 'b1')])}
</pre>
</blockquote>
</div>
<div class="section" id="unit-tests-for-function-argument-application-in-a-model">
<h1>Unit tests for function argument application in a Model</h1>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; v = [('adam', 'b1'), ('betty', 'g1'), ('fido', 'd1'),\
...      ('girl', set(['g1', 'g2'])), ('boy', set(['b1', 'b2'])), ('dog', set(['d1'])),
...      ('love', set([('b1', 'g1'), ('b2', 'g2'), ('g1', 'b1'), ('g2', 'b1')])),
...      ('kiss', null_binary_rel)]
&gt;&gt;&gt; val = Valuation(v)
&gt;&gt;&gt; dom = val.domain
&gt;&gt;&gt; m = Model(dom, val)
&gt;&gt;&gt; g = Assignment(dom)
&gt;&gt;&gt; sorted(val['boy'])
[('b1',), ('b2',)]
&gt;&gt;&gt; ('b1',) in val['boy']
True
&gt;&gt;&gt; ('g1',) in val['boy']
False
&gt;&gt;&gt; ('foo',) in val['boy']
False
&gt;&gt;&gt; ('b1', 'g1') in val['love']
True
&gt;&gt;&gt; ('b1', 'b1') in val['kiss']
False
&gt;&gt;&gt; sorted(val.domain)
['b1', 'b2', 'd1', 'g1', 'g2']
</pre>
</blockquote>
<div class="section" id="model-tests">
<h2>Model Tests</h2>
<p>Extension of Lambda expressions</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; v0 = [('adam', 'b1'), ('betty', 'g1'), ('fido', 'd1'),\
... ('girl', set(['g1', 'g2'])), ('boy', set(['b1', 'b2'])),
... ('dog', set(['d1'])),
... ('love', set([('b1', 'g1'), ('b2', 'g2'), ('g1', 'b1'), ('g2', 'b1')]))]
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; val0 = Valuation(v0)
&gt;&gt;&gt; dom0 = val0.domain
&gt;&gt;&gt; m0 = Model(dom0, val0)
&gt;&gt;&gt; g0 = Assignment(dom0)
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; print(m0.evaluate(r'\x. \y. love(x, y)', g0) == {'g2': {'g2': False, 'b2': False, 'b1': True, 'g1': False, 'd1': False}, 'b2': {'g2': True, 'b2': False, 'b1': False, 'g1': False, 'd1': False}, 'b1': {'g2': False, 'b2': False, 'b1': False, 'g1': True, 'd1': False}, 'g1': {'g2': False, 'b2': False, 'b1': True, 'g1': False, 'd1': False}, 'd1': {'g2': False, 'b2': False, 'b1': False, 'g1': False, 'd1': False}})
True
&gt;&gt;&gt; print(m0.evaluate(r'\x. dog(x) (adam)', g0))
False
&gt;&gt;&gt; print(m0.evaluate(r'\x. (dog(x) | boy(x)) (adam)', g0))
True
&gt;&gt;&gt; print(m0.evaluate(r'\x. \y. love(x, y)(fido)', g0) == {'g2': False, 'b2': False, 'b1': False, 'g1': False, 'd1': False})
True
&gt;&gt;&gt; print(m0.evaluate(r'\x. \y. love(x, y)(adam)', g0) == {'g2': False, 'b2': False, 'b1': False, 'g1': True, 'd1': False})
True
&gt;&gt;&gt; print(m0.evaluate(r'\x. \y. love(x, y)(betty)', g0) == {'g2': False, 'b2': False, 'b1': True, 'g1': False, 'd1': False})
True
&gt;&gt;&gt; print(m0.evaluate(r'\x. \y. love(x, y)(betty)(adam)', g0))
True
&gt;&gt;&gt; print(m0.evaluate(r'\x. \y. love(x, y)(betty, adam)', g0))
True
&gt;&gt;&gt; print(m0.evaluate(r'\y. \x. love(x, y)(fido)(adam)', g0))
False
&gt;&gt;&gt; print(m0.evaluate(r'\y. \x. love(x, y)(betty, adam)', g0))
True
&gt;&gt;&gt; print(m0.evaluate(r'\x. exists y. love(x, y)', g0) == {'g2': True, 'b2': True, 'b1': True, 'g1': True, 'd1': False})
True
&gt;&gt;&gt; print(m0.evaluate(r'\z. adam', g0) == {'g2': 'b1', 'b2': 'b1', 'b1': 'b1', 'g1': 'b1', 'd1': 'b1'})
True
&gt;&gt;&gt; print(m0.evaluate(r'\z. love(x, y)', g0) == {'g2': False, 'b2': False, 'b1': False, 'g1': False, 'd1': False})
True
</pre>
</blockquote>
</div>
</div>
<div class="section" id="propositional-model-test">
<h1>Propositional Model Test</h1>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; tests = [
...     ('P &amp; Q', True),
...     ('P &amp; R', False),
...     ('- P', False),
...     ('- R', True),
...     ('- - P', True),
...     ('- (P &amp; R)', True),
...     ('P | R', True),
...     ('R | P', True),
...     ('R | R', False),
...     ('- P | R', False),
...     ('P | - P', True),
...     ('P -&gt; Q', True),
...     ('P -&gt; R', False),
...     ('R -&gt; P', True),
...     ('P &lt;-&gt; P', True),
...     ('R &lt;-&gt; R', True),
...     ('P &lt;-&gt; R', False),
...     ]
&gt;&gt;&gt; val1 = Valuation([('P', True), ('Q', True), ('R', False)])
&gt;&gt;&gt; dom = set([])
&gt;&gt;&gt; m = Model(dom, val1)
&gt;&gt;&gt; g = Assignment(dom)
&gt;&gt;&gt; for (sent, testvalue) in tests:
...     semvalue = m.evaluate(sent, g)
...     if semvalue == testvalue:
...         print('*', end=' ')
* * * * * * * * * * * * * * * * *
</pre>
</blockquote>
</div>
<div class="section" id="test-of-i-function">
<h1>Test of i Function</h1>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; v = [('adam', 'b1'), ('betty', 'g1'), ('fido', 'd1'),
...      ('girl', set(['g1', 'g2'])), ('boy', set(['b1', 'b2'])), ('dog', set(['d1'])),
...      ('love', set([('b1', 'g1'), ('b2', 'g2'), ('g1', 'b1'), ('g2', 'b1')]))]
&gt;&gt;&gt; val = Valuation(v)
&gt;&gt;&gt; dom = val.domain
&gt;&gt;&gt; m = Model(dom, val)
&gt;&gt;&gt; g = Assignment(dom, [('x', 'b1'), ('y', 'g2')])
&gt;&gt;&gt; exprs = ['adam', 'girl', 'love', 'walks', 'x', 'y', 'z']
&gt;&gt;&gt; lp = LogicParser()
&gt;&gt;&gt; parsed_exprs = [lp.parse(e) for e in exprs]
&gt;&gt;&gt; sorted_set = lambda x: sorted(x) if isinstance(x, set) else x
&gt;&gt;&gt; for parsed in parsed_exprs:
...     try:
...         print(&quot;'%s' gets value %s&quot; % (parsed, sorted_set(m.i(parsed, g))))
...     except Undefined:
...         print(&quot;'%s' is Undefined&quot; % parsed)
'adam' gets value b1
'girl' gets value [('g1',), ('g2',)]
'love' gets value [('b1', 'g1'), ('b2', 'g2'), ('g1', 'b1'), ('g2', 'b1')]
'walks' is Undefined
'x' gets value b1
'y' gets value g2
'z' is Undefined
</pre>
</blockquote>
</div>
<div class="section" id="test-for-formulas-in-model">
<h1>Test for formulas in Model</h1>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; tests = [
...     ('love(adam, betty)', True),
...     ('love(adam, sue)', 'Undefined'),
...     ('dog(fido)', True),
...     ('- dog(fido)', False),
...     ('- - dog(fido)', True),
...     ('- dog(sue)', 'Undefined'),
...     ('dog(fido) &amp; boy(adam)', True),
...     ('- (dog(fido) &amp; boy(adam))', False),
...     ('- dog(fido) &amp; boy(adam)', False),
...     ('dog(fido) | boy(adam)', True),
...     ('- (dog(fido) | boy(adam))', False),
...     ('- dog(fido) | boy(adam)', True),
...     ('- dog(fido) | - boy(adam)', False),
...     ('dog(fido) -&gt; boy(adam)', True),
...     ('- (dog(fido) -&gt; boy(adam))', False),
...     ('- dog(fido) -&gt; boy(adam)', True),
...     ('exists x . love(adam, x)', True),
...     ('all x . love(adam, x)', False),
...     ('fido = fido', True),
...     ('exists x . all y. love(x, y)', False),
...     ('exists x . (x = fido)', True),
...     ('all x . (dog(x) | - dog(x))', True),
...     ('adam = mia', 'Undefined'),
...     ('\\x. (boy(x) | girl(x))', {'g2': True, 'b2': True, 'b1': True, 'g1': True, 'd1': False}),
...     ('\\x. exists y. (boy(x) &amp; love(x, y))', {'g2': False, 'b2': True, 'b1': True, 'g1': False, 'd1': False}),
...     ('exists z1. boy(z1)', True),
...     ('exists x. (boy(x) &amp; - (x = adam))', True),
...     ('exists x. (boy(x) &amp; all y. love(y, x))', False),
...     ('all x. (boy(x) | girl(x))', False),
...     ('all x. (girl(x) -&gt; exists y. boy(y) &amp; love(x, y))', False),
...     ('exists x. (boy(x) &amp; all y. (girl(y) -&gt; love(y, x)))', True),
...     ('exists x. (boy(x) &amp; all y. (girl(y) -&gt; love(x, y)))', False),
...     ('all x. (dog(x) -&gt; - girl(x))', True),
...     ('exists x. exists y. (love(x, y) &amp; love(x, y))', True),
...     ]
&gt;&gt;&gt; for (sent, testvalue) in tests:
...     semvalue = m.evaluate(sent, g)
...     if semvalue == testvalue:
...         print('*', end=' ')
...     else:
...         print(sent, semvalue)
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
</pre>
</blockquote>
</div>
<div class="section" id="satisfier-tests">
<h1>Satisfier Tests</h1>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; formulas = [
...     'boy(x)',
...     '(x = x)',
...     '(boy(x) | girl(x))',
...     '(boy(x) &amp; girl(x))',
...     'love(adam, x)',
...     'love(x, adam)',
...     '- (x = adam)',
...     'exists z22. love(x, z22)',
...     'exists y. love(y, x)',
...     'all y. (girl(y) -&gt; love(x, y))',
...     'all y. (girl(y) -&gt; love(y, x))',
...     'all y. (girl(y) -&gt; (boy(x) &amp; love(y, x)))',
...     'boy(x) &amp; all y. (girl(y) -&gt; love(x, y))',
...     'boy(x) &amp; all y. (girl(y) -&gt; love(y, x))',
...     'boy(x) &amp; exists y. (girl(y) &amp; love(y, x))',
...     'girl(x) -&gt; dog(x)',
...     'all y. (dog(y) -&gt; (x = y))',
...     '- exists y. love(y, x)',
...     'exists y. (love(adam, y) &amp; love(y, x))'
...     ]
&gt;&gt;&gt; g.purge()
&gt;&gt;&gt; g.add('x', 'b1')
{'x': 'b1'}
&gt;&gt;&gt; for f in formulas: # doctest: +NORMALIZE_WHITESPACE
...     try:
...         print(&quot;'%s' gets value: %s&quot; % (f, m.evaluate(f, g)))
...     except Undefined:
...         print(&quot;'%s' is Undefined&quot; % f)
'boy(x)' gets value: True
'(x = x)' gets value: True
'(boy(x) | girl(x))' gets value: True
'(boy(x) &amp; girl(x))' gets value: False
'love(adam, x)' gets value: False
'love(x, adam)' gets value: False
'- (x = adam)' gets value: False
'exists z22. love(x, z22)' gets value: True
'exists y. love(y, x)' gets value: True
'all y. (girl(y) -&gt; love(x, y))' gets value: False
'all y. (girl(y) -&gt; love(y, x))' gets value: True
'all y. (girl(y) -&gt; (boy(x) &amp; love(y, x)))' gets value: True
'boy(x) &amp; all y. (girl(y) -&gt; love(x, y))' gets value: False
'boy(x) &amp; all y. (girl(y) -&gt; love(y, x))' gets value: True
'boy(x) &amp; exists y. (girl(y) &amp; love(y, x))' gets value: True
'girl(x) -&gt; dog(x)' gets value: True
'all y. (dog(y) -&gt; (x = y))' gets value: False
'- exists y. love(y, x)' gets value: False
'exists y. (love(adam, y) &amp; love(y, x))' gets value: True
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; lp = LogicParser()
&gt;&gt;&gt; for fmla in formulas: # doctest: +NORMALIZE_WHITESPACE
...     p = lp.parse(fmla)
...     g.purge()
...     print(&quot;Satisfiers of '%s':\n\t%s&quot; % (p, sorted(m.satisfiers(p, 'x', g))))
Satisfiers of 'boy(x)':
    ['b1', 'b2']
Satisfiers of '(x = x)':
    ['b1', 'b2', 'd1', 'g1', 'g2']
Satisfiers of '(boy(x) | girl(x))':
    ['b1', 'b2', 'g1', 'g2']
Satisfiers of '(boy(x) &amp; girl(x))':
    []
Satisfiers of 'love(adam,x)':
    ['g1']
Satisfiers of 'love(x,adam)':
    ['g1', 'g2']
Satisfiers of '-(x = adam)':
    ['b2', 'd1', 'g1', 'g2']
Satisfiers of 'exists z22.love(x,z22)':
    ['b1', 'b2', 'g1', 'g2']
Satisfiers of 'exists y.love(y,x)':
    ['b1', 'g1', 'g2']
Satisfiers of 'all y.(girl(y) -&gt; love(x,y))':
    []
Satisfiers of 'all y.(girl(y) -&gt; love(y,x))':
    ['b1']
Satisfiers of 'all y.(girl(y) -&gt; (boy(x) &amp; love(y,x)))':
    ['b1']
Satisfiers of '(boy(x) &amp; all y.(girl(y) -&gt; love(x,y)))':
    []
Satisfiers of '(boy(x) &amp; all y.(girl(y) -&gt; love(y,x)))':
    ['b1']
Satisfiers of '(boy(x) &amp; exists y.(girl(y) &amp; love(y,x)))':
    ['b1']
Satisfiers of '(girl(x) -&gt; dog(x))':
    ['b1', 'b2', 'd1']
Satisfiers of 'all y.(dog(y) -&gt; (x = y))':
    ['d1']
Satisfiers of '-exists y.love(y,x)':
    ['b2', 'd1']
Satisfiers of 'exists y.(love(adam,y) &amp; love(y,x))':
    ['b1']
</pre>
</blockquote>
</div>
<div class="section" id="tests-based-on-the-blackburn-bos-testsuite">
<h1>Tests based on the Blackburn &amp; Bos testsuite</h1>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; v1 = [('jules', 'd1'), ('vincent', 'd2'), ('pumpkin', 'd3'),
...       ('honey_bunny', 'd4'), ('yolanda', 'd5'),
...       ('customer', set(['d1', 'd2'])),
...       ('robber', set(['d3', 'd4'])),
...       ('love', set([('d3', 'd4')]))]
&gt;&gt;&gt; val1 = Valuation(v1)
&gt;&gt;&gt; dom1 = val1.domain
&gt;&gt;&gt; m1 = Model(dom1, val1)
&gt;&gt;&gt; g1 = Assignment(dom1)
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; v2 = [('jules', 'd1'), ('vincent', 'd2'), ('pumpkin', 'd3'),
...       ('honey_bunny', 'd4'), ('yolanda', 'd4'),
...       ('customer', set(['d1', 'd2', 'd5', 'd6'])),
...       ('robber', set(['d3', 'd4'])),
...       ('love', set([(None, None)]))]
&gt;&gt;&gt; val2 = Valuation(v2)
&gt;&gt;&gt; dom2 = set(['d1', 'd2', 'd3', 'd4', 'd5', 'd6'])
&gt;&gt;&gt; m2 = Model(dom2, val2)
&gt;&gt;&gt; g2 = Assignment(dom2)
&gt;&gt;&gt; g21 = Assignment(dom2)
&gt;&gt;&gt; g21.add('y', 'd3')
{'y': 'd3'}
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; v3 = [('mia', 'd1'), ('jody', 'd2'), ('jules', 'd3'),
...       ('vincent', 'd4'),
...       ('woman', set(['d1', 'd2'])), ('man', set(['d3', 'd4'])),
...       ('joke', set(['d5', 'd6'])), ('episode', set(['d7', 'd8'])),
...       ('in', set([('d5', 'd7'), ('d5', 'd8')])),
...       ('tell', set([('d1', 'd5'), ('d2', 'd6')]))]
&gt;&gt;&gt; val3 = Valuation(v3)
&gt;&gt;&gt; dom3 = set(['d1', 'd2', 'd3', 'd4', 'd5', 'd6', 'd7', 'd8'])
&gt;&gt;&gt; m3 = Model(dom3, val3)
&gt;&gt;&gt; g3 = Assignment(dom3)
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; tests = [
...     ('exists x. robber(x)', m1, g1, True),
...     ('exists x. exists y. love(y, x)', m1, g1, True),
...     ('exists x0. exists x1. love(x1, x0)', m2, g2, False),
...     ('all x. all y. love(y, x)', m2, g2, False),
...     ('- (all x. all y. love(y, x))', m2, g2, True),
...     ('all x. all y. - love(y, x)', m2, g2, True),
...     ('yolanda = honey_bunny', m2, g2, True),
...     ('mia = honey_bunny', m2, g2, 'Undefined'),
...     ('- (yolanda = honey_bunny)', m2, g2, False),
...     ('- (mia = honey_bunny)', m2, g2, 'Undefined'),
...     ('all x. (robber(x) | customer(x))', m2, g2, True),
...     ('- (all x. (robber(x) | customer(x)))', m2, g2, False),
...     ('(robber(x) | customer(x))', m2, g2, 'Undefined'),
...     ('(robber(y) | customer(y))', m2, g21, True),
...     ('exists x. (man(x) &amp; exists x. woman(x))', m3, g3, True),
...     ('exists x. (man(x) &amp; exists x. woman(x))', m3, g3, True),
...     ('- exists x. woman(x)', m3, g3, False),
...     ('exists x. (tasty(x) &amp; burger(x))', m3, g3, 'Undefined'),
...     ('- exists x. (tasty(x) &amp; burger(x))', m3, g3, 'Undefined'),
...     ('exists x. (man(x) &amp; - exists y. woman(y))', m3, g3, False),
...     ('exists x. (man(x) &amp; - exists x. woman(x))', m3, g3, False),
...     ('exists x. (woman(x) &amp; - exists x. customer(x))', m2, g2, 'Undefined'),
... ]
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; for item in tests:
...     sentence, model, g, testvalue = item
...     semvalue = model.evaluate(sentence, g)
...     if semvalue == testvalue:
...         print('*', end=' ')
...     g.purge()
* * * * * * * * * * * * * * * * * * * * * *
</pre>
</blockquote>
</div>
<div class="section" id="tests-for-mapping-from-syntax-to-semantics">
<h1>Tests for mapping from syntax to semantics</h1>
<p>Load a valuation from a file.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; import nltk.data
&gt;&gt;&gt; val = nltk.data.load('grammars/sample_grammars/valuation1.val')
&gt;&gt;&gt; dom = val.domain
&gt;&gt;&gt; m = Model(dom, val)
&gt;&gt;&gt; g = Assignment(dom)
&gt;&gt;&gt; gramfile = 'grammars/sample_grammars/sem2.fcfg'
&gt;&gt;&gt; inputs = ['John sees a girl', 'every dog barks']
&gt;&gt;&gt; parses = batch_parse(inputs, gramfile)
&gt;&gt;&gt; for sent, trees in zip(inputs, parses):
...     print()
...     print(&quot;Sentence: %s&quot; % sent)
...     for tree in trees:
...         print(&quot;Parse:\n %s&quot; %tree)
...         print(&quot;Semantics: %s&quot; %  root_semrep(tree))
&lt;BLANKLINE&gt;
Sentence: John sees a girl
Parse:
 (S[SEM=&lt;exists x.(girl(x) &amp; see(john,x))&gt;]
  (NP[-LOC, NUM='sg', SEM=&lt;\P.P(john)&gt;]
    (PropN[-LOC, NUM='sg', SEM=&lt;\P.P(john)&gt;] John))
  (VP[NUM='sg', SEM=&lt;\y.exists x.(girl(x) &amp; see(y,x))&gt;]
    (TV[NUM='sg', SEM=&lt;\X y.X(\x.see(y,x))&gt;, TNS='pres'] sees)
    (NP[NUM='sg', SEM=&lt;\Q.exists x.(girl(x) &amp; Q(x))&gt;]
      (Det[NUM='sg', SEM=&lt;\P Q.exists x.(P(x) &amp; Q(x))&gt;] a)
      (Nom[NUM='sg', SEM=&lt;\x.girl(x)&gt;]
        (N[NUM='sg', SEM=&lt;\x.girl(x)&gt;] girl)))))
Semantics: exists x.(girl(x) &amp; see(john,x))
&lt;BLANKLINE&gt;
Sentence: every dog barks
Parse:
 (S[SEM=&lt;all x.(dog(x) -&gt; bark(x))&gt;]
  (NP[NUM='sg', SEM=&lt;\Q.all x.(dog(x) -&gt; Q(x))&gt;]
    (Det[NUM='sg', SEM=&lt;\P Q.all x.(P(x) -&gt; Q(x))&gt;] every)
    (Nom[NUM='sg', SEM=&lt;\x.dog(x)&gt;]
      (N[NUM='sg', SEM=&lt;\x.dog(x)&gt;] dog)))
  (VP[NUM='sg', SEM=&lt;\x.bark(x)&gt;]
    (IV[NUM='sg', SEM=&lt;\x.bark(x)&gt;, TNS='pres'] barks)))
Semantics: all x.(dog(x) -&gt; bark(x))
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; sent = &quot;every dog barks&quot;
&gt;&gt;&gt; result = nltk.sem.batch_interpret([sent], gramfile)[0]
&gt;&gt;&gt; for (syntree, semrep) in result:
...     print(syntree)
...     print()
...     print(semrep)
(S[SEM=&lt;all x.(dog(x) -&gt; bark(x))&gt;]
  (NP[NUM='sg', SEM=&lt;\Q.all x.(dog(x) -&gt; Q(x))&gt;]
    (Det[NUM='sg', SEM=&lt;\P Q.all x.(P(x) -&gt; Q(x))&gt;] every)
    (Nom[NUM='sg', SEM=&lt;\x.dog(x)&gt;]
      (N[NUM='sg', SEM=&lt;\x.dog(x)&gt;] dog)))
  (VP[NUM='sg', SEM=&lt;\x.bark(x)&gt;]
    (IV[NUM='sg', SEM=&lt;\x.bark(x)&gt;, TNS='pres'] barks)))
&lt;BLANKLINE&gt;
all x.(dog(x) -&gt; bark(x))
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; result = nltk.sem.batch_evaluate([sent], gramfile, m, g)[0]
&gt;&gt;&gt; for (syntree, semrel, value) in result:
...     print(syntree)
...     print()
...     print(semrep)
...     print()
...     print(value)
(S[SEM=&lt;all x.(dog(x) -&gt; bark(x))&gt;]
  (NP[NUM='sg', SEM=&lt;\Q.all x.(dog(x) -&gt; Q(x))&gt;]
    (Det[NUM='sg', SEM=&lt;\P Q.all x.(P(x) -&gt; Q(x))&gt;] every)
    (Nom[NUM='sg', SEM=&lt;\x.dog(x)&gt;]
      (N[NUM='sg', SEM=&lt;\x.dog(x)&gt;] dog)))
  (VP[NUM='sg', SEM=&lt;\x.bark(x)&gt;]
    (IV[NUM='sg', SEM=&lt;\x.bark(x)&gt;, TNS='pres'] barks)))
&lt;BLANKLINE&gt;
all x.(dog(x) -&gt; bark(x))
&lt;BLANKLINE&gt;
True
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; sents = ['Mary walks', 'John sees a dog']
&gt;&gt;&gt; results = nltk.sem.batch_interpret(sents, 'grammars/sample_grammars/sem2.fcfg')
&gt;&gt;&gt; for result in results:
...     for (synrep, semrep) in result:
...         print(synrep)
(S[SEM=&lt;walk(mary)&gt;]
  (NP[-LOC, NUM='sg', SEM=&lt;\P.P(mary)&gt;]
    (PropN[-LOC, NUM='sg', SEM=&lt;\P.P(mary)&gt;] Mary))
  (VP[NUM='sg', SEM=&lt;\x.walk(x)&gt;]
    (IV[NUM='sg', SEM=&lt;\x.walk(x)&gt;, TNS='pres'] walks)))
(S[SEM=&lt;exists x.(dog(x) &amp; see(john,x))&gt;]
  (NP[-LOC, NUM='sg', SEM=&lt;\P.P(john)&gt;]
    (PropN[-LOC, NUM='sg', SEM=&lt;\P.P(john)&gt;] John))
  (VP[NUM='sg', SEM=&lt;\y.exists x.(dog(x) &amp; see(y,x))&gt;]
    (TV[NUM='sg', SEM=&lt;\X y.X(\x.see(y,x))&gt;, TNS='pres'] sees)
    (NP[NUM='sg', SEM=&lt;\Q.exists x.(dog(x) &amp; Q(x))&gt;]
      (Det[NUM='sg', SEM=&lt;\P Q.exists x.(P(x) &amp; Q(x))&gt;] a)
      (Nom[NUM='sg', SEM=&lt;\x.dog(x)&gt;]
        (N[NUM='sg', SEM=&lt;\x.dog(x)&gt;] dog)))))
</pre>
</blockquote>
</div>
<div class="section" id="cooper-storage">
<h1>Cooper Storage</h1>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from nltk.sem import cooper_storage as cs
&gt;&gt;&gt; sentence = 'every girl chases a dog'
&gt;&gt;&gt; trees = cs.parse_with_bindops(sentence, grammar='grammars/book_grammars/storage.fcfg')
&gt;&gt;&gt; semrep = trees[0].node['SEM']
&gt;&gt;&gt; cs_semrep = cs.CooperStore(semrep)
&gt;&gt;&gt; print(cs_semrep.core)
chase(z2,z4)
&gt;&gt;&gt; for bo in cs_semrep.store:
...     print(bo)
bo(\P.all x.(girl(x) -&gt; P(x)),z2)
bo(\P.exists x.(dog(x) &amp; P(x)),z4)
&gt;&gt;&gt; cs_semrep.s_retrieve(trace=True)
Permutation 1
   (\P.all x.(girl(x) -&gt; P(x)))(\z2.chase(z2,z4))
   (\P.exists x.(dog(x) &amp; P(x)))(\z4.all x.(girl(x) -&gt; chase(x,z4)))
Permutation 2
   (\P.exists x.(dog(x) &amp; P(x)))(\z4.chase(z2,z4))
   (\P.all x.(girl(x) -&gt; P(x)))(\z2.exists x.(dog(x) &amp; chase(z2,x)))
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; for reading in cs_semrep.readings:
...     print(reading)
exists x.(dog(x) &amp; all z3.(girl(z3) -&gt; chase(z3,x)))
all x.(girl(x) -&gt; exists z4.(dog(z4) &amp; chase(x,z4)))
</pre>
</blockquote>
</div>
</div>
</body>
</html>
