<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.11: http://docutils.sourceforge.net/" />
<title>Unit tests for nltk.tree.Tree</title>
<style type="text/css">

/*
:Author: David Goodger (goodger@python.org)
:Id: $Id: html4css1.css 7614 2013-02-21 15:55:51Z milde $
:Copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.

See http://docutils.sf.net/docs/howto/html-stylesheets.html for how to
customize this style sheet.
*/

/* used to remove borders from tables and images */
.borderless, table.borderless td, table.borderless th {
  border: 0 }

table.borderless td, table.borderless th {
  /* Override padding for "table.docutils td" with "! important".
     The right padding separates the table cells. */
  padding: 0 0.5em 0 0 ! important }

.first {
  /* Override more specific margin styles with "! important". */
  margin-top: 0 ! important }

.last, .with-subtitle {
  margin-bottom: 0 ! important }

.hidden {
  display: none }

a.toc-backref {
  text-decoration: none ;
  color: black }

blockquote.epigraph {
  margin: 2em 5em ; }

dl.docutils dd {
  margin-bottom: 0.5em }

object[type="image/svg+xml"], object[type="application/x-shockwave-flash"] {
  overflow: hidden;
}

/* Uncomment (and remove this text!) to get bold-faced definition list terms
dl.docutils dt {
  font-weight: bold }
*/

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.admonition, div.attention, div.caution, div.danger, div.error,
div.hint, div.important, div.note, div.tip, div.warning {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.admonition p.admonition-title, div.hint p.admonition-title,
div.important p.admonition-title, div.note p.admonition-title,
div.tip p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title, .code .error {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

/* Uncomment (and remove this text!) to get reduced vertical space in
   compound paragraphs.
div.compound .compound-first, div.compound .compound-middle {
  margin-bottom: 0.5em }

div.compound .compound-last, div.compound .compound-middle {
  margin-top: 0.5em }
*/

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em ;
  margin-right: 2em }

div.footer, div.header {
  clear: both;
  font-size: smaller }

div.line-block {
  display: block ;
  margin-top: 1em ;
  margin-bottom: 1em }

div.line-block div.line-block {
  margin-top: 0 ;
  margin-bottom: 0 ;
  margin-left: 1.5em }

div.sidebar {
  margin: 0 0 0.5em 1em ;
  border: medium outset ;
  padding: 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.section-subtitle, h2.section-subtitle, h3.section-subtitle,
h4.section-subtitle, h5.section-subtitle, h6.section-subtitle {
  margin-top: 0.4em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

hr.docutils {
  width: 75% }

img.align-left, .figure.align-left, object.align-left {
  clear: left ;
  float: left ;
  margin-right: 1em }

img.align-right, .figure.align-right, object.align-right {
  clear: right ;
  float: right ;
  margin-left: 1em }

img.align-center, .figure.align-center, object.align-center {
  display: block;
  margin-left: auto;
  margin-right: auto;
}

.align-left {
  text-align: left }

.align-center {
  clear: both ;
  text-align: center }

.align-right {
  text-align: right }

/* reset inner alignment in figures */
div.align-right {
  text-align: inherit }

/* div.align-center * { */
/*   text-align: left } */

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font: inherit }

pre.literal-block, pre.doctest-block, pre.math, pre.code {
  margin-left: 2em ;
  margin-right: 2em }

pre.code .ln { color: grey; } /* line numbers */
pre.code, code { background-color: #eeeeee }
pre.code .comment, code .comment { color: #5C6576 }
pre.code .keyword, code .keyword { color: #3B0D06; font-weight: bold }
pre.code .literal.string, code .literal.string { color: #0C5404 }
pre.code .name.builtin, code .name.builtin { color: #352B84 }
pre.code .deleted, code .deleted { background-color: #DEB0A1}
pre.code .inserted, code .inserted { background-color: #A3D289}

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

span.section-subtitle {
  /* font-size relative to parent (h1..h6 element) */
  font-size: 80% }

table.citation {
  border-left: solid 1px gray;
  margin-left: 1px }

table.docinfo {
  margin: 2em 4em }

table.docutils {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.footnote {
  border-left: solid 1px black;
  margin-left: 1px }

table.docutils td, table.docutils th,
table.docinfo td, table.docinfo th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

table.docutils th.field-name, table.docinfo th.docinfo-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap ;
  padding-left: 0 }

/* "booktabs" style (no vertical lines) */
table.docutils.booktabs {
  border: 0px;
  border-top: 2px solid;
  border-bottom: 2px solid;
  border-collapse: collapse;
}
table.docutils.booktabs * {
  border: 0px;
}
table.docutils.booktabs th {
  border-bottom: thin solid;
  text-align: left;
}

h1 tt.docutils, h2 tt.docutils, h3 tt.docutils,
h4 tt.docutils, h5 tt.docutils, h6 tt.docutils {
  font-size: 100% }

ul.auto-toc {
  list-style-type: none }

</style>
</head>
<body>
<div class="document" id="unit-tests-for-nltk-tree-tree">
<h1 class="title">Unit tests for nltk.tree.Tree</h1>

<!-- Copyright (C) 2001-2013 NLTK Project -->
<!-- For license information, see LICENSE.TXT -->
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from nltk.tree import *
</pre>
</blockquote>
<p>Some trees to run tests on:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; dp1 = Tree('dp', [Tree('d', ['the']), Tree('np', ['dog'])])
&gt;&gt;&gt; dp2 = Tree('dp', [Tree('d', ['the']), Tree('np', ['cat'])])
&gt;&gt;&gt; vp = Tree('vp', [Tree('v', ['chased']), dp2])
&gt;&gt;&gt; tree = Tree('s', [dp1, vp])
&gt;&gt;&gt; print(tree)
(s (dp (d the) (np dog)) (vp (v chased) (dp (d the) (np cat))))
</pre>
</blockquote>
<p>The node value is stored using the <cite>node</cite> attribute:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; dp1.node, dp2.node, vp.node, tree.node
('dp', 'dp', 'vp', 's')
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; print(tree[1,1,1,0])
cat
</pre>
</blockquote>
<p>The <cite>treepositions</cite> method returns a list of the tree positions of
subtrees and leaves in a tree.  By default, it gives the position of
every tree, subtree, and leaf, in prefix order:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; print(tree.treepositions())
[(), (0,), (0, 0), (0, 0, 0), (0, 1), (0, 1, 0), (1,), (1, 0), (1, 0, 0), (1, 1), (1, 1, 0), (1, 1, 0, 0), (1, 1, 1), (1, 1, 1, 0)]
</pre>
</blockquote>
<p>In addition to <cite>str</cite> and <cite>repr</cite>, several methods exist to convert a
tree object to one of several standard tree encodings:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; print(tree.pprint_latex_qtree())
\Tree [.s
        [.dp [.d the ] [.np dog ] ]
        [.vp [.v chased ] [.dp [.d the ] [.np cat ] ] ] ]
</pre>
</blockquote>
<p>Trees can be parsed from treebank strings with the static
<cite>Tree.parse()</cite> method:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; tree2 = Tree.parse('(S (NP I) (VP (V enjoyed) (NP my cookie)))')
&gt;&gt;&gt; print(tree2)
(S (NP I) (VP (V enjoyed) (NP my cookie)))
</pre>
</blockquote>
<p>If the <cite>Tree</cite> constructor is called with a single string argument,
then it simply delegates to <cite>Tree.parse()</cite>.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; print(Tree('(S (NP I) (VP (V enjoyed) (NP my cookie)))'))
(S (NP I) (VP (V enjoyed) (NP my cookie)))
</pre>
</blockquote>
<p>Trees can be compared for equality:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; tree == Tree.parse(str(tree))
True
&gt;&gt;&gt; tree2 == Tree.parse(str(tree2))
True
&gt;&gt;&gt; tree == tree2
False
&gt;&gt;&gt; tree == Tree.parse(str(tree2))
False
&gt;&gt;&gt; tree2 == Tree.parse(str(tree))
False
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; tree != Tree.parse(str(tree))
False
&gt;&gt;&gt; tree2 != Tree.parse(str(tree2))
False
&gt;&gt;&gt; tree != tree2
True
&gt;&gt;&gt; tree != Tree.parse(str(tree2))
True
&gt;&gt;&gt; tree2 != Tree.parse(str(tree))
True
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; tree &lt; tree2 or tree &gt; tree2
True
</pre>
</blockquote>
<div class="section" id="tree-parsing">
<h1>Tree Parsing</h1>
<p>The class method <cite>Tree.parse()</cite> can be used to parse trees:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; tree = Tree.parse('(S (NP I) (VP (V enjoyed) (NP my cookie)))')
&gt;&gt;&gt; print(tree)
(S (NP I) (VP (V enjoyed) (NP my cookie)))
</pre>
</blockquote>
<p>When called on a subclass of <cite>Tree</cite>, it will create trees of that
type:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; tree = ImmutableTree.parse('(VP (V enjoyed) (NP my cookie))')
&gt;&gt;&gt; print(tree)
(VP (V enjoyed) (NP my cookie))
&gt;&gt;&gt; print(type(tree))
&lt;class 'nltk.tree.ImmutableTree'&gt;
&gt;&gt;&gt; tree[1] = 'x'
Traceback (most recent call last):
  . . .
ValueError: ImmutableTree may not be modified
&gt;&gt;&gt; del tree[0]
Traceback (most recent call last):
  . . .
ValueError: ImmutableTree may not be modified
</pre>
</blockquote>
<p>The <tt class="docutils literal">brackets</tt> parameter can be used to specify two characters that
should be used as brackets:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; print(Tree.parse('[S [NP I] [VP [V enjoyed] [NP my cookie]]]',
...                  brackets='[]'))
(S (NP I) (VP (V enjoyed) (NP my cookie)))
&gt;&gt;&gt; print(Tree.parse('&lt;S &lt;NP I&gt; &lt;VP &lt;V enjoyed&gt; &lt;NP my cookie&gt;&gt;&gt;',
...                  brackets='&lt;&gt;'))
(S (NP I) (VP (V enjoyed) (NP my cookie)))
</pre>
</blockquote>
<p>If <tt class="docutils literal">brackets</tt> is not a string, or is not exactly two characters,
then <cite>Tree.parse</cite> raises an exception:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; Tree.parse('&lt;VP &lt;V enjoyed&gt; &lt;NP my cookie&gt;&gt;', brackets='')
Traceback (most recent call last):
  . . .
TypeError: brackets must be a length-2 string
&gt;&gt;&gt; Tree.parse('&lt;VP &lt;V enjoyed&gt; &lt;NP my cookie&gt;&gt;', brackets='&lt;&lt;&gt;&gt;')
Traceback (most recent call last):
  . . .
TypeError: brackets must be a length-2 string
&gt;&gt;&gt; Tree.parse('&lt;VP &lt;V enjoyed&gt; &lt;NP my cookie&gt;&gt;', brackets=12)
Traceback (most recent call last):
  . . .
TypeError: brackets must be a length-2 string
&gt;&gt;&gt; Tree.parse('&lt;&lt;NP my cookie&gt;&gt;', brackets=('&lt;&lt;','&gt;&gt;'))
Traceback (most recent call last):
  . . .
TypeError: brackets must be a length-2 string
</pre>
</blockquote>
<p>(We may add support for multi-character brackets in the future, in
which case the <tt class="docutils literal"><span class="pre">brackets=('&lt;&lt;','&gt;&gt;')</span></tt> example would start working.)</p>
<p>Whitespace brackets are not permitted:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; Tree.parse('(NP my cookie\n', brackets='(\n')
Traceback (most recent call last):
  . . .
TypeError: whitespace brackets not allowed
</pre>
</blockquote>
<p>If an invalid tree is given to Tree.parse, then it raises a
ValueError, with a description of the problem:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; Tree.parse('(NP my cookie) (NP my milk)')
Traceback (most recent call last):
  . . .
ValueError: Tree.parse(): expected 'end-of-string' but got '(NP'
            at index 15.
                &quot;...y cookie) (NP my mil...&quot;
                              ^
&gt;&gt;&gt; Tree.parse(')NP my cookie(')
Traceback (most recent call last):
  . . .
ValueError: Tree.parse(): expected '(' but got ')'
            at index 0.
                &quot;)NP my coo...&quot;
                 ^
&gt;&gt;&gt; Tree.parse('(NP my cookie))')
Traceback (most recent call last):
  . . .
ValueError: Tree.parse(): expected 'end-of-string' but got ')'
            at index 14.
                &quot;...my cookie))&quot;
                              ^
&gt;&gt;&gt; Tree.parse('my cookie)')
Traceback (most recent call last):
  . . .
ValueError: Tree.parse(): expected '(' but got 'my'
            at index 0.
                &quot;my cookie)&quot;
                 ^
&gt;&gt;&gt; Tree.parse('(NP my cookie')
Traceback (most recent call last):
  . . .
ValueError: Tree.parse(): expected ')' but got 'end-of-string'
            at index 13.
                &quot;... my cookie&quot;
                              ^
&gt;&gt;&gt; Tree.parse('')
Traceback (most recent call last):
  . . .
ValueError: Tree.parse(): expected '(' but got 'end-of-string'
            at index 0.
                &quot;&quot;
                 ^
</pre>
</blockquote>
<p>Trees with no children are supported:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; print(Tree.parse('(S)'))
(S )
&gt;&gt;&gt; print(Tree.parse('(X (Y) (Z))'))
(X (Y ) (Z ))
</pre>
</blockquote>
<p>Trees with an empty node and no children are supported:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; print(Tree.parse('()'))
( )
&gt;&gt;&gt; print(Tree.parse('(X () ())'))
(X ( ) ( ))
</pre>
</blockquote>
<p>Trees with an empty node and children are supported, but only if the
first child is not a leaf (otherwise, it will be treated as the node
value).</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; print(Tree.parse('((A) (B) (C))'))
( (A ) (B ) (C ))
&gt;&gt;&gt; print(Tree.parse('((A) leaf)'))
( (A ) leaf)
&gt;&gt;&gt; print(Tree.parse('(((())))'))
( ( ( ( ))))
</pre>
</blockquote>
<p>The optional arguments <cite>parse_node</cite> and <cite>parse_leaf</cite> may be used to
transform the string values of nodes or leaves.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; print(Tree.parse('(A b (C d e) (F (G h i)))',
...                  parse_node=lambda s: '&lt;%s&gt;' % s,
...                  parse_leaf=lambda s: '&quot;%s&quot;' % s))
(&lt;A&gt; &quot;b&quot; (&lt;C&gt; &quot;d&quot; &quot;e&quot;) (&lt;F&gt; (&lt;G&gt; &quot;h&quot; &quot;i&quot;)))
</pre>
</blockquote>
<p>These transformation functions are typically used when the node or
leaf values should be parsed to a non-string value (such as a feature
structure).  If node values and leaf values need to be able to include
whitespace, then you must also use the optional <cite>node_pattern</cite> and
<cite>leaf_pattern</cite> arguments.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from nltk.featstruct import FeatStruct
&gt;&gt;&gt; tree = Tree.parse('([cat=NP] [lex=the] [lex=dog])',
...                   parse_node=FeatStruct, parse_leaf=FeatStruct)
&gt;&gt;&gt; tree.node = tree.node.unify(FeatStruct('[num=singular]'))
&gt;&gt;&gt; print(tree)
([cat='NP', num='singular'] [lex='the'] [lex='dog'])
</pre>
</blockquote>
<p>The optional argument <tt class="docutils literal">remove_empty_top_bracketing</tt> can be used to
remove any top-level empty bracketing that occurs.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; print(Tree.parse('((S (NP I) (VP (V enjoyed) (NP my cookie))))',
...                  remove_empty_top_bracketing=True))
(S (NP I) (VP (V enjoyed) (NP my cookie)))
</pre>
</blockquote>
<p>It will not remove a top-level empty bracketing with multiple children:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; print(Tree.parse('((A a) (B b))'))
( (A a) (B b))
</pre>
</blockquote>
</div>
<div class="section" id="parented-trees">
<h1>Parented Trees</h1>
<p><cite>ParentedTree</cite> is a subclass of <cite>Tree</cite> that automatically maintains
parent pointers for single-parented trees.  Parented trees can be
created directly from a node value and a list of children:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; ptree = (
...     ParentedTree('VP', [
...         ParentedTree('VERB', ['saw']),
...         ParentedTree('NP', [
...             ParentedTree('DET', ['the']),
...             ParentedTree('NOUN', ['dog'])])]))
&gt;&gt;&gt; print(ptree)
(VP (VERB saw) (NP (DET the) (NOUN dog)))
</pre>
</blockquote>
<p>Parented trees can be created from strings using the classmethod
<cite>ParentedTree.parse</cite>:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; ptree = ParentedTree.parse('(VP (VERB saw) (NP (DET the) (NOUN dog)))')
&gt;&gt;&gt; print(ptree)
(VP (VERB saw) (NP (DET the) (NOUN dog)))
&gt;&gt;&gt; print(type(ptree))
&lt;class 'nltk.tree.ParentedTree'&gt;
</pre>
</blockquote>
<p>Parented trees can also be created by using the classmethod
<cite>ParentedTree.convert</cite> to convert another type of tree to a parented
tree:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; tree = Tree.parse('(VP (VERB saw) (NP (DET the) (NOUN dog)))')
&gt;&gt;&gt; ptree = ParentedTree.convert(tree)
&gt;&gt;&gt; print(ptree)
(VP (VERB saw) (NP (DET the) (NOUN dog)))
&gt;&gt;&gt; print(type(ptree))
&lt;class 'nltk.tree.ParentedTree'&gt;
</pre>
</blockquote>
<!-- clean-up:

>>> del tree -->
<p><cite>ParentedTree</cite>s should never be used in the same tree as <cite>Tree</cite>s
or <cite>MultiParentedTree</cite>s.  Mixing tree implementations may result in
incorrect parent pointers and in <cite>TypeError</cite> exceptions:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; # Inserting a Tree in a ParentedTree gives an exception:
&gt;&gt;&gt; ParentedTree('NP', [
...     Tree('DET', ['the']), Tree('NOUN', ['dog'])])
Traceback (most recent call last):
  . . .
TypeError: Can not insert a non-ParentedTree into a ParentedTree
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; # inserting a ParentedTree in a Tree gives incorrect parent pointers:
&gt;&gt;&gt; broken_tree = Tree('NP', [
...     ParentedTree('DET', ['the']), ParentedTree('NOUN', ['dog'])])
&gt;&gt;&gt; print(broken_tree[0].parent())
None
</pre>
</blockquote>
<div class="section" id="parented-tree-methods">
<h2>Parented Tree Methods</h2>
<p>In addition to all the methods defined by the <cite>Tree</cite> class, the
<cite>ParentedTree</cite> class adds six new methods whose values are
automatically updated whenver a parented tree is modified: <cite>parent()</cite>,
<cite>parent_index()</cite>, <cite>left_sibling()</cite>, <cite>right_sibling()</cite>, <cite>root()</cite>, and
<cite>treeposition()</cite>.</p>
<p>The <cite>parent()</cite> method contains a <cite>ParentedTree</cite>'s parent, if it has
one; and <tt class="docutils literal">None</tt> otherwise.  <cite>ParentedTree</cite>s that do not have
parents are known as &quot;root trees.&quot;</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; for subtree in ptree.subtrees():
...     print(subtree)
...     print('  Parent = %s' % subtree.parent())
(VP (VERB saw) (NP (DET the) (NOUN dog)))
  Parent = None
(VERB saw)
  Parent = (VP (VERB saw) (NP (DET the) (NOUN dog)))
(NP (DET the) (NOUN dog))
  Parent = (VP (VERB saw) (NP (DET the) (NOUN dog)))
(DET the)
  Parent = (NP (DET the) (NOUN dog))
(NOUN dog)
  Parent = (NP (DET the) (NOUN dog))
</pre>
</blockquote>
<p>The <cite>parent_index()</cite> method stores the index of a tree in its parent's
child list.  If a tree does not have a parent, then its <cite>parent_index</cite>
is <tt class="docutils literal">None</tt>.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; for subtree in ptree.subtrees():
...     print(subtree)
...     print('  Parent Index = %s' % subtree.parent_index())
...     assert (subtree.parent() is None or
...             subtree.parent()[subtree.parent_index()] is subtree)
(VP (VERB saw) (NP (DET the) (NOUN dog)))
  Parent Index = None
(VERB saw)
  Parent Index = 0
(NP (DET the) (NOUN dog))
  Parent Index = 1
(DET the)
  Parent Index = 0
(NOUN dog)
  Parent Index = 1
</pre>
</blockquote>
<p>Note that <tt class="docutils literal"><span class="pre">ptree.parent().index(ptree)</span></tt> is <em>not</em> equivalent to
<tt class="docutils literal">ptree.parent_index()</tt>.  In particular, <tt class="docutils literal"><span class="pre">ptree.parent().index(ptree)</span></tt>
will return the index of the first child of <tt class="docutils literal">ptree.parent()</tt> that is
equal to <tt class="docutils literal">ptree</tt> (using <tt class="docutils literal">==</tt>); and that child may not be
<tt class="docutils literal">ptree</tt>:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; on_and_on = ParentedTree('CONJP', [
...     ParentedTree('PREP', ['on']),
...     ParentedTree('COJN', ['and']),
...     ParentedTree('PREP', ['on'])])
&gt;&gt;&gt; second_on = on_and_on[2]
&gt;&gt;&gt; print(second_on.parent_index())
2
&gt;&gt;&gt; print(second_on.parent().index(second_on))
0
</pre>
</blockquote>
<p>The methods <cite>left_sibling()</cite> and <cite>right_sibling()</cite> can be used to get a
parented tree's siblings.  If a tree does not have a left or right
sibling, then the corresponding method's value is <tt class="docutils literal">None</tt>:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; for subtree in ptree.subtrees():
...     print(subtree)
...     print('  Left Sibling  = %s' % subtree.left_sibling())
...     print('  Right Sibling = %s' % subtree.right_sibling())
(VP (VERB saw) (NP (DET the) (NOUN dog)))
  Left Sibling  = None
  Right Sibling = None
(VERB saw)
  Left Sibling  = None
  Right Sibling = (NP (DET the) (NOUN dog))
(NP (DET the) (NOUN dog))
  Left Sibling  = (VERB saw)
  Right Sibling = None
(DET the)
  Left Sibling  = None
  Right Sibling = (NOUN dog)
(NOUN dog)
  Left Sibling  = (DET the)
  Right Sibling = None
</pre>
</blockquote>
<p>A parented tree's root tree can be accessed using the <cite>root()</cite>
method.  This method follows the tree's parent pointers until it
finds a tree without a parent.  If a tree does not have a parent, then
it is its own root:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; for subtree in ptree.subtrees():
...     print(subtree)
...     print('  Root = %s' % subtree.root())
(VP (VERB saw) (NP (DET the) (NOUN dog)))
  Root = (VP (VERB saw) (NP (DET the) (NOUN dog)))
(VERB saw)
  Root = (VP (VERB saw) (NP (DET the) (NOUN dog)))
(NP (DET the) (NOUN dog))
  Root = (VP (VERB saw) (NP (DET the) (NOUN dog)))
(DET the)
  Root = (VP (VERB saw) (NP (DET the) (NOUN dog)))
(NOUN dog)
  Root = (VP (VERB saw) (NP (DET the) (NOUN dog)))
</pre>
</blockquote>
<p>The <cite>treeposition()</cite> method can be used to find a tree's treeposition
relative to its root:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; for subtree in ptree.subtrees():
...     print(subtree)
...     print('  Tree Position = %s' % (subtree.treeposition(),))
...     assert subtree.root()[subtree.treeposition()] is subtree
(VP (VERB saw) (NP (DET the) (NOUN dog)))
  Tree Position = ()
(VERB saw)
  Tree Position = (0,)
(NP (DET the) (NOUN dog))
  Tree Position = (1,)
(DET the)
  Tree Position = (1, 0)
(NOUN dog)
  Tree Position = (1, 1)
</pre>
</blockquote>
<p>Whenever a parented tree is modified, all of the methods described
above (<cite>parent()</cite>, <cite>parent_index()</cite>, <cite>left_sibling()</cite>, <cite>right_sibling()</cite>,
<cite>root()</cite>, and <cite>treeposition()</cite>) are automatically updated.  For example,
if we replace <tt class="docutils literal">ptree</tt>'s subtree for the word &quot;dog&quot; with a new
subtree for &quot;cat,&quot; the method values for both the &quot;dog&quot; subtree and the
&quot;cat&quot; subtree get automatically updated:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; # Replace the dog with a cat
&gt;&gt;&gt; dog = ptree[1,1]
&gt;&gt;&gt; cat = ParentedTree('NOUN', ['cat'])
&gt;&gt;&gt; ptree[1,1] = cat
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; # the noun phrase is no longer the dog's parent:
&gt;&gt;&gt; print(dog.parent(), dog.parent_index(), dog.left_sibling())
None None None
&gt;&gt;&gt; # dog is now its own root.
&gt;&gt;&gt; print(dog.root())
(NOUN dog)
&gt;&gt;&gt; print(dog.treeposition())
()
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; # the cat's parent is now the noun phrase:
&gt;&gt;&gt; print(cat.parent())
(NP (DET the) (NOUN cat))
&gt;&gt;&gt; print(cat.parent_index())
1
&gt;&gt;&gt; print(cat.left_sibling())
(DET the)
&gt;&gt;&gt; print(cat.root())
(VP (VERB saw) (NP (DET the) (NOUN cat)))
&gt;&gt;&gt; print(cat.treeposition())
(1, 1)
</pre>
</blockquote>
</div>
<div class="section" id="parentedtree-regression-tests">
<h2>ParentedTree Regression Tests</h2>
<p>Keep track of all trees that we create (including subtrees) using this
variable:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; all_ptrees = []
</pre>
</blockquote>
<p>Define a helper funciton to create new parented trees:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; def make_ptree(s):
...     ptree = ParentedTree.convert(Tree.parse(s))
...     all_ptrees.extend(t for t in ptree.subtrees()
...                       if isinstance(t, Tree))
...     return ptree
</pre>
</blockquote>
<p>Define a test function that examines every subtree in all_ptrees; and
checks that all six of its methods are defined correctly.  If any
ptrees are passed as arguments, then they are printed.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; def pcheck(*print_ptrees):
...     for ptree in all_ptrees:
...         # Check ptree's methods.
...         if ptree.parent() is not None:
...             i = ptree.parent_index()
...             assert ptree.parent()[i] is ptree
...             if i &gt; 0:
...                 assert ptree.left_sibling() is ptree.parent()[i-1]
...             if i &lt; (len(ptree.parent())-1):
...                 assert ptree.right_sibling() is ptree.parent()[i+1]
...             assert len(ptree.treeposition()) &gt; 0
...             assert (ptree.treeposition() ==
...                     ptree.parent().treeposition() + (ptree.parent_index(),))
...             assert ptree.root() is not ptree
...             assert ptree.root() is not None
...             assert ptree.root() is ptree.parent().root()
...             assert ptree.root()[ptree.treeposition()] is ptree
...         else:
...             assert ptree.parent_index() is None
...             assert ptree.left_sibling() is None
...             assert ptree.right_sibling() is None
...             assert ptree.root() is ptree
...             assert ptree.treeposition() == ()
...         # Check ptree's children's methods:
...         for i, child in enumerate(ptree):
...             if isinstance(child, Tree):
...                 # pcheck parent() &amp; parent_index() methods
...                 assert child.parent() is ptree
...                 assert child.parent_index() == i
...                 # pcheck sibling methods
...                 if i == 0:
...                     assert child.left_sibling() is None
...                 else:
...                     assert child.left_sibling() is ptree[i-1]
...                 if i == len(ptree)-1:
...                     assert child.right_sibling() is None
...                 else:
...                     assert child.right_sibling() is ptree[i+1]
...     if print_ptrees:
...         print('ok!', end=' ')
...         for ptree in print_ptrees: print(ptree)
...     else:
...         print('ok!')
</pre>
</blockquote>
<p>Run our test function on a variety of newly-created trees:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; pcheck(make_ptree('(A)'))
ok! (A )
&gt;&gt;&gt; pcheck(make_ptree('(A (B (C (D) (E f)) g) h)'))
ok! (A (B (C (D ) (E f)) g) h)
&gt;&gt;&gt; pcheck(make_ptree('(A (B) (C c) (D d d) (E e e e))'))
ok! (A (B ) (C c) (D d d) (E e e e))
&gt;&gt;&gt; pcheck(make_ptree('(A (B) (C (c)) (D (d) (d)) (E (e) (e) (e)))'))
ok! (A (B ) (C (c )) (D (d ) (d )) (E (e ) (e ) (e )))
</pre>
</blockquote>
<p>Run our test function after performing various tree-modification
operations:</p>
<p><strong>__delitem__()</strong></p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; ptree = make_ptree('(A (B (C (D) (E f) (Q p)) g) h)')
&gt;&gt;&gt; e = ptree[0,0,1]
&gt;&gt;&gt; del ptree[0,0,1]; pcheck(ptree); pcheck(e)
ok! (A (B (C (D ) (Q p)) g) h)
ok! (E f)
&gt;&gt;&gt; del ptree[0,0,0]; pcheck(ptree)
ok! (A (B (C (Q p)) g) h)
&gt;&gt;&gt; del ptree[0,1]; pcheck(ptree)
ok! (A (B (C (Q p))) h)
&gt;&gt;&gt; del ptree[-1]; pcheck(ptree)
ok! (A (B (C (Q p))))
&gt;&gt;&gt; del ptree[-100]
Traceback (most recent call last):
  . . .
IndexError: index out of range
&gt;&gt;&gt; del ptree[()]
Traceback (most recent call last):
  . . .
IndexError: The tree position () may not be deleted.
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; # With slices:
&gt;&gt;&gt; ptree = make_ptree('(A (B c) (D e) f g (H i) j (K l))')
&gt;&gt;&gt; b = ptree[0]
&gt;&gt;&gt; del ptree[0:0]; pcheck(ptree)
ok! (A (B c) (D e) f g (H i) j (K l))
&gt;&gt;&gt; del ptree[:1]; pcheck(ptree); pcheck(b)
ok! (A (D e) f g (H i) j (K l))
ok! (B c)
&gt;&gt;&gt; del ptree[-2:]; pcheck(ptree)
ok! (A (D e) f g (H i))
&gt;&gt;&gt; del ptree[1:3]; pcheck(ptree)
ok! (A (D e) (H i))
&gt;&gt;&gt; ptree = make_ptree('(A (B c) (D e) f g (H i) j (K l))')
&gt;&gt;&gt; del ptree[5:1000]; pcheck(ptree)
ok! (A (B c) (D e) f g (H i))
&gt;&gt;&gt; del ptree[-2:1000]; pcheck(ptree)
ok! (A (B c) (D e) f)
&gt;&gt;&gt; del ptree[-100:1]; pcheck(ptree)
ok! (A (D e) f)
&gt;&gt;&gt; ptree = make_ptree('(A (B c) (D e) f g (H i) j (K l))')
&gt;&gt;&gt; del ptree[1:-2:2]; pcheck(ptree)
ok! (A (B c) f (H i) j (K l))
</pre>
</blockquote>
<p><strong>__setitem__()</strong></p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; ptree = make_ptree('(A (B (C (D) (E f) (Q p)) g) h)')
&gt;&gt;&gt; d, e, q = ptree[0,0]
&gt;&gt;&gt; ptree[0,0,0] = 'x'; pcheck(ptree); pcheck(d)
ok! (A (B (C x (E f) (Q p)) g) h)
ok! (D )
&gt;&gt;&gt; ptree[0,0,1] = make_ptree('(X (Y z))'); pcheck(ptree); pcheck(e)
ok! (A (B (C x (X (Y z)) (Q p)) g) h)
ok! (E f)
&gt;&gt;&gt; ptree[1] = d; pcheck(ptree)
ok! (A (B (C x (X (Y z)) (Q p)) g) (D ))
&gt;&gt;&gt; ptree[-1] = 'x'; pcheck(ptree)
ok! (A (B (C x (X (Y z)) (Q p)) g) x)
&gt;&gt;&gt; ptree[-100] = 'y'
Traceback (most recent call last):
  . . .
IndexError: index out of range
&gt;&gt;&gt; ptree[()] = make_ptree('(X y)')
Traceback (most recent call last):
  . . .
IndexError: The tree position () may not be assigned to.
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; # With slices:
&gt;&gt;&gt; ptree = make_ptree('(A (B c) (D e) f g (H i) j (K l))')
&gt;&gt;&gt; b = ptree[0]
&gt;&gt;&gt; ptree[0:0] = ('x', make_ptree('(Y)')); pcheck(ptree)
ok! (A x (Y ) (B c) (D e) f g (H i) j (K l))
&gt;&gt;&gt; ptree[2:6] = (); pcheck(ptree); pcheck(b)
ok! (A x (Y ) (H i) j (K l))
ok! (B c)
&gt;&gt;&gt; ptree[-2:] = ('z', 'p'); pcheck(ptree)
ok! (A x (Y ) (H i) z p)
&gt;&gt;&gt; ptree[1:3] = [make_ptree('(X)') for x in range(10)]; pcheck(ptree)
ok! (A x (X ) (X ) (X ) (X ) (X ) (X ) (X ) (X ) (X ) (X ) z p)
&gt;&gt;&gt; ptree[5:1000] = []; pcheck(ptree)
ok! (A x (X ) (X ) (X ) (X ))
&gt;&gt;&gt; ptree[-2:1000] = ['n']; pcheck(ptree)
ok! (A x (X ) (X ) n)
&gt;&gt;&gt; ptree[-100:1] = [make_ptree('(U v)')]; pcheck(ptree)
ok! (A (U v) (X ) (X ) n)
&gt;&gt;&gt; ptree[-1:] = (make_ptree('(X)') for x in range(3)); pcheck(ptree)
ok! (A (U v) (X ) (X ) (X ) (X ) (X ))
&gt;&gt;&gt; ptree[1:-2:2] = ['x', 'y']; pcheck(ptree)
ok! (A (U v) x (X ) y (X ) (X ))
</pre>
</blockquote>
<p><strong>append()</strong></p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; ptree = make_ptree('(A (B (C (D) (E f) (Q p)) g) h)')
&gt;&gt;&gt; ptree.append('x'); pcheck(ptree)
ok! (A (B (C (D ) (E f) (Q p)) g) h x)
&gt;&gt;&gt; ptree.append(make_ptree('(X (Y z))')); pcheck(ptree)
ok! (A (B (C (D ) (E f) (Q p)) g) h x (X (Y z)))
</pre>
</blockquote>
<p><strong>extend()</strong></p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; ptree = make_ptree('(A (B (C (D) (E f) (Q p)) g) h)')
&gt;&gt;&gt; ptree.extend(['x', 'y', make_ptree('(X (Y z))')]); pcheck(ptree)
ok! (A (B (C (D ) (E f) (Q p)) g) h x y (X (Y z)))
&gt;&gt;&gt; ptree.extend([]); pcheck(ptree)
ok! (A (B (C (D ) (E f) (Q p)) g) h x y (X (Y z)))
&gt;&gt;&gt; ptree.extend(make_ptree('(X)') for x in range(3)); pcheck(ptree)
ok! (A (B (C (D ) (E f) (Q p)) g) h x y (X (Y z)) (X ) (X ) (X ))
</pre>
</blockquote>
<p><strong>insert()</strong></p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; ptree = make_ptree('(A (B (C (D) (E f) (Q p)) g) h)')
&gt;&gt;&gt; ptree.insert(0, make_ptree('(X (Y z))')); pcheck(ptree)
ok! (A (X (Y z)) (B (C (D ) (E f) (Q p)) g) h)
&gt;&gt;&gt; ptree.insert(-1, make_ptree('(X (Y z))')); pcheck(ptree)
ok! (A (X (Y z)) (B (C (D ) (E f) (Q p)) g) (X (Y z)) h)
&gt;&gt;&gt; ptree.insert(-4, make_ptree('(X (Y z))')); pcheck(ptree)
ok! (A (X (Y z)) (X (Y z)) (B (C (D ) (E f) (Q p)) g) (X (Y z)) h)
&gt;&gt;&gt; # Note: as with ``list``, inserting at a negative index that
&gt;&gt;&gt; # gives a position before the start of the list does *not*
&gt;&gt;&gt; # raise an IndexError exception; it just inserts at 0.
&gt;&gt;&gt; ptree.insert(-400, make_ptree('(X (Y z))')); pcheck(ptree)
ok! (A
  (X (Y z))
  (X (Y z))
  (X (Y z))
  (B (C (D ) (E f) (Q p)) g)
  (X (Y z))
  h)
</pre>
</blockquote>
<p><strong>pop()</strong></p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; ptree = make_ptree('(A (B (C (D) (E f) (Q p)) g) h)')
&gt;&gt;&gt; ptree[0,0].pop(1); pcheck(ptree)
ParentedTree('E', ['f'])
ok! (A (B (C (D ) (Q p)) g) h)
&gt;&gt;&gt; ptree[0].pop(-1); pcheck(ptree)
'g'
ok! (A (B (C (D ) (Q p))) h)
&gt;&gt;&gt; ptree.pop(); pcheck(ptree)
'h'
ok! (A (B (C (D ) (Q p))))
&gt;&gt;&gt; ptree.pop(-100)
Traceback (most recent call last):
  . . .
IndexError: index out of range
</pre>
</blockquote>
<p><strong>remove()</strong></p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; ptree = make_ptree('(A (B (C (D) (E f) (Q p)) g) h)')
&gt;&gt;&gt; e = ptree[0,0,1]
&gt;&gt;&gt; ptree[0,0].remove(ptree[0,0,1]); pcheck(ptree); pcheck(e)
ok! (A (B (C (D ) (Q p)) g) h)
ok! (E f)
&gt;&gt;&gt; ptree[0,0].remove(make_ptree('(Q p)')); pcheck(ptree)
ok! (A (B (C (D )) g) h)
&gt;&gt;&gt; ptree[0,0].remove(make_ptree('(Q p)'))
Traceback (most recent call last):
  . . .
ValueError: ParentedTree('Q', ['p']) is not in list
&gt;&gt;&gt; ptree.remove('h'); pcheck(ptree)
ok! (A (B (C (D )) g))
&gt;&gt;&gt; ptree.remove('h');
Traceback (most recent call last):
  . . .
ValueError: 'h' is not in list
&gt;&gt;&gt; # remove() removes the first subtree that is equal (==) to the
&gt;&gt;&gt; # given tree, which may not be the identical tree we give it:
&gt;&gt;&gt; ptree = make_ptree('(A (X x) (Y y) (X x))')
&gt;&gt;&gt; x1, y, x2 = ptree
&gt;&gt;&gt; ptree.remove(ptree[-1]); pcheck(ptree)
ok! (A (Y y) (X x))
&gt;&gt;&gt; print(x1.parent()); pcheck(x1)
None
ok! (X x)
&gt;&gt;&gt; print(x2.parent())
(A (Y y) (X x))
</pre>
</blockquote>
<p>Test that a tree can not be given multiple parents:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; ptree = make_ptree('(A (X x) (Y y) (Z z))')
&gt;&gt;&gt; ptree[0] = ptree[1]
Traceback (most recent call last):
  . . .
ValueError: Can not insert a subtree that already has a parent.
&gt;&gt;&gt; pcheck()
ok!
</pre>
</blockquote>
<p>[more to be written]</p>
</div>
<div class="section" id="immutableparentedtree-regression-tests">
<h2>ImmutableParentedTree Regression Tests</h2>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; iptree = ImmutableParentedTree.convert(ptree)
&gt;&gt;&gt; type(iptree)
&lt;class 'nltk.tree.ImmutableParentedTree'&gt;
&gt;&gt;&gt; del iptree[0]
Traceback (most recent call last):
  . . .
ValueError: ImmutableParentedTree may not be modified
&gt;&gt;&gt; iptree.node = 'newnode'
Traceback (most recent call last):
  . . .
ValueError: ImmutableParentedTree may not be modified
</pre>
</blockquote>
</div>
<div class="section" id="multiparentedtree-regression-tests">
<h2>MultiParentedTree Regression Tests</h2>
<p>Keep track of all trees that we create (including subtrees) using this
variable:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; all_mptrees = []
</pre>
</blockquote>
<p>Define a helper funciton to create new parented trees:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; def make_mptree(s):
...     mptree = MultiParentedTree.convert(Tree.parse(s))
...     all_mptrees.extend(t for t in mptree.subtrees()
...                       if isinstance(t, Tree))
...     return mptree
</pre>
</blockquote>
<p>Define a test function that examines every subtree in all_mptrees; and
checks that all six of its methods are defined correctly.  If any
mptrees are passed as arguments, then they are printed.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; def mpcheck(*print_mptrees):
...     def has(seq, val): # uses identity comparison
...         for item in seq:
...             if item is val: return True
...         return False
...     for mptree in all_mptrees:
...         # Check mptree's methods.
...         if len(mptree.parents()) == 0:
...             assert len(mptree.left_siblings()) == 0
...             assert len(mptree.right_siblings()) == 0
...             assert len(mptree.roots()) == 1
...             assert mptree.roots()[0] is mptree
...             assert mptree.treepositions(mptree) == [()]
...             left_siblings = right_siblings = ()
...             roots = {id(mptree): 1}
...         else:
...             roots = dict((id(r), 0) for r in mptree.roots())
...             left_siblings = mptree.left_siblings()
...             right_siblings = mptree.right_siblings()
...         for parent in mptree.parents():
...             for i in mptree.parent_indices(parent):
...                 assert parent[i] is mptree
...                 # check left siblings
...                 if i &gt; 0:
...                     for j in range(len(left_siblings)):
...                         if left_siblings[j] is parent[i-1]:
...                             del left_siblings[j]
...                             break
...                     else:
...                         assert 0, 'sibling not found!'
...                 # check ight siblings
...                 if i &lt; (len(parent)-1):
...                     for j in range(len(right_siblings)):
...                         if right_siblings[j] is parent[i+1]:
...                             del right_siblings[j]
...                             break
...                     else:
...                         assert 0, 'sibling not found!'
...             # check roots
...             for root in parent.roots():
...                 assert id(root) in roots, 'missing root'
...                 roots[id(root)] += 1
...         # check that we don't have any unexplained values
...         assert len(left_siblings)==0, 'unexpected sibling'
...         assert len(right_siblings)==0, 'unexpected sibling'
...         for v in roots.values(): assert v&gt;0, roots #'unexpected root'
...         # check treepositions
...         for root in mptree.roots():
...             for treepos in mptree.treepositions(root):
...                 assert root[treepos] is mptree
...         # Check mptree's children's methods:
...         for i, child in enumerate(mptree):
...             if isinstance(child, Tree):
...                 # mpcheck parent() &amp; parent_index() methods
...                 assert has(child.parents(), mptree)
...                 assert i in child.parent_indices(mptree)
...                 # mpcheck sibling methods
...                 if i &gt; 0:
...                     assert has(child.left_siblings(), mptree[i-1])
...                 if i &lt; len(mptree)-1:
...                     assert has(child.right_siblings(), mptree[i+1])
...     if print_mptrees:
...         print('ok!', end=' ')
...         for mptree in print_mptrees: print(mptree)
...     else:
...         print('ok!')
</pre>
</blockquote>
<p>Run our test function on a variety of newly-created trees:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; mpcheck(make_mptree('(A)'))
ok! (A )
&gt;&gt;&gt; mpcheck(make_mptree('(A (B (C (D) (E f)) g) h)'))
ok! (A (B (C (D ) (E f)) g) h)
&gt;&gt;&gt; mpcheck(make_mptree('(A (B) (C c) (D d d) (E e e e))'))
ok! (A (B ) (C c) (D d d) (E e e e))
&gt;&gt;&gt; mpcheck(make_mptree('(A (B) (C (c)) (D (d) (d)) (E (e) (e) (e)))'))
ok! (A (B ) (C (c )) (D (d ) (d )) (E (e ) (e ) (e )))
&gt;&gt;&gt; subtree = make_mptree('(A (B (C (D) (E f)) g) h)')
</pre>
</blockquote>
<p>Including some trees that contain multiple parents:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; mpcheck(MultiParentedTree('Z', [subtree, subtree]))
ok! (Z (A (B (C (D ) (E f)) g) h) (A (B (C (D ) (E f)) g) h))
</pre>
</blockquote>
<p>Run our test function after performing various tree-modification
operations (n.b., these are the same tests that we ran for
<cite>ParentedTree</cite>, above; thus, none of these trees actually <em>uses</em>
multiple parents.)</p>
<p><strong>__delitem__()</strong></p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; mptree = make_mptree('(A (B (C (D) (E f) (Q p)) g) h)')
&gt;&gt;&gt; e = mptree[0,0,1]
&gt;&gt;&gt; del mptree[0,0,1]; mpcheck(mptree); mpcheck(e)
ok! (A (B (C (D ) (Q p)) g) h)
ok! (E f)
&gt;&gt;&gt; del mptree[0,0,0]; mpcheck(mptree)
ok! (A (B (C (Q p)) g) h)
&gt;&gt;&gt; del mptree[0,1]; mpcheck(mptree)
ok! (A (B (C (Q p))) h)
&gt;&gt;&gt; del mptree[-1]; mpcheck(mptree)
ok! (A (B (C (Q p))))
&gt;&gt;&gt; del mptree[-100]
Traceback (most recent call last):
  . . .
IndexError: index out of range
&gt;&gt;&gt; del mptree[()]
Traceback (most recent call last):
  . . .
IndexError: The tree position () may not be deleted.
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; # With slices:
&gt;&gt;&gt; mptree = make_mptree('(A (B c) (D e) f g (H i) j (K l))')
&gt;&gt;&gt; b = mptree[0]
&gt;&gt;&gt; del mptree[0:0]; mpcheck(mptree)
ok! (A (B c) (D e) f g (H i) j (K l))
&gt;&gt;&gt; del mptree[:1]; mpcheck(mptree); mpcheck(b)
ok! (A (D e) f g (H i) j (K l))
ok! (B c)
&gt;&gt;&gt; del mptree[-2:]; mpcheck(mptree)
ok! (A (D e) f g (H i))
&gt;&gt;&gt; del mptree[1:3]; mpcheck(mptree)
ok! (A (D e) (H i))
&gt;&gt;&gt; mptree = make_mptree('(A (B c) (D e) f g (H i) j (K l))')
&gt;&gt;&gt; del mptree[5:1000]; mpcheck(mptree)
ok! (A (B c) (D e) f g (H i))
&gt;&gt;&gt; del mptree[-2:1000]; mpcheck(mptree)
ok! (A (B c) (D e) f)
&gt;&gt;&gt; del mptree[-100:1]; mpcheck(mptree)
ok! (A (D e) f)
&gt;&gt;&gt; mptree = make_mptree('(A (B c) (D e) f g (H i) j (K l))')
&gt;&gt;&gt; del mptree[1:-2:2]; mpcheck(mptree)
ok! (A (B c) f (H i) j (K l))
</pre>
</blockquote>
<p><strong>__setitem__()</strong></p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; mptree = make_mptree('(A (B (C (D) (E f) (Q p)) g) h)')
&gt;&gt;&gt; d, e, q = mptree[0,0]
&gt;&gt;&gt; mptree[0,0,0] = 'x'; mpcheck(mptree); mpcheck(d)
ok! (A (B (C x (E f) (Q p)) g) h)
ok! (D )
&gt;&gt;&gt; mptree[0,0,1] = make_mptree('(X (Y z))'); mpcheck(mptree); mpcheck(e)
ok! (A (B (C x (X (Y z)) (Q p)) g) h)
ok! (E f)
&gt;&gt;&gt; mptree[1] = d; mpcheck(mptree)
ok! (A (B (C x (X (Y z)) (Q p)) g) (D ))
&gt;&gt;&gt; mptree[-1] = 'x'; mpcheck(mptree)
ok! (A (B (C x (X (Y z)) (Q p)) g) x)
&gt;&gt;&gt; mptree[-100] = 'y'
Traceback (most recent call last):
  . . .
IndexError: index out of range
&gt;&gt;&gt; mptree[()] = make_mptree('(X y)')
Traceback (most recent call last):
  . . .
IndexError: The tree position () may not be assigned to.
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; # With slices:
&gt;&gt;&gt; mptree = make_mptree('(A (B c) (D e) f g (H i) j (K l))')
&gt;&gt;&gt; b = mptree[0]
&gt;&gt;&gt; mptree[0:0] = ('x', make_mptree('(Y)')); mpcheck(mptree)
ok! (A x (Y ) (B c) (D e) f g (H i) j (K l))
&gt;&gt;&gt; mptree[2:6] = (); mpcheck(mptree); mpcheck(b)
ok! (A x (Y ) (H i) j (K l))
ok! (B c)
&gt;&gt;&gt; mptree[-2:] = ('z', 'p'); mpcheck(mptree)
ok! (A x (Y ) (H i) z p)
&gt;&gt;&gt; mptree[1:3] = [make_mptree('(X)') for x in range(10)]; mpcheck(mptree)
ok! (A x (X ) (X ) (X ) (X ) (X ) (X ) (X ) (X ) (X ) (X ) z p)
&gt;&gt;&gt; mptree[5:1000] = []; mpcheck(mptree)
ok! (A x (X ) (X ) (X ) (X ))
&gt;&gt;&gt; mptree[-2:1000] = ['n']; mpcheck(mptree)
ok! (A x (X ) (X ) n)
&gt;&gt;&gt; mptree[-100:1] = [make_mptree('(U v)')]; mpcheck(mptree)
ok! (A (U v) (X ) (X ) n)
&gt;&gt;&gt; mptree[-1:] = (make_mptree('(X)') for x in range(3)); mpcheck(mptree)
ok! (A (U v) (X ) (X ) (X ) (X ) (X ))
&gt;&gt;&gt; mptree[1:-2:2] = ['x', 'y']; mpcheck(mptree)
ok! (A (U v) x (X ) y (X ) (X ))
</pre>
</blockquote>
<p><strong>append()</strong></p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; mptree = make_mptree('(A (B (C (D) (E f) (Q p)) g) h)')
&gt;&gt;&gt; mptree.append('x'); mpcheck(mptree)
ok! (A (B (C (D ) (E f) (Q p)) g) h x)
&gt;&gt;&gt; mptree.append(make_mptree('(X (Y z))')); mpcheck(mptree)
ok! (A (B (C (D ) (E f) (Q p)) g) h x (X (Y z)))
</pre>
</blockquote>
<p><strong>extend()</strong></p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; mptree = make_mptree('(A (B (C (D) (E f) (Q p)) g) h)')
&gt;&gt;&gt; mptree.extend(['x', 'y', make_mptree('(X (Y z))')]); mpcheck(mptree)
ok! (A (B (C (D ) (E f) (Q p)) g) h x y (X (Y z)))
&gt;&gt;&gt; mptree.extend([]); mpcheck(mptree)
ok! (A (B (C (D ) (E f) (Q p)) g) h x y (X (Y z)))
&gt;&gt;&gt; mptree.extend(make_mptree('(X)') for x in range(3)); mpcheck(mptree)
ok! (A (B (C (D ) (E f) (Q p)) g) h x y (X (Y z)) (X ) (X ) (X ))
</pre>
</blockquote>
<p><strong>insert()</strong></p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; mptree = make_mptree('(A (B (C (D) (E f) (Q p)) g) h)')
&gt;&gt;&gt; mptree.insert(0, make_mptree('(X (Y z))')); mpcheck(mptree)
ok! (A (X (Y z)) (B (C (D ) (E f) (Q p)) g) h)
&gt;&gt;&gt; mptree.insert(-1, make_mptree('(X (Y z))')); mpcheck(mptree)
ok! (A (X (Y z)) (B (C (D ) (E f) (Q p)) g) (X (Y z)) h)
&gt;&gt;&gt; mptree.insert(-4, make_mptree('(X (Y z))')); mpcheck(mptree)
ok! (A (X (Y z)) (X (Y z)) (B (C (D ) (E f) (Q p)) g) (X (Y z)) h)
&gt;&gt;&gt; # Note: as with ``list``, inserting at a negative index that
&gt;&gt;&gt; # gives a position before the start of the list does *not*
&gt;&gt;&gt; # raise an IndexError exception; it just inserts at 0.
&gt;&gt;&gt; mptree.insert(-400, make_mptree('(X (Y z))')); mpcheck(mptree)
ok! (A
  (X (Y z))
  (X (Y z))
  (X (Y z))
  (B (C (D ) (E f) (Q p)) g)
  (X (Y z))
  h)
</pre>
</blockquote>
<p><strong>pop()</strong></p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; mptree = make_mptree('(A (B (C (D) (E f) (Q p)) g) h)')
&gt;&gt;&gt; mptree[0,0].pop(1); mpcheck(mptree)
MultiParentedTree('E', ['f'])
ok! (A (B (C (D ) (Q p)) g) h)
&gt;&gt;&gt; mptree[0].pop(-1); mpcheck(mptree)
'g'
ok! (A (B (C (D ) (Q p))) h)
&gt;&gt;&gt; mptree.pop(); mpcheck(mptree)
'h'
ok! (A (B (C (D ) (Q p))))
&gt;&gt;&gt; mptree.pop(-100)
Traceback (most recent call last):
  . . .
IndexError: index out of range
</pre>
</blockquote>
<p><strong>remove()</strong></p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; mptree = make_mptree('(A (B (C (D) (E f) (Q p)) g) h)')
&gt;&gt;&gt; e = mptree[0,0,1]
&gt;&gt;&gt; mptree[0,0].remove(mptree[0,0,1]); mpcheck(mptree); mpcheck(e)
ok! (A (B (C (D ) (Q p)) g) h)
ok! (E f)
&gt;&gt;&gt; mptree[0,0].remove(make_mptree('(Q p)')); mpcheck(mptree)
ok! (A (B (C (D )) g) h)
&gt;&gt;&gt; mptree[0,0].remove(make_mptree('(Q p)'))
Traceback (most recent call last):
  . . .
ValueError: MultiParentedTree('Q', ['p']) is not in list
&gt;&gt;&gt; mptree.remove('h'); mpcheck(mptree)
ok! (A (B (C (D )) g))
&gt;&gt;&gt; mptree.remove('h');
Traceback (most recent call last):
  . . .
ValueError: 'h' is not in list
&gt;&gt;&gt; # remove() removes the first subtree that is equal (==) to the
&gt;&gt;&gt; # given tree, which may not be the identical tree we give it:
&gt;&gt;&gt; mptree = make_mptree('(A (X x) (Y y) (X x))')
&gt;&gt;&gt; x1, y, x2 = mptree
&gt;&gt;&gt; mptree.remove(mptree[-1]); mpcheck(mptree)
ok! (A (Y y) (X x))
&gt;&gt;&gt; print([str(p) for p in x1.parents()])
[]
&gt;&gt;&gt; print([str(p) for p in x2.parents()])
['(A (Y y) (X x))']
</pre>
</blockquote>
</div>
<div class="section" id="immutablemultiparentedtree-regression-tests">
<h2>ImmutableMultiParentedTree Regression Tests</h2>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; imptree = ImmutableMultiParentedTree.convert(mptree)
&gt;&gt;&gt; type(imptree)
&lt;class 'nltk.tree.ImmutableMultiParentedTree'&gt;
&gt;&gt;&gt; del imptree[0]
Traceback (most recent call last):
  . . .
ValueError: ImmutableMultiParentedTree may not be modified
&gt;&gt;&gt; imptree.node = 'newnode'
Traceback (most recent call last):
  . . .
ValueError: ImmutableMultiParentedTree may not be modified
</pre>
</blockquote>
</div>
<div class="section" id="probabilistictree-regression-tests">
<h2>ProbabilisticTree Regression Tests</h2>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; prtree = ProbabilisticTree(&quot;S&quot;, [ProbabilisticTree(&quot;NP&quot;, [&quot;N&quot;], prob=0.3)], prob=0.6)
&gt;&gt;&gt; print(prtree)
(S (NP N)) (p=0.6)
&gt;&gt;&gt; import copy
&gt;&gt;&gt; prtree == copy.deepcopy(prtree) == prtree.copy(deep=True) == prtree.copy()
True
&gt;&gt;&gt; prtree[0] is prtree.copy()[0]
True
&gt;&gt;&gt; prtree[0] is prtree.copy(deep=True)[0]
False
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; imprtree = ImmutableProbabilisticTree.convert(prtree)
&gt;&gt;&gt; type(imprtree)
&lt;class 'nltk.tree.ImmutableProbabilisticTree'&gt;
&gt;&gt;&gt; del imprtree[0]
Traceback (most recent call last):
  . . .
ValueError: ImmutableProbabilisticTree may not be modified
&gt;&gt;&gt; imprtree.node = 'newnode'
Traceback (most recent call last):
  . . .
ValueError: ImmutableProbabilisticTree may not be modified
</pre>
</blockquote>
</div>
</div>
<div class="section" id="squashed-bugs">
<h1>Squashed Bugs</h1>
<p>This used to discard the <tt class="docutils literal">(B b)</tt> subtree (fixed in svn 6270):</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; print(Tree.parse('((A a) (B b))'))
( (A a) (B b))
</pre>
</blockquote>
</div>
</div>
</body>
</html>
