<?xml version="1.0" encoding="ascii" ?>

<script language="javascript" type="text/javascript">

function astext(node)
{
    return node.innerHTML.replace(/(<([^>]+)>)/ig,"")
                         .replace(/&gt;/ig, ">")
                         .replace(/&lt;/ig, "<")
                         .replace(/&quot;/ig, '"')
                         .replace(/&amp;/ig, "&");
}

function copy_notify(node, bar_color, data)
{
    // The outer box: relative + inline positioning.
    var box1 = document.createElement("div");
    box1.style.position = "relative";
    box1.style.display = "inline";
    box1.style.top = "2em";
    box1.style.left = "1em";
  
    // A shadow for fun
    var shadow = document.createElement("div");
    shadow.style.position = "absolute";
    shadow.style.left = "-1.3em";
    shadow.style.top = "-1.3em";
    shadow.style.background = "#404040";
    
    // The inner box: absolute positioning.
    var box2 = document.createElement("div");
    box2.style.position = "relative";
    box2.style.border = "1px solid #a0a0a0";
    box2.style.left = "-.2em";
    box2.style.top = "-.2em";
    box2.style.background = "white";
    box2.style.padding = ".3em .4em .3em .4em";
    box2.style.fontStyle = "normal";
    box2.style.background = "#f0e0e0";

    node.insertBefore(box1, node.childNodes.item(0));
    box1.appendChild(shadow);
    shadow.appendChild(box2);
    box2.innerHTML="Copied&nbsp;to&nbsp;the&nbsp;clipboard: " +
                   "<pre class='copy-notify'>"+
                   data+"</pre>";
    setTimeout(function() { node.removeChild(box1); }, 1000);

    var elt = node.parentNode.firstChild;
    elt.style.background = "#ffc0c0";
    setTimeout(function() { elt.style.background = bar_color; }, 200);
}

function copy_codeblock_to_clipboard(node)
{
    var data = astext(node)+"\n";
    if (copy_text_to_clipboard(data)) {
        copy_notify(node, "#40a060", data);
    }
}

function copy_doctest_to_clipboard(node)
{
    var s = astext(node)+"\n   ";
    var data = "";

    var start = 0;
    var end = s.indexOf("\n");
    while (end >= 0) {
        if (s.substring(start, start+4) == ">>> ") {
            data += s.substring(start+4, end+1);
        }
        else if (s.substring(start, start+4) == "... ") {
            data += s.substring(start+4, end+1);
        }
        /*
        else if (end-start > 1) {
            data += "# " + s.substring(start, end+1);
        }*/
        // Grab the next line.
        start = end+1;
        end = s.indexOf("\n", start);
    }
    
    if (copy_text_to_clipboard(data)) {
        copy_notify(node, "#4060a0", data);
    }
}
    
function copy_text_to_clipboard(data)
{
    if (window.clipboardData) {
        window.clipboardData.setData("Text", data);
        return true;
     }
    else if (window.netscape) {
        // w/ default firefox settings, permission will be denied for this:
        netscape.security.PrivilegeManager
                      .enablePrivilege("UniversalXPConnect");
    
        var clip = Components.classes["@mozilla.org/widget/clipboard;1"]
                      .createInstance(Components.interfaces.nsIClipboard);
        if (!clip) return;
    
        var trans = Components.classes["@mozilla.org/widget/transferable;1"]
                       .createInstance(Components.interfaces.nsITransferable);
        if (!trans) return;
    
        trans.addDataFlavor("text/unicode");
    
        var str = new Object();
        var len = new Object();
    
        var str = Components.classes["@mozilla.org/supports-string;1"]
                     .createInstance(Components.interfaces.nsISupportsString);
        var datacopy=data;
        str.data=datacopy;
        trans.setTransferData("text/unicode",str,datacopy.length*2);
        var clipid=Components.interfaces.nsIClipboard;
    
        if (!clip) return false;
    
        clip.setData(trans,null,clipid.kGlobalClipboard);
        return true;
    }
    return false;
}
//-->
</script>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ascii" />
<meta name="generator" content="Docutils 0.12: http://docutils.sourceforge.net/" />
<title></title>
<style type="text/css">

/*
:Author: Edward Loper, James Curran
:Copyright: This stylesheet has been placed in the public domain.

Stylesheet for use with Docutils.

This stylesheet defines new css classes used by NLTK.

It uses a Python syntax highlighting scheme that matches
the colour scheme used by IDLE, which makes it easier for
beginners to check they are typing things in correctly.
*/

/* Include the standard docutils stylesheet. */
@import url(default.css);

/* Custom inline roles */
span.placeholder    { font-style: italic; font-family: monospace; }
span.example        { font-style: italic; }
span.emphasis       { font-style: italic; }
span.termdef        { font-weight: bold; }
/*span.term           { font-style: italic; }*/
span.category       { font-variant: small-caps; }
span.feature        { font-variant: small-caps; }
span.fval           { font-style: italic; }
span.math           { font-style: italic; }
span.mathit         { font-style: italic; }
span.lex            { font-variant: small-caps; }
span.guide-linecount{ text-align: right; display: block;}

/* Python souce code listings */
span.pysrc-prompt   { color: #9b0000; }
span.pysrc-more     { color: #9b00ff; }
span.pysrc-keyword  { color: #e06000; }
span.pysrc-builtin  { color: #940094; }
span.pysrc-string   { color: #00aa00; }
span.pysrc-comment  { color: #ff0000; }
span.pysrc-output   { color: #0000ff; }
span.pysrc-except   { color: #ff0000; }
span.pysrc-defname  { color: #008080; }


/* Doctest blocks */
pre.doctest         { margin: 0; padding: 0; font-weight: bold; }
div.doctest         { margin: 0 1em 1em 1em; padding: 0; }
table.doctest       { margin: 0; padding: 0;
                      border-top: 1px solid gray;
                      border-bottom: 1px solid gray; }
pre.copy-notify     { margin: 0; padding: 0.2em; font-weight: bold;
                      background-color: #ffffff; }

/* Python source listings */
div.pylisting       { margin: 0 1em 1em 1em; padding: 0; }
table.pylisting     { margin: 0; padding: 0;
                      border-top: 1px solid gray; }
td.caption { border-top: 1px solid black; margin: 0; padding: 0; }
.caption-label { font-weight: bold;  }
td.caption p { margin: 0; padding: 0; font-style: normal;}

table tr td.codeblock { 
  padding: 0.2em ! important; margin: 0;
  border-left: 1px solid gray;
  border-right: 2px solid gray;
  border-top: 0px solid gray;
  border-bottom: 1px solid gray;
  font-weight: bold; background-color: #eeffee;
}

table tr td.doctest  { 
  padding: 0.2em; margin: 0;
  border-left: 1px solid gray;
  border-right: 2px solid gray;
  border-top: 0px solid gray;
  border-bottom: 1px solid gray;
  font-weight: bold; background-color: #eeeeff;
}

td.codeblock table tr td.copybar {
    background: #40a060; border: 1px solid gray;
    font-family: monospace; padding: 0; margin: 0; }
td.doctest table tr td.copybar {
    background: #4060a0; border: 1px solid gray;
    font-family: monospace; padding: 0; margin: 0; }

td.pysrc { padding-left: 0.5em; }

img.callout { border-width: 0px; }

table.docutils {
    border-style: solid;
    border-width: 1px;
    margin-top: 6px;
    border-color: grey;
    border-collapse: collapse; }

table.docutils th {
    border-style: none;
    border-width: 1px;
    border-color: grey;
    padding: 0 .5em 0 .5em; }

table.docutils td {
    border-style: none;
    border-width: 1px;
    border-color: grey; 
    padding: 0 .5em 0 .5em; }

table.footnote td { padding: 0; }
table.footnote { border-width: 0; }
table.footnote td { border-width: 0; }
table.footnote th { border-width: 0; }

table.noborder { border-width: 0; }

table.example pre { margin-top: 4px; margin-bottom: 0; }

/* For figures & tables */
p.caption { margin-bottom: 0; }
div.figure { text-align: center; }

/* The index */
div.index { border: 1px solid black;
            background-color: #eeeeee; }
div.index h1 { padding-left: 0.5em; margin-top: 0.5ex;
               border-bottom: 1px solid black; }
ul.index { margin-left: 0.5em; padding-left: 0; }
li.index { list-style-type: none; }
p.index-heading { font-size: 120%; font-style: italic; margin: 0; }
li.index ul { margin-left: 2em; padding-left: 0; }

/* 'Note' callouts */
div.note
{
  border-right:   #87ceeb 1px solid;
  padding-right: 4px;
  border-top: #87ceeb 1px solid;
  padding-left: 4px;
  padding-bottom: 4px;
  margin: 2px 5% 10px;
  border-left: #87ceeb 1px solid;
  padding-top: 4px;
  border-bottom: #87ceeb 1px solid;
  font-style: normal;
  font-family: verdana, arial;
  background-color: #b0c4de;
}

table.avm { border: 0px solid black; width: 0; }
table.avm tbody tr {border: 0px solid black; }
table.avm tbody tr td { padding: 2px; }
table.avm tbody tr td.avm-key { padding: 5px; font-variant: small-caps; }
table.avm tbody tr td.avm-eq { padding: 5px; }
table.avm tbody tr td.avm-val { padding: 5px; font-style: italic; }
p.avm-empty { font-style: normal; }
table.avm colgroup col { border: 0px solid black; }
table.avm tbody tr td.avm-topleft 
    { border-left: 2px solid #000080; border-top: 2px solid #000080; }
table.avm tbody tr td.avm-botleft 
    { border-left: 2px solid #000080; border-bottom: 2px solid #000080; }
table.avm tbody tr td.avm-topright
    { border-right: 2px solid #000080; border-top: 2px solid #000080; }
table.avm tbody tr td.avm-botright
    { border-right: 2px solid #000080; border-bottom: 2px solid #000080; }
table.avm tbody tr td.avm-left
    { border-left: 2px solid #000080; }
table.avm tbody tr td.avm-right
    { border-right: 2px solid #000080; }
table.avm tbody tr td.avm-topbotleft
    { border: 2px solid #000080; border-right: 0px solid black; }
table.avm tbody tr td.avm-topbotright
    { border: 2px solid #000080; border-left: 0px solid black; }
table.avm tbody tr td.avm-ident
    { font-size: 80%; padding: 0; padding-left: 2px; vertical-align: top; }
.avm-pointer
{ border: 1px solid #008000; padding: 1px; color: #008000; 
  background: #c0ffc0; font-style: normal; }

table.gloss { border: 0px solid black; width: 0; }
table.gloss tbody tr { border: 0px solid black; }
table.gloss tbody tr td { border: 0px solid black; }
table.gloss colgroup col { border: 0px solid black; }
table.gloss p { margin: 0; padding: 0; }

table.rst-example { border: 1px solid black; }
table.rst-example tbody tr td { background: #eeeeee; }
table.rst-example thead tr th { background: #c0ffff; }
td.rst-raw { width: 0; }

/* Used by nltk.org/doc/test: */
div.doctest-list { text-align: center; }
table.doctest-list { border: 1px solid black;
  margin-left: auto; margin-right: auto;
}
table.doctest-list tbody tr td { background: #eeeeee;
  border: 1px solid #cccccc; text-align: left; }
table.doctest-list thead tr th { background: #304050; color: #ffffff;
  border: 1px solid #000000;}
table.doctest-list thead tr a { color: #ffffff; }
span.doctest-passed { color: #008000; }
span.doctest-failed { color: #800000; }

</style>
</head>
<body>
<div class="document">


<!-- -*- mode: rst -*- -->
<!-- -*- mode: rst -*- -->
<!-- CAP abbreviations (map to small caps in LaTeX) -->
<!-- Other candidates for global consistency -->
<!-- PTB removed since it must be indexed -->
<!-- WN removed since it must be indexed -->
<!-- misc & punctuation -->
<!-- cdots was unicode U+22EF but not working -->
<!-- exercise meta-tags -->
<!-- Unicode tests -->
<!-- phonetic -->
<!-- misc -->
<!-- used in Unicode section -->
<!-- arrows -->
<!-- unification stuff -->
<!-- Math & Logic -->
<!-- sets -->
<!-- Greek -->
<!-- Chinese -->
<!-- URLs -->
<!-- Python example - a snippet of code in running text -->
<!-- PlaceHolder example -  something that should be replaced by actual code -->
<!-- Linguistic eXample - cited form in running text -->
<!-- Emphasized (more declarative than just using *) -->
<!-- Grammatical Category - e.g. NP and verb as technical terms
.. role:: gc
   :class: category -->
<!-- Math expression - e.g. especially for variables -->
<!-- Textual Math expression - for words 'inside' a math environment -->
<!-- Feature (or attribute) -->
<!-- Raw LaTeX -->
<!-- Raw HTML -->
<!-- Feature-value -->
<!-- Lexemes -->
<!-- Replacements that rely on previous definitions :-) -->
<div class="compound">
</div>
<!-- standard global imports

>>> import nltk, re, pprint
>>> from nltk import word_tokenize -->
<!-- TODO: recipes for flattening a list of lists into a list, and for the reverse grouping a list into a list of lists -->
<!-- TODO: discuss duck typing -->
<!-- TODO: check ch06-extras for further content -->
<!-- TODO: shared values between multiple dictionaries -->
<!-- TODO: general technique for computing transitive closures, e.g.
adjectives connected by synonymy to a particular word, cf.
http://www.aclweb.org/anthology/W04-3253 -->
<!-- TODO: explain function vs method -->
<!-- TODO: say more about performance tuning of a Python program -->
<!-- TODO: add exercises on string formatting -->
<!-- TODO: this chapter presumes knowledge of dictionaries, not defined until ch05 -->
<!-- TODO: the "b" flag for read(), when to use "rb"; also the "rU" flag -->
<div class="section" id="appendix-enough-python-for-this-book">
<span id="app-python"></span><h1>13&nbsp;&nbsp;&nbsp;Appendix: Enough Python for this Book</h1>
<p>This appendex introduces the Python programming language, and it is
intended for readers who are new to Python, or new to programming.
Unlike other introductions to Python, this presentation focuses on
linguistically-motivated tasks.</p>
<p>We'll address the following questions:</p>
<ol class="arabic simple">
<li>How can you get started with Python, and use the interpreter and editor?</li>
<li>How do the fundamental building blocks work, such as loops, functions and assignment?</li>
<li>What are some of the common pitfalls with Python programming and how can you avoid them?</li>
</ol>
<p>This chapter contains many examples and exercises.
If you are new to programming, we encourage you to work through them carefully
and consult other introductions to programming if necessary.</p>
<p>The Python website also provides extensive documentation,
including introductory tutorials and links to other resources.
Please see <tt class="doctest"><span class="pre">http://docs.python.org/</span></tt>.
When using the online Python documentation, be aware that
your installed version might be different from the version
of the documentation you are reading.  You can easily
check what version you have, with <tt class="doctest"><span class="pre"><span class="pysrc-keyword">import</span> sys; sys.version</span></tt>,
and then consult version-specific documentation on the Python website.</p>
<div class="section" id="getting-started">
<h2>13.1&nbsp;&nbsp;&nbsp;Getting Started</h2>
<p>One of the friendly things about Python is that it allows you
to type directly into the interactive <a name="interpreter_index_term" /><span class="termdef">interpreter</span> &#8212;
the program that will be running your Python programs.
You can access the Python interpreter using a simple graphical interface
called the Interactive DeveLopment Environment (IDLE).
On a Mac you can find this under <em>Applications</em>&#8594;<em>MacPython</em>,
and on Windows under <em>All Programs</em>&#8594;<em>Python</em>.
Under Unix you can run Python from the shell by typing <tt class="doctest"><span class="pre">idle</span></tt>
(if this is not installed, try typing <tt class="doctest"><span class="pre">python</span></tt>).
The interpreter will print a blurb about your Python version;
simply check that you are running Python 3.2 or later
(here it is for 3.4.2):</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
Python 3.4.2 (default, Nov 12 2014, 18:23:59)
[GCC 4.2.1 Compatible Apple LLVM 6.0 (clang-600.0.54)] on darwin
Type "help", "copyright", "credits" or "license" for more information.
<span class="pysrc-prompt">&gt;&gt;&gt;</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last">If you are unable to run the Python interpreter, you probably don't
have Python installed correctly.  Please visit <tt class="doctest"><span class="pre">http://python.org/</span></tt> for
detailed instructions. NLTK 3.0 works for Python 2.6, 2.7 and 3.2 onwards.
If you are using Python 2.6 or 2.7, note that the <tt class="doctest"><span class="pre">/</span></tt> operator rounds
fractional results downwards (so <tt class="doctest"><span class="pre">1/3</span></tt> will give you <tt class="doctest"><span class="pre">0</span></tt>).
In order to get the expected behavior of division
you need to type: <tt class="doctest"><span class="pre"><span class="pysrc-keyword">from</span> __future__ <span class="pysrc-keyword">import</span> division</span></tt>.
Users of Python 2.6 and 2.7 will also need to type the following
statement in order to use the print function in our examples:
<tt class="doctest"><span class="pre"><span class="pysrc-keyword">from</span> __future__ <span class="pysrc-keyword">import</span> print_function</span></tt>.</p>
</div>
<p>The <tt class="doctest"><span class="pre"><span class="pysrc-prompt">&gt;&gt;&gt;</span></span></tt> prompt indicates that the Python interpreter is now waiting
for input.  When copying examples from this book, don't type
the &quot;<tt class="doctest"><span class="pre"><span class="pysrc-prompt">&gt;&gt;&gt;</span></span></tt>&quot; yourself.  Now, let's begin by using Python as a calculator:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>1 + 5 * 2 - 3
<span class="pysrc-output">8</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt;</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Once the interpreter has finished calculating the answer and displaying it, the
prompt reappears. This means the Python interpreter is waiting for another instruction.</p>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last"><strong>Your Turn:</strong>
Enter a few more expressions of your own. You can use asterisk (<tt class="doctest"><span class="pre">*</span></tt>)
for multiplication and slash (<tt class="doctest"><span class="pre">/</span></tt>) for division, and parentheses for
bracketing expressions.</p>
</div>
<!-- XXX The following example currently wraps over a page boundary, which
makes it difficult to read, esp since you can't see where the "^" is
pointing. -->
<p>The preceding examples demonstrate how you can work interactively with the
Python interpreter, experimenting with various expressions in the language
to see what they do.
Now let's try a nonsensical expression to see how the interpreter handles it:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>1 +
<span class="pysrc-output">  File &quot;&lt;stdin&gt;&quot;, line 1</span>
<span class="pysrc-output">    1 +</span>
<span class="pysrc-output">      ^</span>
<span class="pysrc-output">SyntaxError: invalid syntax</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt;</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>This produced a <a name="syntax_error_index_term" /><span class="termdef">syntax error</span>.  In Python, it doesn't make sense
to end an instruction with a plus sign. The Python interpreter
indicates the line where the problem occurred (line 1 of <tt class="doctest"><span class="pre">&lt;stdin&gt;</span></tt>,
which stands for &quot;standard input&quot;).</p>
<p>Now that we can use the Python interpreter, we're ready to start
learning Python, and applying it to language data.</p>
</div>
<div class="section" id="texts-as-lists-of-words">
<span id="sec-texts-as-lists-of-words"></span><h2>13.2&nbsp;&nbsp;&nbsp;Texts as Lists of Words</h2>
<p>What is a text?  At one level, it is a sequence of symbols on a page such
as this one, or a sequence of characters in a text file.  At another level, it is a sequence of chapters, made up
of a sequence of sections, where each section is a sequence of paragraphs,
and so on.  However, for our purposes, it is sufficient to think of a text as nothing
more than a sequence of words and punctuation. For this, you need to
understand the &quot;list&quot; data type.</p>
<div class="section" id="lists">
<h3>Lists</h3>
<p>Here's how we will represent a text in Python:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>sent = [<span class="pysrc-string">'What'</span>, <span class="pysrc-string">'is'</span>, <span class="pysrc-string">'the'</span>, <span class="pysrc-string">'airspeed'</span>, <span class="pysrc-string">'of'</span>, <span class="pysrc-string">'an'</span>, <span class="pysrc-string">'unladen'</span>, <span class="pysrc-string">'swallow'</span>, <span class="pysrc-string">'?'</span>]
<span class="pysrc-prompt">&gt;&gt;&gt;</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>After the prompt we've given a name we made up, <tt class="doctest"><span class="pre">sent</span></tt>, short for
&quot;sentence,&quot; followed
by the equals sign, and then some quoted words, separated with
commas, and surrounded with brackets.  This bracketed material
is known as a <a name="list_index_term" /><span class="termdef">list</span> in Python:.
We can inspect it by typing the name <a class="reference internal" href="#inspect-var"><span id="ref-inspect-var"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></span></a>. We can ask for its
length using the built-in <tt class="doctest"><span class="pre">len</span></tt> function <a class="reference internal" href="#len-sent"><span id="ref-len-sent"><img src="callouts/callout2.gif" alt="[2]" class="callout" /></span></a>.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>sent <a name="inspect-var" /><a href="#ref-inspect-var"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></a>
<span class="pysrc-output">['What', 'is', 'the', 'airspeed', 'of', 'an', 'unladen', 'swallow', '?']</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>len(sent) <a name="len-sent" /><a href="#ref-len-sent"><img src="callouts/callout2.gif" alt="[2]" class="callout" /></a>
<span class="pysrc-output">9</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt;</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last"><strong>Your Turn:</strong>
Make up a few sentences of your own, by typing a name, equals
sign, and a list of words, like this:
<tt class="doctest"><span class="pre">ex1 = [<span class="pysrc-string">'Monty'</span>, <span class="pysrc-string">'Python'</span>, <span class="pysrc-string">'and'</span>, <span class="pysrc-string">'the'</span>, <span class="pysrc-string">'Holy'</span>, <span class="pysrc-string">'Grail'</span>]</span></tt>.</p>
</div>
<p>Once you're comfortable defining little texts like this, you can try
out another built-in function:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>sorted(sent)
<span class="pysrc-output">['?', 'What', 'airspeed', 'an', 'is', 'of', 'swallow', 'the', 'unladen']</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt;</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Note that it is standard for computers to sort punctuation
and uppercase letters before lowercase letters. This is due
to the computer's underlying numerical representation of text, which we can see
by asking Python to tell us the ordinal value of a character:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>ord(<span class="pysrc-string">'?'</span>)
<span class="pysrc-output">63</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>ord(<span class="pysrc-string">'W'</span>)
<span class="pysrc-output">87</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>ord(<span class="pysrc-string">'w'</span>)
<span class="pysrc-output">119</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt;</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last"><strong>Your Turn:</strong>
Try sorting the sentences that you made up.</p>
</div>
<p>A pleasant surprise is that we can use Python's addition operator on lists.
Adding two lists creates a new list
with everything from the first list, followed
by everything from the second list:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>[<span class="pysrc-string">'Monty'</span>, <span class="pysrc-string">'Python'</span>] + [<span class="pysrc-string">'and'</span>, <span class="pysrc-string">'the'</span>, <span class="pysrc-string">'Holy'</span>, <span class="pysrc-string">'Grail'</span>]
<span class="pysrc-output">['Monty', 'Python', 'and', 'the', 'Holy', 'Grail']</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt;</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>This special use of the addition operation is called <a name="concatenation_index_term" /><span class="termdef">concatenation</span>;
it combines the lists together into a single list.  We can concatenate
sentences to build up a text.</p>
<p>We don't have to type out the lists each time; we can name them,
then refer back to them using those names:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>frag1 = [<span class="pysrc-string">'Monty'</span>, <span class="pysrc-string">'Python'</span>]
<span class="pysrc-prompt">&gt;&gt;&gt; </span>frag2 = [<span class="pysrc-string">'and'</span>, <span class="pysrc-string">'the'</span>, <span class="pysrc-string">'Holy'</span>, <span class="pysrc-string">'Grail'</span>]
<span class="pysrc-prompt">&gt;&gt;&gt; </span>frag1 + frag2
<span class="pysrc-output">['Monty', 'Python', 'and', 'the', 'Holy', 'Grail']</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt;</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>We can count the number of times a word occurs.
To do this, we specify the name of the list, followed by a period,
then the method name <cite>count</cite>, followed by the word in parentheses:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>frag1.count(<span class="pysrc-string">'Python'</span>)
<span class="pysrc-output">1</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>frag2.count(<span class="pysrc-string">'Python'</span>)
<span class="pysrc-output">0</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt;</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>We can also <a name="append_index_term" /><span class="termdef">append</span> an item to a list.
When we use <tt class="doctest"><span class="pre">append()</span></tt>, no result is printed, but the list is
modified and we can inspect it in the usual way.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>sent.append(<span class="pysrc-string">&quot;!!!&quot;</span>)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>sent
<span class="pysrc-output">['What', 'is', 'the', 'airspeed', 'of', 'an', 'unladen', 'swallow', '?', '!!!']</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt;</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last"><strong>Your Turn:</strong>
Before continuing, experiment with your own example sentences and make sure you can
use Python's general-purpose functions <cite>len</cite> and <cite>sorted</cite>, and the
special list methods <cite>count</cite> and <cite>append</cite>.</p>
</div>
</div>
<div class="section" id="indexing-lists">
<h3>Indexing Lists</h3>
<p>As we have seen, a text in Python is a list of words, represented
using a combination of brackets and quotes. We can use Python to
perform various operations on a text, such as getting its length,
or counting the number of times a certain word appears.</p>
<p>Each item of a list has a position, or <a name="index_index_term" /><span class="termdef">index</span>, starting from
zero. Here are the indexes for our example sentence:</p>
<pre class="literal-block">
| What | is | the | airspeed | of | an | unladen | swallow | ? |
 0      1    2     3          4    5    6         7         8   9
</pre>
<p>We look up the items of a list by index as follows:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>sent[3]
<span class="pysrc-output">'airspeed'</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt;</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>We can do the converse; given a word, find the index of its first occurrence:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>sent.index(<span class="pysrc-string">'airspeed'</span>)
<span class="pysrc-output">3</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt;</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Notice that our indexes start from zero: <tt class="doctest"><span class="pre">sent</span></tt> element zero <tt class="doctest"><span class="pre">sent[0]</span></tt>
is the first word <tt class="doctest"><span class="pre">What</span></tt>, and <tt class="doctest"><span class="pre">sent[7]</span></tt> is <tt class="doctest"><span class="pre">swallow</span></tt>.
The reason is simple: the moment Python accesses the content of a list from
the computer's memory, it is already at the first element;
we have to tell it how many elements forward to go.
Thus, zero steps forward gives us the first element.</p>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last">This practice of counting from zero is initially confusing,
but typical of modern programming languages.
You'll quickly get the hang of it if
you've mastered the system of counting centuries where 19XY is a year
in the 20th century, or if you live in a country where the floors of
a building are numbered from 1, and so walking up <span class="math">n-1</span> flights of
stairs takes you to level <span class="math">n</span>.</p>
</div>
<p>Now, if we accidentally use an index that is too large, we get an error:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>sent[10]
<span class="pysrc-except">Traceback (most recent call last):</span>
<span class="pysrc-except">  File &quot;&lt;stdin&gt;&quot;, line 1, in ?</span>
<span class="pysrc-except">IndexError: list index out of range</span>
<span class="pysrc-except"></span><span class="pysrc-prompt">&gt;&gt;&gt;</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>This time it is not a syntax error, because the program fragment is syntactically correct.
Instead, it is a <a name="runtime_error_index_term" /><span class="termdef">runtime error</span>, and it produces a <tt class="doctest"><span class="pre">Traceback</span></tt> message that
shows the context of the error, followed by the name of the error,
<tt class="doctest"><span class="pre">IndexError</span></tt>, and a brief explanation.</p>
</div>
<div class="section" id="slicing-lists">
<h3>Slicing Lists</h3>
<p>We can access sublists as well, a technique is known as <a name="slicing_index_term" /><span class="termdef">slicing</span>.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>sent[2:8]
<span class="pysrc-output">['the', 'airspeed', 'of', 'an', 'unladen', 'swallow']</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt;</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Note that the slice goes up to, but does not include, the 8th element.
Our visualization of lists, with the numbers appearing to the left of
their cells, is a helpful way to remember this behavior of slicing:</p>
<pre class="literal-block">
| What | is | the | airspeed | of | an | unladen | swallow | ? |
 0      1    2     3          4    5    6         7         8   9
</pre>
<p>Slicing is useful when we come to extracting manageable chunks of language from large texts.
Here we have loaded the entire text of <em>Monty Python and the Holy
Grail</em>, and have sliced out 25 items:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>holy_grail[1600:1625]
<span class="pysrc-output">['We', &quot;'&quot;, 're', 'an', 'anarcho', '-', 'syndicalist', 'commune', '.', 'We',</span>
<span class="pysrc-output">'take', 'it', 'in', 'turns', 'to', 'act', 'as', 'a', 'sort', 'of', 'executive',</span>
<span class="pysrc-output">'officer', 'for', 'the', 'week']</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt;</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>By convention, <tt class="doctest"><span class="pre">m:n</span></tt> means elements <span class="mathit">m</span>&#8230;<span class="mathit">n-1</span>.
As the next example shows,
we can omit the first number if the slice begins at the start of the
list <a class="reference internal" href="#slice2"><span id="ref-slice2"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></span></a>, and we can omit the second number if the slice goes to the end <a class="reference internal" href="#slice3"><span id="ref-slice3"><img src="callouts/callout2.gif" alt="[2]" class="callout" /></span></a>:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>sent[:4] <a name="slice2" /><a href="#ref-slice2"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></a>
<span class="pysrc-output">['What', 'is', 'the', 'airspeed']</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>sent[4:] <a name="slice3" /><a href="#ref-slice3"><img src="callouts/callout2.gif" alt="[2]" class="callout" /></a>
<span class="pysrc-output">['of', 'an', 'unladen', 'swallow', '?', '!!!']</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt;</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>We can modify an element of a list by assigning to one of its index values.
In the next example, we put <tt class="doctest"><span class="pre">sent[0]</span></tt> on the left of the equals sign <a class="reference internal" href="#list-assignment"><span id="ref-list-assignment"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></span></a>.  We can also
replace an entire slice with new material <a class="reference internal" href="#slice-assignment"><span id="ref-slice-assignment"><img src="callouts/callout2.gif" alt="[2]" class="callout" /></span></a>.  A consequence of this
last change is that the list only has four elements, and accessing a later value
generates an error <a class="reference internal" href="#list-error"><span id="ref-list-error"><img src="callouts/callout3.gif" alt="[3]" class="callout" /></span></a>.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>sent[0] = <span class="pysrc-string">'First'</span> <a name="list-assignment" /><a href="#ref-list-assignment"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></a>
<span class="pysrc-prompt">&gt;&gt;&gt; </span>sent[9] = <span class="pysrc-string">'Last'</span>
<span class="pysrc-prompt">&gt;&gt;&gt; </span>len(sent)
<span class="pysrc-output">10</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>sent[1:9] = [<span class="pysrc-string">'Second'</span>, <span class="pysrc-string">'Third'</span>] <a name="slice-assignment" /><a href="#ref-slice-assignment"><img src="callouts/callout2.gif" alt="[2]" class="callout" /></a>
<span class="pysrc-prompt">&gt;&gt;&gt; </span>sent
<span class="pysrc-output">['First', 'Second', 'Third', 'Last']</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>len(sent)
<span class="pysrc-output">4</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>sent[4] <a name="list-error" /><a href="#ref-list-error"><img src="callouts/callout3.gif" alt="[3]" class="callout" /></a>
<span class="pysrc-except">Traceback (most recent call last):</span>
<span class="pysrc-except">  File &quot;&lt;stdin&gt;&quot;, line 1, in ?</span>
<span class="pysrc-except">IndexError: list index out of range</span>
<span class="pysrc-except"></span><span class="pysrc-prompt">&gt;&gt;&gt;</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last"><strong>Your Turn:</strong>
Take a few minutes to define a sentence of your own and modify individual words and
groups of words (slices) using the same methods used earlier.  Check your understanding
by trying the exercises on lists at the end of this chapter.</p>
</div>
</div>
<div class="section" id="variables">
<h3>Variables</h3>
<p>Several times now, we have seen lines like the following:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>sent = [<span class="pysrc-string">'What'</span>, <span class="pysrc-string">'is'</span>, <span class="pysrc-string">'the'</span>, <span class="pysrc-string">'airspeed'</span>, <span class="pysrc-string">'of'</span>, <span class="pysrc-string">'an'</span>, <span class="pysrc-string">'unladen'</span>, <span class="pysrc-string">'swallow'</span>, <span class="pysrc-string">'?'</span>]
<span class="pysrc-prompt">&gt;&gt;&gt;</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Such lines have the form: <em>variable = expression</em>.  Python will evaluate
the expression on the right, and save its result to the variable on
the left.  This process is
called <a name="assignment_index_term" /><span class="termdef">assignment</span>.  It does not generate any output;
you have to type the variable on a line of its
own to inspect its contents.  The equals sign is slightly misleading,
since information is moving from the right side to the left.
It might help to think of it as a left-arrow.
The name of the variable can be anything you like, e.g., <tt class="doctest"><span class="pre">my_sent</span></tt>, <tt class="doctest"><span class="pre">sentence</span></tt>, <tt class="doctest"><span class="pre">xyzzy</span></tt>.
It must start with a letter, and can include numbers and underscores.
Here are some examples of variables and assignments:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>my_sent = [<span class="pysrc-string">'Bravely'</span>, <span class="pysrc-string">'bold'</span>, <span class="pysrc-string">'Sir'</span>, <span class="pysrc-string">'Robin'</span>, <span class="pysrc-string">','</span>, <span class="pysrc-string">'rode'</span>,
<span class="pysrc-more">... </span><span class="pysrc-string">'forth'</span>, <span class="pysrc-string">'from'</span>, <span class="pysrc-string">'Camelot'</span>, <span class="pysrc-string">'.'</span>]
<span class="pysrc-prompt">&gt;&gt;&gt; </span>noun_phrase = my_sent[1:4]
<span class="pysrc-prompt">&gt;&gt;&gt; </span>noun_phrase
<span class="pysrc-output">['bold', 'Sir', 'Robin']</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>wOrDs = sorted(noun_phrase)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>wOrDs
<span class="pysrc-output">['Robin', 'Sir', 'bold']</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt;</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Remember that capitalized words appear before lowercase words in sorted lists.</p>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last">Notice in the previous example that we split the definition
of <tt class="doctest"><span class="pre">my_sent</span></tt> over two lines.  Python expressions can be split across
multiple lines, so long as this happens within any kind of brackets.
Python uses the &quot;<tt class="doctest"><span class="pre"><span class="pysrc-more">...</span></span></tt>&quot; prompt to indicate that more input is
expected.  It doesn't matter how much indentation is used in these
continuation lines, but some indentation usually makes them easier to read.</p>
</div>
<p>It is good to choose meaningful variable names to remind you &#8212; and to help anyone
else who reads your Python code &#8212; what your code is meant to do.
Python does not try to make sense of the names; it blindly follows your instructions,
and does not object if you do something confusing, such as <tt class="doctest"><span class="pre">one = <span class="pysrc-string">'two'</span></span></tt> or <tt class="doctest"><span class="pre">two = 3</span></tt>.
The only restriction is that
a variable name cannot be any of Python's reserved words, such as
<tt class="doctest"><span class="pre">def</span></tt>, <tt class="doctest"><span class="pre"><span class="pysrc-keyword">if</span></span></tt>, <tt class="doctest"><span class="pre"><span class="pysrc-keyword">not</span></span></tt>,
and <tt class="doctest"><span class="pre"><span class="pysrc-keyword">import</span></span></tt>.  If you use a reserved word, Python will produce a syntax error:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">not</span> = <span class="pysrc-string">'Camelot'</span>           
<span class="pysrc-output">File &quot;&lt;stdin&gt;&quot;, line 1</span>
<span class="pysrc-output">    not = 'Camelot'</span>
<span class="pysrc-output">        ^</span>
<span class="pysrc-output">SyntaxError: invalid syntax</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt;</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<div class="caution">
<p class="first admonition-title">Caution!</p>
<p class="last">Take care with your choice of names (or <a name="identifiers_index_term" /><span class="termdef">identifiers</span>) for Python
variables.  First, you should start the name with a letter, optionally
followed by digits (<tt class="doctest"><span class="pre">0</span></tt> to <tt class="doctest"><span class="pre">9</span></tt>) or letters. Thus, <tt class="doctest"><span class="pre">abc23</span></tt> is fine, but
<tt class="doctest"><span class="pre">23abc</span></tt> will cause a syntax error.
Names are case-sensitive, which means that <tt class="doctest"><span class="pre">myVar</span></tt> and <tt class="doctest"><span class="pre">myvar</span></tt>
are distinct variables.  Variable names cannot contain whitespace,
but you can separate words using an underscore, e.g.,
<tt class="doctest"><span class="pre">my_var</span></tt>. Be careful not to insert a hyphen instead of an
underscore: <tt class="doctest"><span class="pre">my-var</span></tt> is wrong, since Python interprets the
&quot;<tt class="doctest"><span class="pre">-</span></tt>&quot; as a minus sign.</p>
</div>
</div>
</div>
<div class="section" id="vocabularies-as-sets-of-words">
<span id="sec-vocabularies-as-sets-of-words"></span><h2>13.3&nbsp;&nbsp;&nbsp;Vocabularies as Sets of Words</h2>
<!-- reimport

>>> from nltk.book import * -->
<p>The most obvious fact about texts that emerges from the examples in <a class="reference external" href="ch01.html#sec-overview-of-nltk">2</a>
is that
they differ in the vocabulary they use.  In this section we will see how to use the
computer to count the words in a text in a variety of useful ways.
As explained <a class="reference external" href="ch01.html#sec-overview-of-nltk">2</a>, you will first need to install
NLTK's data, and then load the example texts from
NLTK's book module, using the command <tt class="doctest"><span class="pre"><span class="pysrc-keyword">from</span> nltk.book <span class="pysrc-keyword">import</span> *</span></tt>.</p>
<p>Let's begin by finding out the length of a text from start to finish,
in terms of the words and punctuation symbols that appear.
Here we will do it for <tt class="doctest"><span class="pre">text3</span></tt>, which contains the text of the Book
of Genesis:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>len(text3)
<span class="pysrc-output">44764</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt;</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>So Genesis has 44,764 words and punctuation symbols, or &quot;tokens.&quot;
A <a name="token_index_term" /><span class="termdef">token</span> is the technical name for a sequence of characters
&#8212; such as <tt class="doctest"><span class="pre">hairy</span></tt>, <tt class="doctest"><span class="pre">his</span></tt>, or <tt class="doctest"><span class="pre">:)</span></tt> &#8212; that we want to treat as a
group. When we count the number of tokens in a text, say, the phrase
<span class="example">to be or not to be</span>, we are counting occurrences of these
sequences. Thus, in our example phrase there are two occurrences of <span class="example">to</span>,
two of <span class="example">be</span>, and one each of <span class="example">or</span> and <span class="example">not</span>. But there are
only four distinct vocabulary items in this phrase.
How many distinct words does the book of Genesis contain?
To work this out in Python, we have to pose the question slightly
differently.  The vocabulary of a text is just the <em>set</em> of tokens
that it uses, since in a set, all duplicates are collapsed
together. In Python we can obtain the vocabulary items of <tt class="doctest"><span class="pre">text3</span></tt> with the
command: <tt class="doctest"><span class="pre">set(text3)</span></tt>.  When you do this, many screens of words will
fly past.  Now try the following:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>sorted(set(text3)) <a name="sorted-set" /><a href="#ref-sorted-set"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></a>
<span class="pysrc-output">['!', &quot;'&quot;, '(', ')', ',', ',)', '.', '.)', ':', ';', ';)', '?', '?)',</span>
<span class="pysrc-output">'A', 'Abel', 'Abelmizraim', 'Abidah', 'Abide', 'Abimael', 'Abimelech',</span>
<span class="pysrc-output">'Abr', 'Abrah', 'Abraham', 'Abram', 'Accad', 'Achbor', 'Adah', ...]</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>len(set(text3)) <a name="len-set" /><a href="#ref-len-set"><img src="callouts/callout2.gif" alt="[2]" class="callout" /></a>
<span class="pysrc-output">2789</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt;</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>By applying Python's built-in <tt class="doctest"><span class="pre">sorted</span></tt> function to the expression <tt class="doctest"><span class="pre">set(text3)</span></tt>
<a class="reference internal" href="#sorted-set"><span id="ref-sorted-set"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></span></a>,  we obtain a sorted list of vocabulary items, beginning
with various punctuation symbols and continuing with words starting with <span class="example">A</span>.
We discover the size of the vocabulary indirectly, by asking
for the number of items in this set, and again we can use <tt class="doctest"><span class="pre">len</span></tt> to
obtain this number <a class="reference internal" href="#len-set"><span id="ref-len-set"><img src="callouts/callout2.gif" alt="[2]" class="callout" /></span></a>.  Although it has 44,764 tokens, this book
has only 2,789 distinct words, or &quot;word types.&quot;
A <a name="word_type_index_term" /><span class="termdef">word type</span> is the form or spelling of the word independently of its
specific occurrences in a text &#8212; that is, the
word considered as a unique item of vocabulary.  Our count of 2,789 items
will include punctuation symbols, so we will generally call these
unique items <a name="types_index_term" /><span class="termdef">types</span> instead of word types.</p>
<p>Now, let's calculate a measure of the lexical
richness of the text.  The next example shows us that the number of
distinct words is just 6% of the total number of words, or equivalently
that each word is used 16 times on average
(remember if you're using Python 2, to start with <tt class="doctest"><span class="pre"><span class="pysrc-keyword">from</span> __future__ <span class="pysrc-keyword">import</span> division</span></tt>).</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>len(set(text3)) / len(text3)
<span class="pysrc-output">0.06230453042623537</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt;</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Next, let's focus on particular words.  We can count how often a word occurs
in a text, and compute what percentage of the text is taken up by a specific word:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>text3.count(<span class="pysrc-string">&quot;smote&quot;</span>)
<span class="pysrc-output">5</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>100 * text4.count(<span class="pysrc-string">'a'</span>) / len(text4)
<span class="pysrc-output">1.4643016433938312</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt;</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last"><strong>Your Turn:</strong>
How many times does the word <span class="example">lol</span> appear in <tt class="doctest"><span class="pre">text5</span></tt>?
How much is this as a percentage of the total number of words
in this text?</p>
</div>
<p>You may want to repeat such calculations on several texts,
but it is tedious to keep retyping the formula.  Instead,
you can come up with your own name for a task, like
&quot;lexical_diversity&quot; or &quot;percentage&quot;, and associate it with a block of code.
Now you only have to type a short
name instead of one or more complete lines of Python code, and
you can re-use it as often as you like. The block of code that does a
task for us is called a <a name="function_index_term" /><span class="termdef">function</span>, and
we define a short name for our function with the keyword <tt class="doctest"><span class="pre">def</span></tt>. The
next example shows how to define two new functions,
<tt class="doctest"><span class="pre">lexical_diversity()</span></tt> and   <tt class="doctest"><span class="pre">percentage()</span></tt>:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">def</span> <span class="pysrc-defname">lexical_diversity</span>(text): <a name="fun-parameter1" /><a href="#ref-fun-parameter1"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></a>
<span class="pysrc-more">... </span>    return len(set(text)) / len(text) <a name="locvar" /><a href="#ref-locvar"><img src="callouts/callout2.gif" alt="[2]" class="callout" /></a>
<span class="pysrc-more">...</span>
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">def</span> <span class="pysrc-defname">percentage</span>(count, total): <a name="fun-parameter2" /><a href="#ref-fun-parameter2"><img src="callouts/callout3.gif" alt="[3]" class="callout" /></a>
<span class="pysrc-more">... </span>    return 100 * count / total
<span class="pysrc-more">...</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<div class="caution">
<p class="first admonition-title">Caution!</p>
<p class="last">The Python interpreter changes the prompt from
<tt class="doctest"><span class="pre"><span class="pysrc-prompt">&gt;&gt;&gt;</span></span></tt> to <tt class="doctest"><span class="pre"><span class="pysrc-more">...</span></span></tt> after encountering the colon at the
end of the first line.  The <tt class="doctest"><span class="pre"><span class="pysrc-more">...</span></span></tt> prompt indicates
that Python expects an <a name="indented_code_block_index_term" /><span class="termdef">indented code block</span> to appear next.
It is up to you to do the indentation, by typing four
spaces or hitting the tab key.  To finish the indented block just
enter a blank line.</p>
</div>
<p>In the definition of <tt class="doctest"><span class="pre">lexical_diversity()</span></tt> <a class="reference internal" href="#fun-parameter1"><span id="ref-fun-parameter1"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></span></a>, we
specify a <a name="parameter_index_term" /><span class="termdef">parameter</span> named <tt class="doctest"><span class="pre">text</span></tt> . This parameter is
a &quot;placeholder&quot; for the actual text whose lexical diversity we want to
compute, and reoccurs in the block of code that will run when the
function is used <a class="reference internal" href="#locvar"><span id="ref-locvar"><img src="callouts/callout2.gif" alt="[2]" class="callout" /></span></a>. Similarly, <tt class="doctest"><span class="pre">percentage()</span></tt> is defined to
take two parameters, named <tt class="doctest"><span class="pre">count</span></tt> and <tt class="doctest"><span class="pre">total</span></tt> <a class="reference internal" href="#fun-parameter2"><span id="ref-fun-parameter2"><img src="callouts/callout3.gif" alt="[3]" class="callout" /></span></a>.</p>
<p>Once Python knows that <tt class="doctest"><span class="pre">lexical_diversity()</span></tt> and <tt class="doctest"><span class="pre">percentage()</span></tt>
are the names for specific blocks
of code, we can go ahead and use these functions:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>lexical_diversity(text3)
<span class="pysrc-output">0.06230453042623537</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>lexical_diversity(text5)
<span class="pysrc-output">0.13477005109975562</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>percentage(4, 5)
<span class="pysrc-output">80.0</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>percentage(text4.count(<span class="pysrc-string">'a'</span>), len(text4))
<span class="pysrc-output">1.4643016433938312</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt;</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>To recap, we use or <a name="call_index_term" /><span class="termdef">call</span> a function such as <tt class="doctest"><span class="pre">lexical_diversity()</span></tt> by typing its name, followed
by an open parenthesis, the name of the text, and then a close
parenthesis. These parentheses will show up often; their role is to separate
the name of a task &#8212; such as <tt class="doctest"><span class="pre">lexical_diversity()</span></tt> &#8212; from the data
that the task is to be performed on &#8212; such as <tt class="doctest"><span class="pre">text3</span></tt>.
The data value that we place in the parentheses when we call a
function is an <a name="argument_index_term" /><span class="termdef">argument</span> to the function.</p>
<p>You have already encountered several functions in this chapter, such
as <tt class="doctest"><span class="pre">len()</span></tt>, <tt class="doctest"><span class="pre">set()</span></tt>, and <tt class="doctest"><span class="pre">sorted()</span></tt>. By convention, we will
always add an empty pair of parentheses after a function name, as in
<tt class="doctest"><span class="pre">len()</span></tt>, just to make clear that what we are talking about is a
function rather than some other kind of Python expression.
Functions are an important concept in programming, and we only
mention them at the outset to give newcomers a sense of the
power and creativity of programming.  Don't worry if you find it a bit
confusing right now.</p>
<p>Later we'll see how to use functions when tabulating data, as in <a class="reference internal" href="#tab-brown-types">13.1</a>.
Each row of the table will involve the same computation but
with different data, and we'll do this repetitive work using a function.</p>
<span class="target" id="tab-brown-types"></span><table border="1" class="docutils" id="tab-brown-types">
<colgroup>
<col width="39%" />
<col width="13%" />
<col width="11%" />
<col width="37%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Genre</th>
<th class="head">Tokens</th>
<th class="head">Types</th>
<th class="head">Lexical diversity</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>skill and hobbies</td>
<td>82345</td>
<td>11935</td>
<td>0.145</td>
</tr>
<tr><td>humor</td>
<td>21695</td>
<td>5017</td>
<td>0.231</td>
</tr>
<tr><td>fiction: science</td>
<td>14470</td>
<td>3233</td>
<td>0.223</td>
</tr>
<tr><td>press: reportage</td>
<td>100554</td>
<td>14394</td>
<td>0.143</td>
</tr>
<tr><td>fiction: romance</td>
<td>70022</td>
<td>8452</td>
<td>0.121</td>
</tr>
<tr><td>religion</td>
<td>39399</td>
<td>6373</td>
<td>0.162</td>
</tr>
</tbody>
<p class="caption"><span class="caption-label">Table 13.1</span>: <p>Lexical Diversity of Various Genres in the <em>Brown Corpus</em></p>
</p>
</table>
</div>
<div class="section" id="making-decisions">
<span id="sec-making-decisions"></span><h2>13.4&nbsp;&nbsp;&nbsp;Making Decisions</h2>
<!-- reimport

>>> from nltk.book import * -->
<p>So far, our little programs have had some interesting qualities:
the ability to work with language, and
the potential to save effort through automation.
A key feature of programming is the ability of machines to
make decisions on our behalf, executing instructions when
certain conditions are met, or repeatedly looping through
text data until some condition is satisfied.  This feature
is known as <a name="control_index_term" /><span class="termdef">control</span>, and is the focus of this section.</p>
<div class="section" id="conditionals">
<h3>Conditionals</h3>
<p>Python supports a wide range of operators, such as <tt class="doctest"><span class="pre">&lt;</span></tt> and <tt class="doctest"><span class="pre">&gt;=</span></tt>, for
testing the relationship between values. The full set of these <a name="relational_operators_index_term" /><span class="termdef">relational
operators</span> is shown in <a class="reference internal" href="#tab-inequalities">13.2</a>.</p>
<span class="target" id="tab-inequalities"></span><table border="1" class="docutils" id="tab-inequalities">
<colgroup>
<col width="14%" />
<col width="86%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Operator</th>
<th class="head">Relationship</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><tt class="doctest"><span class="pre">&lt;</span></tt></td>
<td>less than</td>
</tr>
<tr><td><tt class="doctest"><span class="pre">&lt;=</span></tt></td>
<td>less than or equal to</td>
</tr>
<tr><td><tt class="doctest"><span class="pre">==</span></tt></td>
<td>equal to (note this is two &quot;<tt class="doctest"><span class="pre">=</span></tt>&quot; signs, not one)</td>
</tr>
<tr><td><tt class="doctest"><span class="pre">!=</span></tt></td>
<td>not equal to</td>
</tr>
<tr><td><tt class="doctest"><span class="pre">&gt;</span></tt></td>
<td>greater than</td>
</tr>
<tr><td><tt class="doctest"><span class="pre">&gt;=</span></tt></td>
<td>greater than or equal to</td>
</tr>
</tbody>
<p class="caption"><span class="caption-label">Table 13.2</span>: <p>Numerical Comparison Operators</p>
</p>
</table>
<p>We can use these to select different words from a sentence of news text.
Here are some examples &#8212; only the operator is changed from one
line to the next.  They use the first sentence from the
<em>Wall Street Journal</em> corpus, possibly the most well-known sentence
in NLP, naming Pierre Vinken of Elsevier Publishers,
who was coincidentally an early builder of corpora.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>sent7
<span class="pysrc-output">['Pierre', 'Vinken', ',', '61', 'years', 'old', ',', 'will', 'join', 'the',</span>
<span class="pysrc-output">'board', 'as', 'a', 'nonexecutive', 'director', 'Nov.', '29', '.']</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>[w <span class="pysrc-keyword">for</span> w <span class="pysrc-keyword">in</span> sent7 <span class="pysrc-keyword">if</span> len(w) &lt; 4]
<span class="pysrc-output">[',', '61', 'old', ',', 'the', 'as', 'a', '29', '.']</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>[w <span class="pysrc-keyword">for</span> w <span class="pysrc-keyword">in</span> sent7 <span class="pysrc-keyword">if</span> len(w) &lt;= 4]
<span class="pysrc-output">[',', '61', 'old', ',', 'will', 'join', 'the', 'as', 'a', 'Nov.', '29', '.']</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>[w <span class="pysrc-keyword">for</span> w <span class="pysrc-keyword">in</span> sent7 <span class="pysrc-keyword">if</span> len(w) == 4]
<span class="pysrc-output">['will', 'join', 'Nov.']</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>[w <span class="pysrc-keyword">for</span> w <span class="pysrc-keyword">in</span> sent7 <span class="pysrc-keyword">if</span> len(w) != 4]
<span class="pysrc-output">['Pierre', 'Vinken', ',', '61', 'years', 'old', ',', 'the', 'board',</span>
<span class="pysrc-output">'as', 'a', 'nonexecutive', 'director', '29', '.']</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt;</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>There is a common pattern to all of these examples:
<tt class="doctest"><span class="pre">[w <span class="pysrc-keyword">for</span> w <span class="pysrc-keyword">in</span> text <span class="pysrc-keyword">if</span></span></tt> <em>condition</em> <tt class="doctest"><span class="pre">]</span></tt>, where <em>condition</em> is a
Python &quot;test&quot; that yields either true or false.
In the cases shown in the previous code example, the condition is always a numerical comparison.
However, we can also test various properties of words,
using the functions listed in <a class="reference internal" href="#tab-word-tests">13.3</a>.</p>
<span class="target" id="tab-word-tests"></span><table border="1" class="docutils" id="tab-word-tests">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Function</th>
<th class="head">Meaning</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><tt class="doctest"><span class="pre">s.startswith(t)</span></tt></td>
<td>test if <tt class="doctest"><span class="pre">s</span></tt> starts with <tt class="doctest"><span class="pre">t</span></tt></td>
</tr>
<tr><td><tt class="doctest"><span class="pre">s.endswith(t)</span></tt></td>
<td>test if <tt class="doctest"><span class="pre">s</span></tt> ends with <tt class="doctest"><span class="pre">t</span></tt></td>
</tr>
<tr><td><tt class="doctest"><span class="pre">t <span class="pysrc-keyword">in</span> s</span></tt></td>
<td>test if <tt class="doctest"><span class="pre">t</span></tt> is a substring of <tt class="doctest"><span class="pre">s</span></tt></td>
</tr>
<tr><td><tt class="doctest"><span class="pre">s.islower()</span></tt></td>
<td>test if <tt class="doctest"><span class="pre">s</span></tt> contains cased characters and all are lowercase</td>
</tr>
<tr><td><tt class="doctest"><span class="pre">s.isupper()</span></tt></td>
<td>test if <tt class="doctest"><span class="pre">s</span></tt> contains cased characters and all are uppercase</td>
</tr>
<tr><td><tt class="doctest"><span class="pre">s.isalpha()</span></tt></td>
<td>test if <tt class="doctest"><span class="pre">s</span></tt> is non-empty and all characters in <tt class="doctest"><span class="pre">s</span></tt> are alphabetic</td>
</tr>
<tr><td><tt class="doctest"><span class="pre">s.isalnum()</span></tt></td>
<td>test if <tt class="doctest"><span class="pre">s</span></tt> is non-empty and all characters in <tt class="doctest"><span class="pre">s</span></tt> are alphanumeric</td>
</tr>
<tr><td><tt class="doctest"><span class="pre">s.isdigit()</span></tt></td>
<td>test if <tt class="doctest"><span class="pre">s</span></tt> is non-empty and all characters in <tt class="doctest"><span class="pre">s</span></tt> are digits</td>
</tr>
<tr><td><tt class="doctest"><span class="pre">s.istitle()</span></tt></td>
<td>test if <tt class="doctest"><span class="pre">s</span></tt> contains cased characters and is titlecased
(i.e. all words in <tt class="doctest"><span class="pre">s</span></tt> have initial capitals)</td>
</tr>
</tbody>
<p class="caption"><span class="caption-label">Table 13.3</span>: <p>Some Word Comparison Operators</p>
</p>
</table>
<p>Here are some examples of these operators being used to
select words from our texts:
words ending with <span class="example">-ableness</span>;
words containing <span class="example">gnt</span>;
words having an initial capital;
and words consisting entirely of digits.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>sorted(w <span class="pysrc-keyword">for</span> w <span class="pysrc-keyword">in</span> set(text1) <span class="pysrc-keyword">if</span> w.endswith(<span class="pysrc-string">'ableness'</span>))
<span class="pysrc-output">['comfortableness', 'honourableness', 'immutableness', 'indispensableness', ...]</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>sorted(term <span class="pysrc-keyword">for</span> term <span class="pysrc-keyword">in</span> set(text4) <span class="pysrc-keyword">if</span> <span class="pysrc-string">'gnt'</span> <span class="pysrc-keyword">in</span> term)
<span class="pysrc-output">['Sovereignty', 'sovereignties', 'sovereignty']</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>sorted(item <span class="pysrc-keyword">for</span> item <span class="pysrc-keyword">in</span> set(text6) <span class="pysrc-keyword">if</span> item.istitle())
<span class="pysrc-output">['A', 'Aaaaaaaaah', 'Aaaaaaaah', 'Aaaaaah', 'Aaaah', 'Aaaaugh', 'Aaagh', ...]</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>sorted(item <span class="pysrc-keyword">for</span> item <span class="pysrc-keyword">in</span> set(sent7) <span class="pysrc-keyword">if</span> item.isdigit())
<span class="pysrc-output">['29', '61']</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt;</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>We can also create more complex conditions.  If <span class="math">c</span> is a
condition, then <tt class="doctest"><span class="pre"><span class="pysrc-keyword">not</span></span></tt> <span class="math">c</span> is also a condition.
If we have two conditions <span class="math">c</span><sub>1</sub> and <span class="math">c</span><sub>2</sub>,
then we can combine them to form a new condition using conjunction and disjunction:
<span class="math">c</span><sub>1</sub> <tt class="doctest"><span class="pre"><span class="pysrc-keyword">and</span></span></tt> <span class="math">c</span><sub>2</sub>,
<span class="math">c</span><sub>1</sub> <tt class="doctest"><span class="pre"><span class="pysrc-keyword">or</span></span></tt> <span class="math">c</span><sub>2</sub>.</p>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last"><strong>Your Turn:</strong>
Run the following examples and try to explain what is going on in each one.
Next, try to make up some conditions of your own.</p>
</div>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>sorted(w <span class="pysrc-keyword">for</span> w <span class="pysrc-keyword">in</span> set(text7) <span class="pysrc-keyword">if</span> <span class="pysrc-string">'-'</span> <span class="pysrc-keyword">in</span> w <span class="pysrc-keyword">and</span> <span class="pysrc-string">'index'</span> <span class="pysrc-keyword">in</span> w)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>sorted(wd <span class="pysrc-keyword">for</span> wd <span class="pysrc-keyword">in</span> set(text3) <span class="pysrc-keyword">if</span> wd.istitle() <span class="pysrc-keyword">and</span> len(wd) &gt; 10)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>sorted(w <span class="pysrc-keyword">for</span> w <span class="pysrc-keyword">in</span> set(sent7) <span class="pysrc-keyword">if</span> <span class="pysrc-keyword">not</span> w.islower())
<span class="pysrc-prompt">&gt;&gt;&gt; </span>sorted(t <span class="pysrc-keyword">for</span> t <span class="pysrc-keyword">in</span> set(text2) <span class="pysrc-keyword">if</span> <span class="pysrc-string">'cie'</span> <span class="pysrc-keyword">in</span> t <span class="pysrc-keyword">or</span> <span class="pysrc-string">'cei'</span> <span class="pysrc-keyword">in</span> t)</pre>
</td>
</tr></table></td></tr>
</table></div>
</div>
<div class="section" id="operating-on-every-element">
<h3>Operating on Every Element</h3>
<p>In <a class="reference external" href="ch01.html#sec-computing-with-language-simple-statistics">3</a>, we saw some examples of
counting items other than words.  Let's take a closer look at the notation we used:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>[len(w) <span class="pysrc-keyword">for</span> w <span class="pysrc-keyword">in</span> text1]
<span class="pysrc-output">[1, 4, 4, 2, 6, 8, 4, 1, 9, 1, 1, 8, 2, 1, 4, 11, 5, 2, 1, 7, 6, 1, 3, 4, 5, 2, ...]</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>[w.upper() <span class="pysrc-keyword">for</span> w <span class="pysrc-keyword">in</span> text1]
<span class="pysrc-output">['[', 'MOBY', 'DICK', 'BY', 'HERMAN', 'MELVILLE', '1851', ']', 'ETYMOLOGY', '.', ...]</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt;</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>These expressions have the form <tt class="doctest"><span class="pre">[f(w) <span class="pysrc-keyword">for</span> ...]</span></tt> or <tt class="doctest"><span class="pre">[w.f() <span class="pysrc-keyword">for</span> ...]</span></tt>, where
<tt class="doctest"><span class="pre">f</span></tt> is a function that operates on a word to compute its length, or to
convert it to uppercase.
For now, you don't need to understand the difference between the notations <tt class="doctest"><span class="pre">f(w)</span></tt> and
<tt class="doctest"><span class="pre">w.f()</span></tt>.  Instead, simply learn this Python idiom which performs the
same operation on every element of a list.  In the preceding examples, it goes through
each word in <tt class="doctest"><span class="pre">text1</span></tt>, assigning each one in turn to the variable <tt class="doctest"><span class="pre">w</span></tt> and
performing the specified operation on the variable.</p>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last">The notation just described is called a &quot;list comprehension.&quot;  This is our first example
of a Python idiom, a fixed notation that we use habitually without bothering to
analyze each time.  Mastering such idioms is an important part of becoming a
fluent Python programmer.</p>
</div>
<p>Let's return to the question of vocabulary size, and apply the same idiom here:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>len(text1)
<span class="pysrc-output">260819</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>len(set(text1))
<span class="pysrc-output">19317</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>len(set(word.lower() <span class="pysrc-keyword">for</span> word <span class="pysrc-keyword">in</span> text1))
<span class="pysrc-output">17231</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt;</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Now that we are not double-counting words like <span class="example">This</span> and <span class="example">this</span>, which differ only
in capitalization, we've wiped 2,000 off the vocabulary count!  We can go a step further
and eliminate numbers and punctuation from the vocabulary count by filtering out any
non-alphabetic items:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>len(set(word.lower() <span class="pysrc-keyword">for</span> word <span class="pysrc-keyword">in</span> text1 <span class="pysrc-keyword">if</span> word.isalpha()))
<span class="pysrc-output">16948</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt;</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>This example is slightly complicated: it lowercases all the purely alphabetic items.
Perhaps it would have been simpler just to count the lowercase-only items, but this
gives the wrong answer (why?).</p>
<p>Don't worry if you don't feel confident with list comprehensions yet,
since you'll see many more examples along with explanations in the following chapters.</p>
</div>
<div class="section" id="nested-code-blocks">
<h3>Nested Code Blocks</h3>
<p>Most programming languages permit us to execute a block of code when a
<a name="conditional_expression_index_term" /><span class="termdef">conditional expression</span>, or <tt class="doctest"><span class="pre"><span class="pysrc-keyword">if</span></span></tt> statement, is satisfied.  We
already saw examples of conditional tests in code like <tt class="doctest"><span class="pre">[w <span class="pysrc-keyword">for</span> w <span class="pysrc-keyword">in</span>
sent7 <span class="pysrc-keyword">if</span> len(w) &lt; 4]</span></tt>. In the following program, we have created a
variable called <tt class="doctest"><span class="pre">word</span></tt> containing the string value <tt class="doctest"><span class="pre"><span class="pysrc-string">'cat'</span></span></tt>. The
<tt class="doctest"><span class="pre"><span class="pysrc-keyword">if</span></span></tt> statement checks whether the test <tt class="doctest"><span class="pre">len(word) &lt; 5</span></tt> is true.
It is, so the body of the <tt class="doctest"><span class="pre"><span class="pysrc-keyword">if</span></span></tt> statement is invoked and the
<tt class="doctest"><span class="pre"><span class="pysrc-keyword">print</span></span></tt> statement is executed, displaying a message to the user.
Remember to indent the <tt class="doctest"><span class="pre"><span class="pysrc-keyword">print</span></span></tt> statement by typing four spaces.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>word = <span class="pysrc-string">'cat'</span>
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">if</span> len(word) &lt; 5:
<span class="pysrc-more">... </span>    <span class="pysrc-keyword">print</span>(<span class="pysrc-string">'word length is less than 5'</span>)
<span class="pysrc-more">... </span>  <a name="blank-line" /><a href="#ref-blank-line"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></a>
<span class="pysrc-output">word length is less than 5</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt;</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>When we use the Python interpreter we have to add an extra blank line <a class="reference internal" href="#blank-line"><span id="ref-blank-line"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></span></a>
in order for it to detect that the nested block is complete.</p>
<p>If we change the conditional test to <tt class="doctest"><span class="pre">len(word) &gt;= 5</span></tt>,
to check that the length of <tt class="doctest"><span class="pre">word</span></tt> is greater than or equal to <tt class="doctest"><span class="pre">5</span></tt>,
then the test will no longer be true.
This time, the body of the <tt class="doctest"><span class="pre"><span class="pysrc-keyword">if</span></span></tt> statement will not be executed,
and no message is shown to the user:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">if</span> len(word) &gt;= 5:
<span class="pysrc-more">... </span>  <span class="pysrc-keyword">print</span>(<span class="pysrc-string">'word length is greater than or equal to 5'</span>)
<span class="pysrc-more">...</span>
<span class="pysrc-prompt">&gt;&gt;&gt;</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>An <tt class="doctest"><span class="pre"><span class="pysrc-keyword">if</span></span></tt> statement is known as a <a name="control_structure_index_term" /><span class="termdef">control structure</span>
because it controls whether the code in the indented block will be run.
Another control structure is the <tt class="doctest"><span class="pre"><span class="pysrc-keyword">for</span></span></tt> loop.
Try the following, and remember to include the colon and the four spaces:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">for</span> word <span class="pysrc-keyword">in</span> [<span class="pysrc-string">'Call'</span>, <span class="pysrc-string">'me'</span>, <span class="pysrc-string">'Ishmael'</span>, <span class="pysrc-string">'.'</span>]:
<span class="pysrc-more">... </span>    <span class="pysrc-keyword">print</span>(word)
<span class="pysrc-more">...</span>
<span class="pysrc-output">Call</span>
<span class="pysrc-output">me</span>
<span class="pysrc-output">Ishmael</span>
<span class="pysrc-output">.</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt;</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>This is called a loop because Python executes the code in
circular fashion.  It starts by performing the
assignment <tt class="doctest"><span class="pre">word = <span class="pysrc-string">'Call'</span></span></tt>,
effectively using the <tt class="doctest"><span class="pre">word</span></tt> variable to name the first
item of the list.  Then, it displays the value of <tt class="doctest"><span class="pre">word</span></tt>
to the user.  Next, it goes back to the <tt class="doctest"><span class="pre"><span class="pysrc-keyword">for</span></span></tt> statement,
and performs the assignment <tt class="doctest"><span class="pre">word = <span class="pysrc-string">'me'</span></span></tt>, before displaying this new value
to the user, and so on.  It continues in this fashion until
every item of the list has been processed.</p>
</div>
<div class="section" id="looping-with-conditions">
<h3>Looping with Conditions</h3>
<p>Now we can combine the <tt class="doctest"><span class="pre"><span class="pysrc-keyword">if</span></span></tt> and <tt class="doctest"><span class="pre"><span class="pysrc-keyword">for</span></span></tt> statements.
We will loop over every item of the list, and print
the item only if it ends with the letter <em>l</em>.  We'll pick another
name for the variable to demonstrate that Python doesn't
try to make sense of variable names.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>sent1 = [<span class="pysrc-string">'Call'</span>, <span class="pysrc-string">'me'</span>, <span class="pysrc-string">'Ishmael'</span>, <span class="pysrc-string">'.'</span>]
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">for</span> xyzzy <span class="pysrc-keyword">in</span> sent1:
<span class="pysrc-more">... </span>    <span class="pysrc-keyword">if</span> xyzzy.endswith(<span class="pysrc-string">'l'</span>):
<span class="pysrc-more">... </span>        <span class="pysrc-keyword">print</span>(xyzzy)
<span class="pysrc-more">...</span>
<span class="pysrc-output">Call</span>
<span class="pysrc-output">Ishmael</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt;</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>You will notice that <tt class="doctest"><span class="pre"><span class="pysrc-keyword">if</span></span></tt> and <tt class="doctest"><span class="pre"><span class="pysrc-keyword">for</span></span></tt> statements
have a colon at the end of the line,
before the indentation begins. In fact, all Python
control structures end with a colon.  The colon
indicates that the current statement relates to the
indented block that follows.</p>
<p>We can also specify an action to be taken if
the condition of the <tt class="doctest"><span class="pre"><span class="pysrc-keyword">if</span></span></tt> statement is not met.
Here we see the <tt class="doctest"><span class="pre"><span class="pysrc-keyword">elif</span></span></tt> (else if) statement, and
the <tt class="doctest"><span class="pre"><span class="pysrc-keyword">else</span></span></tt> statement.  Notice that these also have
colons before the indented code.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">for</span> token <span class="pysrc-keyword">in</span> sent1:
<span class="pysrc-more">... </span>    <span class="pysrc-keyword">if</span> token.islower():
<span class="pysrc-more">... </span>        <span class="pysrc-keyword">print</span>(token, <span class="pysrc-string">'is a lowercase word'</span>)
<span class="pysrc-more">... </span>    <span class="pysrc-keyword">elif</span> token.istitle():
<span class="pysrc-more">... </span>        <span class="pysrc-keyword">print</span>(token, <span class="pysrc-string">'is a titlecase word'</span>)
<span class="pysrc-more">... </span>    <span class="pysrc-keyword">else</span>:
<span class="pysrc-more">... </span>        <span class="pysrc-keyword">print</span>(token, <span class="pysrc-string">'is punctuation'</span>)
<span class="pysrc-more">...</span>
<span class="pysrc-output">Call is a titlecase word</span>
<span class="pysrc-output">me is a lowercase word</span>
<span class="pysrc-output">Ishmael is a titlecase word</span>
<span class="pysrc-output">. is punctuation</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt;</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>As you can see, even with this small amount of Python knowledge,
you can start to build multiline Python programs.
It's important to develop such programs in pieces,
testing that each piece does what you expect before
combining them into a program.  This is why the Python
interactive interpreter is so invaluable, and why you should get
comfortable using it.</p>
<p>Finally, let's combine the idioms we've been exploring.
First, we create a list of <span class="example">cie</span> and <span class="example">cei</span> words,
then we loop over each item and print it.  Notice the
extra information given in the print statement: <cite>end=' '</cite>.
This tells Python to print a space (not the default newline) after each word.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>tricky = sorted(w <span class="pysrc-keyword">for</span> w <span class="pysrc-keyword">in</span> set(text2) <span class="pysrc-keyword">if</span> <span class="pysrc-string">'cie'</span> <span class="pysrc-keyword">in</span> w <span class="pysrc-keyword">or</span> <span class="pysrc-string">'cei'</span> <span class="pysrc-keyword">in</span> w)
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">for</span> word <span class="pysrc-keyword">in</span> tricky:
<span class="pysrc-more">... </span>    <span class="pysrc-keyword">print</span>(word, end=<span class="pysrc-string">' '</span>)
<span class="pysrc-output">ancient ceiling conceit conceited conceive conscience</span>
<span class="pysrc-output">conscientious conscientiously deceitful deceive ...</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt;</span></pre>
</td>
</tr></table></td></tr>
</table></div>
</div>
</div>
<div class="section" id="sequences">
<span id="sec-sequences"></span><h2>13.5&nbsp;&nbsp;&nbsp;Sequences</h2>
<p>So far, the only data type we have worked with is the list data type.
Lists are one of several kinds of <a name="sequence_index_term" /><span class="termdef">sequence</span> data type.
There are two other important kinds of sequence that you need to know
about: strings and tuples.</p>
<div class="section" id="strings">
<h3>Strings</h3>
<p>Some of the methods we used to access the elements of a list also work with individual words,
or <a name="strings_index_term" /><span class="termdef">strings</span>.  For example, we can assign a string to a variable <a class="reference internal" href="#assign-string"><span id="ref-assign-string"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></span></a>,
index a string <a class="reference internal" href="#index-string"><span id="ref-index-string"><img src="callouts/callout2.gif" alt="[2]" class="callout" /></span></a>, and slice a string <a class="reference internal" href="#slice-string"><span id="ref-slice-string"><img src="callouts/callout3.gif" alt="[3]" class="callout" /></span></a>:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>name = <span class="pysrc-string">'Monty'</span> <a name="assign-string" /><a href="#ref-assign-string"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></a>
<span class="pysrc-prompt">&gt;&gt;&gt; </span>name[0] <a name="index-string" /><a href="#ref-index-string"><img src="callouts/callout2.gif" alt="[2]" class="callout" /></a>
<span class="pysrc-output">'M'</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>name[:4] <a name="slice-string" /><a href="#ref-slice-string"><img src="callouts/callout3.gif" alt="[3]" class="callout" /></a>
<span class="pysrc-output">'Mont'</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt;</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>We can also perform multiplication and addition with strings:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>name * 2
<span class="pysrc-output">'MontyMonty'</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>name + <span class="pysrc-string">'!'</span>
<span class="pysrc-output">'Monty!'</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt;</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>We can join the words of a list to make a single string, or split a string into a list, as follows:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-string">' '</span>.join([<span class="pysrc-string">'Monty'</span>, <span class="pysrc-string">'Python'</span>])
<span class="pysrc-output">'Monty Python'</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-string">'Monty Python'</span>.split()
<span class="pysrc-output">['Monty', 'Python']</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt;</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>We will come back to the topic of strings in <a class="reference external" href="ch03.html#chap-words">3</a>.
For the time being, we have two important building blocks,
lists and strings.</p>
<!-- XXX next sentence is confusing, since you don't in fact use parentheses -->
<!-- Although the point about ("foo") not being a tuple is a good one, I would be -->
<!-- inclined to advise students to use parentheses as well as comma. Cf your -->
<!-- example of the precedence problem in the debugging section later on: -->
<!-- For example, ``"%s.%s.%02d" % "ph.d.", "n", 1`` produces a run-time error -->
<!-- ``TypeError: not enough arguments for format string``.  This is because the -->
<!-- percent operator has higher precedence than -->
<!-- the comma operator.  The fix is to add parentheses in order to -->
<!-- force the required scope. -->
<!-- Just checked the Python Tutorial: -->
<!-- As you see, on output tuples are always enclosed in parentheses, so that nested -->
<!-- tuples are interpreted correctly; they may be input with or without surrounding -->
<!-- parentheses, although often parentheses are necessary anyway (if the tuple is part -->
<!-- of a larger expression). -->
<!-- SB: done, I think -->
</div>
<div class="section" id="tuples">
<h3>Tuples</h3>
<p>Another kind of sequence is called a <a name="tuple_index_term" /><span class="termdef">tuple</span>.
Tuples are formed with the comma operator <a class="reference internal" href="#create-tuple"><span id="ref-create-tuple"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></span></a>, and typically enclosed
in parentheses. Like lists and strings, tuples can be indexed <a class="reference internal" href="#index-tuple"><span id="ref-index-tuple"><img src="callouts/callout2.gif" alt="[2]" class="callout" /></span></a>
and sliced <a class="reference internal" href="#slice-tuple"><span id="ref-slice-tuple"><img src="callouts/callout3.gif" alt="[3]" class="callout" /></span></a>, and have a length <a class="reference internal" href="#length-tuple"><span id="ref-length-tuple"><img src="callouts/callout4.gif" alt="[4]" class="callout" /></span></a>.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>t = (<span class="pysrc-string">'walk'</span>, <span class="pysrc-string">'fem'</span>, 3) <a name="create-tuple" /><a href="#ref-create-tuple"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></a>
<span class="pysrc-prompt">&gt;&gt;&gt; </span>t
<span class="pysrc-output">('walk', 'fem', 3)</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>t[0] <a name="index-tuple" /><a href="#ref-index-tuple"><img src="callouts/callout2.gif" alt="[2]" class="callout" /></a>
<span class="pysrc-output">'walk'</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>t[1:] <a name="slice-tuple" /><a href="#ref-slice-tuple"><img src="callouts/callout3.gif" alt="[3]" class="callout" /></a>
<span class="pysrc-output">('fem', 3)</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>len(t) <a name="length-tuple" /><a href="#ref-length-tuple"><img src="callouts/callout4.gif" alt="[4]" class="callout" /></a>
<span class="pysrc-output">3</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<div class="caution">
<p class="first admonition-title">Caution!</p>
<p class="last">Tuples are constructed using the comma operator.  Parentheses are a more
general feature of Python syntax, designed for grouping.
A tuple containing the single element <tt class="doctest"><span class="pre"><span class="pysrc-string">'snark'</span></span></tt> is defined by adding a
trailing comma, like this: &quot;<tt class="doctest"><span class="pre"><span class="pysrc-string">'snark'</span>,</span></tt>&quot;.  The empty tuple is a special
case, and is defined using empty parentheses <tt class="doctest"><span class="pre">()</span></tt>.</p>
</div>
<!-- XXX how about making the following contrast: -->
<!-- >>> type(('snark')) -->
<!-- <type 'str'> -->
<!-- >>> type(('snark',)) -->
<!-- <type 'tuple'> -->
<!-- XXX this would be a good place to explain tuple assignment / sequence unpacking -->
<!-- (unless you did in a revision of ch03 - - it is mentioned only in an exercise to -->
<!-- this chapter AF -->
<p>Let's compare strings, lists and tuples directly, and do the indexing, slice, and length
operation on each type:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>raw = <span class="pysrc-string">'I turned off the spectroroute'</span>
<span class="pysrc-prompt">&gt;&gt;&gt; </span>text = [<span class="pysrc-string">'I'</span>, <span class="pysrc-string">'turned'</span>, <span class="pysrc-string">'off'</span>, <span class="pysrc-string">'the'</span>, <span class="pysrc-string">'spectroroute'</span>]
<span class="pysrc-prompt">&gt;&gt;&gt; </span>pair = (6, <span class="pysrc-string">'turned'</span>)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>raw[2], text[3], pair[1]
<span class="pysrc-output">('t', 'the', 'turned')</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>raw[-3:], text[-3:], pair[-3:]
<span class="pysrc-output">('ute', ['off', 'the', 'spectroroute'], (6, 'turned'))</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>len(raw), len(text), len(pair)
<span class="pysrc-output">(29, 5, 2)</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Notice in this code sample that we computed multiple values on a
single line, separated by commas.  These comma-separated expressions
are actually just tuples &#8212; Python allows us to omit the
parentheses around tuples if there is no ambiguity. When we print a
tuple, the parentheses are always displayed.</p>
</div>
<div class="section" id="operating-on-sequence-types">
<h3>Operating on Sequence Types</h3>
<p>We can iterate over the items in a sequence <tt class="doctest"><span class="pre">s</span></tt> in a variety of useful ways,
as shown in <a class="reference internal" href="#tab-python-sequence">13.4</a>.</p>
<span class="target" id="tab-python-sequence"></span><table border="1" class="docutils" id="tab-python-sequence">
<colgroup>
<col width="45%" />
<col width="55%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Python Expression</th>
<th class="head">Comment</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><tt class="doctest"><span class="pre"><span class="pysrc-keyword">for</span> item <span class="pysrc-keyword">in</span> s</span></tt></td>
<td>iterate over the items of <tt class="doctest"><span class="pre">s</span></tt></td>
</tr>
<tr><td><tt class="doctest"><span class="pre"><span class="pysrc-keyword">for</span> item <span class="pysrc-keyword">in</span> sorted(s)</span></tt></td>
<td>iterate over the items of <tt class="doctest"><span class="pre">s</span></tt> in order</td>
</tr>
<tr><td><tt class="doctest"><span class="pre"><span class="pysrc-keyword">for</span> item <span class="pysrc-keyword">in</span> set(s)</span></tt></td>
<td>iterate over unique elements of <tt class="doctest"><span class="pre">s</span></tt></td>
</tr>
<tr><td><tt class="doctest"><span class="pre"><span class="pysrc-keyword">for</span> item <span class="pysrc-keyword">in</span> reversed(s)</span></tt></td>
<td>iterate over elements of <tt class="doctest"><span class="pre">s</span></tt> in reverse</td>
</tr>
<tr><td><tt class="doctest"><span class="pre"><span class="pysrc-keyword">for</span> item <span class="pysrc-keyword">in</span> set(s).difference(t)</span></tt></td>
<td>iterate over elements of <tt class="doctest"><span class="pre">s</span></tt> not in <tt class="doctest"><span class="pre">t</span></tt></td>
</tr>
</tbody>
<p class="caption"><span class="caption-label">Table 13.4</span>: <p>Various ways to iterate over sequences</p>
</p>
</table>
<p>The sequence functions illustrated in <a class="reference internal" href="#tab-python-sequence">13.4</a> can be combined
in various ways; for example, to get unique elements of <tt class="doctest"><span class="pre">s</span></tt> sorted
in reverse, use <tt class="doctest"><span class="pre">reversed(sorted(set(s)))</span></tt>.
We can randomize the contents of a list <tt class="doctest"><span class="pre">s</span></tt> before iterating over
them, using <tt class="doctest"><span class="pre">random.shuffle(s)</span></tt>.</p>
<p>We can convert between these sequence types.  For example,
<tt class="doctest"><span class="pre">tuple(s)</span></tt> converts any kind of sequence into a tuple, and
<tt class="doctest"><span class="pre">list(s)</span></tt> converts any kind of sequence into a list.
We can convert a list of strings to a single string using the
<tt class="doctest"><span class="pre">join()</span></tt> function, e.g. <tt class="doctest"><span class="pre"><span class="pysrc-string">':'</span>.join(words)</span></tt>.</p>
<p>Some other objects, such as a <tt class="doctest"><span class="pre">FreqDist</span></tt>, can be converted into a
sequence (using <tt class="doctest"><span class="pre">list()</span></tt> or <tt class="doctest"><span class="pre">sorted()</span></tt>) and support iteration, e.g.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>raw = <span class="pysrc-string">'Red lorry, yellow lorry, red lorry, yellow lorry.'</span>
<span class="pysrc-prompt">&gt;&gt;&gt; </span>text = word_tokenize(raw)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>fdist = nltk.FreqDist(text)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>sorted(fdist)
<span class="pysrc-output">[',', '.', 'Red', 'lorry', 'red', 'yellow']</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">for</span> key <span class="pysrc-keyword">in</span> fdist:
<span class="pysrc-more">... </span>    <span class="pysrc-keyword">print</span>(key + <span class="pysrc-string">':'</span>, fdist[key], end=<span class="pysrc-string">'; '</span>)
<span class="pysrc-more">...</span>
<span class="pysrc-output">lorry: 4; red: 1; .: 1; ,: 3; Red: 1; yellow: 2</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>In the next example, we use tuples to re-arrange the
contents of our list.  (We can omit the parentheses
because the comma has higher precedence than assignment.)</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>words = [<span class="pysrc-string">'I'</span>, <span class="pysrc-string">'turned'</span>, <span class="pysrc-string">'off'</span>, <span class="pysrc-string">'the'</span>, <span class="pysrc-string">'spectroroute'</span>]
<span class="pysrc-prompt">&gt;&gt;&gt; </span>words[2], words[3], words[4] = words[3], words[4], words[2]
<span class="pysrc-prompt">&gt;&gt;&gt; </span>words
<span class="pysrc-output">['I', 'turned', 'the', 'spectroroute', 'off']</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>This is an idiomatic and readable way to move items inside a list.
It is equivalent to the following traditional way of doing such
tasks that does not use tuples (notice that this method needs a
temporary variable <tt class="doctest"><span class="pre">tmp</span></tt>).</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>tmp = words[2]
<span class="pysrc-prompt">&gt;&gt;&gt; </span>words[2] = words[3]
<span class="pysrc-prompt">&gt;&gt;&gt; </span>words[3] = words[4]
<span class="pysrc-prompt">&gt;&gt;&gt; </span>words[4] = tmp</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>As we have seen, Python has sequence functions such as <tt class="doctest"><span class="pre">sorted()</span></tt> and <tt class="doctest"><span class="pre">reversed()</span></tt>
that rearrange the items of a sequence.  There are also functions that
modify the <span class="emphasis">structure</span> of a sequence and which can be handy for
language processing.  Thus, <tt class="doctest"><span class="pre">zip()</span></tt> takes
the items of two or more sequences and &quot;zips&quot; them together into a single list of tuples.
Given a sequence <tt class="doctest"><span class="pre">s</span></tt>, <tt class="doctest"><span class="pre">enumerate(s)</span></tt> returns pairs consisting of
an index and the item at that index.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>words = [<span class="pysrc-string">'I'</span>, <span class="pysrc-string">'turned'</span>, <span class="pysrc-string">'off'</span>, <span class="pysrc-string">'the'</span>, <span class="pysrc-string">'spectroroute'</span>]
<span class="pysrc-prompt">&gt;&gt;&gt; </span>tags = [<span class="pysrc-string">'noun'</span>, <span class="pysrc-string">'verb'</span>, <span class="pysrc-string">'prep'</span>, <span class="pysrc-string">'det'</span>, <span class="pysrc-string">'noun'</span>]
<span class="pysrc-prompt">&gt;&gt;&gt; </span>zip(words, tags)
<span class="pysrc-output">&lt;zip object at ...&gt;</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>list(zip(words, tags))
<span class="pysrc-output">[('I', 'noun'), ('turned', 'verb'), ('off', 'prep'),</span>
<span class="pysrc-output">('the', 'det'), ('spectroroute', 'noun')]</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>list(enumerate(words))
<span class="pysrc-output">[(0, 'I'), (1, 'turned'), (2, 'off'), (3, 'the'), (4, 'spectroroute')]</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last">It is a widespread feature of Python 3 and NLTK 3 to only perform
computation when required (a feature known as &quot;lazy evaluation&quot;).
If you ever see a result like <tt class="doctest"><span class="pre">&lt;zip object at 0x10d005448&gt;</span></tt> when
you expect to see a sequence, you can force the object to be
evaluated just by putting it in a context that expects a sequence,
like <tt class="doctest"><span class="pre">list(</span></tt><span class="mathit">x</span><tt class="doctest"><span class="pre">)</span></tt>, or <tt class="doctest"><span class="pre"><span class="pysrc-keyword">for</span> item <span class="pysrc-keyword">in</span></span></tt> <span class="mathit">x</span>.</p>
</div>
<p>For some NLP tasks it is necessary to cut up a sequence into two or more parts.
For instance, we might want to &quot;train&quot; a system on 90% of the data and test it
on the remaining 10%.  To do this we decide the location where we want to
cut the data <a class="reference internal" href="#cut-location"><span id="ref-cut-location"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></span></a>, then cut the sequence at that location <a class="reference internal" href="#cut-sequence"><span id="ref-cut-sequence"><img src="callouts/callout2.gif" alt="[2]" class="callout" /></span></a>.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>text = nltk.corpus.nps_chat.words()
<span class="pysrc-prompt">&gt;&gt;&gt; </span>cut = int(0.9 * len(text)) <a name="cut-location" /><a href="#ref-cut-location"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></a>
<span class="pysrc-prompt">&gt;&gt;&gt; </span>training_data, test_data = text[:cut], text[cut:] <a name="cut-sequence" /><a href="#ref-cut-sequence"><img src="callouts/callout2.gif" alt="[2]" class="callout" /></a>
<span class="pysrc-prompt">&gt;&gt;&gt; </span>text == training_data + test_data <a name="cut-preserve" /><a href="#ref-cut-preserve"><img src="callouts/callout3.gif" alt="[3]" class="callout" /></a>
<span class="pysrc-output">True</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>len(training_data) / len(test_data) <a name="cut-ratio" /><a href="#ref-cut-ratio"><img src="callouts/callout4.gif" alt="[4]" class="callout" /></a>
<span class="pysrc-output">9.0</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>We can verify that none of the original data is lost during this process, nor is it duplicated
<a class="reference internal" href="#cut-preserve"><span id="ref-cut-preserve"><img src="callouts/callout3.gif" alt="[3]" class="callout" /></span></a>.  We can also verify that the ratio of the sizes of the two pieces is what
we intended <a class="reference internal" href="#cut-ratio"><span id="ref-cut-ratio"><img src="callouts/callout4.gif" alt="[4]" class="callout" /></span></a>.</p>
</div>
<div class="section" id="combining-different-sequence-types">
<h3>Combining Different Sequence Types</h3>
<p>Let's combine our knowledge of these three sequence types, together with list
comprehensions, to perform the task of sorting the words in a string by
their length.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>words = <span class="pysrc-string">'I turned off the spectroroute'</span>.split() <a name="string-object" /><a href="#ref-string-object"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></a>
<span class="pysrc-prompt">&gt;&gt;&gt; </span>wordlens = [(len(word), word) <span class="pysrc-keyword">for</span> word <span class="pysrc-keyword">in</span> words] <a name="tuple-comprehension" /><a href="#ref-tuple-comprehension"><img src="callouts/callout2.gif" alt="[2]" class="callout" /></a>
<span class="pysrc-prompt">&gt;&gt;&gt; </span>wordlens.sort() <a name="sort-method" /><a href="#ref-sort-method"><img src="callouts/callout3.gif" alt="[3]" class="callout" /></a>
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-string">' '</span>.join(w <span class="pysrc-keyword">for</span> (_, w) <span class="pysrc-keyword">in</span> wordlens) <a name="discard-length" /><a href="#ref-discard-length"><img src="callouts/callout4.gif" alt="[4]" class="callout" /></a>
<span class="pysrc-output">'I off the turned spectroroute'</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<!-- XXX cf earlier remark about explaining what "in-place" means -->
<p>Each of the above lines of code contains a significant feature.
A simple string is actually an object with methods defined on it such as <tt class="doctest"><span class="pre">split()</span></tt> <a class="reference internal" href="#string-object"><span id="ref-string-object"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></span></a>.
We use a list comprehension to build a list of tuples <a class="reference internal" href="#tuple-comprehension"><span id="ref-tuple-comprehension"><img src="callouts/callout2.gif" alt="[2]" class="callout" /></span></a>,
where each tuple consists of a number (the word length) and the
word, e.g. <tt class="doctest"><span class="pre">(3, <span class="pysrc-string">'the'</span>)</span></tt>.  We use the <tt class="doctest"><span class="pre">sort()</span></tt> method <a class="reference internal" href="#sort-method"><span id="ref-sort-method"><img src="callouts/callout3.gif" alt="[3]" class="callout" /></span></a>
to sort the list in-place.  Finally, we discard the length
information and join the words back into a single string <a class="reference internal" href="#discard-length"><span id="ref-discard-length"><img src="callouts/callout4.gif" alt="[4]" class="callout" /></span></a>.
(The underscore <a class="reference internal" href="#discard-length"><img src="callouts/callout4.gif" alt="[4]" class="callout" /></a> is just a regular Python variable,
but we can use underscore by convention to indicate that we will
not use its value.)</p>
<p>We began by talking about the commonalities in these sequence types,
but the above code illustrates important differences in their
roles.  First, strings appear at the beginning and the end: this is
typical in the context where our program is reading in some text and
producing output for us to read.  Lists and tuples are used in the
middle, but for different purposes.  A list is typically a sequence of
objects all having the <span class="emphasis">same type</span>, of <span class="emphasis">arbitrary length</span>.  We often
use lists to hold sequences of words.  In contrast,
a tuple is typically a collection of objects of <span class="emphasis">different types</span>, of
<span class="emphasis">fixed length</span>.  We often use a tuple to hold a <a name="record_index_term" /><span class="termdef">record</span>,
a collection of different <a name="fields_index_term" /><span class="termdef">fields</span> relating to some entity.
This distinction between the use of lists and tuples takes some
getting used to,
so here is another example:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>lexicon = [
<span class="pysrc-more">... </span>    (<span class="pysrc-string">'the'</span>, <span class="pysrc-string">'det'</span>, [<span class="pysrc-string">'Di:'</span>, <span class="pysrc-string">'D&#64;'</span>]),
<span class="pysrc-more">... </span>    (<span class="pysrc-string">'off'</span>, <span class="pysrc-string">'prep'</span>, [<span class="pysrc-string">'Qf'</span>, <span class="pysrc-string">'O:f'</span>])
<span class="pysrc-more">... </span>]</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Here, a lexicon is represented as a list because it is a
collection of objects of a single type &#8212; lexical entries &#8212;
of no predetermined length.  An individual entry is represented as a
tuple because it is a collection of objects with different
interpretations, such as the orthographic form, the part of speech,
and the pronunciations (represented in the SAMPA computer-readable
phonetic alphabet <tt class="doctest"><span class="pre">http://www.phon.ucl.ac.uk/home/sampa/</span></tt>).
Note that these pronunciations are stored using a list. (Why?)</p>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last">A good way to decide when to use tuples vs lists is to ask whether
the interpretation of an item depends on its position.  For example,
a tagged token combines two strings having different interpretation,
and we choose to interpret the first item as the token and the
second item as the tag.  Thus we use tuples like this: <tt class="doctest"><span class="pre">(<span class="pysrc-string">'grail'</span>, <span class="pysrc-string">'noun'</span>)</span></tt>;
a tuple of the form <tt class="doctest"><span class="pre">(<span class="pysrc-string">'noun'</span>, <span class="pysrc-string">'grail'</span>)</span></tt> would be nonsensical since
it would be a word <tt class="doctest"><span class="pre">noun</span></tt> tagged <tt class="doctest"><span class="pre">grail</span></tt>.
In contrast, the elements of a text are all tokens, and position is
not significant.  Thus we use lists like this: <tt class="doctest"><span class="pre">[<span class="pysrc-string">'venetian'</span>, <span class="pysrc-string">'blind'</span>]</span></tt>;
a list of the form <tt class="doctest"><span class="pre">[<span class="pysrc-string">'blind'</span>, <span class="pysrc-string">'venetian'</span>]</span></tt> would be equally valid.
The linguistic meaning of the words might be different, but the
interpretation of list items as tokens is unchanged.</p>
</div>
<p>The distinction between lists and tuples has been described in terms of
usage.  However, there is a more fundamental difference: in Python,
lists are <a name="mutable_index_term" /><span class="termdef">mutable</span>, while tuples are <a name="immutable_index_term" /><span class="termdef">immutable</span>.  In other
words, lists can be modified, while tuples cannot.  Here are some of
the operations on lists that do in-place modification of the list.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>lexicon.sort()
<span class="pysrc-prompt">&gt;&gt;&gt; </span>lexicon[1] = (<span class="pysrc-string">'turned'</span>, <span class="pysrc-string">'VBD'</span>, [<span class="pysrc-string">'t3:nd'</span>, <span class="pysrc-string">'t3`nd'</span>])
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">del</span> lexicon[0]</pre>
</td>
</tr></table></td></tr>
</table></div>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last"><strong>Your Turn:</strong>
Convert <tt class="doctest"><span class="pre">lexicon</span></tt> to a tuple, using <tt class="doctest"><span class="pre">lexicon = tuple(lexicon)</span></tt>,
then try each of the above operations, to confirm that none of
them is permitted on tuples.</p>
</div>
</div>
<div class="section" id="generator-expressions">
<h3>Generator Expressions</h3>
<p>We've been making heavy use of list comprehensions, for compact and readable
processing of texts.  Here's an example where we tokenize and normalize a text:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>text = <span class="pysrc-string">'''&quot;When I use a word,&quot; Humpty Dumpty said in rather a scornful tone,</span>
<span class="pysrc-more">... </span><span class="pysrc-string">&quot;it means just what I choose it to mean - neither more nor less.&quot;'''</span>
<span class="pysrc-prompt">&gt;&gt;&gt; </span>[w.lower() <span class="pysrc-keyword">for</span> w <span class="pysrc-keyword">in</span> word_tokenize(text)]
<span class="pysrc-output">['``', 'when', 'i', 'use', 'a', 'word', ',', &quot;''&quot;, 'humpty', 'dumpty', 'said', ...]</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Suppose we now want to process these words further.  We can do this by inserting the above
expression inside a call to some other function <a class="reference internal" href="#max-comprehension"><span id="ref-max-comprehension"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></span></a>,
but Python allows us to omit the brackets <a class="reference internal" href="#max-generator"><span id="ref-max-generator"><img src="callouts/callout2.gif" alt="[2]" class="callout" /></span></a>.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>max([w.lower() <span class="pysrc-keyword">for</span> w <span class="pysrc-keyword">in</span> word_tokenize(text)]) <a name="max-comprehension" /><a href="#ref-max-comprehension"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></a>
<span class="pysrc-output">'word'</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>max(w.lower() <span class="pysrc-keyword">for</span> w <span class="pysrc-keyword">in</span> word_tokenize(text)) <a name="max-generator" /><a href="#ref-max-generator"><img src="callouts/callout2.gif" alt="[2]" class="callout" /></a>
<span class="pysrc-output">'word'</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>The second line uses a <a name="generator_expression_index_term" /><span class="termdef">generator expression</span>.  This is more than a notational convenience:
in many language processing situations, generator expressions will be more efficient.
In <a class="reference internal" href="#max-comprehension"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></a>, storage for the list object must be allocated
before the value of max() is computed.  If the text is
very large, this could be slow.  In <a class="reference internal" href="#max-generator"><img src="callouts/callout2.gif" alt="[2]" class="callout" /></a>, the data is streamed to the calling
function.  Since the calling function simply has to find the maximum value &#8212; the
word which comes latest in lexicographic sort order &#8212; it can process the stream
of data without having to store anything more than the maximum value seen so far.</p>
</div>
</div>
<div class="section" id="reusing-code">
<span id="sec-reusing-code"></span><h2>13.6&nbsp;&nbsp;&nbsp;Reusing Code</h2>
<p>By this time you've probably typed and retyped a lot of code in the Python
interactive interpreter.  If you mess up when retyping a complex example you have
to enter it again.  Using the arrow keys to access and modify previous commands is helpful but only goes so
far.  In this section we see two important ways to reuse code: text editors and Python functions.</p>
<div class="section" id="creating-programs-with-a-text-editor">
<h3>Creating Programs with a Text Editor</h3>
<p>The Python interactive interpreter performs your instructions as soon as you type
them.  Often, it is better to compose a multi-line program using a text editor,
then ask Python to run the whole program at once.  Using IDLE, you can do
this by going to the <tt class="doctest"><span class="pre">File</span></tt> menu and opening a new window.  Try this now, and
enter the following one-line program:</p>
<pre class="literal-block">
print('Monty Python')
</pre>
<p>Save this program in a file called <tt class="doctest"><span class="pre">monty.py</span></tt>, then
go to the <tt class="doctest"><span class="pre">Run</span></tt> menu, and select the command <tt class="doctest"><span class="pre">Run Module</span></tt>.
(We'll learn what modules are shortly.)
The result in the main IDLE window should look like this:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>================================ RESTART ================================
<span class="pysrc-prompt">&gt;&gt;&gt;</span>
<span class="pysrc-output">Monty Python</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt;</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>You can also type <tt class="doctest"><span class="pre"><span class="pysrc-keyword">from</span> monty <span class="pysrc-keyword">import</span> *</span></tt> and it will do the same thing.</p>
<p>From now on, you have a choice of using the interactive interpreter or a
text editor to create your programs.  It is often convenient to test your ideas
using the interpreter, revising a line of code until it does what you expect.
Once you're ready, you can paste the code
(minus any <tt class="doctest"><span class="pre"><span class="pysrc-prompt">&gt;&gt;&gt;</span></span></tt> or <tt class="doctest"><span class="pre"><span class="pysrc-more">...</span></span></tt> prompts) into the text editor,
continue to expand it, and finally save the program
in a file so that you don't have to type it in again later.
Give the file a short but descriptive name, using all lowercase letters and separating
words with underscore, and using the <tt class="doctest"><span class="pre">.py</span></tt> filename extension, e.g., <tt class="doctest"><span class="pre">monty_python.py</span></tt>.</p>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last"><strong>Important:</strong>
Our inline code examples include the <tt class="doctest"><span class="pre"><span class="pysrc-prompt">&gt;&gt;&gt;</span></span></tt> and <tt class="doctest"><span class="pre"><span class="pysrc-more">...</span></span></tt> prompts
as if we are interacting directly with the interpreter.  As they get more complicated,
you should instead type them into the editor, without the prompts, and run them
from the editor as shown above.  When we provide longer programs in this book,
we will leave out the prompts to remind you to type them into a file rather
than using the interpreter.  You can see this already in <a class="reference external" href="ch02.html#code-random-text">2.1</a> above.
Note that it still includes a couple of lines with the Python prompt;
this is the interactive part of the task where you inspect some data and invoke a function.
Remember that all code samples like <a class="reference external" href="ch02.html#code-random-text">2.1</a> are downloadable
from <tt class="doctest"><span class="pre">http://nltk.org/</span></tt>.</p>
</div>
</div>
<div class="section" id="functions">
<h3>Functions</h3>
<p>Suppose that you work on analyzing text that involves different forms
of the same word, and that part of your program needs to work out
the plural form of a given singular noun.  Suppose it needs to do this
work in two places, once when it is processing some texts, and again
when it is processing user input.</p>
<p>Rather than repeating the same code several times over, it is more
efficient and reliable to localize this work inside a <a name="function_index_term_2" /><span class="termdef">function</span>.
A function is just a named block of code that performs some well-defined
task, as we saw in <a class="reference internal" href="#sec-vocabularies-as-sets-of-words">13.3</a>.
A function is usually defined to take some inputs, using special variables known as <a name="parameters_index_term" /><span class="termdef">parameters</span>,
and it may produce a result, also known as a <a name="return_value_index_term" /><span class="termdef">return value</span>.
We define a function using the keyword <tt class="doctest"><span class="pre">def</span></tt> followed by the
function name and any input parameters, followed by the body of the
function.  Here's the function we saw in <a class="reference internal" href="#sec-vocabularies-as-sets-of-words">13.3</a>:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">def</span> <span class="pysrc-defname">lexical_diversity</span>(text):
<span class="pysrc-more">... </span>    return len(text) / len(set(text))</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>We use the keyword <tt class="doctest"><span class="pre">return</span></tt> to indicate the value that is
produced as output by the function.  In the above example,
all the work of the function is done in the <tt class="doctest"><span class="pre">return</span></tt> statement.
Here's an equivalent definition which does the same work
using multiple lines of code.  We'll change the parameter name
from <tt class="doctest"><span class="pre">text</span></tt> to <tt class="doctest"><span class="pre">my_text_data</span></tt> to remind you that this is an arbitrary choice:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">def</span> <span class="pysrc-defname">lexical_diversity</span>(my_text_data):
<span class="pysrc-more">... </span>    word_count = len(my_text_data)
<span class="pysrc-more">... </span>    vocab_size = len(set(my_text_data))
<span class="pysrc-more">... </span>    diversity_score = vocab_size / word_count
<span class="pysrc-more">... </span>    return diversity_score</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Notice that we've created some new variables inside the body of the function.
These are <a name="local_variables_index_term" /><span class="termdef">local variables</span> and are not accessible outside the function.
So now we have defined a function with the name <tt class="doctest"><span class="pre">lexical_diversity</span></tt>. But just
defining it won't produce any output!
Functions do nothing until they are &quot;called&quot; (or &quot;invoked&quot;):</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">from</span> nltk.corpus <span class="pysrc-keyword">import</span> genesis
<span class="pysrc-prompt">&gt;&gt;&gt; </span>kjv = genesis.words(<span class="pysrc-string">'english-kjv.txt'</span>)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>lexical_diversity(kjv)
<span class="pysrc-output">0.06230453042623537</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Let's return to our earlier scenario, and actually define a simple
function to work out English plurals.  The function <tt class="doctest"><span class="pre">plural()</span></tt> in <a class="reference internal" href="#code-plural">13.1</a>
takes a singular noun and generates a plural form, though it is not always
correct.  (We'll discuss functions at greater length in <a class="reference internal" href="#sec-functions">13.8</a>.)</p>
<span class="target" id="code-plural"></span><div class="pylisting">
<table border="0" cellpadding="0" cellspacing="0" class="pylisting" width="95%">
<tr><td class="codeblock">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_codeblock_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-keyword">def</span> <span class="pysrc-defname">plural</span>(word):
    <span class="pysrc-keyword">if</span> word.endswith(<span class="pysrc-string">'y'</span>):
        return word[:-1] + <span class="pysrc-string">'ies'</span>
    <span class="pysrc-keyword">elif</span> word[-1] <span class="pysrc-keyword">in</span> <span class="pysrc-string">'sx'</span> <span class="pysrc-keyword">or</span> word[-2:] <span class="pysrc-keyword">in</span> [<span class="pysrc-string">'sh'</span>, <span class="pysrc-string">'ch'</span>]:
        return word + <span class="pysrc-string">'es'</span>
    <span class="pysrc-keyword">elif</span> word.endswith(<span class="pysrc-string">'an'</span>):
        return word[:-2] + <span class="pysrc-string">'en'</span>
    <span class="pysrc-keyword">else</span>:
        return word + <span class="pysrc-string">'s'</span></pre>
</td>
</tr></table></td></tr>
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>plural(<span class="pysrc-string">'fairy'</span>)
<span class="pysrc-output">'fairies'</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>plural(<span class="pysrc-string">'woman'</span>)
<span class="pysrc-output">'women'</span></pre>
</td>
</tr></table></td></tr>
<tr><td class="caption"><p class="caption"><a class="reference external" href="pylisting/code_plural.py" type="text/x-python"><span class="caption-label">Example 13.1 (code_plural.py)</span></a>: <span class="caption-label">Figure 13.1</span>: A Python Function: this function tries to work out the
plural form of any English noun; the keyword <tt class="doctest"><span class="pre">def</span></tt> (define)
is followed by the function name, then a parameter inside
parentheses, and a colon; the body of the function is the
indented block of code; it tries to recognize patterns
within the word and process the word accordingly; e.g., if the
word ends with <span class="example">y</span>, delete the <span class="example">y</span> and add <span class="example">ies</span>.</td></tr></p>
</table></div>
<p>The <tt class="doctest"><span class="pre">endswith()</span></tt> function is always associated with a string object
(e.g., <tt class="doctest"><span class="pre">word</span></tt> in <a class="reference internal" href="#code-plural">13.1</a>).  To call such functions, we give
the name of the object, a period, and then the name of the function.
These functions are usually known as <a name="methods_index_term" /><span class="termdef">methods</span>.</p>
</div>
<div class="section" id="modules">
<h3>Modules</h3>
<p>Over time you will find that you create a variety of useful little text processing functions,
and you end up copying them from old programs to new ones.  Which file contains the
latest version of the function you want to use?
It makes life a lot easier if you can collect your work into a single place, and
access previously defined functions without making copies.</p>
<p>To do this, save your function(s) in a file called (say) <tt class="doctest"><span class="pre">text_proc.py</span></tt>.
Now, you can access your work simply by importing it from the file:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">from</span> text_proc <span class="pysrc-keyword">import</span> plural
<span class="pysrc-prompt">&gt;&gt;&gt; </span>plural(<span class="pysrc-string">'wish'</span>)
<span class="pysrc-output">wishes</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>plural(<span class="pysrc-string">'fan'</span>)
<span class="pysrc-output">fen</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Our plural function obviously has an error, since the plural of
<span class="example">fan</span> is <span class="example">fans</span>.
Instead of typing in a new version of the function, we can
simply edit the existing one.  Thus, at every
stage, there is only one version of our plural function, and no confusion about
which one is being used.</p>
<p>A collection of variable and function definitions in a file is called a Python
<a name="module_index_term" /><span class="termdef">module</span>.  A collection of related modules is called a <a name="package_index_term" /><span class="termdef">package</span>.
NLTK's code for processing the Brown Corpus is an example of a module,
and its collection of code for processing all the different corpora is
an example of a package.  NLTK itself is a set of packages, sometimes
called a <a name="library_index_term" /><span class="termdef">library</span>.</p>
<div class="caution">
<p class="first admonition-title">Caution!</p>
<p class="last">If you are creating a file to contain some of your Python
code, do <em>not</em> name your file <tt class="doctest"><span class="pre">nltk.py</span></tt>: it may get imported in
place of the &quot;real&quot; NLTK package.  When it imports modules, Python
first looks in the current directory (folder).</p>
</div>
</div>
</div>
<div class="section" id="questions-of-style">
<h2>13.7&nbsp;&nbsp;&nbsp;Questions of Style</h2>
<p>Programming is as much an art as a science.  The undisputed &quot;bible&quot; of programming,
a 2,500 page multi-volume work by Donald Knuth, is called
<span class="emphasis">The Art of Computer Programming</span>.  Many books have been written on
<span class="emphasis">Literate Programming</span>, recognizing that humans, not just computers,
must read and understand programs.  Here we pick up on some issues of
programming style that have important ramifications for the readability
of your code, including code layout, procedural vs declarative style,
and the use of loop variables.</p>
<div class="section" id="python-coding-style">
<h3>Python Coding Style</h3>
<p>When writing programs you make many subtle choices about names,
spacing, comments, and so on.  When you look at code written by
other people, needless differences in style make it harder
to interpret the code.  Therefore, the designers of the Python
language have published a style guide for Python code, available
at <tt class="doctest"><span class="pre">http://www.python.org/dev/peps/pep-0008/</span></tt>.
The underlying value presented in the style guide is <span class="emphasis">consistency</span>,
for the purpose of maximizing the readability of code.
We briefly review some of its key recommendations here, and refer
readers to the full guide for detailed discussion with examples.</p>
<!-- XXX use pylisting for following example? -->
<p>Code layout should use four spaces per indentation level.  You should make sure that
when you write Python code in a file, you
avoid tabs for indentation, since these can be misinterpreted by
different text editors and the indentation can be messed up.
Lines should be less than 80 characters long; if necessary you can
break a line inside parentheses, brackets, or braces, because
Python is able to detect that the line continues over to the next line.
If you need to break a line outside parentheses, brackets, or braces,
you can often add extra parentheses, and you can always add a backslash at
the end of the line that is broken:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">if</span> (len(syllables) &gt; 4 <span class="pysrc-keyword">and</span> len(syllables[2]) == 3 <span class="pysrc-keyword">and</span>
<span class="pysrc-more">... </span>   syllables[2][2] <span class="pysrc-keyword">in</span> [aeiou] <span class="pysrc-keyword">and</span> syllables[2][3] == syllables[1][3]):
<span class="pysrc-more">... </span>    process(syllables)
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">if</span> len(syllables) &gt; 4 <span class="pysrc-keyword">and</span> len(syllables[2]) == 3 <span class="pysrc-keyword">and</span> \
<span class="pysrc-more">... </span>   syllables[2][2] <span class="pysrc-keyword">in</span> [aeiou] <span class="pysrc-keyword">and</span> syllables[2][3] == syllables[1][3]:
<span class="pysrc-more">... </span>    process(syllables)</pre>
</td>
</tr></table></td></tr>
</table></div>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last">Typing spaces instead of tabs soon becomes a chore.  Many programming
editors have built-in support for Python, and can automatically indent
code and highlight any syntax errors (including indentation errors).
For a list of Python-aware editors, please see
<tt class="doctest"><span class="pre">http://wiki.python.org/moin/PythonEditors</span></tt>.</p>
</div>
</div>
<div class="section" id="procedural-vs-declarative-style">
<h3>Procedural vs Declarative Style</h3>
<!-- XXX ?? Is this really referring to coding style, or was it originally in a -->
<!-- different context? Make a more clear contrast between coding style and programming -->
<!-- style? -->
<!-- XXX following snippet is first time they've seen += -->
<!-- XXX this section seems to be more oriented towards "Python for C-Programmers" -->
<!-- rather than to novices. -->
<p>We have just seen how the same task can be performed in different
ways, with implications for efficiency.  Another factor influencing
program development is <em>programming style</em>.  Consider the following
program to compute the average length of words in the Brown Corpus:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>tokens = nltk.corpus.brown.words(categories=<span class="pysrc-string">'news'</span>)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>count = 0
<span class="pysrc-prompt">&gt;&gt;&gt; </span>total = 0
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">for</span> token <span class="pysrc-keyword">in</span> tokens:
<span class="pysrc-more">... </span>    count += 1
<span class="pysrc-more">... </span>    total += len(token)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>total / count
<span class="pysrc-output">4.401545438271973</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<!-- XXX above is first use of +=, so needs explaining -->
<p>In this program we use the variable <tt class="doctest"><span class="pre">count</span></tt> to keep track of the
number of tokens seen, and <tt class="doctest"><span class="pre">total</span></tt> to store the combined length of
all words.  This is a low-level style, not far removed from machine
code, the primitive operations performed by the computer's CPU.
The two variables are just like a CPU's registers, accumulating values
at many intermediate stages, values that are meaningless until the end.
We say that this program is written in a <em>procedural</em> style, dictating
the machine operations step by step.  Now consider the following
program that computes the same thing:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>total = sum(len(t) <span class="pysrc-keyword">for</span> t <span class="pysrc-keyword">in</span> tokens)
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">print</span>(total / len(tokens))
<span class="pysrc-output">4.401...</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<!-- Monkey patching so that the next example doesn't take forever
>>> tokens = "the cat sat on the mat".split() -->
<p>The first line uses a generator expression to sum the token lengths,
while the second line computes the average as before.
Each line of code performs a complete, meaningful task, which
can be understood in terms of high-level properties like:
&quot;<tt class="doctest"><span class="pre">total</span></tt> is the sum of the lengths of the tokens&quot;.
Implementation details are left to the Python interpreter.
The second program uses a built-in function, and constitutes
programming at a more abstract level; the resulting code is
more declarative.  Let's look at an extreme example:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>word_list = []
<span class="pysrc-prompt">&gt;&gt;&gt; </span>i = 0
<span class="pysrc-prompt">&gt;&gt;&gt; </span>while i &lt; len(tokens):
<span class="pysrc-more">... </span>    j = 0
<span class="pysrc-more">... </span>    while j &lt; len(word_list) <span class="pysrc-keyword">and</span> word_list[j] &lt;= tokens[i]:
<span class="pysrc-more">... </span>        j += 1
<span class="pysrc-more">... </span>    <span class="pysrc-keyword">if</span> j == 0 <span class="pysrc-keyword">or</span> tokens[i] != word_list[j-1]:
<span class="pysrc-more">... </span>        word_list.insert(j, tokens[i])
<span class="pysrc-more">... </span>    i += 1
<span class="pysrc-more">...</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>The equivalent declarative version uses familiar built-in functions,
and its purpose is instantly recognizable:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>word_list = sorted(set(tokens))</pre>
</td>
</tr></table></td></tr>
</table></div>
<!-- XXX you are taking for granted that the reader already knows what a loop variable is. -->
<p>Another case where a loop variable seems to be necessary is for printing
a counter with each line of output.  Instead, we can use <tt class="doctest"><span class="pre">enumerate()</span></tt>, which
processes a sequence <tt class="doctest"><span class="pre">s</span></tt> and produces a tuple of the form <tt class="doctest"><span class="pre">(i, s[i])</span></tt> for each
item in <tt class="doctest"><span class="pre">s</span></tt>, starting with <tt class="doctest"><span class="pre">(0, s[0])</span></tt>.  Here we enumerate the key-value pairs of the
frequency distribution, resulting in nested tuples <tt class="doctest"><span class="pre">(rank, (word, count))</span></tt>.
We print <tt class="doctest"><span class="pre">rank+1</span></tt> so that the counting appears to start from <tt class="doctest"><span class="pre">1</span></tt>,
as required when producing a list of ranked items.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>fd = nltk.FreqDist(nltk.corpus.brown.words())
<span class="pysrc-prompt">&gt;&gt;&gt; </span>cumulative = 0.0
<span class="pysrc-prompt">&gt;&gt;&gt; </span>most_common_words = [word <span class="pysrc-keyword">for</span> (word, count) <span class="pysrc-keyword">in</span> fd.most_common()]
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">for</span> rank, word <span class="pysrc-keyword">in</span> enumerate(most_common_words):
<span class="pysrc-more">... </span>    cumulative += fd.freq(word)
<span class="pysrc-more">... </span>    <span class="pysrc-keyword">print</span>(<span class="pysrc-string">&quot;%3d %6.2f%% %s&quot;</span> % (rank + 1, cumulative * 100, word))
<span class="pysrc-more">... </span>    <span class="pysrc-keyword">if</span> cumulative &gt; 0.25:
<span class="pysrc-more">... </span>        break
<span class="pysrc-more">...</span>
<span class="pysrc-output">  1   5.40% the</span>
<span class="pysrc-output">  2  10.42% ,</span>
<span class="pysrc-output">  3  14.67% .</span>
<span class="pysrc-output">  4  17.78% of</span>
<span class="pysrc-output">  5  20.19% and</span>
<span class="pysrc-output">  6  22.40% to</span>
<span class="pysrc-output">  7  24.29% a</span>
<span class="pysrc-output">  8  25.97% in</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>It's sometimes tempting to use loop variables to store a maximum or minimum value
seen so far.  Let's use this method to find the longest word in a text.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>text = nltk.corpus.gutenberg.words(<span class="pysrc-string">'milton-paradise.txt'</span>)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>longest = <span class="pysrc-string">''</span>
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">for</span> word <span class="pysrc-keyword">in</span> text:
<span class="pysrc-more">... </span>    <span class="pysrc-keyword">if</span> len(word) &gt; len(longest):
<span class="pysrc-more">... </span>        longest = word
<span class="pysrc-prompt">&gt;&gt;&gt; </span>longest
<span class="pysrc-output">'unextinguishable'</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>However, a more transparent solution uses two list comprehensions,
both having forms that should be familiar by now:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>maxlen = max(len(word) <span class="pysrc-keyword">for</span> word <span class="pysrc-keyword">in</span> text)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>[word <span class="pysrc-keyword">for</span> word <span class="pysrc-keyword">in</span> text <span class="pysrc-keyword">if</span> len(word) == maxlen]
<span class="pysrc-output">['unextinguishable', 'transubstantiate', 'inextinguishable', 'incomprehensible']</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Note that our first solution found the first word having the longest length, while the
second solution found <em>all</em> of the longest words (which is usually what we would want).
Although there's a theoretical efficiency difference between the two solutions,
the main overhead is reading the data into main memory; once it's there, a second pass
through the data is effectively instantaneous.  We also need to balance our concerns about
program efficiency with programmer efficiency.  A fast but cryptic solution
will be harder to understand and maintain.</p>
</div>
<div class="section" id="some-legitimate-uses-for-counters">
<h3>Some Legitimate Uses for Counters</h3>
<!-- XXX it just struck me that we don't seem to explain range() at any point, tho' -->
<!-- it's used a couple of times in ch03 (added exercise to ch01; also mentioned in ch02). -->
<p>There are cases where we still want to use loop variables in a list comprehension.
For example, we need to use a loop variable to extract successive overlapping n-grams
from a list:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>sent = [<span class="pysrc-string">'The'</span>, <span class="pysrc-string">'dog'</span>, <span class="pysrc-string">'gave'</span>, <span class="pysrc-string">'John'</span>, <span class="pysrc-string">'the'</span>, <span class="pysrc-string">'newspaper'</span>]
<span class="pysrc-prompt">&gt;&gt;&gt; </span>n = 3
<span class="pysrc-prompt">&gt;&gt;&gt; </span>[sent[i:i+n] <span class="pysrc-keyword">for</span> i <span class="pysrc-keyword">in</span> range(len(sent)-n+1)]
<span class="pysrc-output">[['The', 'dog', 'gave'],</span>
<span class="pysrc-output"> ['dog', 'gave', 'John'],</span>
<span class="pysrc-output"> ['gave', 'John', 'the'],</span>
<span class="pysrc-output"> ['John', 'the', 'newspaper']]</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>It is quite tricky to get the range of the loop variable right.
Since this is a common operation in NLP, NLTK
supports it with functions <tt class="doctest"><span class="pre">bigrams(text)</span></tt> and <tt class="doctest"><span class="pre">trigrams(text)</span></tt>, and
a general purpose <tt class="doctest"><span class="pre">ngrams(text, n)</span></tt>.</p>
<p>Here's an example of how we can use loop variables in
building multidimensional structures.
For example, to build an array with <em>m</em> rows and <em>n</em> columns,
where each cell is a set, we could use a nested list comprehension:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>m, n = 3, 7
<span class="pysrc-prompt">&gt;&gt;&gt; </span>array = [[set() <span class="pysrc-keyword">for</span> i <span class="pysrc-keyword">in</span> range(n)] <span class="pysrc-keyword">for</span> j <span class="pysrc-keyword">in</span> range(m)]
<span class="pysrc-prompt">&gt;&gt;&gt; </span>array[2][5].add(<span class="pysrc-string">'Alice'</span>)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>pprint.pprint(array)
<span class="pysrc-output">[[set(), set(), set(), set(), set(), set(), set()],</span>
<span class="pysrc-output"> [set(), set(), set(), set(), set(), set(), set()],</span>
<span class="pysrc-output"> [set(), set(), set(), set(), set(), {'Alice'}, set()]]</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Observe that the loop variables <tt class="doctest"><span class="pre">i</span></tt> and <tt class="doctest"><span class="pre">j</span></tt> are not used
anywhere in the resulting object, they are just needed for a syntactically
correct <tt class="doctest"><span class="pre"><span class="pysrc-keyword">for</span></span></tt> statement.  As another example of this usage, observe
that the expression <tt class="doctest"><span class="pre">[<span class="pysrc-string">'very'</span> <span class="pysrc-keyword">for</span> i <span class="pysrc-keyword">in</span> range(3)]</span></tt> produces a list
containing three instances of <tt class="doctest"><span class="pre"><span class="pysrc-string">'very'</span></span></tt>, with no integers in sight.</p>
<p>Note that it would be incorrect to do this work using multiplication,
for reasons concerning object copying that were discussed earlier in this section.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>array = [[set()] * n] * m
<span class="pysrc-prompt">&gt;&gt;&gt; </span>array[2][5].add(7)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>pprint.pprint(array)
<span class="pysrc-output">[[{7}, {7}, {7}, {7}, {7}, {7}, {7}],</span>
<span class="pysrc-output"> [{7}, {7}, {7}, {7}, {7}, {7}, {7}],</span>
<span class="pysrc-output"> [{7}, {7}, {7}, {7}, {7}, {7}, {7}]]</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<!-- XXX this seems to more of an opening statement that a closing one - - since it -->
<!-- assumes the reader already knows some other languages -->
<p>Iteration is an important programming device.
It is tempting to adopt idioms from other languages.
However, Python offers some elegant and highly readable alternatives,
as we have seen.</p>
</div>
</div>
<div class="section" id="functions-the-foundation-of-structured-programming">
<span id="sec-functions"></span><h2>13.8&nbsp;&nbsp;&nbsp;Functions: The Foundation of Structured Programming</h2>
<!-- XXX excessive duplication of information that was already presented in ch02; -->
<!-- e.g. motivation for functions, terminology of 'parameter' and 'body', return -->
<!-- statement etc.  (some collapsing) -->
<p>Functions provide an effective way to package and re-use program code,
as already explained in <a class="reference internal" href="#sec-reusing-code">13.6</a>.
For example, suppose we find that we often want to read text from an HTML file.
This involves several steps: opening the file, reading it in, normalizing
whitespace, and stripping HTML markup.  We can collect these steps into a
function, and give it a name such as <tt class="doctest"><span class="pre">get_text()</span></tt>, as shown in <a class="reference internal" href="#code-get-text">13.2</a>.</p>
<span class="target" id="code-get-text"></span><div class="pylisting">
<table border="0" cellpadding="0" cellspacing="0" class="pylisting" width="95%">
<tr><td class="codeblock">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_codeblock_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-keyword">import</span> re
<span class="pysrc-keyword">def</span> <span class="pysrc-defname">get_text</span>(file):
    <span class="pysrc-string">&quot;&quot;&quot;Read text from a file, normalizing whitespace and stripping HTML markup.&quot;&quot;&quot;</span>
    text = open(file).read()
    text = re.sub(r<span class="pysrc-string">'&lt;.*?&gt;'</span>, <span class="pysrc-string">' '</span>, text)
    text = re.sub(<span class="pysrc-string">'\s+'</span>, <span class="pysrc-string">' '</span>, text)
    return text</pre>
</td>
</tr></table></td></tr>
<tr><td class="caption"><p class="caption"><a class="reference external" href="pylisting/code_get_text.py" type="text/x-python"><span class="caption-label">Example 13.2 (code_get_text.py)</span></a>: <span class="caption-label">Figure 13.2</span>: Read text from a file</td></tr></p>
</table></div>
<p>Now, any time we want to get cleaned-up text from an HTML file, we can just call
<tt class="doctest"><span class="pre">get_text()</span></tt> with the name of the file as its only argument.  It will return
a string, and we can assign this to a variable, e.g.:
<tt class="doctest"><span class="pre">contents = get_text(<span class="pysrc-string">&quot;test.html&quot;</span>)</span></tt>.  Each time we want to use this series of
steps we only have to call the function.</p>
<p>Using functions has the benefit of saving space in our program.  More
importantly, our choice of name for the function helps make the program <em>readable</em>.
In the case of the above example, whenever our program needs to read cleaned-up
text from a file we don't have to clutter the program with four lines of code, we
simply need to call <tt class="doctest"><span class="pre">get_text()</span></tt>.  This naming helps to provide some &quot;semantic
interpretation&quot; &#8212; it helps a reader of our program to see what the program &quot;means&quot;.</p>
<p>Notice that the above function definition contains a string.  The first string inside
a function definition is called a <a name="docstring_index_term" /><span class="termdef">docstring</span>.  Not only does it document the
purpose of the function to someone reading the code, it is accessible to a programmer
who has loaded the code from a file:</p>
<pre class="literal-block">
|   &gt;&gt;&gt; help(get_text)
|   Help on function get_text in module __main__:
|
|   get(text)
|       Read text from a file, normalizing whitespace and stripping HTML markup.
</pre>
<p>We have seen that functions help to make our work reusable and readable.  They
also help make it <em>reliable</em>.  When we re-use code that has already been developed
and tested, we can be more confident that it handles a variety of cases correctly.
We also remove the risk that we forget some important step, or introduce a bug.
The program that calls our function also has increased reliability.  The author
of that program is dealing with a shorter program, and its components behave
transparently.</p>
<p>To summarize, as its name suggests, a function captures functionality.
It is a segment of code that can be given a meaningful name and which performs
a well-defined task.  Functions allow us to abstract away from the details,
to see a bigger picture, and to program more effectively.</p>
<p>The rest of this section takes a closer look at functions, exploring the
mechanics and discussing ways to make your programs easier to read.</p>
<div class="section" id="function-inputs-and-outputs">
<h3>Function Inputs and Outputs</h3>
<p>We pass information to functions using a function's parameters,
the parenthesized list of variables and constants following
the function's name in the function definition.  Here's a complete example:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">def</span> <span class="pysrc-defname">repeat</span>(msg, num):  <a name="fun-def" /><a href="#ref-fun-def"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></a>
<span class="pysrc-more">... </span>    return <span class="pysrc-string">' '</span>.join([msg] * num)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>monty = <span class="pysrc-string">'Monty Python'</span>
<span class="pysrc-prompt">&gt;&gt;&gt; </span>repeat(monty, 3) <a name="fun-call" /><a href="#ref-fun-call"><img src="callouts/callout2.gif" alt="[2]" class="callout" /></a>
<span class="pysrc-output">'Monty Python Monty Python Monty Python'</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>We first define the function to take two parameters, <tt class="doctest"><span class="pre">msg</span></tt> and <tt class="doctest"><span class="pre">num</span></tt>
<a class="reference internal" href="#fun-def"><span id="ref-fun-def"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></span></a>. Then we call the function and pass it two arguments, <tt class="doctest"><span class="pre">monty</span></tt> and <tt class="doctest"><span class="pre">3</span></tt>
<a class="reference internal" href="#fun-call"><span id="ref-fun-call"><img src="callouts/callout2.gif" alt="[2]" class="callout" /></span></a>; these arguments fill the &quot;placeholders&quot; provided by the parameters and
provide values for the occurrences of <tt class="doctest"><span class="pre">msg</span></tt> and <tt class="doctest"><span class="pre">num</span></tt> in the function body.</p>
<p>It is not necessary to have any parameters, as we see in the following example:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">def</span> <span class="pysrc-defname">monty</span>():
<span class="pysrc-more">... </span>    return <span class="pysrc-string">&quot;Monty Python&quot;</span>
<span class="pysrc-prompt">&gt;&gt;&gt; </span>monty()
<span class="pysrc-output">'Monty Python'</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>A function usually communicates its results back to the calling program via the <tt class="doctest"><span class="pre">return</span></tt> statement,
as we have just seen.  To the calling program, it looks as if the function call had been replaced
with the function's result, e.g.:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>repeat(monty(), 3)
<span class="pysrc-output">'Monty Python Monty Python Monty Python'</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>repeat(<span class="pysrc-string">'Monty Python'</span>, 3)
<span class="pysrc-output">'Monty Python Monty Python Monty Python'</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>A Python function is not required to have a return statement.
Some functions do their work as a side effect, printing a result,
modifying a file, or updating the contents of a parameter to the function
(such functions are called &quot;procedures&quot; in some other programming languages).</p>
<!-- XXX these examples would be easier for a novice to grasp if they knew more about -->
<!-- how functions are used in context. For example, they need to first know that you might -->
<!-- want to write ``foo = my_sort2(l)`` or have a function that only produces -->
<!-- side-effects before they see the significance of these. -->
<p>Consider the following three sort functions.
The third one is dangerous because a programmer could
use it without realizing that it had modified its input.
In general, functions should modify the contents of a parameter
(<tt class="doctest"><span class="pre">my_sort1()</span></tt>), or return a value (<tt class="doctest"><span class="pre">my_sort2()</span></tt>),
not both (<tt class="doctest"><span class="pre">my_sort3()</span></tt>).</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">def</span> <span class="pysrc-defname">my_sort1</span>(mylist):      <span class="pysrc-comment"># good: modifies its argument, no return value</span>
<span class="pysrc-more">... </span>    mylist.sort()
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">def</span> <span class="pysrc-defname">my_sort2</span>(mylist):      <span class="pysrc-comment"># good: doesn't touch its argument, returns value</span>
<span class="pysrc-more">... </span>    return sorted(mylist)
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">def</span> <span class="pysrc-defname">my_sort3</span>(mylist):      <span class="pysrc-comment"># bad: modifies its argument and also returns it</span>
<span class="pysrc-more">... </span>    mylist.sort()
<span class="pysrc-more">... </span>    return mylist</pre>
</td>
</tr></table></td></tr>
</table></div>
</div>
<div class="section" id="parameter-passing">
<h3>Parameter Passing</h3>
<p>Back in <a href="#id3"><span class="problematic" id="id4">sec-back-to-the-basics_</span></a> you saw that assignment works on values,
but that the value of a structured object is a <span class="emphasis">reference</span> to that object.  The same
is true for functions.  Python interprets function parameters as values (this is
known as <a name="call_by_value_index_term" /><span class="termdef">call-by-value</span>).  In the following code, <tt class="doctest"><span class="pre">set_up()</span></tt> has two parameters,
both of which are modified inside the function.  We begin by assigning an empty string
to <tt class="doctest"><span class="pre">w</span></tt> and an empty list to <tt class="doctest"><span class="pre">p</span></tt>.  After calling the function, <tt class="doctest"><span class="pre">w</span></tt> is unchanged,
while <tt class="doctest"><span class="pre">p</span></tt> is changed:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">def</span> <span class="pysrc-defname">set_up</span>(word, properties):
<span class="pysrc-more">... </span>    word = <span class="pysrc-string">'lolcat'</span>
<span class="pysrc-more">... </span>    properties.append(<span class="pysrc-string">'noun'</span>)
<span class="pysrc-more">... </span>    properties = 5
<span class="pysrc-more">...</span>
<span class="pysrc-prompt">&gt;&gt;&gt; </span>w = <span class="pysrc-string">''</span>
<span class="pysrc-prompt">&gt;&gt;&gt; </span>p = []
<span class="pysrc-prompt">&gt;&gt;&gt; </span>set_up(w, p)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>w
<span class="pysrc-output">''</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>p
<span class="pysrc-output">['noun']</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Notice that <tt class="doctest"><span class="pre">w</span></tt> was not changed by the function.
When we called <tt class="doctest"><span class="pre">set_up(w, p)</span></tt>, the value of <tt class="doctest"><span class="pre">w</span></tt> (an empty string) was assigned to
a new variable <tt class="doctest"><span class="pre">word</span></tt>.  Inside the function, the value of <tt class="doctest"><span class="pre">word</span></tt> was modified.
However, that change did not propagate to <tt class="doctest"><span class="pre">w</span></tt>.  This parameter passing is
identical to the following sequence of assignments:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>w = <span class="pysrc-string">''</span>
<span class="pysrc-prompt">&gt;&gt;&gt; </span>word = w
<span class="pysrc-prompt">&gt;&gt;&gt; </span>word = <span class="pysrc-string">'lolcat'</span>
<span class="pysrc-prompt">&gt;&gt;&gt; </span>w
<span class="pysrc-output">''</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Let's look at what happened with the list <tt class="doctest"><span class="pre">p</span></tt>.
When we called <tt class="doctest"><span class="pre">set_up(w, p)</span></tt>, the value of <tt class="doctest"><span class="pre">p</span></tt> (a reference to an empty
list) was assigned to a new local variable <tt class="doctest"><span class="pre">properties</span></tt>,
so both variables now reference the same memory location.
The function modifies <tt class="doctest"><span class="pre">properties</span></tt>, and this change is also
reflected in the value of <tt class="doctest"><span class="pre">p</span></tt> as we saw.  The function also
assigned a new value to properties (the number <tt class="doctest"><span class="pre">5</span></tt>); this
did not modify the contents at that memory location, but
created a new local variable.
This behavior is just as if we had done the following sequence of assignments:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>p = []
<span class="pysrc-prompt">&gt;&gt;&gt; </span>properties = p
<span class="pysrc-prompt">&gt;&gt;&gt; </span>properties.append(<span class="pysrc-string">'noun'</span>)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>properties = 5
<span class="pysrc-prompt">&gt;&gt;&gt; </span>p
<span class="pysrc-output">['noun']</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Thus, to understand Python's call-by-value parameter passing,
it is enough to understand how assignment works.  Remember that you
can use the <tt class="doctest"><span class="pre">id()</span></tt> function and <tt class="doctest"><span class="pre"><span class="pysrc-keyword">is</span></span></tt> operator to check your
understanding of object identity after each statement.</p>
</div>
<div class="section" id="variable-scope">
<h3>Variable Scope</h3>
<p>Function definitions create a new, local <a name="scope_index_term" /><span class="termdef">scope</span> for variables.
When you assign to a new variable inside the body of a function,
the name is only defined within that function.  The name is not
visible outside the function, or in other functions.  This behavior
means you can choose variable names without being concerned about
collisions with names used in your other function definitions.</p>
<p>When you refer to an existing name from within the body
of a function, the Python interpreter first tries to resolve
the name with respect to the names that are local to the function.
If nothing is found, the interpreter checks if it is a global
name within the module.  Finally, if that does not succeed, the
interpreter checks if the name is a Python built-in.  This is
the so-called <a name="lgb_rule_index_term" /><span class="termdef">LGB rule</span> of name resolution: local,
then global, then built-in.</p>
<div class="caution">
<p class="first admonition-title">Caution!</p>
<p class="last">A function can enable access to a global variable using the
<tt class="doctest"><span class="pre"><span class="pysrc-keyword">global</span></span></tt> declaration.  However, this practice should be
avoided as much as possible.  Defining global variables
inside a function introduces dependencies on context
and limits the portability (or reusability) of the function.
In general you should use parameters for function inputs
and return values for function outputs.</p>
</div>
</div>
<div class="section" id="checking-parameter-types">
<h3>Checking Parameter Types</h3>
<p>Python does not allow us to declare the type of a variable when we write a program,
and this permits us to define functions that are flexible
about the type of their arguments.  For example, a tagger might expect
a sequence of words, but it wouldn't care whether this sequence is expressed
as a list or a tuple (or an iterator, another sequence type that is
outside the scope of the current discussion).</p>
<p>However, often we want to write programs for later use by others, and want
to program in a defensive style, providing useful warnings when functions
have not been invoked correctly.  The author of the following <tt class="doctest"><span class="pre">tag()</span></tt>
function assumed that its argument would always be a string.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">def</span> <span class="pysrc-defname">tag</span>(word):
<span class="pysrc-more">... </span>    <span class="pysrc-keyword">if</span> word <span class="pysrc-keyword">in</span> [<span class="pysrc-string">'a'</span>, <span class="pysrc-string">'the'</span>, <span class="pysrc-string">'all'</span>]:
<span class="pysrc-more">... </span>        return <span class="pysrc-string">'det'</span>
<span class="pysrc-more">... </span>    <span class="pysrc-keyword">else</span>:
<span class="pysrc-more">... </span>        return <span class="pysrc-string">'noun'</span>
<span class="pysrc-more">...</span>
<span class="pysrc-prompt">&gt;&gt;&gt; </span>tag(<span class="pysrc-string">'the'</span>)
<span class="pysrc-output">'det'</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>tag(<span class="pysrc-string">'knight'</span>)
<span class="pysrc-output">'noun'</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>tag([<span class="pysrc-string">&quot;'Tis&quot;</span>, <span class="pysrc-string">'but'</span>, <span class="pysrc-string">'a'</span>, <span class="pysrc-string">'scratch'</span>]) <a name="list-arg" /><a href="#ref-list-arg"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></a>
<span class="pysrc-output">'noun'</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>The function returns sensible values for the arguments <tt class="doctest"><span class="pre"><span class="pysrc-string">'the'</span></span></tt> and <tt class="doctest"><span class="pre"><span class="pysrc-string">'knight'</span></span></tt>,
but look what happens when it is passed a list <a class="reference internal" href="#list-arg"><span id="ref-list-arg"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></span></a> &#8212; it fails to
complain, even though the result which it returns is clearly incorrect.
The author of this function could take some extra steps to
ensure that the <tt class="doctest"><span class="pre">word</span></tt> parameter of the <tt class="doctest"><span class="pre">tag()</span></tt> function is a string.
A naive approach would be to check the type of the argument using
<tt class="doctest"><span class="pre"><span class="pysrc-keyword">if</span> <span class="pysrc-keyword">not</span> type(word) <span class="pysrc-keyword">is</span> str</span></tt>, and if <tt class="doctest"><span class="pre">word</span></tt> is not a string, to simply
return Python's special empty value, <tt class="doctest"><span class="pre">None</span></tt>. This is a slight improvement, because
the function is checking the type of the argument, and trying to return a &quot;special&quot;, diagnostic
value for the wrong input.
However, it is also dangerous because the calling program
may not detect that <tt class="doctest"><span class="pre">None</span></tt> is intended as a &quot;special&quot; value, and this diagnostic
return value may then be
propagated to other parts of the program with unpredictable consequences.
This approach also fails if the word is a Unicode string, which has
type <tt class="doctest"><span class="pre">unicode</span></tt>, not <tt class="doctest"><span class="pre">str</span></tt>.
Here's a better solution, using an <tt class="doctest"><span class="pre">assert</span></tt> statement together with Python's <tt class="doctest"><span class="pre">basestring</span></tt>
type that generalizes over both <tt class="doctest"><span class="pre">unicode</span></tt> and <tt class="doctest"><span class="pre">str</span></tt>.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">def</span> <span class="pysrc-defname">tag</span>(word):
<span class="pysrc-more">... </span>    assert isinstance(word, basestring), <span class="pysrc-string">&quot;argument to tag() must be a string&quot;</span>
<span class="pysrc-more">... </span>    <span class="pysrc-keyword">if</span> word <span class="pysrc-keyword">in</span> [<span class="pysrc-string">'a'</span>, <span class="pysrc-string">'the'</span>, <span class="pysrc-string">'all'</span>]:
<span class="pysrc-more">... </span>        return <span class="pysrc-string">'det'</span>
<span class="pysrc-more">... </span>    <span class="pysrc-keyword">else</span>:
<span class="pysrc-more">... </span>        return <span class="pysrc-string">'noun'</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>If the <tt class="doctest"><span class="pre">assert</span></tt> statement fails, it will produce an error that cannot be ignored,
since it halts program execution.
Additionally, the error message is easy to interpret.  Adding assertions to
a program helps you find logical errors, and is a kind of <a name="defensive_programming_index_term" /><span class="termdef">defensive programming</span>.
A more fundamental approach is to document the parameters to each function
using docstrings as described later in this section.</p>
<!-- XXX should we mention try / except here? -->
</div>
<div class="section" id="functional-decomposition">
<h3>Functional Decomposition</h3>
<p>Well-structured programs usually make extensive use of functions.
When a block of program code grows longer than 10-20 lines, it is a
great help to readability if the code is broken up into one or more
functions, each one having a clear purpose.  This is analogous to
the way a good essay is divided into paragraphs, each expressing one main idea.</p>
<!-- XXX not clear here whether you are really talking about actions (in which case -->
<!-- :lx: role is maybe inappropriate / misleading) or about lexical semantics. -->
<!-- XXX the following code snippet could well occur earlier, e.g in section where you -->
<!-- talk about function inputs and outputs, so as to motivate different kinds of -->
<!-- return values, and then perhaps repeated here. -->
<p>Functions provide an important kind of abstraction.
They allow us to group multiple actions into a single, complex action,
and associate a name with it.
(Compare this with the way we combine the actions of
<span class="example">go</span> and <span class="example">bring back</span> into a single more complex action <span class="example">fetch</span>.)
When we use functions, the main program can be written at a higher level
of abstraction, making its structure transparent, e.g.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>data = load_corpus()
<span class="pysrc-prompt">&gt;&gt;&gt; </span>results = analyze(data)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>present(results)</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Appropriate use of functions makes programs more readable and maintainable.
Additionally, it becomes possible to reimplement a function
&#8212; replacing the function's body with more efficient code &#8212;
without having to be concerned with the rest of the program.</p>
<p>Consider the <tt class="doctest"><span class="pre">freq_words</span></tt> function in <a class="reference internal" href="#code-freq-words1">13.3</a>.
It updates the contents of a frequency distribution that is
passed in as a parameter, and it also prints a list of the
<span class="math">n</span> most frequent words.</p>
<span class="target" id="code-freq-words1"></span><div class="pylisting">
<table border="0" cellpadding="0" cellspacing="0" class="pylisting" width="95%">
<tr><td class="codeblock">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_codeblock_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-keyword">from</span> urllib <span class="pysrc-keyword">import</span> request
<span class="pysrc-keyword">from</span> bs4 <span class="pysrc-keyword">import</span> BeautifulSoup

<span class="pysrc-keyword">def</span> <span class="pysrc-defname">freq_words</span>(url, freqdist, n):
    html = request.urlopen(url).read().decode(<span class="pysrc-string">'utf8'</span>)
    raw = BeautifulSoup(html).get_text()
    <span class="pysrc-keyword">for</span> word <span class="pysrc-keyword">in</span> word_tokenize(raw):
        freqdist[word.lower()] += 1
    result = []
    <span class="pysrc-keyword">for</span> word, count <span class="pysrc-keyword">in</span> freqdist.most_common(n):
        result = result + [word]
    <span class="pysrc-keyword">print</span>(result)</pre>
</td>
</tr></table></td></tr>
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>constitution = <span class="pysrc-string">&quot;http://www.archives.gov/exhibits/charters/constitution_transcript.html&quot;</span>
<span class="pysrc-prompt">&gt;&gt;&gt; </span>fd = nltk.FreqDist()
<span class="pysrc-prompt">&gt;&gt;&gt; </span>freq_words(constitution, fd, 30)
<span class="pysrc-output">['the', ',', 'of', 'and', 'shall', '.', 'be', 'to', ';', 'in', 'states',</span>
<span class="pysrc-output">'or', 'united', 'a', 'state', 'by', 'for', 'any', '=', 'which', 'president',</span>
<span class="pysrc-output">'all', 'on', 'may', 'such', 'as', 'have', ')', '(', 'congress']</span></pre>
</td>
</tr></table></td></tr>
<tr><td class="caption"><p class="caption"><a class="reference external" href="pylisting/code_freq_words1.py" type="text/x-python"><span class="caption-label">Example 13.3 (code_freq_words1.py)</span></a>: <span class="caption-label">Figure 13.3</span>: Poorly Designed Function to Compute Frequent Words</td></tr></p>
</table></div>
<p>This function has a number of problems.
The function has two side-effects: it modifies the contents of its second
parameter, and it prints a selection of the results it has computed.
The function would be easier to understand and to reuse elsewhere if we
initialize the <tt class="doctest"><span class="pre">FreqDist()</span></tt> object inside the function (in the same place
it is populated), and if we moved the selection and display of results to the
calling program. Given that its task is to identify frequent words, it
should probably just return a list, not the whole frequency distribution.
In <a class="reference internal" href="#code-freq-words2">13.4</a> we <a name="refactor_index_term" /><span class="termdef">refactor</span> this function,
and simplify its interface by dropping the <tt class="doctest"><span class="pre">freqdist</span></tt> parameter.</p>
<span class="target" id="code-freq-words2"></span><div class="pylisting">
<table border="0" cellpadding="0" cellspacing="0" class="pylisting" width="95%">
<tr><td class="codeblock">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_codeblock_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-keyword">from</span> urllib <span class="pysrc-keyword">import</span> request
<span class="pysrc-keyword">from</span> bs4 <span class="pysrc-keyword">import</span> BeautifulSoup

<span class="pysrc-keyword">def</span> <span class="pysrc-defname">freq_words</span>(url, n):
    html = request.urlopen(url).read().decode(<span class="pysrc-string">'utf8'</span>)
    text = BeautifulSoup(html).get_text()
    freqdist = nltk.FreqDist(word.lower() <span class="pysrc-keyword">for</span> word <span class="pysrc-keyword">in</span> word_tokenize(text))
    return [word <span class="pysrc-keyword">for</span> (word, _) <span class="pysrc-keyword">in</span> fd.most_common(n)]</pre>
</td>
</tr></table></td></tr>
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>freq_words(constitution, 30)
<span class="pysrc-output">['the', ',', 'of', 'and', 'shall', '.', 'be', 'to', ';', 'in', 'states',</span>
<span class="pysrc-output">'or', 'united', 'a', 'state', 'by', 'for', 'any', '=', 'which', 'president',</span>
<span class="pysrc-output">'all', 'on', 'may', 'such', 'as', 'have', ')', '(', 'congress']</span></pre>
</td>
</tr></table></td></tr>
<tr><td class="caption"><p class="caption"><a class="reference external" href="pylisting/code_freq_words2.py" type="text/x-python"><span class="caption-label">Example 13.4 (code_freq_words2.py)</span></a>: <span class="caption-label">Figure 13.4</span>: Well-Designed Function to Compute Frequent Words</td></tr></p>
</table></div>
<p>The readability and usability of the <tt class="doctest"><span class="pre">freq_words</span></tt> function is improved.</p>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last">We have used <tt class="doctest"><span class="pre">_</span></tt> as a variable name. This is no different to any other
variable except it signals to the reader that we don't have a use
for the information it holds.</p>
</div>
</div>
<div class="section" id="documenting-functions">
<h3>Documenting Functions</h3>
<p>If we have done a good job at decomposing our program into functions, then it should
be easy to describe the purpose of each function in plain language, and provide
this in the docstring at the top of the function definition.  This statement
should not explain how the functionality is implemented; in fact it should be possible
to re-implement the function using a different method without changing this
statement.</p>
<p>For the simplest functions, a one-line docstring is usually adequate (see <a class="reference internal" href="#code-get-text">13.2</a>).
You should provide a triple-quoted string containing a complete sentence on a single line.
For non-trivial functions, you should still provide a one sentence summary on the first line,
since many docstring processing tools index this string.  This should be followed by
a blank line, then a more detailed description of the functionality
(see <tt class="doctest"><span class="pre">http://www.python.org/dev/peps/pep-0257/</span></tt> for more information in docstring
conventions).</p>
<!-- XXX it would be really nice to have a screen dump of the HTML output. -->
<p>Docstrings can include a <a name="doctest_block_index_term" /><span class="termdef">doctest block</span>, illustrating the use of
the function and the expected output.  These can be tested automatically
using Python's <tt class="doctest"><span class="pre">docutils</span></tt> module.
Docstrings should document the type of each parameter to the function, and the return
type.  At a minimum, that can be done in plain text.  However, note that NLTK uses
the Sphinx markup language to document parameters.  This format
can be automatically converted into richly structured
API documentation (see <tt class="doctest"><span class="pre">http://nltk.org/</span></tt>), and includes special handling of certain
&quot;fields&quot; such as <tt class="doctest"><span class="pre">param</span></tt> which allow the inputs and outputs of functions to be
clearly documented.  <a class="reference internal" href="#code-sphinx">13.5</a> illustrates
a complete docstring.</p>
<span class="target" id="code-sphinx"></span><div class="pylisting">
<table border="0" cellpadding="0" cellspacing="0" class="pylisting" width="95%">
<tr><td class="codeblock">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_codeblock_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-keyword">def</span> <span class="pysrc-defname">accuracy</span>(reference, test):
    <span class="pysrc-string">&quot;&quot;&quot;</span>
<span class="pysrc-string">    Calculate the fraction of test items that equal the corresponding reference items.</span>

<span class="pysrc-string">    Given a list of reference values and a corresponding list of test values,</span>
<span class="pysrc-string">    return the fraction of corresponding values that are equal.</span>
<span class="pysrc-string">    In particular, return the fraction of indexes</span>
<span class="pysrc-string">    {0&lt;i&lt;=len(test)} such that C{test[i] == reference[i]}.</span>

<span class="pysrc-string">        &gt;&gt;&gt; accuracy(['ADJ', 'N', 'V', 'N'], ['N', 'N', 'V', 'ADJ'])</span>
<span class="pysrc-string">        0.5</span>

<span class="pysrc-string">    :param reference: An ordered list of reference values</span>
<span class="pysrc-string">    :type reference: list</span>
<span class="pysrc-string">    :param test: A list of values to compare against the corresponding</span>
<span class="pysrc-string">        reference values</span>
<span class="pysrc-string">    :type test: list</span>
<span class="pysrc-string">    :return: the accuracy score</span>
<span class="pysrc-string">    :rtype: float</span>
<span class="pysrc-string">    :raises ValueError: If reference and length do not have the same length</span>
<span class="pysrc-string">    &quot;&quot;&quot;</span>

    <span class="pysrc-keyword">if</span> len(reference) != len(test):
        raise ValueError(<span class="pysrc-string">&quot;Lists must have the same length.&quot;</span>)
    num_correct = 0
    <span class="pysrc-keyword">for</span> x, y <span class="pysrc-keyword">in</span> zip(reference, test):
        <span class="pysrc-keyword">if</span> x == y:
            num_correct += 1
    return float(num_correct) / len(reference)</pre>
</td>
</tr></table></td></tr>
<tr><td class="caption"><p class="caption"><a class="reference external" href="pylisting/code_sphinx.py" type="text/x-python"><span class="caption-label">Example 13.5 (code_sphinx.py)</span></a>: <span class="caption-label">Figure 13.5</span>: Illustration of a complete docstring, consisting of a one-line summary,
a more detailed explanation, a doctest example, and Sphinx markup
specifying the parameters, types, return type, and exceptions.</td></tr></p>
</table></div>
</div>
</div>
<div class="section" id="doing-more-with-functions">
<span id="sec-doing-more-with-functions"></span><h2>13.9&nbsp;&nbsp;&nbsp;Doing More with Functions</h2>
<p>This section discusses more advanced features, which you may prefer to skip on the
first time through this chapter.</p>
<div class="section" id="functions-as-arguments">
<h3>Functions as Arguments</h3>
<p>So far the arguments we have passed into functions have been simple objects like
strings, or structured objects like lists.  Python also lets us pass a function as
an argument to another function.  Now we can abstract out the operation, and apply
a <span class="emphasis">different operation</span> on the <span class="emphasis">same data</span>.  As the following examples show,
we can pass the built-in function <tt class="doctest"><span class="pre">len()</span></tt> or a user-defined function <tt class="doctest"><span class="pre">last_letter()</span></tt>
as arguments to another function:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>sent = [<span class="pysrc-string">'Take'</span>, <span class="pysrc-string">'care'</span>, <span class="pysrc-string">'of'</span>, <span class="pysrc-string">'the'</span>, <span class="pysrc-string">'sense'</span>, <span class="pysrc-string">','</span>, <span class="pysrc-string">'and'</span>, <span class="pysrc-string">'the'</span>,
<span class="pysrc-more">... </span>        <span class="pysrc-string">'sounds'</span>, <span class="pysrc-string">'will'</span>, <span class="pysrc-string">'take'</span>, <span class="pysrc-string">'care'</span>, <span class="pysrc-string">'of'</span>, <span class="pysrc-string">'themselves'</span>, <span class="pysrc-string">'.'</span>]
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">def</span> <span class="pysrc-defname">extract_property</span>(prop):
<span class="pysrc-more">... </span>    return [prop(word) <span class="pysrc-keyword">for</span> word <span class="pysrc-keyword">in</span> sent]
<span class="pysrc-more">...</span>
<span class="pysrc-prompt">&gt;&gt;&gt; </span>extract_property(len)
<span class="pysrc-output">[4, 4, 2, 3, 5, 1, 3, 3, 6, 4, 4, 4, 2, 10, 1]</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">def</span> <span class="pysrc-defname">last_letter</span>(word):
<span class="pysrc-more">... </span>    return word[-1]
<span class="pysrc-prompt">&gt;&gt;&gt; </span>extract_property(last_letter)
<span class="pysrc-output">['e', 'e', 'f', 'e', 'e', ',', 'd', 'e', 's', 'l', 'e', 'e', 'f', 's', '.']</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>The objects <tt class="doctest"><span class="pre">len</span></tt> and <tt class="doctest"><span class="pre">last_letter</span></tt> can be
passed around like lists and dictionaries.  Notice that parentheses
are only used after a function name if we are invoking the function;
when we are simply treating the function as an object these are omitted.</p>
<p>Python provides us with one more way to define functions as arguments
to other functions, so-called <a name="lambda_expressions_index_term" /><span class="termdef">lambda expressions</span>.  Supposing there
was no need to use the above <tt class="doctest"><span class="pre">last_letter()</span></tt> function in multiple places,
and thus no need to give it a name.  We can equivalently write the following:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>extract_property(<span class="pysrc-keyword">lambda</span> w: w[-1])
<span class="pysrc-output">['e', 'e', 'f', 'e', 'e', ',', 'd', 'e', 's', 'l', 'e', 'e', 'f', 's', '.']</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Our next example illustrates passing a function to the <tt class="doctest"><span class="pre">sorted()</span></tt> function.
When we call the latter with a single argument (the list to be sorted),
it compares the elements directly.
However, we can specify an operation to be performed on the item
before the comparison takes place, and we can specify whether sorting
should be based on increasing or decreasing values.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>sorted(sent)
<span class="pysrc-output">[',', '.', 'Take', 'and', 'care', 'care', 'of', 'of', 'sense', 'sounds',</span>
<span class="pysrc-output">'take', 'the', 'the', 'themselves', 'will']</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>sorted(sent, str.lower)
<span class="pysrc-output">[',', '.', 'and', 'care', 'care', 'of', 'of', 'sense', 'sounds', 'Take',</span>
<span class="pysrc-output">'take', 'the', 'the', 'themselves', 'will']</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>sorted(sent, len, reverse=True)
<span class="pysrc-output">['themselves', 'sounds', 'sense', 'Take', 'care', 'will', 'take', 'care',</span>
<span class="pysrc-output">'the', 'and', 'the', 'of', 'of', ',', '.']</span></pre>
</td>
</tr></table></td></tr>
</table></div>
</div>
<div class="section" id="accumulative-functions">
<h3>Accumulative Functions</h3>
<p>These functions start by initializing some storage, and iterate over
input to build it up, before returning some final object (a large structure
or aggregated result).  A standard way to do this is to initialize an
empty list, accumulate the material, then return the list, as shown
in function <tt class="doctest"><span class="pre">search1()</span></tt> in <a class="reference internal" href="#code-search-examples">13.6</a>.</p>
<span class="target" id="code-search-examples"></span><div class="pylisting">
<table border="0" cellpadding="0" cellspacing="0" class="pylisting" width="95%">
<tr><td class="codeblock">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_codeblock_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-keyword">def</span> <span class="pysrc-defname">search1</span>(substring, words):
    result = []
    <span class="pysrc-keyword">for</span> word <span class="pysrc-keyword">in</span> words:
        <span class="pysrc-keyword">if</span> substring <span class="pysrc-keyword">in</span> word:
            result.append(word)
    return result

<span class="pysrc-keyword">def</span> <span class="pysrc-defname">search2</span>(substring, words):
    <span class="pysrc-keyword">for</span> word <span class="pysrc-keyword">in</span> words:
        <span class="pysrc-keyword">if</span> substring <span class="pysrc-keyword">in</span> word:
            yield word</pre>
</td>
</tr></table></td></tr>
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">for</span> item <span class="pysrc-keyword">in</span> search1(<span class="pysrc-string">'zz'</span>, nltk.corpus.brown.words()):
<span class="pysrc-more">... </span>    <span class="pysrc-keyword">print</span>(item, end=<span class="pysrc-string">&quot; &quot;</span>)
<span class="pysrc-output">Grizzlies' fizzled Rizzuto huzzahs dazzler jazz Pezza ...</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">for</span> item <span class="pysrc-keyword">in</span> search2(<span class="pysrc-string">'zz'</span>, nltk.corpus.brown.words()):
<span class="pysrc-more">... </span>    <span class="pysrc-keyword">print</span>(item, end=<span class="pysrc-string">&quot; &quot;</span>)
<span class="pysrc-output">Grizzlies' fizzled Rizzuto huzzahs dazzler jazz Pezza ...</span></pre>
</td>
</tr></table></td></tr>
<tr><td class="caption"><p class="caption"><a class="reference external" href="pylisting/code_search_examples.py" type="text/x-python"><span class="caption-label">Example 13.6 (code_search_examples.py)</span></a>: <span class="caption-label">Figure 13.6</span>: Accumulating Output into a List</td></tr></p>
</table></div>
<p>The function <tt class="doctest"><span class="pre">search2()</span></tt> is a generator.
The first time this function is called, it gets as far as the <tt class="doctest"><span class="pre">yield</span></tt>
statement and pauses.  The calling program gets the first word and does
any necessary processing.  Once the calling program is ready for another
word, execution of the function is continued from where it stopped, until
the next time it encounters a <tt class="doctest"><span class="pre">yield</span></tt> statement.  This approach is
typically more efficient, as the function only generates the data as it is
required by the calling program, and does not need to allocate additional
memory to store the output (cf. our discussion of generator expressions above).</p>
<p>Here's a more sophisticated example of a generator which produces
all permutations of a list of words.  In order to force the <tt class="doctest"><span class="pre">permutations()</span></tt>
function to generate all its output, we wrap it with a call to <tt class="doctest"><span class="pre">list()</span></tt> <a class="reference internal" href="#listperm"><span id="ref-listperm"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></span></a>.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">def</span> <span class="pysrc-defname">permutations</span>(seq):
<span class="pysrc-more">... </span>    <span class="pysrc-keyword">if</span> len(seq) &lt;= 1:
<span class="pysrc-more">... </span>        yield seq
<span class="pysrc-more">... </span>    <span class="pysrc-keyword">else</span>:
<span class="pysrc-more">... </span>        <span class="pysrc-keyword">for</span> perm <span class="pysrc-keyword">in</span> permutations(seq[1:]):
<span class="pysrc-more">... </span>            <span class="pysrc-keyword">for</span> i <span class="pysrc-keyword">in</span> range(len(perm)+1):
<span class="pysrc-more">... </span>                yield perm[:i] + seq[0:1] + perm[i:]
<span class="pysrc-more">...</span>
<span class="pysrc-prompt">&gt;&gt;&gt; </span>list(permutations([<span class="pysrc-string">'police'</span>, <span class="pysrc-string">'fish'</span>, <span class="pysrc-string">'buffalo'</span>])) <a name="listperm" /><a href="#ref-listperm"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></a>
<span class="pysrc-output">[['police', 'fish', 'buffalo'], ['fish', 'police', 'buffalo'],</span>
<span class="pysrc-output"> ['fish', 'buffalo', 'police'], ['police', 'buffalo', 'fish'],</span>
<span class="pysrc-output"> ['buffalo', 'police', 'fish'], ['buffalo', 'fish', 'police']]</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last">The <tt class="doctest"><span class="pre">permutations</span></tt> function uses a technique called recursion,
discussed below in <a href="#id5"><span class="problematic" id="id6">sec-algorithm-design_</span></a>.
The ability to generate permutations of a set of words is
useful for creating data to test a grammar (<a class="reference external" href="ch08.html#chap-parse">8.</a>).</p>
</div>
</div>
<div class="section" id="higher-order-functions">
<h3>Higher-Order Functions</h3>
<p>Python provides some higher-order functions that are standard
features of functional programming languages such as Haskell.
We illustrate them here, alongside the equivalent expression
using list comprehensions.</p>
<p>Let's start by defining a function <tt class="doctest"><span class="pre">is_content_word()</span></tt>
which checks whether a word is from the open class of content words.
We use this function as the first parameter of <tt class="doctest"><span class="pre">filter()</span></tt>,
which applies the function to each item in the sequence contained
in its second parameter, and only retains the items for which
the function returns <tt class="doctest"><span class="pre">True</span></tt>.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">def</span> <span class="pysrc-defname">is_content_word</span>(word):
<span class="pysrc-more">... </span>    return word.lower() <span class="pysrc-keyword">not</span> <span class="pysrc-keyword">in</span> [<span class="pysrc-string">'a'</span>, <span class="pysrc-string">'of'</span>, <span class="pysrc-string">'the'</span>, <span class="pysrc-string">'and'</span>, <span class="pysrc-string">'will'</span>, <span class="pysrc-string">','</span>, <span class="pysrc-string">'.'</span>]
<span class="pysrc-prompt">&gt;&gt;&gt; </span>sent = [<span class="pysrc-string">'Take'</span>, <span class="pysrc-string">'care'</span>, <span class="pysrc-string">'of'</span>, <span class="pysrc-string">'the'</span>, <span class="pysrc-string">'sense'</span>, <span class="pysrc-string">','</span>, <span class="pysrc-string">'and'</span>, <span class="pysrc-string">'the'</span>,
<span class="pysrc-more">... </span>        <span class="pysrc-string">'sounds'</span>, <span class="pysrc-string">'will'</span>, <span class="pysrc-string">'take'</span>, <span class="pysrc-string">'care'</span>, <span class="pysrc-string">'of'</span>, <span class="pysrc-string">'themselves'</span>, <span class="pysrc-string">'.'</span>]
<span class="pysrc-prompt">&gt;&gt;&gt; </span>list(filter(is_content_word, sent))
<span class="pysrc-output">['Take', 'care', 'sense', 'sounds', 'take', 'care', 'themselves']</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>[w <span class="pysrc-keyword">for</span> w <span class="pysrc-keyword">in</span> sent <span class="pysrc-keyword">if</span> is_content_word(w)]
<span class="pysrc-output">['Take', 'care', 'sense', 'sounds', 'take', 'care', 'themselves']</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Another higher-order function is <tt class="doctest"><span class="pre">map()</span></tt>, which applies a function
to every item in a sequence.  It is a general version of the
<tt class="doctest"><span class="pre">extract_property()</span></tt> function we saw in <a class="reference internal" href="#sec-doing-more-with-functions">13.9</a>.
Here is a simple way to find the average length of a sentence in the news
section of the Brown Corpus, followed by an equivalent version with list comprehension
calculation:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>lengths = list(map(len, nltk.corpus.brown.sents(categories=<span class="pysrc-string">'news'</span>)))
<span class="pysrc-prompt">&gt;&gt;&gt; </span>sum(lengths) / len(lengths)
<span class="pysrc-output">21.75081116158339</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>lengths = [len(sent) <span class="pysrc-keyword">for</span> sent <span class="pysrc-keyword">in</span> nltk.corpus.brown.sents(categories=<span class="pysrc-string">'news'</span>)]
<span class="pysrc-prompt">&gt;&gt;&gt; </span>sum(lengths) / len(lengths)
<span class="pysrc-output">21.75081116158339</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>In the above examples we specified a user-defined function <tt class="doctest"><span class="pre">is_content_word()</span></tt>
and a built-in function <tt class="doctest"><span class="pre">len()</span></tt>.  We can also provide a lambda expression.
Here's a pair of equivalent examples which count the number of vowels in each word.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>list(map(<span class="pysrc-keyword">lambda</span> w: len(filter(<span class="pysrc-keyword">lambda</span> c: c.lower() <span class="pysrc-keyword">in</span> <span class="pysrc-string">&quot;aeiou&quot;</span>, w)), sent))
<span class="pysrc-output">[2, 2, 1, 1, 2, 0, 1, 1, 2, 1, 2, 2, 1, 3, 0]</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>[len(c <span class="pysrc-keyword">for</span> c <span class="pysrc-keyword">in</span> w <span class="pysrc-keyword">if</span> c.lower() <span class="pysrc-keyword">in</span> <span class="pysrc-string">&quot;aeiou&quot;</span>) <span class="pysrc-keyword">for</span> w <span class="pysrc-keyword">in</span> sent]
<span class="pysrc-output">[2, 2, 1, 1, 2, 0, 1, 1, 2, 1, 2, 2, 1, 3, 0]</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>The solutions based on list comprehensions are usually more readable than the
solutions based on higher-order functions, and we have favored the former
approach throughout this book.</p>
</div>
<div class="section" id="named-arguments">
<h3>Named Arguments</h3>
<p>When there are a lot of parameters it is easy to get confused about the
correct order.  Instead we can refer to parameters by name, and even assign
them a default value just in case one was not provided by the calling
program.  Now the parameters can be specified in any order, and can be omitted.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">def</span> <span class="pysrc-defname">repeat</span>(msg=<span class="pysrc-string">'&lt;empty&gt;'</span>, num=1):
<span class="pysrc-more">... </span>    return msg * num
<span class="pysrc-prompt">&gt;&gt;&gt; </span>repeat(num=3)
<span class="pysrc-output">'&lt;empty&gt;&lt;empty&gt;&lt;empty&gt;'</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>repeat(msg=<span class="pysrc-string">'Alice'</span>)
<span class="pysrc-output">'Alice'</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>repeat(num=5, msg=<span class="pysrc-string">'Alice'</span>)
<span class="pysrc-output">'AliceAliceAliceAliceAlice'</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<!-- XXX this is going to be confusing for the novice. I suggest omitting the kwargs** -->
<!-- parameter for simplicity, and referring the reader to the Python Tutorial. -->
<p>These are called <a name="keyword_arguments_index_term" /><span class="termdef">keyword arguments</span>.
If we mix these two kinds of parameters, then we must ensure that the unnamed parameters precede the named ones.
It has to be this way, since unnamed parameters are defined by position.  We can define a function that takes
an arbitrary number of unnamed and named parameters, and access them via an in-place list of arguments <tt class="doctest"><span class="pre">*args</span></tt> and
an &quot;in-place dictionary&quot; of keyword arguments <tt class="doctest"><span class="pre">**kwargs</span></tt>.
(Dictionaries will be presented in <a class="reference internal" href="#sec-dictionaries">13.11</a>.)</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">def</span> <span class="pysrc-defname">generic</span>(*args, **kwargs):
<span class="pysrc-more">... </span>    <span class="pysrc-keyword">print</span>(args)
<span class="pysrc-more">... </span>    <span class="pysrc-keyword">print</span>(kwargs)
<span class="pysrc-more">...</span>
<span class="pysrc-prompt">&gt;&gt;&gt; </span>generic(1, <span class="pysrc-string">&quot;African swallow&quot;</span>, monty=<span class="pysrc-string">&quot;python&quot;</span>)
<span class="pysrc-output">(1, 'African swallow')</span>
<span class="pysrc-output">{'monty': 'python'}</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>When <tt class="doctest"><span class="pre">*args</span></tt> appears as a function parameter, it actually corresponds to all the unnamed parameters of
the function.  Here's another illustration of this aspect of Python syntax, for the <tt class="doctest"><span class="pre">zip()</span></tt> function which
operates on a variable number of arguments.  We'll use the variable name <tt class="doctest"><span class="pre">*song</span></tt> to demonstrate that
there's nothing special about the name <tt class="doctest"><span class="pre">*args</span></tt>.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>song = [[<span class="pysrc-string">'four'</span>, <span class="pysrc-string">'calling'</span>, <span class="pysrc-string">'birds'</span>],
<span class="pysrc-more">... </span>        [<span class="pysrc-string">'three'</span>, <span class="pysrc-string">'French'</span>, <span class="pysrc-string">'hens'</span>],
<span class="pysrc-more">... </span>        [<span class="pysrc-string">'two'</span>, <span class="pysrc-string">'turtle'</span>, <span class="pysrc-string">'doves'</span>]]
<span class="pysrc-prompt">&gt;&gt;&gt; </span>list(zip(song[0], song[1], song[2]))
<span class="pysrc-output">[('four', 'three', 'two'), ('calling', 'French', 'turtle'), ('birds', 'hens', 'doves')]</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>list(zip(*song))
<span class="pysrc-output">[('four', 'three', 'two'), ('calling', 'French', 'turtle'), ('birds', 'hens', 'doves')]</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>It should be clear from the above example that typing <tt class="doctest"><span class="pre">*song</span></tt> is just a convenient
shorthand, and equivalent to typing out <tt class="doctest"><span class="pre">song[0], song[1], song[2]</span></tt>.</p>
<p>Here's another example of the use of keyword arguments in a function
definition, along with three equivalent ways to call the function:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">def</span> <span class="pysrc-defname">freq_words</span>(file, min=1, num=10):
<span class="pysrc-more">... </span>    text = open(file).read()
<span class="pysrc-more">... </span>    tokens = word_tokenize(text)
<span class="pysrc-more">... </span>    freqdist = nltk.FreqDist(t <span class="pysrc-keyword">for</span> t <span class="pysrc-keyword">in</span> tokens <span class="pysrc-keyword">if</span> len(t) &gt;= min)
<span class="pysrc-more">... </span>    return freqdist.most_common(num)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>fw = freq_words(<span class="pysrc-string">'ch01.rst'</span>, 4, 10)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>fw = freq_words(<span class="pysrc-string">'ch01.rst'</span>, min=4, num=10)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>fw = freq_words(<span class="pysrc-string">'ch01.rst'</span>, num=10, min=4)</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>A side-effect of having named arguments is that they permit optionality.  Thus we
can leave out any arguments where we are happy with the default value:
<tt class="doctest"><span class="pre">freq_words(<span class="pysrc-string">'ch01.rst'</span>, min=4)</span></tt>, <tt class="doctest"><span class="pre">freq_words(<span class="pysrc-string">'ch01.rst'</span>, 4)</span></tt>.
Another common use of optional arguments is to permit a flag.
Here's a revised version of the same function that reports its
progress if a <tt class="doctest"><span class="pre">verbose</span></tt> flag is set:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">def</span> <span class="pysrc-defname">freq_words</span>(file, min=1, num=10, verbose=False):
<span class="pysrc-more">... </span>    freqdist = FreqDist()
<span class="pysrc-more">... </span>    <span class="pysrc-keyword">if</span> verbose: <span class="pysrc-keyword">print</span>(<span class="pysrc-string">&quot;Opening&quot;</span>, file)
<span class="pysrc-more">... </span>    text = open(file).read()
<span class="pysrc-more">... </span>    <span class="pysrc-keyword">if</span> verbose: <span class="pysrc-keyword">print</span>(<span class="pysrc-string">&quot;Read in %d characters&quot;</span> % len(file))
<span class="pysrc-more">... </span>    <span class="pysrc-keyword">for</span> word <span class="pysrc-keyword">in</span> word_tokenize(text):
<span class="pysrc-more">... </span>        <span class="pysrc-keyword">if</span> len(word) &gt;= min:
<span class="pysrc-more">... </span>            freqdist[word] += 1
<span class="pysrc-more">... </span>            <span class="pysrc-keyword">if</span> verbose <span class="pysrc-keyword">and</span> freqdist.N() % 100 == 0: <span class="pysrc-keyword">print</span>(<span class="pysrc-string">&quot;.&quot;</span>, sep=<span class="pysrc-string">&quot;&quot;</span>)
<span class="pysrc-more">... </span>    <span class="pysrc-keyword">if</span> verbose: <span class="pysrc-keyword">print</span>
<span class="pysrc-more">... </span>    return freqdist.most_common(num)</pre>
</td>
</tr></table></td></tr>
</table></div>
<div class="caution">
<p class="first admonition-title">Caution!</p>
<p class="last">Take care not to use a mutable object as the default value of
a parameter.  A series of calls to the function will use the
same object, sometimes with bizarre results as we will see in
the discussion of debugging below.</p>
</div>
<div class="caution">
<p class="first admonition-title">Caution!</p>
<p>If your program will work with a lot of files, it is a good idea to
close any open files once they are no longer required. Python will
close open files automatically if you use the <tt class="doctest"><span class="pre">with</span></tt> statement:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>with open(<span class="pysrc-string">&quot;lexicon.txt&quot;</span>) <span class="pysrc-keyword">as</span> f:
<span class="pysrc-more">... </span>    data = f.read()
<span class="pysrc-more">... </span>    <span class="pysrc-comment"># process the data</span></pre>
</td>
</tr></table></td></tr>
</table></div>
</div>
</div>
</div>
<div class="section" id="program-development">
<span id="sec-program-development"></span><h2>13.10&nbsp;&nbsp;&nbsp;Program Development</h2>
<p>Programming is a skill that is acquired over several years of
experience with a variety of programming languages and tasks.  Key
high-level abilities are <em>algorithm design</em> and its manifestation in
<em>structured programming</em>.  Key low-level abilities include familiarity
with the syntactic constructs of the language, and knowledge of a
variety of diagnostic methods for trouble-shooting a program which
does not exhibit the expected behavior.</p>
<p>This section describes the internal structure of a program module and
how to organize a multi-module program.  Then it describes various
kinds of error that arise during program development, what you can
do to fix them and, better still, to avoid them in the first place.</p>
<div class="section" id="structure-of-a-python-module">
<h3>Structure of a Python Module</h3>
<p>The purpose of a program module is to bring logically-related definitions and functions
together in order to facilitate re-use and abstraction.  Python modules are nothing
more than individual <tt class="doctest"><span class="pre">.py</span></tt> files.  For example, if you were working
with a particular corpus format, the functions to read and write the format could be
kept together.  Constants used by both formats, such as field separators,
or a <tt class="doctest"><span class="pre">EXTN = <span class="pysrc-string">&quot;.inf&quot;</span></span></tt> filename extension, could be shared.  If the format was updated,
you would know that only one file needed to be changed.  Similarly, a module could
contain code for creating and manipulating a particular data structure such as
syntax trees, or code for performing a particular processing task such as
plotting corpus statistics.</p>
<p>When you start writing Python modules, it helps to have some
examples to emulate.  You can locate the code for any NLTK module on your
system using the <tt class="doctest"><span class="pre">__file__</span></tt> variable, e.g.:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>nltk.metrics.distance.__file__
<span class="pysrc-output">'/usr/lib/python2.5/site-packages/nltk/metrics/distance.pyc'</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>This returns the location of the compiled <tt class="doctest"><span class="pre">.pyc</span></tt> file for the module, and
you'll probably see a different location on your machine. The file that you will need
to open is the corresponding <tt class="doctest"><span class="pre">.py</span></tt> source file, and this will be in the same
directory as the <tt class="doctest"><span class="pre">.pyc</span></tt> file.
Alternatively, you can view the latest version of this module on the web
at <tt class="doctest"><span class="pre">http://code.google.com/p/nltk/source/browse/trunk/nltk/nltk/metrics/distance.py</span></tt>.</p>
<p>Like every other NLTK module, <tt class="doctest"><span class="pre">distance.py</span></tt> begins with a group of comment
lines giving a one-line title of the module and identifying the authors.
(Since the code is distributed, it also includes the URL where the
code is available, a copyright statement, and license information.)
Next is the module-level docstring, a triple-quoted multiline string
containing information about the module that will be printed when
someone types <tt class="doctest"><span class="pre">help(nltk.metrics.distance)</span></tt>.</p>
<!-- XXX how about putting this in a pylisting?  (didn't work) -->
<pre class="literal-block">
# Natural Language Toolkit: Distance Metrics
#
# Copyright (C) 2001-2015 NLTK Project
# Author: Edward Loper &lt;edloper&#64;gmail.com&gt;
#         Steven Bird &lt;stevenbird1&#64;gmail.com&gt;
#         Tom Lippincott &lt;tom&#64;cs.columbia.edu&gt;
# URL: &lt;http://nltk.org/&gt;
# For license information, see LICENSE.TXT
#

&quot;&quot;&quot;
Distance Metrics.

Compute the distance between two items (usually strings).
As metrics, they must satisfy the following three requirements:

1. d(a, a) = 0
2. d(a, b) &gt;= 0
3. d(a, c) &lt;= d(a, b) + d(b, c)
&quot;&quot;&quot;
</pre>
<p>After this comes all the import statements required for the module,
then any global variables,
followed by a series of function definitions that make up most
of the module.  Other modules define &quot;classes,&quot; the main building block
of object-oriented programming, which falls outside the scope of this book.
(Most NLTK modules also include a <tt class="doctest"><span class="pre">demo()</span></tt> function which can be used
to see examples of the module in use.)</p>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last">Some module variables and functions are only used within the module.
These should have names beginning with an underscore, e.g. <tt class="doctest"><span class="pre">_helper()</span></tt>,
since this will hide the name.  If another module imports this one,
using the idiom: <tt class="doctest"><span class="pre"><span class="pysrc-keyword">from</span> module <span class="pysrc-keyword">import</span> *</span></tt>, these names will not be imported.
You can optionally list the externally accessible names of a module using
a special built-in variable like this: <tt class="doctest"><span class="pre">__all__ = [<span class="pysrc-string">'edit_distance'</span>, <span class="pysrc-string">'jaccard_distance'</span>]</span></tt>.</p>
</div>
</div>
<div class="section" id="multi-module-programs">
<h3>Multi-Module Programs</h3>
<p>Some programs bring together a diverse range of tasks, such as loading data from
a corpus, performing some analysis tasks on the data, then visualizing it.
We may already have stable modules that take care of loading data and producing visualizations.
Our work might involve coding up the analysis task, and just invoking functions
from the existing modules.  This scenario is depicted in <a class="reference internal" href="#fig-multi-module">13.7</a>.</p>
<span class="target" id="fig-multi-module"></span><div class="figure" id="fig-multi-module">
<img alt="../images/multi-module.png" src="../images/multi-module.png" style="width: 360.0px; height: 237.60000000000002px;" />
<p class="caption"><span class="caption-label">Figure 13.7</span>: Structure of a Multi-Module Program: The main program <tt class="doctest"><span class="pre">my_program.py</span></tt> imports functions
from two other modules; unique analysis tasks are localized to the main program, while
common loading and visualization tasks are kept apart to facilitate re-use and abstraction.</p>
</div>
<p>By dividing our work into several modules and using <tt class="doctest"><span class="pre"><span class="pysrc-keyword">import</span></span></tt> statements to
access functions defined elsewhere, we can keep the individual modules simple
and easy to maintain.  This approach will also result in a growing collection
of modules, and make it possible for us to build sophisticated systems involving
a hierarchy of modules.  Designing such systems well is a
complex software engineering task, and beyond the scope of this book.</p>
</div>
<div class="section" id="sources-of-error">
<h3>Sources of Error</h3>
<p>Mastery of programming depends on having a variety of problem-solving skills to
draw upon when the program doesn't work as expected.  Something as trivial as
a mis-placed symbol might cause the program to behave very differently.
We call these &quot;bugs&quot; because they are tiny in comparison to the damage
they can cause.  They creep into our code unnoticed, and it's only much later
when we're running the program on some new data that their presence is detected.
Sometimes, fixing one bug only reveals another, and we get the distinct impression
that the bug is on the move.  The only reassurance we have is that bugs are
spontaneous and not the fault of the programmer.</p>
<p>Flippancy aside, debugging code is hard because there are so many ways for
it to be faulty.  Our understanding of the input data, the algorithm, or
even the programming language, may be at fault.  Let's look at examples
of each of these.</p>
<p>First, the input data may contain some unexpected characters.
For example, WordNet synset names have the form <tt class="doctest"><span class="pre">tree.n.01</span></tt>, with three
components separated using periods.  The NLTK WordNet module initially
decomposed these names using <tt class="doctest"><span class="pre">split(<span class="pysrc-string">'.'</span>)</span></tt>.  However, this method broke when
someone tried to look up the word <span class="example">PhD</span>, which has the synset
name <tt class="doctest"><span class="pre">ph.d..n.01</span></tt>, containing four periods instead of the expected two.
The solution was to use <tt class="doctest"><span class="pre">rsplit(<span class="pysrc-string">'.'</span>, 2)</span></tt> to do at most two splits, using
the rightmost instances of the period, and leaving the <tt class="doctest"><span class="pre">ph.d.</span></tt> string intact.
Although several people had tested
the module before it was released, it was some weeks before someone detected
the problem (see <tt class="doctest"><span class="pre">http://code.google.com/p/nltk/issues/detail?id=297</span></tt>).</p>
<p>Second, a supplied function might not behave as expected.
For example, while testing NLTK's interface to WordNet, one of the
authors noticed that no synsets had any antonyms defined, even though
the underlying database provided a large quantity of antonym information.
What looked like a bug in the WordNet interface turned out to
be a misunderstanding about WordNet itself: antonyms are defined for
lemmas, not for synsets.  The only &quot;bug&quot; was a misunderstanding
of the interface (see <tt class="doctest"><span class="pre">http://code.google.com/p/nltk/issues/detail?id=98</span></tt>).</p>
<!-- XXX much easier to get the point of the next example if it is on a single line, so -->
<!-- a doctest block would work better -->
<p>Third, our understanding of Python's semantics may be at fault.
It is easy to make the wrong assumption about the relative
scope of two operators.
For example, <tt class="doctest"><span class="pre"><span class="pysrc-string">&quot;%s.%s.%02d&quot;</span> % <span class="pysrc-string">&quot;ph.d.&quot;</span>, <span class="pysrc-string">&quot;n&quot;</span>, 1</span></tt> produces a run-time
error <tt class="doctest"><span class="pre">TypeError: <span class="pysrc-keyword">not</span> enough arguments <span class="pysrc-keyword">for</span> format string</span></tt>.
This is because the percent operator has higher precedence than
the comma operator.  The fix is to add parentheses in order to
force the required scope.  As another example, suppose we are
defining a function to collect all tokens of a text having a
given length.  The function has parameters for the text and
the word length, and an extra parameter that allows the initial
value of the result to be given as a parameter:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">def</span> <span class="pysrc-defname">find_words</span>(text, wordlength, result=[]):
<span class="pysrc-more">... </span>    <span class="pysrc-keyword">for</span> word <span class="pysrc-keyword">in</span> text:
<span class="pysrc-more">... </span>        <span class="pysrc-keyword">if</span> len(word) == wordlength:
<span class="pysrc-more">... </span>            result.append(word)
<span class="pysrc-more">... </span>    return result
<span class="pysrc-prompt">&gt;&gt;&gt; </span>find_words([<span class="pysrc-string">'omg'</span>, <span class="pysrc-string">'teh'</span>, <span class="pysrc-string">'lolcat'</span>, <span class="pysrc-string">'sitted'</span>, <span class="pysrc-string">'on'</span>, <span class="pysrc-string">'teh'</span>, <span class="pysrc-string">'mat'</span>], 3) <a name="find-words-1" /><a href="#ref-find-words-1"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></a>
<span class="pysrc-output">['omg', 'teh', 'teh', 'mat']</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>find_words([<span class="pysrc-string">'omg'</span>, <span class="pysrc-string">'teh'</span>, <span class="pysrc-string">'lolcat'</span>, <span class="pysrc-string">'sitted'</span>, <span class="pysrc-string">'on'</span>, <span class="pysrc-string">'teh'</span>, <span class="pysrc-string">'mat'</span>], 2, [<span class="pysrc-string">'ur'</span>]) <a name="find-words-2" /><a href="#ref-find-words-2"><img src="callouts/callout2.gif" alt="[2]" class="callout" /></a>
<span class="pysrc-output">['ur', 'on']</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>find_words([<span class="pysrc-string">'omg'</span>, <span class="pysrc-string">'teh'</span>, <span class="pysrc-string">'lolcat'</span>, <span class="pysrc-string">'sitted'</span>, <span class="pysrc-string">'on'</span>, <span class="pysrc-string">'teh'</span>, <span class="pysrc-string">'mat'</span>], 3) <a name="find-words-3" /><a href="#ref-find-words-3"><img src="callouts/callout3.gif" alt="[3]" class="callout" /></a>
<span class="pysrc-output">['omg', 'teh', 'teh', 'mat', 'omg', 'teh', 'teh', 'mat']</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>The first time we call <tt class="doctest"><span class="pre">find_words()</span></tt> <a class="reference internal" href="#find-words-1"><span id="ref-find-words-1"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></span></a>, we get all three-letter
words as expected.  The second time we specify an initial value for the result,
a one-element list <tt class="doctest"><span class="pre">[<span class="pysrc-string">'ur'</span>]</span></tt>, and as expected, the result has this word along with the
other two-letter word in our text.  Now, the next time we call <tt class="doctest"><span class="pre">find_words()</span></tt> <a class="reference internal" href="#find-words-3"><span id="ref-find-words-3"><img src="callouts/callout3.gif" alt="[3]" class="callout" /></span></a>
we use the same parameters as in <a class="reference internal" href="#find-words-1"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></a>, but we get a different result!
Each time we call <tt class="doctest"><span class="pre">find_words()</span></tt> with no third parameter, the result will
simply extend the result of the previous call, rather than start with the
empty result list as specified in the function definition.  The program's
behavior is not as expected because we incorrectly assumed that the default
value was created at the time the function was invoked.  However, it is
created just once, at the time the Python interpreter loads the function.
This one list object is used whenever no explicit value is provided to the function.</p>
</div>
<div class="section" id="debugging-techniques">
<h3>Debugging Techniques</h3>
<p>Since most code errors result from the programmer making incorrect assumptions,
the first thing to do when you detect a bug is to <span class="emphasis">check your assumptions</span>.
Localize the problem by adding <tt class="doctest"><span class="pre"><span class="pysrc-keyword">print</span></span></tt> statements to the program, showing the
value of important variables, and showing how far the program has progressed.</p>
<p>If the program produced an &quot;exception&quot; &#8212; a run-time error &#8212;
the interpreter will print a <a name="stack_trace_index_term" /><span class="termdef">stack trace</span>,
pinpointing the location of program execution at the time of the error.
If the program depends on input data, try to reduce this to the smallest
size while still producing the error.</p>
<p>Once you have localized the problem to a particular function, or to a line
of code, you need to work out what is going wrong.  It is often helpful to
recreate the situation using the interactive command line.  Define some
variables then copy-paste the offending line of code into the session
and see what happens.  Check your understanding of the code by reading
some documentation, and examining other code samples that purport to do
the same thing that you are trying to do.  Try explaining your code to
someone else, in case they can see where things are going wrong.</p>
<p>Python provides a <a name="debugger_index_term" /><span class="termdef">debugger</span> which allows you to monitor the execution
of your program, specify line numbers where execution will stop (i.e. <a name="breakpoints_index_term" /><span class="termdef">breakpoints</span>),
and step through sections of code and inspect the value of variables.
You can invoke the debugger on your code as follows:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">import</span> pdb
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">import</span> mymodule
<span class="pysrc-prompt">&gt;&gt;&gt; </span>pdb.run(<span class="pysrc-string">'mymodule.myfunction()'</span>)</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>It will present you with a prompt <tt class="doctest"><span class="pre">(Pdb)</span></tt> where you can type instructions
to the debugger.  Type <tt class="doctest"><span class="pre">help</span></tt> to see the full list of commands.
Typing <tt class="doctest"><span class="pre">step</span></tt> (or just <tt class="doctest"><span class="pre">s</span></tt>) will execute the current line and
stop.  If the current line calls a function, it will enter the function
and stop at the first line.  Typing <tt class="doctest"><span class="pre">next</span></tt> (or just <tt class="doctest"><span class="pre">n</span></tt>) is similar,
but it stops execution at the next line in the current function.  The
<tt class="doctest"><span class="pre">break</span></tt> (or <tt class="doctest"><span class="pre">b</span></tt>) command can be used to create or list breakpoints.  Type
<tt class="doctest"><span class="pre">continue</span></tt> (or <tt class="doctest"><span class="pre">c</span></tt>) to continue execution as far as the next breakpoint.
Type the name of any variable to inspect its value.</p>
<p>We can use the Python debugger to locate the problem in our <tt class="doctest"><span class="pre">find_words()</span></tt>
function.  Remember that the problem arose the second time the function was
called.  We'll start by calling the function without using the debugger <a href="#id7"><span class="problematic" id="id8">first-run_</span></a>,
using the smallest possible input.  The second time, we'll call it with the
debugger <a href="#id9"><span class="problematic" id="id10">second-run_</span></a>.
.. doctest-ignore:</p>
<pre class="literal-block">
&gt;&gt;&gt; import pdb
&gt;&gt;&gt; find_words(['cat'], 3) # [_first-run]
['cat']
&gt;&gt;&gt; pdb.run(&quot;find_words(['dog'], 3)&quot;) # [_second-run]
&gt; &lt;string&gt;(1)&lt;module&gt;()
(Pdb) step
--Call--
&gt; &lt;stdin&gt;(1)find_words()
(Pdb) args
text = ['dog']
wordlength = 3
result = ['cat']
</pre>
<p>Here we typed just two commands into the debugger: <tt class="doctest"><span class="pre">step</span></tt> took us inside
the function, and <tt class="doctest"><span class="pre">args</span></tt> showed the values of its arguments (or parameters).
We see immediately that <tt class="doctest"><span class="pre">result</span></tt> has an initial value of <tt class="doctest"><span class="pre">[<span class="pysrc-string">'cat'</span>]</span></tt>, and not
the empty list as expected.  The debugger has helped us to localize the problem,
prompting us to check our understanding of Python functions.</p>
</div>
<div class="section" id="defensive-programming">
<h3>Defensive Programming</h3>
<p>In order to avoid some of the pain of debugging, it helps to adopt
some defensive programming habits.  Instead of writing a 20-line
program then testing it, build the program bottom-up out of
small pieces that are known to work.  Each time you combine these
pieces to make a larger unit, test it carefully to see that it works
as expected.  Consider adding <tt class="doctest"><span class="pre">assert</span></tt> statements to your code,
specifying properties of a variable, e.g. <tt class="doctest"><span class="pre">assert(isinstance(text, list))</span></tt>.
If the value of the <tt class="doctest"><span class="pre">text</span></tt> variable later becomes a string when your
code is used in some larger context, this will raise an <tt class="doctest"><span class="pre">AssertionError</span></tt>
and you will get immediate notification of the problem.</p>
<p>Once you think you've found the bug, view your solution as a hypothesis.
Try to predict the effect of your bugfix before re-running the program.
If the bug isn't fixed, don't fall into the trap of blindly changing
the code in the hope that it will magically start working again.
Instead, for each change, try to articulate a hypothesis about what
is wrong and why the change will fix the problem.  Then undo the change
if the problem was not resolved.</p>
<p>As you develop your program, extend its functionality, and fix any bugs,
it helps to maintain a suite of test cases.
This is called <a name="regression_testing_index_term" /><span class="termdef">regression testing</span>, since it is meant to detect
situations where the code &quot;regresses&quot; &#8212; where a change to the
code has an unintended side-effect of breaking something that
used to work.  Python provides a simple regression testing framework
in the form of the <tt class="doctest"><span class="pre">doctest</span></tt> module.  This module searches a file
of code or documentation for blocks of text that look like
an interactive Python session, of the form you have already seen
many times in this book.  It executes the Python commands it finds,
and tests that their output matches the output supplied in the original
file.  Whenever there is a mismatch, it reports the expected and actual
values.  For details please consult the <tt class="doctest"><span class="pre">doctest</span></tt> documentation at
<tt class="doctest"><span class="pre">http://docs.python.org/library/doctest.html</span></tt>.  Apart from its
value for regression testing, the <tt class="doctest"><span class="pre">doctest</span></tt> module is useful for
ensuring that your software documentation stays in sync with your
code.</p>
<p>Perhaps the most important defensive programming strategy is to
set out your code clearly, choose meaningful variable and function
names, and simplify the code wherever possible by decomposing it into
functions and modules with well-documented interfaces.</p>
</div>
</div>
<div class="section" id="dictionaries">
<span id="sec-dictionaries"></span><h2>13.11&nbsp;&nbsp;&nbsp;Dictionaries</h2>
<p>A dictionary, also known as a <a name="mapping_index_term" /><span class="termdef">mapping</span>, <a name="associative_array_index_term" /><span class="termdef">associative array</span>
or <a name="hash_array_index_term" /><span class="termdef">hash array</span>, is a data type for storing correspondences
between keys and values. For instance, we could define a dictionary
that maps from words to their definitions (like a real-world
dictionary). But we could also map from a word to its part of speech,
or a word and its frequency, and so forth.</p>
<div class="section" id="lists-vs-dictionaries">
<h3>Lists vs Dictionaries</h3>
<p>A text, as we have seen, is treated in Python as a list of words.
An important property of lists is that we can &quot;look up&quot; a particular
item by giving its index, e.g. <tt class="doctest"><span class="pre">text1[100]</span></tt>.  Notice how we specify
a number, and get back a word.  We can think of a list as a simple
kind of table, as shown in <a class="reference internal" href="#fig-maps01">13.8</a>.</p>
<span class="target" id="fig-maps01"></span><div class="figure" id="fig-maps01">
<img alt="../images/maps01.png" src="../images/maps01.png" style="width: 136.8px; height: 113.4px;" />
<p class="caption"><span class="caption-label">Figure 13.8</span>: List Look-up: we access the contents of a Python list with the help of an integer index.</p>
</div>
<p>Contrast this situation with frequency distributions (<a class="reference external" href="ch01.html#sec-computing-with-language-simple-statistics">3</a>),
where we specify a word, and get back a number, e.g. <tt class="doctest"><span class="pre">fdist[<span class="pysrc-string">'monstrous'</span>]</span></tt>, which
tells us the number of times a given word has occurred in a text.  Look-up using words is
familiar to anyone who has used a dictionary.  Some more examples are shown in
<a class="reference internal" href="#fig-maps02">13.9</a>.</p>
<span class="target" id="fig-maps02"></span><div class="figure" id="fig-maps02">
<img alt="../images/maps02.png" src="../images/maps02.png" style="width: 719.62px; height: 170.5px;" />
<p class="caption"><span class="caption-label">Figure 13.9</span>: Dictionary Look-up: we access the entry of a dictionary using a key
such as someone's name, a web domain, or an English word;
other names for dictionary are map, hashmap, hash, and associative array.</p>
</div>
<p>In the case of a phonebook, we look up an entry using a <span class="emphasis">name</span>,
and get back a number.  When we type a domain name in a web browser,
the computer looks this up to get back an IP address.  A word
frequency table allows us to look up a word and find its frequency in
a text collection.  In all these cases, we are mapping from names to
numbers, rather than the other way around as with a list.
In general, we would like to be able to map between
arbitrary types of information.  <a class="reference internal" href="#tab-linguistic-objects">13.5</a> lists a variety
of linguistic objects, along with what they map.</p>
<span class="target" id="tab-linguistic-objects"></span><table border="1" class="docutils" id="tab-linguistic-objects">
<colgroup>
<col width="26%" />
<col width="14%" />
<col width="60%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Linguistic Object</th>
<th class="head">Maps From</th>
<th class="head">Maps To</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>Document Index</td>
<td>Word</td>
<td>List of pages (where word is found)</td>
</tr>
<tr><td>Thesaurus</td>
<td>Word sense</td>
<td>List of synonyms</td>
</tr>
<tr><td>Dictionary</td>
<td>Headword</td>
<td>Entry (part-of-speech, sense definitions, etymology)</td>
</tr>
<tr><td>Comparative Wordlist</td>
<td>Gloss term</td>
<td>Cognates (list of words, one per language)</td>
</tr>
<tr><td>Morph Analyzer</td>
<td>Surface form</td>
<td>Morphological analysis (list of component morphemes)</td>
</tr>
</tbody>
<p class="caption"><span class="caption-label">Table 13.5</span>: <p>Linguistic Objects as Mappings from Keys to Values</p>
</p>
</table>
<p>Most often, we are mapping from a &quot;word&quot; to some structured object.
For example, a document index maps from a word (which we can represent
as a string), to a list of pages (represented as a list of integers).
In this section, we will see how to represent such mappings in Python.</p>
</div>
<div class="section" id="dictionaries-in-python">
<h3>Dictionaries in Python</h3>
<p>Python provides a <a name="dictionary_index_term" /><span class="termdef">dictionary</span> data type that can be used for
mapping between arbitrary types.  It is like a conventional dictionary,
in that it gives you an efficient way to look things up.  However,
as we see from <a class="reference internal" href="#tab-linguistic-objects">13.5</a>, it has a much wider range of uses.</p>
<p>To illustrate, we define <tt class="doctest"><span class="pre">pos</span></tt> to be an empty dictionary and then add four
entries to it, specifying the part-of-speech of some words.  We add
entries to a dictionary using the familiar square bracket notation:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>pos = {}
<span class="pysrc-prompt">&gt;&gt;&gt; </span>pos
<span class="pysrc-output">{}</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>pos[<span class="pysrc-string">'colorless'</span>] = <span class="pysrc-string">'ADJ'</span> <a name="pos-colorless" /><a href="#ref-pos-colorless"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></a>
<span class="pysrc-prompt">&gt;&gt;&gt; </span>pos
<span class="pysrc-output">{'colorless': 'ADJ'}</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>pos[<span class="pysrc-string">'ideas'</span>] = <span class="pysrc-string">'N'</span>
<span class="pysrc-prompt">&gt;&gt;&gt; </span>pos[<span class="pysrc-string">'sleep'</span>] = <span class="pysrc-string">'V'</span>
<span class="pysrc-prompt">&gt;&gt;&gt; </span>pos[<span class="pysrc-string">'furiously'</span>] = <span class="pysrc-string">'ADV'</span>
<span class="pysrc-prompt">&gt;&gt;&gt; </span>pos <a name="pos-inspect" /><a href="#ref-pos-inspect"><img src="callouts/callout2.gif" alt="[2]" class="callout" /></a>
<span class="pysrc-output">{'furiously': 'ADV', 'ideas': 'N', 'colorless': 'ADJ', 'sleep': 'V'}</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>So, for example, <a class="reference internal" href="#pos-colorless"><span id="ref-pos-colorless"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></span></a> says that
the part-of-speech of <span class="example">colorless</span> is adjective, or more
specifically, that the <a name="key_index_term" /><span class="termdef">key</span> <tt class="doctest"><span class="pre"><span class="pysrc-string">'colorless'</span></span></tt>
is assigned the <a name="value_index_term" /><span class="termdef">value</span> <tt class="doctest"><span class="pre"><span class="pysrc-string">'ADJ'</span></span></tt>  in dictionary <tt class="doctest"><span class="pre">pos</span></tt>.
When we inspect the value of <tt class="doctest"><span class="pre">pos</span></tt> <a class="reference internal" href="#pos-inspect"><span id="ref-pos-inspect"><img src="callouts/callout2.gif" alt="[2]" class="callout" /></span></a> we see
a set of key-value pairs.  Once we have populated the dictionary
in this way, we can employ the keys to retrieve values:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>pos[<span class="pysrc-string">'ideas'</span>]
<span class="pysrc-output">'N'</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>pos[<span class="pysrc-string">'colorless'</span>]
<span class="pysrc-output">'ADJ'</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Of course, we might accidentally use a key that hasn't been assigned a value.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>pos[<span class="pysrc-string">'green'</span>]
<span class="pysrc-except">Traceback (most recent call last):</span>
<span class="pysrc-except">  File &quot;&lt;stdin&gt;&quot;, line 1, in ?</span>
<span class="pysrc-except">KeyError: 'green'</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>This raises an important question.  Unlike lists and strings, where we
can use <tt class="doctest"><span class="pre">len()</span></tt> to work out which integers will be legal indexes,
how do we work out the legal keys for a dictionary?  If the dictionary
is not too big, we can simply inspect its contents by evaluating the
variable <tt class="doctest"><span class="pre">pos</span></tt>.  As we saw above (line <a class="reference internal" href="#pos-inspect"><img src="callouts/callout2.gif" alt="[2]" class="callout" /></a>), this gives
us the key-value pairs.  Notice that they are not in the same order they
were originally entered; this is because dictionaries are not sequences
but mappings (cf. <a class="reference internal" href="#fig-maps02">13.9</a>), and the keys are not inherently
ordered.</p>
<p>Alternatively, to just find the keys, we can convert the
dictionary to a list <a class="reference internal" href="#dict-to-list"><span id="ref-dict-to-list"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></span></a> &#8212; or use
the dictionary in a context where a list is expected,
as the parameter of <tt class="doctest"><span class="pre">sorted()</span></tt> <a class="reference internal" href="#dict-sorted"><span id="ref-dict-sorted"><img src="callouts/callout2.gif" alt="[2]" class="callout" /></span></a>,
or in a <tt class="doctest"><span class="pre"><span class="pysrc-keyword">for</span></span></tt> loop <a class="reference internal" href="#dict-for-loop"><span id="ref-dict-for-loop"><img src="callouts/callout3.gif" alt="[3]" class="callout" /></span></a>.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>list(pos) <a name="dict-to-list" /><a href="#ref-dict-to-list"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></a>
<span class="pysrc-output">['ideas', 'furiously', 'colorless', 'sleep']</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>sorted(pos) <a name="dict-sorted" /><a href="#ref-dict-sorted"><img src="callouts/callout2.gif" alt="[2]" class="callout" /></a>
<span class="pysrc-output">['colorless', 'furiously', 'ideas', 'sleep']</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>[w <span class="pysrc-keyword">for</span> w <span class="pysrc-keyword">in</span> pos <span class="pysrc-keyword">if</span> w.endswith(<span class="pysrc-string">'s'</span>)] <a name="dict-for-loop" /><a href="#ref-dict-for-loop"><img src="callouts/callout3.gif" alt="[3]" class="callout" /></a>
<span class="pysrc-output">['colorless', 'ideas']</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last">When you type <tt class="doctest"><span class="pre">list(pos)</span></tt> you might see a different order
to the one shown above.  If you want to see the keys in order, just sort them.</p>
</div>
<p>As well as iterating over all keys
in the dictionary with a <tt class="doctest"><span class="pre"><span class="pysrc-keyword">for</span></span></tt> loop, we can use the <tt class="doctest"><span class="pre"><span class="pysrc-keyword">for</span></span></tt> loop
as we did for printing lists:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">for</span> word <span class="pysrc-keyword">in</span> sorted(pos):
<span class="pysrc-more">... </span>    <span class="pysrc-keyword">print</span>(word + <span class="pysrc-string">&quot;:&quot;</span>, pos[word])
<span class="pysrc-more">...</span>
<span class="pysrc-output">colorless: ADJ</span>
<span class="pysrc-output">furiously: ADV</span>
<span class="pysrc-output">sleep: V</span>
<span class="pysrc-output">ideas: N</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Finally, the dictionary methods <tt class="doctest"><span class="pre"><span class="pysrc-builtin">keys</span>()</span></tt>, <tt class="doctest"><span class="pre"><span class="pysrc-builtin">values</span>()</span></tt> and
<tt class="doctest"><span class="pre"><span class="pysrc-builtin">items</span>()</span></tt> allow us to access the keys, values, and key-value pairs as separate lists.
We can even sort tuples <a class="reference internal" href="#sort-tuples"><span id="ref-sort-tuples"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></span></a>, which orders them according to their first element
(and if the first elements are the same, it uses their second elements).</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>list(pos.keys())
<span class="pysrc-output">['colorless', 'furiously', 'sleep', 'ideas']</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>list(pos.values())
<span class="pysrc-output">['ADJ', 'ADV', 'V', 'N']</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>list(pos.items())
<span class="pysrc-output">[('colorless', 'ADJ'), ('furiously', 'ADV'), ('sleep', 'V'), ('ideas', 'N')]</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">for</span> key, val <span class="pysrc-keyword">in</span> sorted(pos.items()): <a name="sort-tuples" /><a href="#ref-sort-tuples"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></a>
<span class="pysrc-more">... </span>    <span class="pysrc-keyword">print</span>(key + <span class="pysrc-string">&quot;:&quot;</span>, val)
<span class="pysrc-more">...</span>
<span class="pysrc-output">colorless: ADJ</span>
<span class="pysrc-output">furiously: ADV</span>
<span class="pysrc-output">ideas: N</span>
<span class="pysrc-output">sleep: V</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>We want to be sure that when we look something up in a dictionary, we
only get one value for each key. Now
suppose we try to use a dictionary to store the fact that the
word <span class="example">sleep</span> can be used as both a verb and a noun:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>pos[<span class="pysrc-string">'sleep'</span>] = <span class="pysrc-string">'V'</span>
<span class="pysrc-prompt">&gt;&gt;&gt; </span>pos[<span class="pysrc-string">'sleep'</span>]
<span class="pysrc-output">'V'</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>pos[<span class="pysrc-string">'sleep'</span>] = <span class="pysrc-string">'N'</span>
<span class="pysrc-prompt">&gt;&gt;&gt; </span>pos[<span class="pysrc-string">'sleep'</span>]
<span class="pysrc-output">'N'</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Initially, <tt class="doctest"><span class="pre">pos[<span class="pysrc-string">'sleep'</span>]</span></tt> is given the value <tt class="doctest"><span class="pre"><span class="pysrc-string">'V'</span></span></tt>. But this is
immediately overwritten with the new value <tt class="doctest"><span class="pre"><span class="pysrc-string">'N'</span></span></tt>.
In other words, there can only be one entry in the dictionary for <tt class="doctest"><span class="pre"><span class="pysrc-string">'sleep'</span></span></tt>.
However, there is a way of storing multiple values in
that entry: we use a list value,
e.g. <tt class="doctest"><span class="pre">pos[<span class="pysrc-string">'sleep'</span>] = [<span class="pysrc-string">'N'</span>, <span class="pysrc-string">'V'</span>]</span></tt>.  In fact, this is what we
saw in <a class="reference external" href="ch02.html#sec-lexical-resources">3</a> for the CMU Pronouncing Dictionary,
which stores multiple pronunciations for a single word.</p>
</div>
<div class="section" id="defining-dictionaries">
<h3>Defining Dictionaries</h3>
<p>We can use the same key-value pair format to create a dictionary.  There's
a couple of ways to do this, and we will normally use the first:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>pos = {<span class="pysrc-string">'colorless'</span>: <span class="pysrc-string">'ADJ'</span>, <span class="pysrc-string">'ideas'</span>: <span class="pysrc-string">'N'</span>, <span class="pysrc-string">'sleep'</span>: <span class="pysrc-string">'V'</span>, <span class="pysrc-string">'furiously'</span>: <span class="pysrc-string">'ADV'</span>}
<span class="pysrc-prompt">&gt;&gt;&gt; </span>pos = dict(colorless=<span class="pysrc-string">'ADJ'</span>, ideas=<span class="pysrc-string">'N'</span>, sleep=<span class="pysrc-string">'V'</span>, furiously=<span class="pysrc-string">'ADV'</span>)</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Note that dictionary keys must be immutable types, such as strings and tuples.
If we try to define a dictionary using a mutable key, we get a <tt class="doctest"><span class="pre">TypeError</span></tt>:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>pos = {[<span class="pysrc-string">'ideas'</span>, <span class="pysrc-string">'blogs'</span>, <span class="pysrc-string">'adventures'</span>]: <span class="pysrc-string">'N'</span>}
<span class="pysrc-except">Traceback (most recent call last):</span>
<span class="pysrc-except">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span>
<span class="pysrc-except">TypeError: list objects are unhashable</span></pre>
</td>
</tr></table></td></tr>
</table></div>
</div>
<div class="section" id="default-dictionaries">
<h3>Default Dictionaries</h3>
<p>If we try to access a key that is not in a dictionary, we get an error.
However, its often useful if a dictionary can automatically create
an entry for this new key and give it a default value, such as zero or
the empty list.  For this reason, a special kind of dictionary
called a <tt class="doctest"><span class="pre">defaultdict</span></tt> is available.
In order to use it, we have to supply a parameter which can be used to
create the default value, e.g. <tt class="doctest"><span class="pre">int</span></tt>, <tt class="doctest"><span class="pre">float</span></tt>, <tt class="doctest"><span class="pre">str</span></tt>, <tt class="doctest"><span class="pre">list</span></tt>, <tt class="doctest"><span class="pre">dict</span></tt>,
<tt class="doctest"><span class="pre">tuple</span></tt>.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">from</span> collections <span class="pysrc-keyword">import</span> defaultdict
<span class="pysrc-prompt">&gt;&gt;&gt; </span>frequency = defaultdict(int)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>frequency[<span class="pysrc-string">'colorless'</span>] = 4
<span class="pysrc-prompt">&gt;&gt;&gt; </span>frequency[<span class="pysrc-string">'ideas'</span>]
<span class="pysrc-output">0</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>pos = defaultdict(list)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>pos[<span class="pysrc-string">'sleep'</span>] = [<span class="pysrc-string">'NOUN'</span>, <span class="pysrc-string">'VERB'</span>]
<span class="pysrc-prompt">&gt;&gt;&gt; </span>pos[<span class="pysrc-string">'ideas'</span>]
<span class="pysrc-output">[]</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last">These default values are actually functions that convert other
objects to the specified type (e.g. <tt class="doctest"><span class="pre">int(<span class="pysrc-string">&quot;2&quot;</span>)</span></tt>, <tt class="doctest"><span class="pre">list(<span class="pysrc-string">&quot;2&quot;</span>)</span></tt>).
When they are called with no parameter &#8212; <tt class="doctest"><span class="pre">int()</span></tt>, <tt class="doctest"><span class="pre">list()</span></tt>
&#8212; they return <tt class="doctest"><span class="pre">0</span></tt> and <tt class="doctest"><span class="pre">[]</span></tt> respectively.</p>
</div>
<p>The above examples specified the default value of a dictionary entry to
be the default value of a particular data type.  However, we can specify
any default value we like, simply by providing the name of a function
that can be called with no arguments to create the required value.
Let's return to our part-of-speech example, and create a dictionary
whose default value for any entry is <tt class="doctest"><span class="pre"><span class="pysrc-string">'N'</span></span></tt> <a class="reference internal" href="#default-noun"><span id="ref-default-noun"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></span></a>.
When we access a non-existent entry <a class="reference internal" href="#non-existent"><span id="ref-non-existent"><img src="callouts/callout2.gif" alt="[2]" class="callout" /></span></a>,
it is automatically added to the dictionary <a class="reference internal" href="#automatically-added"><span id="ref-automatically-added"><img src="callouts/callout3.gif" alt="[3]" class="callout" /></span></a>.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>pos = defaultdict(<span class="pysrc-keyword">lambda</span>: <span class="pysrc-string">'NOUN'</span>) <a name="default-noun" /><a href="#ref-default-noun"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></a>
<span class="pysrc-prompt">&gt;&gt;&gt; </span>pos[<span class="pysrc-string">'colorless'</span>] = <span class="pysrc-string">'ADJ'</span>
<span class="pysrc-prompt">&gt;&gt;&gt; </span>pos[<span class="pysrc-string">'blog'</span>] <a name="non-existent" /><a href="#ref-non-existent"><img src="callouts/callout2.gif" alt="[2]" class="callout" /></a>
<span class="pysrc-output">'NOUN'</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>list(pos.items())
<span class="pysrc-output">[('blog', 'NOUN'), ('colorless', 'ADJ')] # [_automatically-added]</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<div class="note">
<p class="first admonition-title">Note</p>
<p>The above example used a <span class="emphasis">lambda expression</span>, introduced in
<a class="reference internal" href="#sec-functions">13.8</a>.  This lambda expression specifies no
parameters, so we call it using parentheses with no arguments.
Thus, the definitions of <tt class="doctest"><span class="pre">f</span></tt> and <tt class="doctest"><span class="pre">g</span></tt> below are equivalent:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>f = <span class="pysrc-keyword">lambda</span>: <span class="pysrc-string">'NOUN'</span>
<span class="pysrc-prompt">&gt;&gt;&gt; </span>f()
<span class="pysrc-output">'NOUN'</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">def</span> <span class="pysrc-defname">g</span>():
<span class="pysrc-more">... </span>    return <span class="pysrc-string">'NOUN'</span>
<span class="pysrc-prompt">&gt;&gt;&gt; </span>g()
<span class="pysrc-output">'NOUN'</span></pre>
</td>
</tr></table></td></tr>
</table></div>
</div>
<p>Let's see how default dictionaries could be used in a more substantial
language processing task.
Many language processing tasks &#8212; including tagging &#8212; struggle to correctly process
the hapaxes of a text.  They can perform better with a fixed vocabulary and a
guarantee that no new words will appear.  We can preprocess a text to replace
low-frequency words with a special &quot;out of vocabulary&quot; token <tt class="doctest"><span class="pre">UNK</span></tt>, with
the help of a default dictionary.  (Can you work out how to do this without
reading on?)</p>
<p>We need to create a default dictionary that maps each word to its replacement.
The most frequent <span class="math">n</span> words will be mapped to themselves.
Everything else will be mapped to <tt class="doctest"><span class="pre">UNK</span></tt>.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>alice = nltk.corpus.gutenberg.words(<span class="pysrc-string">'carroll-alice.txt'</span>)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>vocab = nltk.FreqDist(alice)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>v1000 = [word <span class="pysrc-keyword">for</span> (word, _) <span class="pysrc-keyword">in</span> vocab.most_common(1000)]
<span class="pysrc-prompt">&gt;&gt;&gt; </span>mapping = defaultdict(<span class="pysrc-keyword">lambda</span>: <span class="pysrc-string">'UNK'</span>)
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">for</span> v <span class="pysrc-keyword">in</span> v1000:
<span class="pysrc-more">... </span>    mapping[v] = v
<span class="pysrc-more">...</span>
<span class="pysrc-prompt">&gt;&gt;&gt; </span>alice2 = [mapping[v] <span class="pysrc-keyword">for</span> v <span class="pysrc-keyword">in</span> alice]
<span class="pysrc-prompt">&gt;&gt;&gt; </span>alice2[:100]
<span class="pysrc-output">['UNK', 'Alice', &quot;'&quot;, 's', 'UNK', 'in', 'UNK', 'by', 'UNK', 'UNK', 'UNK',</span>
<span class="pysrc-output">'UNK', 'CHAPTER', 'I', '.', 'UNK', 'the', 'Rabbit', '-', 'UNK', 'Alice',</span>
<span class="pysrc-output">'was', 'beginning', 'to', 'get', 'very', 'tired', 'of', 'sitting', 'by',</span>
<span class="pysrc-output">'her', 'sister', 'on', 'the', 'UNK', ',', 'and', 'of', 'having', 'nothing',</span>
<span class="pysrc-output">'to', 'do', ':', 'once', 'or', 'twice', 'she', 'had', 'UNK', 'into', 'the',</span>
<span class="pysrc-output">'book', 'her', 'sister', 'was', 'UNK', ',', 'but', 'it', 'had', 'no',</span>
<span class="pysrc-output">'pictures', 'or', 'UNK', 'in', 'it', ',', &quot;'&quot;, 'and', 'what', 'is', 'the',</span>
<span class="pysrc-output">'use', 'of', 'a', 'book', &quot;,'&quot;, 'thought', 'Alice', &quot;'&quot;, 'without',</span>
<span class="pysrc-output">'pictures', 'or', 'conversation', &quot;?'&quot; ...]</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>len(set(alice2))
<span class="pysrc-output">1001</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<!-- note: |TRY|
Repeat the above example for different vocabulary sizes and different texts.
How small a vocabulary can you tolerate while still getting something useful
from the text? -->
</div>
<div class="section" id="incrementally-updating-a-dictionary">
<h3>Incrementally Updating a Dictionary</h3>
<p>We can employ dictionaries to count occurrences, emulating the method
for tallying words shown in <a class="reference external" href="ch01.html#fig-tally">fig-tally</a>.
We begin by initializing an empty <tt class="doctest"><span class="pre">defaultdict</span></tt>, then process each
part-of-speech tag in the text.  If the tag hasn't been seen before,
it will have a zero count by default.  Each time we encounter a tag,
we increment its count using the <tt class="doctest"><span class="pre">+=</span></tt> operator.</p>
<span class="target" id="code-dictionary"></span><div class="pylisting">
<table border="0" cellpadding="0" cellspacing="0" class="pylisting" width="95%">
<tr><td class="codeblock">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_codeblock_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">from</span> collections <span class="pysrc-keyword">import</span> defaultdict
<span class="pysrc-prompt">&gt;&gt;&gt; </span>counts = defaultdict(int)
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">from</span> nltk.corpus <span class="pysrc-keyword">import</span> brown
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">for</span> (word, tag) <span class="pysrc-keyword">in</span> brown.tagged_words(categories=<span class="pysrc-string">'news'</span>, tagset=<span class="pysrc-string">'universal'</span>):
<span class="pysrc-more">... </span>    counts[tag] += 1
<span class="pysrc-more">...</span>
<span class="pysrc-prompt">&gt;&gt;&gt; </span>counts[<span class="pysrc-string">'NOUN'</span>]
30640
<span class="pysrc-prompt">&gt;&gt;&gt; </span>sorted(counts)
[<span class="pysrc-string">'.'</span>, <span class="pysrc-string">'ADJ'</span>, <span class="pysrc-string">'ADP'</span>, <span class="pysrc-string">'ADV'</span>, <span class="pysrc-string">'CONJ'</span>, <span class="pysrc-string">'DET'</span>, <span class="pysrc-string">'NOUN'</span>, <span class="pysrc-string">'NUM'</span>, <span class="pysrc-string">'PRON'</span>, <span class="pysrc-string">'PRT'</span>, <span class="pysrc-string">'VERB'</span>, <span class="pysrc-string">'X'</span>]

<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">from</span> operator <span class="pysrc-keyword">import</span> itemgetter
<span class="pysrc-prompt">&gt;&gt;&gt; </span>sorted(counts.items(), key=itemgetter(1), reverse=True)
[(<span class="pysrc-string">'NOUN'</span>, 30640), (<span class="pysrc-string">'VERB'</span>, 14399), (<span class="pysrc-string">'ADP'</span>, 12355), (<span class="pysrc-string">'.'</span>, 11928), ...]
<span class="pysrc-prompt">&gt;&gt;&gt; </span>[t <span class="pysrc-keyword">for</span> t, c <span class="pysrc-keyword">in</span> sorted(counts.items(), key=itemgetter(1), reverse=True)]
[<span class="pysrc-string">'NOUN'</span>, <span class="pysrc-string">'VERB'</span>, <span class="pysrc-string">'ADP'</span>, <span class="pysrc-string">'.'</span>, <span class="pysrc-string">'DET'</span>, <span class="pysrc-string">'ADJ'</span>, <span class="pysrc-string">'ADV'</span>, <span class="pysrc-string">'CONJ'</span>, <span class="pysrc-string">'PRON'</span>, <span class="pysrc-string">'PRT'</span>, <span class="pysrc-string">'NUM'</span>, <span class="pysrc-string">'X'</span>]</pre>
</td>
</tr></table></td></tr>
<tr><td class="caption"><p class="caption"><a class="reference external" href="pylisting/code_dictionary.py" type="text/x-python"><span class="caption-label">Example 13.10 (code_dictionary.py)</span></a>: <span class="caption-label">Figure 13.10</span>: Incrementally Updating a Dictionary, and Sorting by Value</td></tr></p>
</table></div>
<p>The listing in <a class="reference internal" href="#code-dictionary">13.10</a> illustrates an important idiom for
sorting a dictionary by its values, to show words in decreasing
order of frequency.  The first parameter of <tt class="doctest"><span class="pre">sorted()</span></tt> is the items
to sort, a list of tuples consisting of a POS tag and a frequency.
The second parameter specifies the sort key using a function <tt class="doctest"><span class="pre">itemgetter()</span></tt>.
In general, <tt class="doctest"><span class="pre">itemgetter(n)</span></tt> returns a function that can be called on
some other sequence object to obtain the <span class="math">n</span>th element, e.g.:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>pair = (<span class="pysrc-string">'NP'</span>, 8336)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>pair[1]
<span class="pysrc-output">8336</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>itemgetter(1)(pair)
<span class="pysrc-output">8336</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>The last parameter of <tt class="doctest"><span class="pre">sorted()</span></tt> specifies that the items should be returned
in reverse order, i.e. decreasing values of frequency.</p>
<p>There's a second useful programming idiom at the beginning of
<a class="reference internal" href="#code-dictionary">13.10</a>, where we initialize a <tt class="doctest"><span class="pre">defaultdict</span></tt> and then use a
<tt class="doctest"><span class="pre"><span class="pysrc-keyword">for</span></span></tt> loop to update its values. Here's a schematic version:</p>
<div class="line-block">
<div class="line"><tt class="doctest"><span class="pre"><span class="pysrc-prompt">&gt;&gt;&gt; </span>my_dictionary = defaultdict(</span></tt><em>function to create default value</em><tt class="doctest"><span class="pre">)</span></tt></div>
<div class="line"><tt class="doctest"><span class="pre"><span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">for</span></span></tt> <em>item</em> <tt class="doctest"><span class="pre"><span class="pysrc-keyword">in</span></span></tt> <em>sequence</em><tt class="doctest"><span class="pre">:</span></tt></div>
<div class="line"><tt class="doctest"><span class="pre"><span class="pysrc-more">... </span>     my_dictionary[</span></tt><em>item_key</em><tt class="doctest"><span class="pre">]</span></tt> <em>is updated with information about item</em></div>
</div>
<p>Here's another instance of this pattern, where we index words according to their last two letters:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>last_letters = defaultdict(list)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>words = nltk.corpus.words.words(<span class="pysrc-string">'en'</span>)
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">for</span> word <span class="pysrc-keyword">in</span> words:
<span class="pysrc-more">... </span>    key = word[-2:]
<span class="pysrc-more">... </span>    last_letters[key].append(word)
<span class="pysrc-more">...</span>
<span class="pysrc-prompt">&gt;&gt;&gt; </span>last_letters[<span class="pysrc-string">'ly'</span>]
<span class="pysrc-output">['abactinally', 'abandonedly', 'abasedly', 'abashedly', 'abashlessly', 'abbreviately',</span>
<span class="pysrc-output">'abdominally', 'abhorrently', 'abidingly', 'abiogenetically', 'abiologically', ...]</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>last_letters[<span class="pysrc-string">'zy'</span>]
<span class="pysrc-output">['blazy', 'bleezy', 'blowzy', 'boozy', 'breezy', 'bronzy', 'buzzy', 'Chazy', ...]</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>The following example uses the same pattern to create an anagram dictionary.
(You might experiment with the third line to get an idea of why this program works.)</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>anagrams = defaultdict(list)
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">for</span> word <span class="pysrc-keyword">in</span> words:
<span class="pysrc-more">... </span>    key = <span class="pysrc-string">''</span>.join(sorted(word))
<span class="pysrc-more">... </span>    anagrams[key].append(word)
<span class="pysrc-more">...</span>
<span class="pysrc-prompt">&gt;&gt;&gt; </span>anagrams[<span class="pysrc-string">'aeilnrt'</span>]
<span class="pysrc-output">['entrail', 'latrine', 'ratline', 'reliant', 'retinal', 'trenail']</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Since accumulating words like this is such a common task,
NLTK provides a more convenient way of creating a <tt class="doctest"><span class="pre">defaultdict(list)</span></tt>,
in the form of <tt class="doctest"><span class="pre">nltk.Index()</span></tt>.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>anagrams = nltk.Index((<span class="pysrc-string">''</span>.join(sorted(w)), w) <span class="pysrc-keyword">for</span> w <span class="pysrc-keyword">in</span> words)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>anagrams[<span class="pysrc-string">'aeilnrt'</span>]
<span class="pysrc-output">['entrail', 'latrine', 'ratline', 'reliant', 'retinal', 'trenail']</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last"><tt class="doctest"><span class="pre">nltk.Index</span></tt> is a <tt class="doctest"><span class="pre">defaultdict(list)</span></tt> with extra support for
initialization.  Similarly,
<tt class="doctest"><span class="pre">nltk.FreqDist</span></tt> is essentially a <tt class="doctest"><span class="pre">defaultdict(int)</span></tt> with extra
support for initialization (along with sorting and plotting methods).</p>
</div>
</div>
<div class="section" id="complex-keys-and-values">
<h3>Complex Keys and Values</h3>
<p>We can use default dictionaries with complex keys and values.
Let's study the range of possible tags for a word, given the
word itself, and the tag of the previous word.  We will see
how this information can be used by a POS tagger.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>pos = defaultdict(<span class="pysrc-keyword">lambda</span>: defaultdict(int))
<span class="pysrc-prompt">&gt;&gt;&gt; </span>brown_news_tagged = brown.tagged_words(categories=<span class="pysrc-string">'news'</span>, tagset=<span class="pysrc-string">'universal'</span>)
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">for</span> ((w1, t1), (w2, t2)) <span class="pysrc-keyword">in</span> nltk.bigrams(brown_news_tagged): <a name="processing-pairs" /><a href="#ref-processing-pairs"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></a>
<span class="pysrc-more">... </span>    pos[(t1, w2)][t2] += 1 <a name="tag-word-update" /><a href="#ref-tag-word-update"><img src="callouts/callout2.gif" alt="[2]" class="callout" /></a>
<span class="pysrc-more">...</span>
<span class="pysrc-prompt">&gt;&gt;&gt; </span>pos[(<span class="pysrc-string">'DET'</span>, <span class="pysrc-string">'right'</span>)] <a name="compound-key" /><a href="#ref-compound-key"><img src="callouts/callout3.gif" alt="[3]" class="callout" /></a>
<span class="pysrc-output">defaultdict(&lt;class 'int'&gt;, {'ADJ': 11, 'NOUN': 5})</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>This example uses a dictionary whose default value for an entry
is a dictionary (whose default value is <tt class="doctest"><span class="pre">int()</span></tt>, i.e. zero).
Notice how we iterated over the bigrams of the tagged
corpus, processing a pair of word-tag pairs for each iteration <a class="reference internal" href="#processing-pairs"><span id="ref-processing-pairs"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></span></a>.
Each time through the loop we updated our <tt class="doctest"><span class="pre">pos</span></tt> dictionary's
entry for <tt class="doctest"><span class="pre">(t1, w2)</span></tt>, a tag and its <em>following</em> word <a class="reference internal" href="#tag-word-update"><span id="ref-tag-word-update"><img src="callouts/callout2.gif" alt="[2]" class="callout" /></span></a>.
When we look up an item in <tt class="doctest"><span class="pre">pos</span></tt> we must specify a compound key <a class="reference internal" href="#compound-key"><span id="ref-compound-key"><img src="callouts/callout3.gif" alt="[3]" class="callout" /></span></a>,
and we get back a dictionary object.
A POS tagger could use such information to decide that the
word <span class="example">right</span>, when preceded by a determiner, should be tagged as <tt class="doctest"><span class="pre">ADJ</span></tt>.</p>
</div>
<div class="section" id="inverting-a-dictionary">
<h3>Inverting a Dictionary</h3>
<p>Dictionaries support efficient lookup, so long as you want to get the value for
any key.  If <tt class="doctest"><span class="pre">d</span></tt> is a dictionary and <tt class="doctest"><span class="pre">k</span></tt> is a key, we type <tt class="doctest"><span class="pre">d[k]</span></tt> and
immediately obtain the value.  Finding a key given a value is slower and more
cumbersome:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>counts = defaultdict(int)
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">for</span> word <span class="pysrc-keyword">in</span> nltk.corpus.gutenberg.words(<span class="pysrc-string">'milton-paradise.txt'</span>):
<span class="pysrc-more">... </span>    counts[word] += 1
<span class="pysrc-more">...</span>
<span class="pysrc-prompt">&gt;&gt;&gt; </span>[key <span class="pysrc-keyword">for</span> (key, value) <span class="pysrc-keyword">in</span> counts.items() <span class="pysrc-keyword">if</span> value == 32]
<span class="pysrc-output">['brought', 'Him', 'virtue', 'Against', 'There', 'thine', 'King', 'mortal',</span>
<span class="pysrc-output">'every', 'been']</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>If we expect to do this kind of &quot;reverse lookup&quot; often, it helps to construct
a dictionary that maps values to keys.  In the case that no two keys have
the same value, this is an easy thing to do.  We just get all the key-value
pairs in the dictionary, and create a new dictionary of value-key
pairs. The next example also illustrates another way of initializing a
dictionary <tt class="doctest"><span class="pre">pos</span></tt> with key-value pairs.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>pos = {<span class="pysrc-string">'colorless'</span>: <span class="pysrc-string">'ADJ'</span>, <span class="pysrc-string">'ideas'</span>: <span class="pysrc-string">'N'</span>, <span class="pysrc-string">'sleep'</span>: <span class="pysrc-string">'V'</span>, <span class="pysrc-string">'furiously'</span>: <span class="pysrc-string">'ADV'</span>}
<span class="pysrc-prompt">&gt;&gt;&gt; </span>pos2 = dict((value, key) <span class="pysrc-keyword">for</span> (key, value) <span class="pysrc-keyword">in</span> pos.items())
<span class="pysrc-prompt">&gt;&gt;&gt; </span>pos2[<span class="pysrc-string">'N'</span>]
<span class="pysrc-output">'ideas'</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Let's first make our part-of-speech dictionary a bit more realistic
and add some more words to <tt class="doctest"><span class="pre">pos</span></tt> using the dictionary <tt class="doctest"><span class="pre"><span class="pysrc-builtin">update</span>()</span></tt> method, to
create the situation where multiple keys have the same value. Then the
technique just shown for reverse lookup will no longer work (why
not?).  Instead, we have to use <tt class="doctest"><span class="pre">append()</span></tt> to accumulate the words
for each part-of-speech, as follows:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>pos.update({<span class="pysrc-string">'cats'</span>: <span class="pysrc-string">'N'</span>, <span class="pysrc-string">'scratch'</span>: <span class="pysrc-string">'V'</span>, <span class="pysrc-string">'peacefully'</span>: <span class="pysrc-string">'ADV'</span>, <span class="pysrc-string">'old'</span>: <span class="pysrc-string">'ADJ'</span>})
<span class="pysrc-prompt">&gt;&gt;&gt; </span>pos2 = defaultdict(list)
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">for</span> key, value <span class="pysrc-keyword">in</span> pos.items():
<span class="pysrc-more">... </span>    pos2[value].append(key)
<span class="pysrc-more">...</span>
<span class="pysrc-prompt">&gt;&gt;&gt; </span>pos2[<span class="pysrc-string">'ADV'</span>]
<span class="pysrc-output">['peacefully', 'furiously']</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Now we have inverted the <tt class="doctest"><span class="pre">pos</span></tt> dictionary, and can look up any part-of-speech and find
all words having that part-of-speech.  We can do the same thing even
more simply using NLTK's support for indexing as follows:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>pos2 = nltk.Index((value, key) <span class="pysrc-keyword">for</span> (key, value) <span class="pysrc-keyword">in</span> pos.items())
<span class="pysrc-prompt">&gt;&gt;&gt; </span>pos2[<span class="pysrc-string">'ADV'</span>]
<span class="pysrc-output">['peacefully', 'furiously']</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>A summary of Python's dictionary methods is given in <a class="reference internal" href="#tab-dict">13.6</a>.</p>
<span class="target" id="tab-dict"></span><table border="1" class="docutils" id="tab-dict">
<colgroup>
<col width="37%" />
<col width="63%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Example</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><tt class="doctest"><span class="pre">d = {}</span></tt></td>
<td>create an empty dictionary and assign it to <tt class="doctest"><span class="pre">d</span></tt></td>
</tr>
<tr><td><tt class="doctest"><span class="pre">d[key] = value</span></tt></td>
<td>assign a value to a given dictionary key</td>
</tr>
<tr><td><tt class="doctest"><span class="pre">d.keys()</span></tt></td>
<td>the list of keys of the dictionary</td>
</tr>
<tr><td><tt class="doctest"><span class="pre">list(d)</span></tt></td>
<td>the list of keys of the dictionary</td>
</tr>
<tr><td><tt class="doctest"><span class="pre">sorted(d)</span></tt></td>
<td>the keys of the dictionary, sorted</td>
</tr>
<tr><td><tt class="doctest"><span class="pre">key <span class="pysrc-keyword">in</span> d</span></tt></td>
<td>test whether a particular key is in the dictionary</td>
</tr>
<tr><td><tt class="doctest"><span class="pre"><span class="pysrc-keyword">for</span> key <span class="pysrc-keyword">in</span> d</span></tt></td>
<td>iterate over the keys of the dictionary</td>
</tr>
<tr><td><tt class="doctest"><span class="pre">d.values()</span></tt></td>
<td>the list of values in the dictionary</td>
</tr>
<tr><td><tt class="doctest"><span class="pre">dict([(k1,v1), (k2,v2), ...])</span></tt></td>
<td>create a dictionary from a list of key-value pairs</td>
</tr>
<tr><td><tt class="doctest"><span class="pre">d1.update(d2)</span></tt></td>
<td>add all items from <tt class="doctest"><span class="pre">d2</span></tt> to <tt class="doctest"><span class="pre">d1</span></tt></td>
</tr>
<tr><td><tt class="doctest"><span class="pre">defaultdict(int)</span></tt></td>
<td>a dictionary whose default value is zero</td>
</tr>
</tbody>
<p class="caption"><span class="caption-label">Table 13.6</span>: <p>Python's Dictionary Methods: A summary of commonly-used methods and idioms
involving dictionaries.</p>
</p>
</table>
</div>
</div>
<div class="section" id="exercises">
<h2>13.12&nbsp;&nbsp;&nbsp;Exercises</h2>
<ol class="arabic">
<li><p class="first">&#9788; Try using the Python interpreter as a calculator, and
typing expressions like <tt class="doctest"><span class="pre">12 / (4 + 1)</span></tt>.</p>
</li>
<li><p class="first">&#9788; Given an alphabet of 26 letters, there are 26 to the power
10, or <tt class="doctest"><span class="pre">26 ** 10</span></tt>, ten-letter strings we can form.  That works out
to <tt class="doctest"><span class="pre">141167095653376L</span></tt> (the <tt class="doctest"><span class="pre">L</span></tt> at the end just indicates that
this is Python's long-number format).  How many hundred-letter
strings are possible?</p>
</li>
<li><p class="first">&#9788; The Python multiplication operation can be applied to lists.
What happens when you type <tt class="doctest"><span class="pre">[<span class="pysrc-string">'Monty'</span>, <span class="pysrc-string">'Python'</span>] * 20</span></tt>,
or <tt class="doctest"><span class="pre">3 * sent1</span></tt>?</p>
</li>
<li><p class="first">&#9788; Review <a class="reference internal" href="#sec-vocabularies-as-sets-of-words">13.3</a> on
vocabularies as sets of words.  How many words are there in <tt class="doctest"><span class="pre">text2</span></tt>?
How many distinct words are there?</p>
</li>
<li><p class="first">&#9788; Compare the lexical diversity scores for humor
and romance fiction in <a class="reference internal" href="#tab-brown-types">13.1</a>.  Which genre is
more lexically diverse?</p>
</li>
<li><p class="first">&#9788; Produce a dispersion plot of the four main protagonists in
<em>Sense and Sensibility</em>: Elinor, Marianne, Edward, and Willoughby.
What can you observe about the different roles played by the males
and females in this novel?  Can you identify the couples?</p>
</li>
<li><p class="first">&#9788; Find the collocations in <tt class="doctest"><span class="pre">text5</span></tt>.</p>
</li>
<li><p class="first">&#9788; Consider the following Python expression: <tt class="doctest"><span class="pre">len(set(text4))</span></tt>.
State the purpose of this expression.  Describe the two steps
involved in performing this computation.</p>
</li>
<li><p class="first">&#9788; Review <a class="reference internal" href="#sec-texts-as-lists-of-words">13.2</a>
on lists and strings.</p>
<ol class="loweralpha simple">
<li>Define a string and assign it to a variable, e.g.,
<tt class="doctest"><span class="pre">my_string = <span class="pysrc-string">'My String'</span></span></tt> (but put something more interesting in the string).
Print the contents of this variable in two ways, first
by simply typing the variable name and pressing enter, then
by using the <tt class="doctest"><span class="pre"><span class="pysrc-keyword">print</span></span></tt> statement.</li>
<li>Try adding the string to itself using <tt class="doctest"><span class="pre">my_string + my_string</span></tt>, or multiplying
it by a number, e.g., <tt class="doctest"><span class="pre">my_string * 3</span></tt>.  Notice that the strings
are joined together without any spaces.  How could you fix this?</li>
</ol>
</li>
<li><p class="first">&#9788; Define a variable <tt class="doctest"><span class="pre">my_sent</span></tt> to be a list of words, using
the syntax <tt class="doctest"><span class="pre">my_sent = [<span class="pysrc-string">&quot;My&quot;</span>, <span class="pysrc-string">&quot;sent&quot;</span>]</span></tt> (but with your own words,
or a favorite saying).</p>
<ol class="loweralpha simple">
<li>Use <tt class="doctest"><span class="pre"><span class="pysrc-string">' '</span>.join(my_sent)</span></tt> to convert this into a string.</li>
<li>Use <tt class="doctest"><span class="pre">split()</span></tt> to split the string back into the list form
you had to start with.</li>
</ol>
</li>
<li><p class="first">&#9788; Define several variables containing lists of words, e.g., <tt class="doctest"><span class="pre">phrase1</span></tt>,
<tt class="doctest"><span class="pre">phrase2</span></tt>, and so on.  Join them together in various combinations (using the plus operator)
to form whole sentences.  What is the relationship between
<tt class="doctest"><span class="pre">len(phrase1 + phrase2)</span></tt> and <tt class="doctest"><span class="pre">len(phrase1) + len(phrase2)</span></tt>?</p>
</li>
<li><p class="first">&#9788; Consider the following two expressions, which have the same
value.  Which one will typically be more relevant in NLP?  Why?</p>
<ol class="loweralpha simple">
<li><tt class="doctest"><span class="pre"><span class="pysrc-string">&quot;Monty Python&quot;</span>[6:12]</span></tt></li>
<li><tt class="doctest"><span class="pre">[<span class="pysrc-string">&quot;Monty&quot;</span>, <span class="pysrc-string">&quot;Python&quot;</span>][1]</span></tt></li>
</ol>
</li>
<li><p class="first">&#9788; We have seen how to represent a sentence as a list of words, where
each word is a sequence of characters.  What does <tt class="doctest"><span class="pre">sent1[2][2]</span></tt> do?
Why?  Experiment with other index values.</p>
</li>
<li><p class="first">&#9788; The first sentence of <tt class="doctest"><span class="pre">text3</span></tt> is provided to you in the
variable <tt class="doctest"><span class="pre">sent3</span></tt>.  The index of <span class="example">the</span> in <tt class="doctest"><span class="pre">sent3</span></tt> is 1, because <tt class="doctest"><span class="pre">sent3[1]</span></tt>
gives us <tt class="doctest"><span class="pre"><span class="pysrc-string">'the'</span></span></tt>.  What are the indexes of the two other occurrences
of this word in <tt class="doctest"><span class="pre">sent3</span></tt>?</p>
</li>
<li><p class="first">&#9788; Review the discussion of conditionals in <a class="reference internal" href="#sec-making-decisions">13.4</a>.
Find all words in the Chat Corpus (<tt class="doctest"><span class="pre">text5</span></tt>)
starting with the letter <span class="example">b</span>.  Show them in alphabetical order.</p>
</li>
<li><p class="first">&#9788; Type the expression <tt class="doctest"><span class="pre">list(range(10))</span></tt> at the interpreter prompt.
Now try <tt class="doctest"><span class="pre">list(range(10, 20))</span></tt>, <tt class="doctest"><span class="pre">list(range(10, 20, 2))</span></tt>, and <tt class="doctest"><span class="pre">list(range(20, 10, -2))</span></tt>.
We will see a variety of uses for this built-in function in later chapters.</p>
</li>
<li><p class="first">&#9788; Find out more about sequence objects using Python's help facility.
In the interpreter, type <tt class="doctest"><span class="pre">help(str)</span></tt>, <tt class="doctest"><span class="pre">help(list)</span></tt>, and <tt class="doctest"><span class="pre">help(tuple)</span></tt>.
This will give you a full list of the functions supported by each type.
Some functions have special names flanked with underscore; as the
help documentation shows, each such function corresponds to something
more familiar.  For example <tt class="doctest"><span class="pre">x.__getitem__(y)</span></tt> is just a long-winded
way of saying <tt class="doctest"><span class="pre">x[y]</span></tt>.</p>
</li>
<li><p class="first">&#9788; Identify three operations that can be performed on both tuples
and lists.  Identify three list operations that cannot be performed on
tuples.  Name a context where using a list instead of a tuple generates
a Python error.</p>
</li>
<li><p class="first">&#9788; Find out how to create a tuple consisting of a single item.
There are at least two ways to do this.</p>
</li>
<li><p class="first">&#9788; Create a list <tt class="doctest"><span class="pre">words = [<span class="pysrc-string">'is'</span>, <span class="pysrc-string">'NLP'</span>, <span class="pysrc-string">'fun'</span>, <span class="pysrc-string">'?'</span>]</span></tt>.  Use
a series of assignment statements (e.g. <tt class="doctest"><span class="pre">words[1] = words[2]</span></tt>)
and a temporary variable <tt class="doctest"><span class="pre">tmp</span></tt> to transform this list into the
list <tt class="doctest"><span class="pre">[<span class="pysrc-string">'NLP'</span>, <span class="pysrc-string">'is'</span>, <span class="pysrc-string">'fun'</span>, <span class="pysrc-string">'!'</span>]</span></tt>.  Now do the same transformation
using tuple assignment.</p>
</li>
<li><p class="first">&#9788; Does the method for creating a sliding window of n-grams
behave correctly for the two limiting cases: <span class="math">n</span> = 1, and <span class="math">n</span> = <tt class="doctest"><span class="pre">len(sent)</span></tt>?</p>
</li>
<li><p class="first">&#9788; We pointed out that when empty strings and empty lists occur
in the condition part of an <tt class="doctest"><span class="pre"><span class="pysrc-keyword">if</span></span></tt> clause, they evaluate to
<tt class="doctest"><span class="pre">False</span></tt>. In this case, they are said to be occurring in a
Boolean context.
Experiment with different kind of non-Boolean expressions in Boolean
contexts, and see whether they evaluate as <tt class="doctest"><span class="pre">True</span></tt> or <tt class="doctest"><span class="pre">False</span></tt>.</p>
</li>
<li><p class="first">&#9788; Use the inequality operators to compare strings, e.g.
<tt class="doctest"><span class="pre"><span class="pysrc-string">'Monty'</span> &lt; <span class="pysrc-string">'Python'</span></span></tt>.  What happens when you do <tt class="doctest"><span class="pre"><span class="pysrc-string">'Z'</span> &lt; <span class="pysrc-string">'a'</span></span></tt>?
Try pairs of strings which have a common prefix, e.g. <tt class="doctest"><span class="pre"><span class="pysrc-string">'Monty'</span> &lt; <span class="pysrc-string">'Montague'</span></span></tt>.
Read up on &quot;lexicographical sort&quot; in order to understand what is
going on here.  Try comparing structured objects, e.g.
<tt class="doctest"><span class="pre">(<span class="pysrc-string">'Monty'</span>, 1) &lt; (<span class="pysrc-string">'Monty'</span>, 2)</span></tt>.  Does this behave as expected?</p>
</li>
<li><p class="first">&#9788; Write code that removes whitespace at the beginning and end of a
string, and normalizes whitespace between words to be a single
space character.</p>
<ol class="arabic simple">
<li>do this task using <tt class="doctest"><span class="pre">split()</span></tt> and <tt class="doctest"><span class="pre">join()</span></tt></li>
<li>do this task using regular expression substitutions</li>
</ol>
</li>
<li><p class="first">&#9681; Use <tt class="doctest"><span class="pre">text9.index()</span></tt> to find the index of the word <span class="example">sunset</span>.
You'll need to insert this word as an argument between the parentheses.
By a process of trial and error, find the slice for the complete sentence that
contains this word.</p>
</li>
<li><p class="first">&#9681; Using list addition, and the <tt class="doctest"><span class="pre">set</span></tt> and <tt class="doctest"><span class="pre">sorted</span></tt> operations, compute the
vocabulary of the sentences <tt class="doctest"><span class="pre">sent1</span></tt> ... <tt class="doctest"><span class="pre">sent8</span></tt>.</p>
</li>
<li><p class="first">&#9681; What is the difference between the following two lines?
Which one will give a larger value?  Will this be the case for other texts?</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>sorted(set(w.lower() <span class="pysrc-keyword">for</span> w <span class="pysrc-keyword">in</span> text1))
<span class="pysrc-prompt">&gt;&gt;&gt; </span>sorted(w.lower() <span class="pysrc-keyword">for</span> w <span class="pysrc-keyword">in</span> set(text1))</pre>
</td>
</tr></table></td></tr>
</table></div>
</li>
<li><p class="first">&#9681; What is the difference between the following two tests:
<tt class="doctest"><span class="pre">w.isupper()</span></tt> and <tt class="doctest"><span class="pre"><span class="pysrc-keyword">not</span> w.islower()</span></tt>?</p>
</li>
<li><p class="first">&#9681; Write the slice expression that extracts the last two words of <tt class="doctest"><span class="pre">text2</span></tt>.</p>
</li>
<li><p class="first">&#9681; Find all the four-letter words in the Chat Corpus (<tt class="doctest"><span class="pre">text5</span></tt>).
With the help of a frequency distribution (<tt class="doctest"><span class="pre">FreqDist</span></tt>), show these
words in decreasing order of frequency.</p>
</li>
<li><p class="first">&#9681; Review the discussion of looping with conditions in <a class="reference internal" href="#sec-making-decisions">13.4</a>.
Use a combination of <tt class="doctest"><span class="pre"><span class="pysrc-keyword">for</span></span></tt> and <tt class="doctest"><span class="pre"><span class="pysrc-keyword">if</span></span></tt> statements to loop over the words of
the movie script for <em>Monty Python and the Holy Grail</em> (<tt class="doctest"><span class="pre">text6</span></tt>)
and <tt class="doctest"><span class="pre"><span class="pysrc-keyword">print</span></span></tt> all the uppercase words, one per line.</p>
</li>
<li><p class="first">&#9681; Write expressions for finding all words in <tt class="doctest"><span class="pre">text6</span></tt> that
meet the conditions listed below.  The result should be in the form of
a list of words: <tt class="doctest"><span class="pre">[<span class="pysrc-string">'word1'</span>, <span class="pysrc-string">'word2'</span>, ...]</span></tt>.</p>
<ol class="loweralpha simple">
<li>Ending in <span class="example">ize</span></li>
<li>Containing the letter <span class="example">z</span></li>
<li>Containing the sequence of letters <span class="example">pt</span></li>
<li>Having all lowercase letters except for an initial capital (i.e., <tt class="doctest"><span class="pre">titlecase</span></tt>)</li>
</ol>
</li>
<li><p class="first">&#9681; Define <tt class="doctest"><span class="pre">sent</span></tt> to be the list of words
<tt class="doctest"><span class="pre">[<span class="pysrc-string">'she'</span>, <span class="pysrc-string">'sells'</span>, <span class="pysrc-string">'sea'</span>, <span class="pysrc-string">'shells'</span>, <span class="pysrc-string">'by'</span>, <span class="pysrc-string">'the'</span>, <span class="pysrc-string">'sea'</span>, <span class="pysrc-string">'shore'</span>]</span></tt>.
Now write code to perform the following tasks:</p>
<ol class="loweralpha simple">
<li>Print all words beginning with <span class="example">sh</span></li>
<li>Print all words longer than four characters</li>
</ol>
</li>
<li><p class="first">&#9681; What does the following Python code do?  <tt class="doctest"><span class="pre">sum(len(w) <span class="pysrc-keyword">for</span> w <span class="pysrc-keyword">in</span> text1)</span></tt>
Can you use it to work out the average word length of a text?</p>
</li>
<li><p class="first">&#9681; Define a function called <tt class="doctest"><span class="pre">vocab_size(text)</span></tt> that has a single
parameter for the text, and which returns the vocabulary size of the text.</p>
</li>
<li><p class="first">&#9681; Define a function <tt class="doctest"><span class="pre">percent(word, text)</span></tt> that calculates
how often a given word occurs in a text, and expresses the result
as a percentage.</p>
</li>
<li><p class="first">&#9681; We have been using sets to store vocabularies.  Try the following
Python expression: <tt class="doctest"><span class="pre">set(sent3) &lt; set(text1)</span></tt>.  Experiment with this using
different arguments to <tt class="doctest"><span class="pre">set()</span></tt>.  What does it do?
Can you think of a practical application for this?</p>
</li>
<li><p class="first">&#9681; Write code to sort words by length. Consult the Python
documentation concerning the <tt class="doctest"><span class="pre">key</span></tt> parameter.</p>
</li>
<li><p class="first">&#9681; Create a list of words and store it in a variable <tt class="doctest"><span class="pre">sent1</span></tt>.
Now assign <tt class="doctest"><span class="pre">sent2 = sent1</span></tt>.  Modify one of the items in <tt class="doctest"><span class="pre">sent1</span></tt>
and verify that <tt class="doctest"><span class="pre">sent2</span></tt> has changed.</p>
<ol class="loweralpha simple">
<li>Now try the same exercise but instead assign <tt class="doctest"><span class="pre">sent2 = sent1[:]</span></tt>.
Modify <tt class="doctest"><span class="pre">sent1</span></tt> again and see what happens to <tt class="doctest"><span class="pre">sent2</span></tt>.  Explain.</li>
<li>Now define <tt class="doctest"><span class="pre">text1</span></tt> to be a list of lists of strings (e.g. to
represent a text consisting of multiple sentences.  Now assign
<tt class="doctest"><span class="pre">text2 = text1[:]</span></tt>, assign a new value to one of the words,
e.g. <tt class="doctest"><span class="pre">text1[1][1] = <span class="pysrc-string">'Monty'</span></span></tt>.  Check what this did to <tt class="doctest"><span class="pre">text2</span></tt>.
Explain.</li>
<li>Load Python's <tt class="doctest"><span class="pre">deepcopy()</span></tt> function (i.e. <tt class="doctest"><span class="pre"><span class="pysrc-keyword">from</span> <span class="pysrc-builtin">copy</span> <span class="pysrc-keyword">import</span> deepcopy</span></tt>),
consult its documentation, and test that it makes a fresh copy of any
object.</li>
</ol>
</li>
<li><p class="first">&#9681; Initialize an <em>n</em>-by-<em>m</em> list of lists of empty strings using list
multiplication, e.g. <tt class="doctest"><span class="pre">word_table = [[<span class="pysrc-string">''</span>] * n] * m</span></tt>.  What happens
when you set one of its values, e.g. <tt class="doctest"><span class="pre">word_table[1][2] = <span class="pysrc-string">&quot;hello&quot;</span></span></tt>?
Explain why this happens.  Now write an expression using <tt class="doctest"><span class="pre">range()</span></tt>
to construct a list of lists, and show that it does not have this problem.</p>
</li>
<li><p class="first">&#9681; Write code to initialize a two-dimensional array of sets called
<tt class="doctest"><span class="pre">word_vowels</span></tt> and process a list of words, adding each
word to <tt class="doctest"><span class="pre">word_vowels[l][v]</span></tt> where <tt class="doctest"><span class="pre">l</span></tt> is the length of the word and <tt class="doctest"><span class="pre">v</span></tt> is
the number of vowels it contains.</p>
</li>
<li><p class="first">&#9681; Write a function <tt class="doctest"><span class="pre">novel10(text)</span></tt> that prints any word that
appeared in the last 10% of a text that had not been encountered earlier.</p>
</li>
<li><p class="first">&#9681; Write a program that takes a sentence expressed as a single string,
splits it and counts up the words.  Get it to print out each word and the
word's frequency, one per line, in alphabetical order.</p>
</li>
<li><p class="first">&#9681; Write a function <tt class="doctest"><span class="pre">shorten(text, n)</span></tt> to process a text, omitting the <span class="math">n</span>
most frequently occurring words of the text.  How readable is it?</p>
</li>
<li><p class="first">&#9681; Write code to print out an index for a lexicon, allowing someone
to look up words according to their meanings (or pronunciations; whatever
properties are contained in lexical entries).</p>
</li>
<li><p class="first">&#9681; Write a list comprehension that sorts a list of WordNet synsets for
proximity to a given synset.  For example, given the synsets
<tt class="doctest"><span class="pre">minke_whale.n.01</span></tt>, <tt class="doctest"><span class="pre">orca.n.01</span></tt>, <tt class="doctest"><span class="pre">novel.n.01</span></tt>, and <tt class="doctest"><span class="pre">tortoise.n.01</span></tt>,
sort them according to their <tt class="doctest"><span class="pre">shortest_path_distance()</span></tt> from <tt class="doctest"><span class="pre">right_whale.n.01</span></tt>.</p>
</li>
<li><p class="first">&#9681; Write a function that takes a list of words (containing duplicates) and
returns a list of words (with no duplicates) sorted by decreasing frequency.
E.g. if the input list contained 10 instances of the word <tt class="doctest"><span class="pre">table</span></tt> and 9 instances
of the word <tt class="doctest"><span class="pre">chair</span></tt>, then <tt class="doctest"><span class="pre">table</span></tt> would appear before <tt class="doctest"><span class="pre">chair</span></tt> in the output
list.</p>
</li>
<li><p class="first">&#9681; Write a function that takes a text and a vocabulary as its arguments
and returns the set of words that appear in the text but not in the
vocabulary.  Both arguments can be represented as lists of strings.
Can you do this in a single line, using <tt class="doctest"><span class="pre">set.difference()</span></tt>?</p>
</li>
<li><p class="first">&#9681; Import the <tt class="doctest"><span class="pre">itemgetter()</span></tt> function from the <tt class="doctest"><span class="pre">operator</span></tt> module in Python's
standard library (i.e. <tt class="doctest"><span class="pre"><span class="pysrc-keyword">from</span> operator <span class="pysrc-keyword">import</span> itemgetter</span></tt>).  Create a list
<tt class="doctest"><span class="pre">words</span></tt> containing several words.  Now try calling:
<tt class="doctest"><span class="pre">sorted(words, key=itemgetter(1))</span></tt>, and <tt class="doctest"><span class="pre">sorted(words, key=itemgetter(-1))</span></tt>.
Explain what <tt class="doctest"><span class="pre">itemgetter()</span></tt> is doing.</p>
</li>
<li><p class="first">&#9681; Write a recursive function <tt class="doctest"><span class="pre">lookup(trie, key)</span></tt> that looks up a key in a trie,
and returns the value it finds.  Extend the function to return a word when it is uniquely
determined by its prefix (e.g. <tt class="doctest"><span class="pre">vanguard</span></tt> is the only word that starts with <tt class="doctest"><span class="pre">vang-</span></tt>,
so <tt class="doctest"><span class="pre">lookup(trie, <span class="pysrc-string">'vang'</span>)</span></tt> should return the same thing as <tt class="doctest"><span class="pre">lookup(trie, <span class="pysrc-string">'vanguard'</span>)</span></tt>).</p>
</li>
<li><p class="first">&#9681; Read up on &quot;keyword linkage&quot; (chapter 5 of <a class="reference external" href="bibliography.html#scott2006" id="id1">(Scott &amp; Tribble, 2006)</a>).  Extract keywords from
NLTK's Shakespeare Corpus and using the NetworkX package, plot keyword linkage networks.</p>
</li>
<li><p class="first">&#9681; Read about string edit distance and the Levenshtein Algorithm.
Try the implementation provided in <tt class="doctest"><span class="pre">nltk.edit_distance()</span></tt>.
In what way is this using dynamic programming?  Does it use the bottom-up or
top-down approach?
[See also <tt class="doctest"><span class="pre">http://norvig.com/spell-correct.html</span></tt>]</p>
</li>
<li><p class="first">&#9681; The Catalan numbers arise in many applications of combinatorial mathematics,
including the counting of parse trees (<a class="reference external" href="ch08.html#sec-grammar-development">6</a>).  The series
can be defined as follows: C<sub>0</sub> = 1, and
C<sub>n+1</sub> = &#931;<sub>0..n</sub> (C<sub>i</sub>C<sub>n-i</sub>).</p>
<ol class="loweralpha simple">
<li>Write a recursive function to compute <span class="math">n</span>th Catalan number C<sub>n</sub>.</li>
<li>Now write another function that does this computation using dynamic programming.</li>
<li>Use the <tt class="doctest"><span class="pre">timeit</span></tt> module to compare the performance of these functions as <span class="math">n</span>
increases.</li>
</ol>
</li>
<li><p class="first">&#9733;
Reproduce some of the results of <a class="reference external" href="bibliography.html#zhao07" id="id2">(Zhao &amp; Zobel, 2007)</a> concerning authorship identification.</p>
</li>
<li><p class="first">&#9733; Study gender-specific lexical choice, and see if you can
reproduce some of the results of <tt class="doctest"><span class="pre">http://www.clintoneast.com/articles/words.php</span></tt></p>
</li>
<li><p class="first">&#9733; Write a recursive function that pretty prints a trie in alphabetically
sorted order, e.g.:</p>
<pre class="literal-block">
chair: 'flesh'
---t: 'cat'
--ic: 'stylish'
---en: 'dog'
</pre>
</li>
<li><p class="first">&#9733; With the help of the trie data structure, write a recursive
function that processes text, locating the uniqueness point in
each word, and discarding the remainder of each word.  How much compression does this
give?  How readable is the resulting text?</p>
</li>
<li><p class="first">&#9733; Obtain some raw text, in the form of a single, long string.
Use Python's <tt class="doctest"><span class="pre">textwrap</span></tt> module to break it up into multiple lines.
Now write code to add extra spaces between words, in order to justify
the output.  Each line must have the same width, and spaces must be
approximately evenly distributed across each line.  No line can
begin or end with a space.</p>
</li>
<li><p class="first">&#9733; Develop a simple extractive summarization tool, that prints the
sentences of a document which contain the highest total word
frequency.  Use <tt class="doctest"><span class="pre">FreqDist()</span></tt> to count word frequencies, and use
<tt class="doctest"><span class="pre">sum</span></tt> to sum the frequencies of the words in each sentence.
Rank the sentences according to their score.  Finally, print the <em>n</em>
highest-scoring sentences in document order.  Carefully review the
design of your program, especially your approach to this double
sorting.  Make sure the program is written as clearly as possible.</p>
</li>
<li><p class="first">&#9733;
Read the following article on semantic orientation of adjectives.
Use the NetworkX package to visualize
a network of adjectives with edges to indicate same vs different
semantic orientation.  <tt class="doctest"><span class="pre">http://www.aclweb.org/anthology/P97-1023</span></tt></p>
</li>
<li><p class="first">&#9733;
Design an algorithm to find the &quot;statistically improbable
phrases&quot; of a document collection.
<tt class="doctest"><span class="pre">http://www.amazon.com/gp/search-inside/sipshelp.html</span></tt></p>
</li>
<li><p class="first">&#9733; Write a program to implement a brute-force algorithm for
discovering word squares, a kind of <span class="math">n</span> &#215; <span class="math">n</span> crossword
in which the entry in the <span class="math">n</span>th row is the same as the entry
in the <span class="math">n</span>th column.  For discussion, see
<tt class="doctest"><span class="pre">http://itre.cis.upenn.edu/~myl/languagelog/archives/002679.html</span></tt></p>
</li>
</ol>
<!-- #. |hard| Extend the program in Example compound-keys_ in the following ways:

a) Define two sets ``verbs`` and ``preps``, and add each verb and preposition
   as they are encountered.  (Note that you can add an item to a set without
   bothering to check whether it is already present.)

b) Create nested loops to display the results, iterating over verbs and
   prepositions in sorted order.  Generate one line of output per verb,
   listing prepositions and attachment ratios as follows:
   ``raised: about 0:3, at 1:0, by 9:0, for 3:6, from 5:0, in 5:5...``

c) We used a tuple to represent a compound key consisting of two strings.
   However, we could have simply concatenated the strings, e.g.
   ``key = verb + ":" + prep``, resulting in a simple string key.
   Why is it better to use tuples for compound keys? -->
<!-- Footer to be used in all chapters -->
<div class="admonition-about-this-document admonition">
<p class="first admonition-title">About this document...</p>
<p>UPDATED FOR NLTK 3.0.
This is a chapter from <em>Natural Language Processing with Python</em>,
by <a class="reference external" href="http://estive.net/">Steven Bird</a>, <a class="reference external" href="http://homepages.inf.ed.ac.uk/ewan/">Ewan Klein</a> and <a class="reference external" href="http://ed.loper.org/">Edward Loper</a>,
Copyright &#169; 2014 the authors.
It is distributed with the <em>Natural Language Toolkit</em> [<tt class="doctest"><span class="pre">http://nltk.org/</span></tt>],
Version 3.0, under the terms of the
<em>Creative Commons Attribution-Noncommercial-No Derivative Works 3.0 United States License</em>
[<a class="reference external" href="http://creativecommons.org/licenses/by-nc-nd/3.0/us/">http://creativecommons.org/licenses/by-nc-nd/3.0/us/</a>].</p>
<p class="last">This document was built on
Sat  2 May 2015 20:52:29 AEST</p>
</div>
</div>
</div>
<div class="system-messages section">
<h1>Docutils System Messages</h1>
<div class="system-message" id="id3">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">ch13.rst2</tt>, line 1798); <em><a href="#id4">backlink</a></em></p>
Unknown target name: &quot;sec-back-to-the-basics&quot;.</div>
<div class="system-message" id="id5">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">ch13.rst2</tt>, line 2230); <em><a href="#id6">backlink</a></em></p>
Unknown target name: &quot;sec-algorithm-design&quot;.</div>
<div class="system-message" id="id7">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">ch13.rst2</tt>, line 2627); <em><a href="#id8">backlink</a></em></p>
Unknown target name: &quot;first-run&quot;.</div>
<div class="system-message" id="id9">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">ch13.rst2</tt>, line 2627); <em><a href="#id10">backlink</a></em></p>
Unknown target name: &quot;second-run&quot;.</div>
</div>
</div>
</body>
</html>
