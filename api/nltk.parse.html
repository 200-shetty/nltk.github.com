

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>parse Package &mdash; NLTK 2.0 documentation</title>
    
    <link rel="stylesheet" href="../_static/agogo.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="NLTK 2.0 documentation" href="../index.html" /> 
  </head>
  <body>
    <div class="header-wrapper">
      <div class="header">
        <div class="headertitle"><a
          href="../index.html">NLTK 2.0 documentation</a></div>
        <div class="rel">
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a>
        </div>
       </div>
    </div>

    <div class="content-wrapper">
      <div class="content">
        <div class="document">
            
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="parse-package">
<h1>parse Package<a class="headerlink" href="#parse-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="id1">
<h2><tt class="xref py py-mod docutils literal"><span class="pre">parse</span></tt> Package<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<span class="target" id="module-nltk.parse"></span><p>NLTK Parsers</p>
<p>Classes and interfaces for producing tree structures that represent
the internal organization of a text.  This task is known as X{parsing}
the text, and the resulting tree structures are called the text&#8217;s
X{parses}.  Typically, the text is a single sentence, and the tree
structure represents the syntactic structure of the sentence.
However, parsers can also be used in other domains.  For example,
parsers can be used to derive the morphological structure of the
morphemes that make up a word, or to derive the discourse structure
for a set of utterances.</p>
<p>Sometimes, a single piece of text can be represented by more than one
tree structure.  Texts represented by more than one tree structure are
called X{ambiguous} texts.  Note that there are actually two ways in
which a text can be ambiguous:</p>
<blockquote>
<div><ul class="simple">
<li>The text has multiple correct parses.</li>
<li>There is not enough information to decide which of several
candidate parses is correct.</li>
</ul>
</div></blockquote>
<p>However, the parser module does I{not} distinguish these two types of
ambiguity.</p>
<p>The parser module defines C{ParserI}, a standard interface for parsing
texts; and two simple implementations of that interface,
C{ShiftReduceParser} and C{RecursiveDescentParser}.  It also contains
three sub-modules for specialized kinds of parsing:</p>
<blockquote>
<div><ul class="simple">
<li>C{nltk.parser.chart} defines chart parsing, which uses dynamic
programming to efficiently parse texts.</li>
<li>C{nltk.parser.probabilistic} defines probabilistic parsing, which
associates a probability with each parse.</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="module-nltk.parse.api">
<span id="api-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">api</span></tt> Module<a class="headerlink" href="#module-nltk.parse.api" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="nltk.parse.api.ParserI">
<em class="property">class </em><tt class="descclassname">nltk.parse.api.</tt><tt class="descname">ParserI</tt><a class="reference internal" href="../_modules/nltk/parse/api.html#ParserI"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.api.ParserI" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>A processing class for deriving trees that represent possible
structures for a sequence of tokens.  These tree structures are
known as X{parses}.  Typically, parsers are used to derive syntax
trees for sentences.  But parsers can also be used to derive other
kinds of tree structure, such as morphological trees and discourse
structures.</p>
<dl class="docutils">
<dt>Subclasses must define:</dt>
<dd><ul class="first last simple">
<li>at least one of: L{parse()}, L{nbest_parse()}, L{iter_parse()},
L{batch_parse()}, L{batch_nbest_parse()}, L{batch_iter_parse()}.</li>
</ul>
</dd>
<dt>Subclasses may define:</dt>
<dd><ul class="first last simple">
<li>L{grammar()}</li>
<li>either L{prob_parse()} or L{batch_prob_parse()} (or both)</li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="nltk.parse.api.ParserI.batch_iter_parse">
<tt class="descname">batch_iter_parse</tt><big>(</big><em>sents</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/api.html#ParserI.batch_iter_parse"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.api.ParserI.batch_iter_parse" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply L{self.iter_parse()} to each element of C{sents}.  I.e.:</p>
<blockquote>
<div>return [self.iter_parse(sent) for sent in sents]</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">list of iter of L{Tree}</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.parse.api.ParserI.batch_nbest_parse">
<tt class="descname">batch_nbest_parse</tt><big>(</big><em>sents</em>, <em>n=None</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/api.html#ParserI.batch_nbest_parse"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.api.ParserI.batch_nbest_parse" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply L{self.nbest_parse()} to each element of C{sents}.  I.e.:</p>
<blockquote>
<div>return [self.nbest_parse(sent, n) for sent in sents]</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">list of list of L{Tree}</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.parse.api.ParserI.batch_parse">
<tt class="descname">batch_parse</tt><big>(</big><em>sents</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/api.html#ParserI.batch_parse"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.api.ParserI.batch_parse" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply L{self.parse()} to each element of C{sents}.  I.e.:</p>
<blockquote>
<div>return [self.parse(sent) for sent in sents]</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">list of L{Tree}</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.parse.api.ParserI.batch_prob_parse">
<tt class="descname">batch_prob_parse</tt><big>(</big><em>sents</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/api.html#ParserI.batch_prob_parse"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.api.ParserI.batch_prob_parse" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply L{self.prob_parse()} to each element of C{sents}.  I.e.:</p>
<blockquote>
<div>return [self.prob_parse(sent) for sent in sents]</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">list of L{ProbDistI} of L{Tree}</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.parse.api.ParserI.grammar">
<tt class="descname">grammar</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/parse/api.html#ParserI.grammar"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.api.ParserI.grammar" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The grammar used by this parser.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.parse.api.ParserI.iter_parse">
<tt class="descname">iter_parse</tt><big>(</big><em>sent</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/api.html#ParserI.iter_parse"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.api.ParserI.iter_parse" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">An iterator that generates parse trees that represent</td>
</tr>
</tbody>
</table>
<p>possible structures for the given sentence.  When possible,
this list is sorted from most likely to least likely.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>sent</strong> (<em>L{list} of L{string}</em>) &#8211; The sentence to be parsed</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">iter of L{Tree}</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.parse.api.ParserI.nbest_parse">
<tt class="descname">nbest_parse</tt><big>(</big><em>sent</em>, <em>n=None</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/api.html#ParserI.nbest_parse"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.api.ParserI.nbest_parse" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A list of parse trees that represent possible</td>
</tr>
</tbody>
</table>
<p>structures for the given sentence.  When possible, this list is
sorted from most likely to least likely.  If C{n} is
specified, then the returned list will contain at most C{n}
parse trees.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>sent</strong> (<em>L{list} of L{string}</em>) &#8211; The sentence to be parsed</li>
<li><strong>n</strong> (<em>int</em>) &#8211; The maximum number of trees to return.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">list of L{Tree}</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.parse.api.ParserI.parse">
<tt class="descname">parse</tt><big>(</big><em>sent</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/api.html#ParserI.parse"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.api.ParserI.parse" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A parse tree that represents the structure of the</td>
</tr>
</tbody>
</table>
<p>given sentence, or None if no parse tree is found.  If
multiple parses are found, then return the best parse.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>sent</strong> (<em>L{list} of L{string}</em>) &#8211; The sentence to be parsed</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">L{Tree}</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.parse.api.ParserI.prob_parse">
<tt class="descname">prob_parse</tt><big>(</big><em>sent</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/api.html#ParserI.prob_parse"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.api.ParserI.prob_parse" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A probability distribution over the possible parse</td>
</tr>
</tbody>
</table>
<p>trees for the given sentence.  If there are no possible parse
trees for the given sentence, return a probability distribution
that assigns a probability of 1.0 to None.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>sent</strong> (<em>L{list} of L{string}</em>) &#8211; The sentence to be parsed</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">L{ProbDistI} of L{Tree}</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-nltk.parse.chart">
<span id="chart-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">chart</span></tt> Module<a class="headerlink" href="#module-nltk.parse.chart" title="Permalink to this headline">¶</a></h2>
<p>Data classes and parser implementations for &#8220;chart parsers&#8221;, which
use dynamic programming to efficiently parse a text.  A X{chart
parser} derives parse trees for a text by iteratively adding &#8220;edges&#8221;
to a &#8220;chart.&#8221;  Each X{edge} represents a hypothesis about the tree
structure for a subsequence of the text.  The X{chart} is a
&#8220;blackboard&#8221; for composing and combining these hypotheses.</p>
<p>When a chart parser begins parsing a text, it creates a new (empty)
chart, spanning the text.  It then incrementally adds new edges to the
chart.  A set of X{chart rules} specifies the conditions under which
new edges should be added to the chart.  Once the chart reaches a
stage where none of the chart rules adds any new edges, parsing is
complete.</p>
<p>Charts are encoded with the L{Chart} class, and edges are encoded with
the L{TreeEdge} and L{LeafEdge} classes.  The chart parser module
defines three chart parsers:</p>
<blockquote>
<div><ul class="simple">
<li>C{ChartParser} is a simple and flexible chart parser.  Given a
set of chart rules, it will apply those rules to the chart until
no more edges are added.</li>
<li>C{SteppingChartParser} is a subclass of C{ChartParser} that can
be used to step through the parsing process.</li>
</ul>
</div></blockquote>
<dl class="class">
<dt id="nltk.parse.chart.AbstractChartRule">
<em class="property">class </em><tt class="descclassname">nltk.parse.chart.</tt><tt class="descname">AbstractChartRule</tt><a class="reference internal" href="../_modules/nltk/parse/chart.html#AbstractChartRule"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.chart.AbstractChartRule" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.parse.chart.ChartRuleI" title="nltk.parse.chart.ChartRuleI"><tt class="xref py py-class docutils literal"><span class="pre">nltk.parse.chart.ChartRuleI</span></tt></a></p>
<p>An abstract base class for chart rules.  C{AbstractChartRule}
provides:</p>
<blockquote>
<div><ul class="simple">
<li>A default implementation for C{apply}, based on C{apply_iter}.</li>
<li>A default implementation for C{apply_everywhere_iter},
based on C{apply_iter}.</li>
<li>A default implementation for C{apply_everywhere}, based on
C{apply_everywhere_iter}.  Currently, this implementation
assumes that C{NUM_EDGES}&lt;=3.</li>
<li>A default implementation for C{__str__}, which returns a
name basd on the rule&#8217;s class name.</li>
</ul>
</div></blockquote>
<dl class="method">
<dt id="nltk.parse.chart.AbstractChartRule.apply">
<tt class="descname">apply</tt><big>(</big><em>chart</em>, <em>grammar</em>, <em>*edges</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/chart.html#AbstractChartRule.apply"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.chart.AbstractChartRule.apply" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nltk.parse.chart.AbstractChartRule.apply_everywhere">
<tt class="descname">apply_everywhere</tt><big>(</big><em>chart</em>, <em>grammar</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/chart.html#AbstractChartRule.apply_everywhere"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.chart.AbstractChartRule.apply_everywhere" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nltk.parse.chart.AbstractChartRule.apply_everywhere_iter">
<tt class="descname">apply_everywhere_iter</tt><big>(</big><em>chart</em>, <em>grammar</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/chart.html#AbstractChartRule.apply_everywhere_iter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.chart.AbstractChartRule.apply_everywhere_iter" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nltk.parse.chart.AbstractChartRule.apply_iter">
<tt class="descname">apply_iter</tt><big>(</big><em>chart</em>, <em>grammar</em>, <em>*edges</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/chart.html#AbstractChartRule.apply_iter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.chart.AbstractChartRule.apply_iter" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.parse.chart.BottomUpChartParser">
<em class="property">class </em><tt class="descclassname">nltk.parse.chart.</tt><tt class="descname">BottomUpChartParser</tt><big>(</big><em>grammar</em>, <em>**parser_args</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/chart.html#BottomUpChartParser"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.chart.BottomUpChartParser" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.parse.chart.ChartParser" title="nltk.parse.chart.ChartParser"><tt class="xref py py-class docutils literal"><span class="pre">nltk.parse.chart.ChartParser</span></tt></a></p>
<p>A L{ChartParser} using a bottom-up parsing strategy.
See L{ChartParser} for more information.</p>
</dd></dl>

<dl class="class">
<dt id="nltk.parse.chart.BottomUpLeftCornerChartParser">
<em class="property">class </em><tt class="descclassname">nltk.parse.chart.</tt><tt class="descname">BottomUpLeftCornerChartParser</tt><big>(</big><em>grammar</em>, <em>**parser_args</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/chart.html#BottomUpLeftCornerChartParser"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.chart.BottomUpLeftCornerChartParser" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.parse.chart.ChartParser" title="nltk.parse.chart.ChartParser"><tt class="xref py py-class docutils literal"><span class="pre">nltk.parse.chart.ChartParser</span></tt></a></p>
<p>A L{ChartParser} using a bottom-up left-corner parsing strategy.
This strategy is often more efficient than standard bottom-up.
See L{ChartParser} for more information.</p>
</dd></dl>

<dl class="class">
<dt id="nltk.parse.chart.BottomUpPredictCombineRule">
<em class="property">class </em><tt class="descclassname">nltk.parse.chart.</tt><tt class="descname">BottomUpPredictCombineRule</tt><a class="reference internal" href="../_modules/nltk/parse/chart.html#BottomUpPredictCombineRule"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.chart.BottomUpPredictCombineRule" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.parse.chart.BottomUpPredictRule" title="nltk.parse.chart.BottomUpPredictRule"><tt class="xref py py-class docutils literal"><span class="pre">nltk.parse.chart.BottomUpPredictRule</span></tt></a></p>
<p>A rule licensing any edge corresponding to a production whose
right-hand side begins with a complete edge&#8217;s left-hand side.  In
particular, this rule specifies that:</p>
<blockquote>
<div><ul class="simple">
<li>[A S{-&gt;} S{alpha} <a href="#id2"><span class="problematic" id="id3">*</span></a>]</li>
</ul>
</div></blockquote>
<dl class="docutils">
<dt>licenses the edge:</dt>
<dd><ul class="first last simple">
<li>[B S{-&gt;} A * S{beta}]</li>
</ul>
</dd>
</dl>
<p>for each grammar production C{B S{-&gt;} A S{beta}}.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Note :</th><td class="field-body">This is like L{BottomUpPredictRule}, but it also applies</td>
</tr>
</tbody>
</table>
<p>the L{FundamentalRule} to the resulting edge.</p>
<dl class="attribute">
<dt id="nltk.parse.chart.BottomUpPredictCombineRule.NUM_EDGES">
<tt class="descname">NUM_EDGES</tt><em class="property"> = 1</em><a class="headerlink" href="#nltk.parse.chart.BottomUpPredictCombineRule.NUM_EDGES" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nltk.parse.chart.BottomUpPredictCombineRule.apply_iter">
<tt class="descname">apply_iter</tt><big>(</big><em>chart</em>, <em>grammar</em>, <em>edge</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/chart.html#BottomUpPredictCombineRule.apply_iter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.chart.BottomUpPredictCombineRule.apply_iter" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.parse.chart.BottomUpPredictRule">
<em class="property">class </em><tt class="descclassname">nltk.parse.chart.</tt><tt class="descname">BottomUpPredictRule</tt><a class="reference internal" href="../_modules/nltk/parse/chart.html#BottomUpPredictRule"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.chart.BottomUpPredictRule" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.parse.chart.AbstractChartRule" title="nltk.parse.chart.AbstractChartRule"><tt class="xref py py-class docutils literal"><span class="pre">nltk.parse.chart.AbstractChartRule</span></tt></a></p>
<p>A rule licensing any edge corresponding to a production whose
right-hand side begins with a complete edge&#8217;s left-hand side.  In
particular, this rule specifies that:</p>
<blockquote>
<div><ul class="simple">
<li>[A S{-&gt;} S{alpha} <a href="#id4"><span class="problematic" id="id5">*</span></a>]</li>
</ul>
</div></blockquote>
<dl class="docutils">
<dt>licenses the edge:</dt>
<dd><ul class="first last simple">
<li>[B S{-&gt;} * A S{beta}]</li>
</ul>
</dd>
</dl>
<p>for each grammar production C{B S{-&gt;} A S{beta}}.</p>
<dl class="attribute">
<dt id="nltk.parse.chart.BottomUpPredictRule.NUM_EDGES">
<tt class="descname">NUM_EDGES</tt><em class="property"> = 1</em><a class="headerlink" href="#nltk.parse.chart.BottomUpPredictRule.NUM_EDGES" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nltk.parse.chart.BottomUpPredictRule.apply_iter">
<tt class="descname">apply_iter</tt><big>(</big><em>chart</em>, <em>grammar</em>, <em>edge</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/chart.html#BottomUpPredictRule.apply_iter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.chart.BottomUpPredictRule.apply_iter" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.parse.chart.CachedTopDownPredictRule">
<em class="property">class </em><tt class="descclassname">nltk.parse.chart.</tt><tt class="descname">CachedTopDownPredictRule</tt><a class="reference internal" href="../_modules/nltk/parse/chart.html#CachedTopDownPredictRule"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.chart.CachedTopDownPredictRule" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.parse.chart.TopDownPredictRule" title="nltk.parse.chart.TopDownPredictRule"><tt class="xref py py-class docutils literal"><span class="pre">nltk.parse.chart.TopDownPredictRule</span></tt></a></p>
<p>A cached version of L{TopDownPredictRule}.  After the first time
this rule is applied to an edge with a given C{end} and C{next},
it will not generate any more edges for edges with that C{end} and
C{next}.</p>
<p>If C{chart} or C{grammar} are changed, then the cache is flushed.</p>
<dl class="method">
<dt id="nltk.parse.chart.CachedTopDownPredictRule.apply_iter">
<tt class="descname">apply_iter</tt><big>(</big><em>chart</em>, <em>grammar</em>, <em>edge</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/chart.html#CachedTopDownPredictRule.apply_iter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.chart.CachedTopDownPredictRule.apply_iter" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.parse.chart.Chart">
<em class="property">class </em><tt class="descclassname">nltk.parse.chart.</tt><tt class="descname">Chart</tt><big>(</big><em>tokens</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/chart.html#Chart"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.chart.Chart" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>A blackboard for hypotheses about the syntactic constituents of a
sentence.  A chart contains a set of edges, and each edge encodes
a single hypothesis about the structure of some portion of the
sentence.</p>
<p>The L{select} method can be used to select a specific collection
of edges.  For example C{chart.select(is_complete=True, start=0)}
yields all complete edges whose start indices are 0.  To ensure
the efficiency of these selection operations, C{Chart} dynamically
creates and maintains an index for each set of attributes that
have been selected on.</p>
<p>In order to reconstruct the trees that are represented by an edge,
the chart associates each edge with a set of child pointer lists.
A X{child pointer list} is a list of the edges that license an
edge&#8217;s right-hand side.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><ul class="first last simple">
<li><strong>_tokens</strong> &#8211; The sentence that the chart covers.</li>
<li><strong>_num_leaves</strong> &#8211; The number of tokens.</li>
<li><strong>_edges</strong> &#8211; A list of the edges in the chart</li>
<li><strong>_edge_to_cpls</strong> &#8211; A dictionary mapping each edge to a set
of child pointer lists that are associated with that edge.</li>
<li><strong>_indexes</strong> &#8211; A dictionary mapping tuples of edge attributes
to indices, where each index maps the corresponding edge
attribute values to lists of edges.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="nltk.parse.chart.Chart.child_pointer_lists">
<tt class="descname">child_pointer_lists</tt><big>(</big><em>edge</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/chart.html#Chart.child_pointer_lists"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.chart.Chart.child_pointer_lists" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">list of list of C{EdgeI}</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">The set of child pointer lists for the given edge.
Each child pointer list is a list of edges that have
been used to form this edge.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.parse.chart.Chart.dot_digraph">
<tt class="descname">dot_digraph</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/parse/chart.html#Chart.dot_digraph"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.chart.Chart.dot_digraph" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nltk.parse.chart.Chart.edges">
<tt class="descname">edges</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/parse/chart.html#Chart.edges"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.chart.Chart.edges" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A list of all edges in this chart.  New edges
that are added to the chart after the call to edges()
will I{not} be contained in this list.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">list of L{EdgeI}</td>
</tr>
<tr class="field-odd field"><th class="field-name">See :</th><td class="field-body">L{iteredges}, L{select}</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.parse.chart.Chart.initialize">
<tt class="descname">initialize</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/parse/chart.html#Chart.initialize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.chart.Chart.initialize" title="Permalink to this definition">¶</a></dt>
<dd><p>Clear the chart.</p>
</dd></dl>

<dl class="method">
<dt id="nltk.parse.chart.Chart.insert">
<tt class="descname">insert</tt><big>(</big><em>edge</em>, <em>*child_pointer_lists</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/chart.html#Chart.insert"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.chart.Chart.insert" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a new edge to the chart.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>edge</strong> (<em>L{EdgeI}</em>) &#8211; The new edge</li>
<li><strong>child_pointer_lists</strong> (<em>C(sequence} of tuple of L{EdgeI}</em>) &#8211; A sequence of lists of the edges that 
were used to form this edge.  This list is used to reconstruct 
the trees (or partial trees) that are associated with C{edge}.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">bool</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">True if this operation modified the chart.  In
particular, return true iff the chart did not already
contain C{edge}, or if it did not already associate
C{child_pointer_lists} with C{edge}.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.parse.chart.Chart.insert_with_backpointer">
<tt class="descname">insert_with_backpointer</tt><big>(</big><em>new_edge</em>, <em>previous_edge</em>, <em>child_edge</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/chart.html#Chart.insert_with_backpointer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.chart.Chart.insert_with_backpointer" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a new edge to the chart, using a pointer to the previous edge.</p>
</dd></dl>

<dl class="method">
<dt id="nltk.parse.chart.Chart.iteredges">
<tt class="descname">iteredges</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/parse/chart.html#Chart.iteredges"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.chart.Chart.iteredges" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">An iterator over the edges in this chart.  It is 
I{not} guaranteed that new edges which are added to the 
chart before the iterator is exhausted will also be  
generated.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">iter of L{EdgeI}</td>
</tr>
<tr class="field-odd field"><th class="field-name">See :</th><td class="field-body">L{edges}, L{select}</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.parse.chart.Chart.leaf">
<tt class="descname">leaf</tt><big>(</big><em>index</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/chart.html#Chart.leaf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.chart.Chart.leaf" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The leaf value of the word at the given index.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">str</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.parse.chart.Chart.leaves">
<tt class="descname">leaves</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/parse/chart.html#Chart.leaves"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.chart.Chart.leaves" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A list of the leaf values of each word in the
chart&#8217;s sentence.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">list of str</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.parse.chart.Chart.num_edges">
<tt class="descname">num_edges</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/parse/chart.html#Chart.num_edges"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.chart.Chart.num_edges" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The number of edges contained in this chart.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">int</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.parse.chart.Chart.num_leaves">
<tt class="descname">num_leaves</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/parse/chart.html#Chart.num_leaves"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.chart.Chart.num_leaves" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The number of words in this chart&#8217;s sentence.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">int</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.parse.chart.Chart.parses">
<tt class="descname">parses</tt><big>(</big><em>root</em>, <em>tree_class=&lt;class 'nltk.tree.Tree'&gt;</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/chart.html#Chart.parses"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.chart.Chart.parses" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A list of the complete tree structures that span</td>
</tr>
</tbody>
</table>
<p>the entire chart, and whose root node is C{root}.</p>
</dd></dl>

<dl class="method">
<dt id="nltk.parse.chart.Chart.pp">
<tt class="descname">pp</tt><big>(</big><em>width=None</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/chart.html#Chart.pp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.chart.Chart.pp" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A pretty-printed string representation of this chart.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">str</td>
</tr>
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>width</strong> &#8211; The number of characters allotted to each
index in the sentence.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.parse.chart.Chart.pp_edge">
<tt class="descname">pp_edge</tt><big>(</big><em>edge</em>, <em>width=None</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/chart.html#Chart.pp_edge"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.chart.Chart.pp_edge" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A pretty-printed string representation of a given edge
in this chart.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">str</td>
</tr>
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>width</strong> &#8211; The number of characters allotted to each
index in the sentence.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.parse.chart.Chart.pp_leaves">
<tt class="descname">pp_leaves</tt><big>(</big><em>width=None</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/chart.html#Chart.pp_leaves"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.chart.Chart.pp_leaves" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A pretty-printed string representation of this</td>
</tr>
</tbody>
</table>
<p>chart&#8217;s leaves.  This string can be used as a header
for calls to L{pp_edge}.</p>
</dd></dl>

<dl class="method">
<dt id="nltk.parse.chart.Chart.select">
<tt class="descname">select</tt><big>(</big><em>**restrictions</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/chart.html#Chart.select"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.chart.Chart.select" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">An iterator over the edges in this chart.  Any
new edges that are added to the chart before the iterator
is exahusted will also be generated.  C{restrictions}
can be used to restrict the set of edges that will be
generated.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">iter of L{EdgeI}</td>
</tr>
</tbody>
</table>
<p>&#64;kwarg span: Only generate edges C{e} where C{e.span()==span}
&#64;kwarg start: Only generate edges C{e} where C{e.start()==start}
&#64;kwarg end: Only generate edges C{e} where C{e.end()==end}
&#64;kwarg length: Only generate edges C{e} where C{e.length()==length}
&#64;kwarg lhs: Only generate edges C{e} where C{e.lhs()==lhs}
&#64;kwarg rhs: Only generate edges C{e} where C{e.rhs()==rhs}
&#64;kwarg next: Only generate edges C{e} where C{e.next()==next}
&#64;kwarg dot: Only generate edges C{e} where C{e.dot()==dot}
&#64;kwarg is_complete: Only generate edges C{e} where</p>
<blockquote>
<div>C{e.is_complete()==is_complete}</div></blockquote>
<dl class="docutils">
<dt>&#64;kwarg is_incomplete: Only generate edges C{e} where</dt>
<dd>C{e.is_incomplete()==is_incomplete}</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nltk.parse.chart.Chart.trees">
<tt class="descname">trees</tt><big>(</big><em>edge</em>, <em>tree_class=&lt;class 'nltk.tree.Tree'&gt;</em>, <em>complete=False</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/chart.html#Chart.trees"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.chart.Chart.trees" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A list of the tree structures that are associated</td>
</tr>
</tbody>
</table>
<p>with C{edge}.</p>
<p>If C{edge} is incomplete, then the unexpanded children will be
encoded as childless subtrees, whose node value is the
corresponding terminal or nonterminal.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">list of L{Tree}</td>
</tr>
<tr class="field-even field"><th class="field-name">Note :</th><td class="field-body">If two trees share a common subtree, then the same
Tree may be used to encode that subtree in
both trees.  If you need to eliminate this subtree
sharing, then create a deep copy of each tree.</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.parse.chart.ChartParser">
<em class="property">class </em><tt class="descclassname">nltk.parse.chart.</tt><tt class="descname">ChartParser</tt><big>(</big><em>grammar, strategy=[&lt;nltk.parse.chart.LeafInitRule object at 0x4188d10&gt;, &lt;nltk.parse.chart.EmptyPredictRule object at 0x4188c90&gt;, &lt;nltk.parse.chart.BottomUpPredictCombineRule object at 0x4188c10&gt;, &lt;nltk.parse.chart.SingleEdgeFundamentalRule object at 0x4188bd0&gt;], trace=0, trace_chart_width=50, use_agenda=True, chart_class=&lt;class 'nltk.parse.chart.Chart'&gt;</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/chart.html#ChartParser"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.chart.ChartParser" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.parse.api.ParserI" title="nltk.parse.api.ParserI"><tt class="xref py py-class docutils literal"><span class="pre">nltk.parse.api.ParserI</span></tt></a></p>
<p>A generic chart parser.  A X{strategy}, or list of
L{ChartRules&lt;ChartRuleI&gt;}, is used to decide what edges to add to
the chart.  In particular, C{ChartParser} uses the following
algorithm to parse texts:</p>
<blockquote>
<div><ul>
<li><p class="first">Until no new edges are added:
- For each I{rule} in I{strategy}:</p>
<blockquote>
<div><ul class="simple">
<li>Apply I{rule} to any applicable edges in the chart.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first">Return any complete parses in the chart</p>
</li>
</ul>
</div></blockquote>
<dl class="method">
<dt id="nltk.parse.chart.ChartParser.chart_parse">
<tt class="descname">chart_parse</tt><big>(</big><em>tokens</em>, <em>trace=None</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/chart.html#ChartParser.chart_parse"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.chart.ChartParser.chart_parse" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The final parse L{Chart},</td>
</tr>
</tbody>
</table>
<p>from which all possible parse trees can be extracted.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>tokens</strong> (<em>L{list} of L{string}</em>) &#8211; The sentence to be parsed</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">L{Chart}</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.parse.chart.ChartParser.grammar">
<tt class="descname">grammar</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/parse/chart.html#ChartParser.grammar"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.chart.ChartParser.grammar" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nltk.parse.chart.ChartParser.nbest_parse">
<tt class="descname">nbest_parse</tt><big>(</big><em>tokens</em>, <em>n=None</em>, <em>tree_class=&lt;class 'nltk.tree.Tree'&gt;</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/chart.html#ChartParser.nbest_parse"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.chart.ChartParser.nbest_parse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.parse.chart.ChartRuleI">
<em class="property">class </em><tt class="descclassname">nltk.parse.chart.</tt><tt class="descname">ChartRuleI</tt><a class="reference internal" href="../_modules/nltk/parse/chart.html#ChartRuleI"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.chart.ChartRuleI" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>A rule that specifies what new edges are licensed by any given set
of existing edges.  Each chart rule expects a fixed number of
edges, as indicated by the class variable L{NUM_EDGES}.  In
particular:</p>
<blockquote>
<div><ul class="simple">
<li>A chart rule with C{NUM_EDGES=0} specifies what new edges are
licensed, regardless of existing edges.</li>
<li>A chart rule with C{NUM_EDGES=1} specifies what new edges are
licensed by a single existing edge.</li>
<li>A chart rule with C{NUM_EDGES=2} specifies what new edges are
licensed by a pair of existing edges.</li>
</ul>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
</tbody>
</table>
<dl class="docutils">
<dt>&#64;cvar NUM_EDGES: The number of existing edges that this rule uses</dt>
<dd>to license new edges.  Typically, this number ranges from zero
to two.</dd>
</dl>
<dl class="method">
<dt id="nltk.parse.chart.ChartRuleI.apply">
<tt class="descname">apply</tt><big>(</big><em>chart</em>, <em>grammar</em>, <em>*edges</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/chart.html#ChartRuleI.apply"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.chart.ChartRuleI.apply" title="Permalink to this definition">¶</a></dt>
<dd><p>Add the edges licensed by this rule and the given edges to the
chart.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>edges</strong> (<em>list of L{EdgeI}</em>) &#8211; A set of existing edges.  The number of edges
that should be passed to C{apply} is specified by the
L{NUM_EDGES} class variable.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">list of L{EdgeI}</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A list of the edges that were added.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.parse.chart.ChartRuleI.apply_everywhere">
<tt class="descname">apply_everywhere</tt><big>(</big><em>chart</em>, <em>grammar</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/chart.html#ChartRuleI.apply_everywhere"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.chart.ChartRuleI.apply_everywhere" title="Permalink to this definition">¶</a></dt>
<dd><p>Add all the edges licensed by this rule and the edges in the
chart to the chart.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">list of L{EdgeI}</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A list of the edges that were added.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.parse.chart.ChartRuleI.apply_everywhere_iter">
<tt class="descname">apply_everywhere_iter</tt><big>(</big><em>chart</em>, <em>grammar</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/chart.html#ChartRuleI.apply_everywhere_iter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.chart.ChartRuleI.apply_everywhere_iter" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A generator that will add all edges licensed by
this rule, given the edges that are currently in the
chart, one at a time.  Each time the generator is resumed,
it will either add a new edge and yield that edge; or
return.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">iter of L{EdgeI}</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.parse.chart.ChartRuleI.apply_iter">
<tt class="descname">apply_iter</tt><big>(</big><em>chart</em>, <em>grammar</em>, <em>*edges</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/chart.html#ChartRuleI.apply_iter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.chart.ChartRuleI.apply_iter" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A generator that will add edges licensed by this rule
and the given edges to the chart, one at a time.  Each
time the generator is resumed, it will either add a new
edge and yield that edge; or return.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">iter of L{EdgeI}</td>
</tr>
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>edges</strong> (<em>list of L{EdgeI}</em>) &#8211; A set of existing edges.  The number of edges
that should be passed to C{apply} is specified by the
L{NUM_EDGES} class variable.</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.parse.chart.EdgeI">
<em class="property">class </em><tt class="descclassname">nltk.parse.chart.</tt><tt class="descname">EdgeI</tt><a class="reference internal" href="../_modules/nltk/parse/chart.html#EdgeI"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.chart.EdgeI" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>A hypothesis about the structure of part of a sentence.
Each edge records the fact that a structure is (partially)
consistent with the sentence.  An edge contains:</p>
<blockquote>
<div><ul class="simple">
<li>A X{span}, indicating what part of the sentence is
consistent with the hypothesized structure.</li>
<li>A X{left-hand side}, specifying what kind of structure is
hypothesized.</li>
<li>A X{right-hand side}, specifying the contents of the
hypothesized structure.</li>
<li>A X{dot position}, indicating how much of the hypothesized
structure is consistent with the sentence.</li>
</ul>
</div></blockquote>
<p>Every edge is either X{complete} or X{incomplete}:</p>
<blockquote>
<div><ul class="simple">
<li>An edge is X{complete} if its structure is fully consistent
with the sentence.</li>
<li>An edge is X{incomplete} if its structure is partially
consistent with the sentence.  For every incomplete edge, the
span specifies a possible prefix for the edge&#8217;s structure.</li>
</ul>
</div></blockquote>
<p>There are two kinds of edge:</p>
<blockquote>
<div><ul class="simple">
<li>C{TreeEdges&lt;TreeEdge&gt;} record which trees have been found to
be (partially) consistent with the text.</li>
<li>C{LeafEdges&lt;leafEdge&gt;} record the tokens occur in the text.</li>
</ul>
</div></blockquote>
<p>The C{EdgeI} interface provides a common interface to both types
of edge, allowing chart parsers to treat them in a uniform manner.</p>
<dl class="method">
<dt id="nltk.parse.chart.EdgeI.dot">
<tt class="descname">dot</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/parse/chart.html#EdgeI.dot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.chart.EdgeI.dot" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">This edge&#8217;s dot position, which indicates how much of
the hypothesized structure is consistent with the
sentence.  In particular, C{self.rhs[:dot]} is consistent
with C{subtoks[self.start():self.end()]}.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">int</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.parse.chart.EdgeI.end">
<tt class="descname">end</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/parse/chart.html#EdgeI.end"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.chart.EdgeI.end" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The end index of this edge&#8217;s span.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">int</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.parse.chart.EdgeI.is_complete">
<tt class="descname">is_complete</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/parse/chart.html#EdgeI.is_complete"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.chart.EdgeI.is_complete" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">True if this edge&#8217;s structure is fully consistent
with the text.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">bool</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.parse.chart.EdgeI.is_incomplete">
<tt class="descname">is_incomplete</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/parse/chart.html#EdgeI.is_incomplete"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.chart.EdgeI.is_incomplete" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">True if this edge&#8217;s structure is partially consistent
with the text.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">bool</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.parse.chart.EdgeI.length">
<tt class="descname">length</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/parse/chart.html#EdgeI.length"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.chart.EdgeI.length" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The length of this edge&#8217;s span.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">int</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.parse.chart.EdgeI.lhs">
<tt class="descname">lhs</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/parse/chart.html#EdgeI.lhs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.chart.EdgeI.lhs" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">This edge&#8217;s left-hand side, which specifies what kind
of structure is hypothesized by this edge.</td>
</tr>
<tr class="field-even field"><th class="field-name">See :</th><td class="field-body">L{TreeEdge} and L{LeafEdge} for a description of
the left-hand side values for each edge type.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.parse.chart.EdgeI.next">
<tt class="descname">next</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/parse/chart.html#EdgeI.next"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.chart.EdgeI.next" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The element of this edge&#8217;s right-hand side that
immediately follows its dot.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">C{Nonterminal} or X{terminal} or None</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.parse.chart.EdgeI.rhs">
<tt class="descname">rhs</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/parse/chart.html#EdgeI.rhs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.chart.EdgeI.rhs" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">This edge&#8217;s right-hand side, which specifies
the content of the structure hypothesized by this
edge.</td>
</tr>
<tr class="field-even field"><th class="field-name">See :</th><td class="field-body">L{TreeEdge} and L{LeafEdge} for a description of
the right-hand side values for each edge type.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.parse.chart.EdgeI.span">
<tt class="descname">span</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/parse/chart.html#EdgeI.span"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.chart.EdgeI.span" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A tuple C{(s,e)}, where C{subtokens[s:e]} is the
portion of the sentence that is consistent with this
edge&#8217;s structure.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">C{(int, int)}</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.parse.chart.EdgeI.start">
<tt class="descname">start</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/parse/chart.html#EdgeI.start"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.chart.EdgeI.start" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The start index of this edge&#8217;s span.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">int</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.parse.chart.EmptyPredictRule">
<em class="property">class </em><tt class="descclassname">nltk.parse.chart.</tt><tt class="descname">EmptyPredictRule</tt><a class="reference internal" href="../_modules/nltk/parse/chart.html#EmptyPredictRule"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.chart.EmptyPredictRule" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.parse.chart.AbstractChartRule" title="nltk.parse.chart.AbstractChartRule"><tt class="xref py py-class docutils literal"><span class="pre">nltk.parse.chart.AbstractChartRule</span></tt></a></p>
<p>A rule that inserts all empty productions as passive edges,
in every position in the chart.</p>
<dl class="attribute">
<dt id="nltk.parse.chart.EmptyPredictRule.NUM_EDGES">
<tt class="descname">NUM_EDGES</tt><em class="property"> = 0</em><a class="headerlink" href="#nltk.parse.chart.EmptyPredictRule.NUM_EDGES" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nltk.parse.chart.EmptyPredictRule.apply_iter">
<tt class="descname">apply_iter</tt><big>(</big><em>chart</em>, <em>grammar</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/chart.html#EmptyPredictRule.apply_iter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.chart.EmptyPredictRule.apply_iter" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.parse.chart.FilteredBottomUpPredictCombineRule">
<em class="property">class </em><tt class="descclassname">nltk.parse.chart.</tt><tt class="descname">FilteredBottomUpPredictCombineRule</tt><a class="reference internal" href="../_modules/nltk/parse/chart.html#FilteredBottomUpPredictCombineRule"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.chart.FilteredBottomUpPredictCombineRule" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.parse.chart.BottomUpPredictCombineRule" title="nltk.parse.chart.BottomUpPredictCombineRule"><tt class="xref py py-class docutils literal"><span class="pre">nltk.parse.chart.BottomUpPredictCombineRule</span></tt></a></p>
<dl class="method">
<dt id="nltk.parse.chart.FilteredBottomUpPredictCombineRule.apply_iter">
<tt class="descname">apply_iter</tt><big>(</big><em>chart</em>, <em>grammar</em>, <em>edge</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/chart.html#FilteredBottomUpPredictCombineRule.apply_iter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.chart.FilteredBottomUpPredictCombineRule.apply_iter" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.parse.chart.FilteredSingleEdgeFundamentalRule">
<em class="property">class </em><tt class="descclassname">nltk.parse.chart.</tt><tt class="descname">FilteredSingleEdgeFundamentalRule</tt><a class="reference internal" href="../_modules/nltk/parse/chart.html#FilteredSingleEdgeFundamentalRule"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.chart.FilteredSingleEdgeFundamentalRule" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.parse.chart.SingleEdgeFundamentalRule" title="nltk.parse.chart.SingleEdgeFundamentalRule"><tt class="xref py py-class docutils literal"><span class="pre">nltk.parse.chart.SingleEdgeFundamentalRule</span></tt></a></p>
</dd></dl>

<dl class="class">
<dt id="nltk.parse.chart.FundamentalRule">
<em class="property">class </em><tt class="descclassname">nltk.parse.chart.</tt><tt class="descname">FundamentalRule</tt><a class="reference internal" href="../_modules/nltk/parse/chart.html#FundamentalRule"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.chart.FundamentalRule" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.parse.chart.AbstractChartRule" title="nltk.parse.chart.AbstractChartRule"><tt class="xref py py-class docutils literal"><span class="pre">nltk.parse.chart.AbstractChartRule</span></tt></a></p>
<p>A rule that joins two adjacent edges to form a single combined
edge.  In particular, this rule specifies that any pair of edges:</p>
<blockquote>
<div><ul class="simple">
<li>[A S{-&gt;} S{alpha} * B S{beta}][i:j]</li>
<li>[B S{-&gt;} S{gamma} <a href="#id6"><span class="problematic" id="id7">*</span></a>][j:k]</li>
</ul>
</div></blockquote>
<dl class="docutils">
<dt>licenses the edge:</dt>
<dd><ul class="first last simple">
<li>[A S{-&gt;} S{alpha} B * S{beta}][i:j]</li>
</ul>
</dd>
</dl>
<dl class="attribute">
<dt id="nltk.parse.chart.FundamentalRule.NUM_EDGES">
<tt class="descname">NUM_EDGES</tt><em class="property"> = 2</em><a class="headerlink" href="#nltk.parse.chart.FundamentalRule.NUM_EDGES" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nltk.parse.chart.FundamentalRule.apply_iter">
<tt class="descname">apply_iter</tt><big>(</big><em>chart</em>, <em>grammar</em>, <em>left_edge</em>, <em>right_edge</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/chart.html#FundamentalRule.apply_iter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.chart.FundamentalRule.apply_iter" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.parse.chart.LeafEdge">
<em class="property">class </em><tt class="descclassname">nltk.parse.chart.</tt><tt class="descname">LeafEdge</tt><big>(</big><em>leaf</em>, <em>index</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/chart.html#LeafEdge"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.chart.LeafEdge" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.parse.chart.EdgeI" title="nltk.parse.chart.EdgeI"><tt class="xref py py-class docutils literal"><span class="pre">nltk.parse.chart.EdgeI</span></tt></a></p>
<p>An edge that records the fact that a leaf value is consistent with
a word in the sentence.  A leaf edge consists of:</p>
<blockquote>
<div><ul class="simple">
<li>An X{index}, indicating the position of the word.</li>
<li>A X{leaf}, specifying the word&#8217;s content.</li>
</ul>
</div></blockquote>
<p>A leaf edge&#8217;s left-hand side is its leaf value, and its right hand
side is C{()}.  Its span is C{[index, index+1]}, and its dot
position is C{0}.</p>
<dl class="method">
<dt id="nltk.parse.chart.LeafEdge.dot">
<tt class="descname">dot</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/parse/chart.html#LeafEdge.dot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.chart.LeafEdge.dot" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nltk.parse.chart.LeafEdge.end">
<tt class="descname">end</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/parse/chart.html#LeafEdge.end"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.chart.LeafEdge.end" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nltk.parse.chart.LeafEdge.is_complete">
<tt class="descname">is_complete</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/parse/chart.html#LeafEdge.is_complete"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.chart.LeafEdge.is_complete" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nltk.parse.chart.LeafEdge.is_incomplete">
<tt class="descname">is_incomplete</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/parse/chart.html#LeafEdge.is_incomplete"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.chart.LeafEdge.is_incomplete" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nltk.parse.chart.LeafEdge.length">
<tt class="descname">length</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/parse/chart.html#LeafEdge.length"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.chart.LeafEdge.length" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nltk.parse.chart.LeafEdge.lhs">
<tt class="descname">lhs</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/parse/chart.html#LeafEdge.lhs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.chart.LeafEdge.lhs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nltk.parse.chart.LeafEdge.next">
<tt class="descname">next</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/parse/chart.html#LeafEdge.next"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.chart.LeafEdge.next" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nltk.parse.chart.LeafEdge.rhs">
<tt class="descname">rhs</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/parse/chart.html#LeafEdge.rhs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.chart.LeafEdge.rhs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nltk.parse.chart.LeafEdge.span">
<tt class="descname">span</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/parse/chart.html#LeafEdge.span"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.chart.LeafEdge.span" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nltk.parse.chart.LeafEdge.start">
<tt class="descname">start</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/parse/chart.html#LeafEdge.start"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.chart.LeafEdge.start" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.parse.chart.LeafInitRule">
<em class="property">class </em><tt class="descclassname">nltk.parse.chart.</tt><tt class="descname">LeafInitRule</tt><a class="reference internal" href="../_modules/nltk/parse/chart.html#LeafInitRule"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.chart.LeafInitRule" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.parse.chart.AbstractChartRule" title="nltk.parse.chart.AbstractChartRule"><tt class="xref py py-class docutils literal"><span class="pre">nltk.parse.chart.AbstractChartRule</span></tt></a></p>
<dl class="attribute">
<dt id="nltk.parse.chart.LeafInitRule.NUM_EDGES">
<tt class="descname">NUM_EDGES</tt><em class="property"> = 0</em><a class="headerlink" href="#nltk.parse.chart.LeafInitRule.NUM_EDGES" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nltk.parse.chart.LeafInitRule.apply_iter">
<tt class="descname">apply_iter</tt><big>(</big><em>chart</em>, <em>grammar</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/chart.html#LeafInitRule.apply_iter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.chart.LeafInitRule.apply_iter" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.parse.chart.LeftCornerChartParser">
<em class="property">class </em><tt class="descclassname">nltk.parse.chart.</tt><tt class="descname">LeftCornerChartParser</tt><big>(</big><em>grammar</em>, <em>**parser_args</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/chart.html#LeftCornerChartParser"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.chart.LeftCornerChartParser" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.parse.chart.ChartParser" title="nltk.parse.chart.ChartParser"><tt class="xref py py-class docutils literal"><span class="pre">nltk.parse.chart.ChartParser</span></tt></a></p>
</dd></dl>

<dl class="class">
<dt id="nltk.parse.chart.SingleEdgeFundamentalRule">
<em class="property">class </em><tt class="descclassname">nltk.parse.chart.</tt><tt class="descname">SingleEdgeFundamentalRule</tt><a class="reference internal" href="../_modules/nltk/parse/chart.html#SingleEdgeFundamentalRule"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.chart.SingleEdgeFundamentalRule" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.parse.chart.FundamentalRule" title="nltk.parse.chart.FundamentalRule"><tt class="xref py py-class docutils literal"><span class="pre">nltk.parse.chart.FundamentalRule</span></tt></a></p>
<p>A rule that joins a given edge with adjacent edges in the chart,
to form combined edges.  In particular, this rule specifies that
either of the edges:</p>
<blockquote>
<div><ul class="simple">
<li>[A S{-&gt;} S{alpha} * B S{beta}][i:j]</li>
<li>[B S{-&gt;} S{gamma} <a href="#id8"><span class="problematic" id="id9">*</span></a>][j:k]</li>
</ul>
</div></blockquote>
<dl class="docutils">
<dt>licenses the edge:</dt>
<dd><ul class="first last simple">
<li>[A S{-&gt;} S{alpha} B * S{beta}][i:j]</li>
</ul>
</dd>
</dl>
<p>if the other edge is already in the chart.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Note :</th><td class="field-body">This is basically L{FundamentalRule}, with one edge left
unspecified.</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="nltk.parse.chart.SingleEdgeFundamentalRule.NUM_EDGES">
<tt class="descname">NUM_EDGES</tt><em class="property"> = 1</em><a class="headerlink" href="#nltk.parse.chart.SingleEdgeFundamentalRule.NUM_EDGES" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nltk.parse.chart.SingleEdgeFundamentalRule.apply_iter">
<tt class="descname">apply_iter</tt><big>(</big><em>chart</em>, <em>grammar</em>, <em>edge</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/chart.html#SingleEdgeFundamentalRule.apply_iter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.chart.SingleEdgeFundamentalRule.apply_iter" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.parse.chart.SteppingChartParser">
<em class="property">class </em><tt class="descclassname">nltk.parse.chart.</tt><tt class="descname">SteppingChartParser</tt><big>(</big><em>grammar</em>, <em>strategy=</em><span class="optional">[</span><span class="optional">]</span>, <em>trace=0</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/chart.html#SteppingChartParser"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.chart.SteppingChartParser" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.parse.chart.ChartParser" title="nltk.parse.chart.ChartParser"><tt class="xref py py-class docutils literal"><span class="pre">nltk.parse.chart.ChartParser</span></tt></a></p>
<p>A C{ChartParser} that allows you to step through the parsing
process, adding a single edge at a time.  It also allows you to
change the parser&#8217;s strategy or grammar midway through parsing a
text.</p>
<p>The C{initialize} method is used to start parsing a text.  C{step}
adds a single edge to the chart.  C{set_strategy} changes the
strategy used by the chart parser.  C{parses} returns the set of
parses that has been found by the chart parser.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><strong>_restart</strong> &#8211; Records whether the parser&#8217;s strategy, grammar,
or chart has been changed.  If so, then L{step} must restart
the parsing algorithm.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="nltk.parse.chart.SteppingChartParser.chart">
<tt class="descname">chart</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/parse/chart.html#SteppingChartParser.chart"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.chart.SteppingChartParser.chart" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The chart that is used by this parser.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.parse.chart.SteppingChartParser.current_chartrule">
<tt class="descname">current_chartrule</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/parse/chart.html#SteppingChartParser.current_chartrule"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.chart.SteppingChartParser.current_chartrule" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The chart rule used to generate the most recent edge.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.parse.chart.SteppingChartParser.grammar">
<tt class="descname">grammar</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/parse/chart.html#SteppingChartParser.grammar"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.chart.SteppingChartParser.grammar" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The grammar used by this parser.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.parse.chart.SteppingChartParser.initialize">
<tt class="descname">initialize</tt><big>(</big><em>tokens</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/chart.html#SteppingChartParser.initialize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.chart.SteppingChartParser.initialize" title="Permalink to this definition">¶</a></dt>
<dd><p>Begin parsing the given tokens.</p>
</dd></dl>

<dl class="method">
<dt id="nltk.parse.chart.SteppingChartParser.nbest_parse">
<tt class="descname">nbest_parse</tt><big>(</big><em>tokens</em>, <em>n=None</em>, <em>tree_class=&lt;class 'nltk.tree.Tree'&gt;</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/chart.html#SteppingChartParser.nbest_parse"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.chart.SteppingChartParser.nbest_parse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nltk.parse.chart.SteppingChartParser.parses">
<tt class="descname">parses</tt><big>(</big><em>tree_class=&lt;class 'nltk.tree.Tree'&gt;</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/chart.html#SteppingChartParser.parses"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.chart.SteppingChartParser.parses" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The parse trees currently contained in the chart.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.parse.chart.SteppingChartParser.set_chart">
<tt class="descname">set_chart</tt><big>(</big><em>chart</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/chart.html#SteppingChartParser.set_chart"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.chart.SteppingChartParser.set_chart" title="Permalink to this definition">¶</a></dt>
<dd><p>Load a given chart into the chart parser.</p>
</dd></dl>

<dl class="method">
<dt id="nltk.parse.chart.SteppingChartParser.set_grammar">
<tt class="descname">set_grammar</tt><big>(</big><em>grammar</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/chart.html#SteppingChartParser.set_grammar"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.chart.SteppingChartParser.set_grammar" title="Permalink to this definition">¶</a></dt>
<dd><p>Change the grammar used by the parser.</p>
</dd></dl>

<dl class="method">
<dt id="nltk.parse.chart.SteppingChartParser.set_strategy">
<tt class="descname">set_strategy</tt><big>(</big><em>strategy</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/chart.html#SteppingChartParser.set_strategy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.chart.SteppingChartParser.set_strategy" title="Permalink to this definition">¶</a></dt>
<dd><p>Change the startegy that the parser uses to decide which edges
to add to the chart.
:type strategy: list of L{ChartRuleI}
:param strategy: A list of rules that should be used to decide</p>
<blockquote>
<div>what edges to add to the chart.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="nltk.parse.chart.SteppingChartParser.step">
<tt class="descname">step</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/parse/chart.html#SteppingChartParser.step"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.chart.SteppingChartParser.step" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A generator that adds edges to the chart, one at a</td>
</tr>
</tbody>
</table>
<p>time.  Each time the generator is resumed, it adds a single
edge and yields that edge.  If no more edges can be added,
then it yields None.</p>
<p>If the parser&#8217;s strategy, grammar, or chart is changed, then
the generator will continue adding edges using the new
strategy, grammar, or chart.</p>
<p>Note that this generator never terminates, since the grammar
or strategy might be changed to values that would add new
edges.  Instead, it yields None when no more edges can be
added with the current strategy and grammar.</p>
</dd></dl>

<dl class="method">
<dt id="nltk.parse.chart.SteppingChartParser.strategy">
<tt class="descname">strategy</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/parse/chart.html#SteppingChartParser.strategy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.chart.SteppingChartParser.strategy" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The strategy used by this parser.</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.parse.chart.TopDownChartParser">
<em class="property">class </em><tt class="descclassname">nltk.parse.chart.</tt><tt class="descname">TopDownChartParser</tt><big>(</big><em>grammar</em>, <em>**parser_args</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/chart.html#TopDownChartParser"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.chart.TopDownChartParser" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.parse.chart.ChartParser" title="nltk.parse.chart.ChartParser"><tt class="xref py py-class docutils literal"><span class="pre">nltk.parse.chart.ChartParser</span></tt></a></p>
<p>A L{ChartParser} using a top-down parsing strategy.
See L{ChartParser} for more information.</p>
</dd></dl>

<dl class="class">
<dt id="nltk.parse.chart.TopDownInitRule">
<em class="property">class </em><tt class="descclassname">nltk.parse.chart.</tt><tt class="descname">TopDownInitRule</tt><a class="reference internal" href="../_modules/nltk/parse/chart.html#TopDownInitRule"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.chart.TopDownInitRule" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.parse.chart.AbstractChartRule" title="nltk.parse.chart.AbstractChartRule"><tt class="xref py py-class docutils literal"><span class="pre">nltk.parse.chart.AbstractChartRule</span></tt></a></p>
<p>A rule licensing edges corresponding to the grammar productions for
the grammar&#8217;s start symbol.  In particular, this rule specifies that:</p>
<blockquote>
<div><ul class="simple">
<li>[S S{-&gt;} * S{alpha}][0:i]</li>
</ul>
</div></blockquote>
<p>is licensed for each grammar production C{S S{-&gt;} S{alpha}}, where
C{S} is the grammar&#8217;s start symbol.</p>
<dl class="attribute">
<dt id="nltk.parse.chart.TopDownInitRule.NUM_EDGES">
<tt class="descname">NUM_EDGES</tt><em class="property"> = 0</em><a class="headerlink" href="#nltk.parse.chart.TopDownInitRule.NUM_EDGES" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nltk.parse.chart.TopDownInitRule.apply_iter">
<tt class="descname">apply_iter</tt><big>(</big><em>chart</em>, <em>grammar</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/chart.html#TopDownInitRule.apply_iter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.chart.TopDownInitRule.apply_iter" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.parse.chart.TopDownPredictRule">
<em class="property">class </em><tt class="descclassname">nltk.parse.chart.</tt><tt class="descname">TopDownPredictRule</tt><a class="reference internal" href="../_modules/nltk/parse/chart.html#TopDownPredictRule"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.chart.TopDownPredictRule" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.parse.chart.AbstractChartRule" title="nltk.parse.chart.AbstractChartRule"><tt class="xref py py-class docutils literal"><span class="pre">nltk.parse.chart.AbstractChartRule</span></tt></a></p>
<p>A rule licensing edges corresponding to the grammar productions
for the nonterminal following an incomplete edge&#8217;s dot.  In
particular, this rule specifies that:</p>
<blockquote>
<div><ul class="simple">
<li>[A S{-&gt;} S{alpha} * B S{beta}][i:j]</li>
</ul>
</div></blockquote>
<dl class="docutils">
<dt>licenses the edge:</dt>
<dd><ul class="first last simple">
<li>[B S{-&gt;} * S{gamma}][j:j]</li>
</ul>
</dd>
</dl>
<p>for each grammar production C{B S{-&gt;} S{gamma}}.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Note :</th><td class="field-body">This rule corresponds to the Predictor Rule in Earley parsing.</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="nltk.parse.chart.TopDownPredictRule.NUM_EDGES">
<tt class="descname">NUM_EDGES</tt><em class="property"> = 1</em><a class="headerlink" href="#nltk.parse.chart.TopDownPredictRule.NUM_EDGES" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nltk.parse.chart.TopDownPredictRule.apply_iter">
<tt class="descname">apply_iter</tt><big>(</big><em>chart</em>, <em>grammar</em>, <em>edge</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/chart.html#TopDownPredictRule.apply_iter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.chart.TopDownPredictRule.apply_iter" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.parse.chart.TreeEdge">
<em class="property">class </em><tt class="descclassname">nltk.parse.chart.</tt><tt class="descname">TreeEdge</tt><big>(</big><em>span</em>, <em>lhs</em>, <em>rhs</em>, <em>dot=0</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/chart.html#TreeEdge"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.chart.TreeEdge" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.parse.chart.EdgeI" title="nltk.parse.chart.EdgeI"><tt class="xref py py-class docutils literal"><span class="pre">nltk.parse.chart.EdgeI</span></tt></a></p>
<p>An edge that records the fact that a tree is (partially)
consistent with the sentence.  A tree edge consists of:</p>
<blockquote>
<div><ul class="simple">
<li>A X{span}, indicating what part of the sentence is
consistent with the hypothesized tree.</li>
<li>A X{left-hand side}, specifying the hypothesized tree&#8217;s node
value.</li>
<li>A X{right-hand side}, specifying the hypothesized tree&#8217;s
children.  Each element of the right-hand side is either a
terminal, specifying a token with that terminal as its leaf
value; or a nonterminal, specifying a subtree with that
nonterminal&#8217;s symbol as its node value.</li>
<li>A X{dot position}, indicating which children are consistent
with part of the sentence.  In particular, if C{dot} is the
dot position, C{rhs} is the right-hand size, C{(start,end)}
is the span, and C{sentence} is the list of subtokens in the
sentence, then C{subtokens[start:end]} can be spanned by the
children specified by C{rhs[:dot]}.</li>
</ul>
</div></blockquote>
<p>For more information about edges, see the L{EdgeI} interface.</p>
<dl class="method">
<dt id="nltk.parse.chart.TreeEdge.dot">
<tt class="descname">dot</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/parse/chart.html#TreeEdge.dot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.chart.TreeEdge.dot" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nltk.parse.chart.TreeEdge.end">
<tt class="descname">end</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/parse/chart.html#TreeEdge.end"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.chart.TreeEdge.end" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="staticmethod">
<dt id="nltk.parse.chart.TreeEdge.from_production">
<em class="property">static </em><tt class="descname">from_production</tt><big>(</big><em>production</em>, <em>index</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/chart.html#TreeEdge.from_production"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.chart.TreeEdge.from_production" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A new C{TreeEdge} formed from the given production.
The new edge&#8217;s left-hand side and right-hand side will
be taken from C{production}; its span will be 
C{(index,index)}; and its dot position will be C{0}.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">L{TreeEdge}</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.parse.chart.TreeEdge.is_complete">
<tt class="descname">is_complete</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/parse/chart.html#TreeEdge.is_complete"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.chart.TreeEdge.is_complete" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nltk.parse.chart.TreeEdge.is_incomplete">
<tt class="descname">is_incomplete</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/parse/chart.html#TreeEdge.is_incomplete"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.chart.TreeEdge.is_incomplete" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nltk.parse.chart.TreeEdge.length">
<tt class="descname">length</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/parse/chart.html#TreeEdge.length"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.chart.TreeEdge.length" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nltk.parse.chart.TreeEdge.lhs">
<tt class="descname">lhs</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/parse/chart.html#TreeEdge.lhs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.chart.TreeEdge.lhs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nltk.parse.chart.TreeEdge.move_dot_forward">
<tt class="descname">move_dot_forward</tt><big>(</big><em>new_end</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/chart.html#TreeEdge.move_dot_forward"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.chart.TreeEdge.move_dot_forward" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A new C{TreeEdge} formed from this edge.
The new edge&#8217;s dot position is increased by C{1}, 
and its end index will be replaced by C{new_end}.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">L{TreeEdge}</td>
</tr>
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>new_end</strong> (<em>int</em>) &#8211; The new end index.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.parse.chart.TreeEdge.next">
<tt class="descname">next</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/parse/chart.html#TreeEdge.next"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.chart.TreeEdge.next" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nltk.parse.chart.TreeEdge.rhs">
<tt class="descname">rhs</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/parse/chart.html#TreeEdge.rhs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.chart.TreeEdge.rhs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nltk.parse.chart.TreeEdge.span">
<tt class="descname">span</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/parse/chart.html#TreeEdge.span"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.chart.TreeEdge.span" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nltk.parse.chart.TreeEdge.start">
<tt class="descname">start</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/parse/chart.html#TreeEdge.start"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.chart.TreeEdge.start" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="nltk.parse.chart.demo">
<tt class="descclassname">nltk.parse.chart.</tt><tt class="descname">demo</tt><big>(</big><em>choice=None</em>, <em>should_print_times=True</em>, <em>should_print_grammar=False</em>, <em>should_print_trees=True</em>, <em>trace=2</em>, <em>sent='I saw John with a dog with my cookie'</em>, <em>numparses=5</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/chart.html#demo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.chart.demo" title="Permalink to this definition">¶</a></dt>
<dd><p>A demonstration of the chart parsers.</p>
</dd></dl>

<dl class="function">
<dt id="nltk.parse.chart.demo_grammar">
<tt class="descclassname">nltk.parse.chart.</tt><tt class="descname">demo_grammar</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/parse/chart.html#demo_grammar"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.chart.demo_grammar" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-nltk.parse.dependencygraph">
<span id="dependencygraph-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">dependencygraph</span></tt> Module<a class="headerlink" href="#module-nltk.parse.dependencygraph" title="Permalink to this headline">¶</a></h2>
<p>Tools for reading and writing dependency trees.
The input is assumed to be in U{Malt-TAB&lt;<a class="reference external" href="http://w3.msi.vxu.se/~nivre/research/MaltXML.html">http://w3.msi.vxu.se/~nivre/research/MaltXML.html</a>&gt;} format.</p>
<p>Currently only reads the first tree in a file.</p>
<dl class="class">
<dt id="nltk.parse.dependencygraph.DependencyGraph">
<em class="property">class </em><tt class="descclassname">nltk.parse.dependencygraph.</tt><tt class="descname">DependencyGraph</tt><big>(</big><em>tree_str=None</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/dependencygraph.html#DependencyGraph"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.dependencygraph.DependencyGraph" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>A container for the nodes and labelled edges of a dependency structure.</p>
<dl class="method">
<dt id="nltk.parse.dependencygraph.DependencyGraph.add_arc">
<tt class="descname">add_arc</tt><big>(</big><em>head_address</em>, <em>mod_address</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/dependencygraph.html#DependencyGraph.add_arc"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.dependencygraph.DependencyGraph.add_arc" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds an arc from the node specified by head_address to the 
node specified by the mod address.</p>
</dd></dl>

<dl class="method">
<dt id="nltk.parse.dependencygraph.DependencyGraph.add_node">
<tt class="descname">add_node</tt><big>(</big><em>node</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/dependencygraph.html#DependencyGraph.add_node"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.dependencygraph.DependencyGraph.add_node" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nltk.parse.dependencygraph.DependencyGraph.connect_graph">
<tt class="descname">connect_graph</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/parse/dependencygraph.html#DependencyGraph.connect_graph"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.dependencygraph.DependencyGraph.connect_graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Fully connects all non-root nodes.  All nodes are set to be dependents
of the root node.</p>
</dd></dl>

<dl class="method">
<dt id="nltk.parse.dependencygraph.DependencyGraph.contains_address">
<tt class="descname">contains_address</tt><big>(</big><em>node_address</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/dependencygraph.html#DependencyGraph.contains_address"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.dependencygraph.DependencyGraph.contains_address" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true if the graph contains a node with the given node 
address, false otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="nltk.parse.dependencygraph.DependencyGraph.contains_cycle">
<tt class="descname">contains_cycle</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/parse/dependencygraph.html#DependencyGraph.contains_cycle"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.dependencygraph.DependencyGraph.contains_cycle" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nltk.parse.dependencygraph.DependencyGraph.get_by_address">
<tt class="descname">get_by_address</tt><big>(</big><em>node_address</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/dependencygraph.html#DependencyGraph.get_by_address"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.dependencygraph.DependencyGraph.get_by_address" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the node with the given address.</p>
</dd></dl>

<dl class="method">
<dt id="nltk.parse.dependencygraph.DependencyGraph.get_cycle_path">
<tt class="descname">get_cycle_path</tt><big>(</big><em>curr_node</em>, <em>goal_node_index</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/dependencygraph.html#DependencyGraph.get_cycle_path"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.dependencygraph.DependencyGraph.get_cycle_path" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nltk.parse.dependencygraph.DependencyGraph.left_children">
<tt class="descname">left_children</tt><big>(</big><em>node_index</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/dependencygraph.html#DependencyGraph.left_children"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.dependencygraph.DependencyGraph.left_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of left children under the node specified
by the given address.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="nltk.parse.dependencygraph.DependencyGraph.load">
<em class="property">static </em><tt class="descname">load</tt><big>(</big><em>file</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/dependencygraph.html#DependencyGraph.load"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.dependencygraph.DependencyGraph.load" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>file</strong> &#8211; a file in Malt-TAB format</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.parse.dependencygraph.DependencyGraph.redirect_arcs">
<tt class="descname">redirect_arcs</tt><big>(</big><em>originals</em>, <em>redirect</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/dependencygraph.html#DependencyGraph.redirect_arcs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.dependencygraph.DependencyGraph.redirect_arcs" title="Permalink to this definition">¶</a></dt>
<dd><p>Redirects arcs to any of the nodes in the originals list 
to the redirect node address.</p>
</dd></dl>

<dl class="method">
<dt id="nltk.parse.dependencygraph.DependencyGraph.remove_by_address">
<tt class="descname">remove_by_address</tt><big>(</big><em>address</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/dependencygraph.html#DependencyGraph.remove_by_address"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.dependencygraph.DependencyGraph.remove_by_address" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes the node with the given address.  References 
to this node in others will still exist.</p>
</dd></dl>

<dl class="method">
<dt id="nltk.parse.dependencygraph.DependencyGraph.right_children">
<tt class="descname">right_children</tt><big>(</big><em>node_index</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/dependencygraph.html#DependencyGraph.right_children"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.dependencygraph.DependencyGraph.right_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of right children under the node specified
by the given address.</p>
</dd></dl>

<dl class="method">
<dt id="nltk.parse.dependencygraph.DependencyGraph.to_conll">
<tt class="descname">to_conll</tt><big>(</big><em>style</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/dependencygraph.html#DependencyGraph.to_conll"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.dependencygraph.DependencyGraph.to_conll" title="Permalink to this definition">¶</a></dt>
<dd><p>The dependency graph in CoNLL format.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>style</strong> (<em>int</em>) &#8211; the style to use for the format (3, 4, 10 columns)</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">str</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.parse.dependencygraph.DependencyGraph.tree">
<tt class="descname">tree</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/parse/dependencygraph.html#DependencyGraph.tree"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.dependencygraph.DependencyGraph.tree" title="Permalink to this definition">¶</a></dt>
<dd><p>Starting with the C{root} node, build a dependency tree using the NLTK 
L{Tree} constructor. Dependency labels are omitted.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="nltk.parse.dependencygraph.conll_demo">
<tt class="descclassname">nltk.parse.dependencygraph.</tt><tt class="descname">conll_demo</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/parse/dependencygraph.html#conll_demo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.dependencygraph.conll_demo" title="Permalink to this definition">¶</a></dt>
<dd><p>A demonstration of how to read a string representation of 
a CoNLL format dependency tree.</p>
</dd></dl>

<dl class="function">
<dt id="nltk.parse.dependencygraph.conll_file_demo">
<tt class="descclassname">nltk.parse.dependencygraph.</tt><tt class="descname">conll_file_demo</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/parse/dependencygraph.html#conll_file_demo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.dependencygraph.conll_file_demo" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="nltk.parse.dependencygraph.cycle_finding_demo">
<tt class="descclassname">nltk.parse.dependencygraph.</tt><tt class="descname">cycle_finding_demo</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/parse/dependencygraph.html#cycle_finding_demo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.dependencygraph.cycle_finding_demo" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="nltk.parse.dependencygraph.demo">
<tt class="descclassname">nltk.parse.dependencygraph.</tt><tt class="descname">demo</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/parse/dependencygraph.html#demo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.dependencygraph.demo" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="nltk.parse.dependencygraph.malt_demo">
<tt class="descclassname">nltk.parse.dependencygraph.</tt><tt class="descname">malt_demo</tt><big>(</big><em>nx=False</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/dependencygraph.html#malt_demo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.dependencygraph.malt_demo" title="Permalink to this definition">¶</a></dt>
<dd><p>A demonstration of the result of reading a dependency
version of the first sentence of the Penn Treebank.</p>
</dd></dl>

<dl class="function">
<dt id="nltk.parse.dependencygraph.nx_graph">
<tt class="descclassname">nltk.parse.dependencygraph.</tt><tt class="descname">nx_graph</tt><big>(</big><em>self</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/dependencygraph.html#nx_graph"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.dependencygraph.nx_graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the data in a C{nodelist} into a networkx 
labeled directed graph.
:rtype: C{XDigraph}</p>
</dd></dl>

</div>
<div class="section" id="module-nltk.parse.earleychart">
<span id="earleychart-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">earleychart</span></tt> Module<a class="headerlink" href="#module-nltk.parse.earleychart" title="Permalink to this headline">¶</a></h2>
<p>Data classes and parser implementations for I{incremental} chart 
parsers, which use dynamic programming to efficiently parse a text.  
A X{chart parser} derives parse trees for a text by iteratively adding 
&#8220;edges&#8221; to a &#8220;chart&#8221;.  Each X{edge} represents a hypothesis about the tree
structure for a subsequence of the text.  The X{chart} is a
&#8220;blackboard&#8221; for composing and combining these hypotheses.</p>
<p>A parser is X{incremental}, if it guarantees that for all i, j where i &lt; j,
all edges ending at i are built before any edges ending at j.    
This is appealing for, say, speech recognizer hypothesis filtering.</p>
<p>The main parser class is L{EarleyChartParser}, which is a top-down
algorithm, originally formulated by Jay Earley (1970).</p>
<dl class="class">
<dt id="nltk.parse.earleychart.CompleteFundamentalRule">
<em class="property">class </em><tt class="descclassname">nltk.parse.earleychart.</tt><tt class="descname">CompleteFundamentalRule</tt><a class="reference internal" href="../_modules/nltk/parse/earleychart.html#CompleteFundamentalRule"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.earleychart.CompleteFundamentalRule" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.parse.chart.SingleEdgeFundamentalRule" title="nltk.parse.chart.SingleEdgeFundamentalRule"><tt class="xref py py-class docutils literal"><span class="pre">nltk.parse.chart.SingleEdgeFundamentalRule</span></tt></a></p>
</dd></dl>

<dl class="class">
<dt id="nltk.parse.earleychart.CompleterRule">
<em class="property">class </em><tt class="descclassname">nltk.parse.earleychart.</tt><tt class="descname">CompleterRule</tt><a class="reference internal" href="../_modules/nltk/parse/earleychart.html#CompleterRule"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.earleychart.CompleterRule" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.parse.earleychart.CompleteFundamentalRule" title="nltk.parse.earleychart.CompleteFundamentalRule"><tt class="xref py py-class docutils literal"><span class="pre">nltk.parse.earleychart.CompleteFundamentalRule</span></tt></a></p>
<dl class="method">
<dt id="nltk.parse.earleychart.CompleterRule.apply_iter">
<tt class="descname">apply_iter</tt><big>(</big><em>chart</em>, <em>grammar</em>, <em>edge</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/earleychart.html#CompleterRule.apply_iter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.earleychart.CompleterRule.apply_iter" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.parse.earleychart.EarleyChartParser">
<em class="property">class </em><tt class="descclassname">nltk.parse.earleychart.</tt><tt class="descname">EarleyChartParser</tt><big>(</big><em>grammar</em>, <em>**parser_args</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/earleychart.html#EarleyChartParser"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.earleychart.EarleyChartParser" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.parse.earleychart.IncrementalChartParser" title="nltk.parse.earleychart.IncrementalChartParser"><tt class="xref py py-class docutils literal"><span class="pre">nltk.parse.earleychart.IncrementalChartParser</span></tt></a></p>
</dd></dl>

<dl class="class">
<dt id="nltk.parse.earleychart.FeatureCompleteFundamentalRule">
<em class="property">class </em><tt class="descclassname">nltk.parse.earleychart.</tt><tt class="descname">FeatureCompleteFundamentalRule</tt><a class="reference internal" href="../_modules/nltk/parse/earleychart.html#FeatureCompleteFundamentalRule"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.earleychart.FeatureCompleteFundamentalRule" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.parse.featurechart.FeatureSingleEdgeFundamentalRule" title="nltk.parse.featurechart.FeatureSingleEdgeFundamentalRule"><tt class="xref py py-class docutils literal"><span class="pre">nltk.parse.featurechart.FeatureSingleEdgeFundamentalRule</span></tt></a></p>
</dd></dl>

<dl class="class">
<dt id="nltk.parse.earleychart.FeatureCompleterRule">
<em class="property">class </em><tt class="descclassname">nltk.parse.earleychart.</tt><tt class="descname">FeatureCompleterRule</tt><a class="reference internal" href="../_modules/nltk/parse/earleychart.html#FeatureCompleterRule"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.earleychart.FeatureCompleterRule" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.parse.earleychart.CompleterRule" title="nltk.parse.earleychart.CompleterRule"><tt class="xref py py-class docutils literal"><span class="pre">nltk.parse.earleychart.CompleterRule</span></tt></a></p>
</dd></dl>

<dl class="class">
<dt id="nltk.parse.earleychart.FeatureEarleyChartParser">
<em class="property">class </em><tt class="descclassname">nltk.parse.earleychart.</tt><tt class="descname">FeatureEarleyChartParser</tt><big>(</big><em>grammar</em>, <em>**parser_args</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/earleychart.html#FeatureEarleyChartParser"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.earleychart.FeatureEarleyChartParser" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.parse.earleychart.FeatureIncrementalChartParser" title="nltk.parse.earleychart.FeatureIncrementalChartParser"><tt class="xref py py-class docutils literal"><span class="pre">nltk.parse.earleychart.FeatureIncrementalChartParser</span></tt></a></p>
</dd></dl>

<dl class="class">
<dt id="nltk.parse.earleychart.FeatureIncrementalBottomUpChartParser">
<em class="property">class </em><tt class="descclassname">nltk.parse.earleychart.</tt><tt class="descname">FeatureIncrementalBottomUpChartParser</tt><big>(</big><em>grammar</em>, <em>**parser_args</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/earleychart.html#FeatureIncrementalBottomUpChartParser"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.earleychart.FeatureIncrementalBottomUpChartParser" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.parse.earleychart.FeatureIncrementalChartParser" title="nltk.parse.earleychart.FeatureIncrementalChartParser"><tt class="xref py py-class docutils literal"><span class="pre">nltk.parse.earleychart.FeatureIncrementalChartParser</span></tt></a></p>
</dd></dl>

<dl class="class">
<dt id="nltk.parse.earleychart.FeatureIncrementalBottomUpLeftCornerChartParser">
<em class="property">class </em><tt class="descclassname">nltk.parse.earleychart.</tt><tt class="descname">FeatureIncrementalBottomUpLeftCornerChartParser</tt><big>(</big><em>grammar</em>, <em>**parser_args</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/earleychart.html#FeatureIncrementalBottomUpLeftCornerChartParser"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.earleychart.FeatureIncrementalBottomUpLeftCornerChartParser" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.parse.earleychart.FeatureIncrementalChartParser" title="nltk.parse.earleychart.FeatureIncrementalChartParser"><tt class="xref py py-class docutils literal"><span class="pre">nltk.parse.earleychart.FeatureIncrementalChartParser</span></tt></a></p>
</dd></dl>

<dl class="class">
<dt id="nltk.parse.earleychart.FeatureIncrementalChart">
<em class="property">class </em><tt class="descclassname">nltk.parse.earleychart.</tt><tt class="descname">FeatureIncrementalChart</tt><big>(</big><em>tokens</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/earleychart.html#FeatureIncrementalChart"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.earleychart.FeatureIncrementalChart" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.parse.earleychart.IncrementalChart" title="nltk.parse.earleychart.IncrementalChart"><tt class="xref py py-class docutils literal"><span class="pre">nltk.parse.earleychart.IncrementalChart</span></tt></a>, <a class="reference internal" href="#nltk.parse.featurechart.FeatureChart" title="nltk.parse.featurechart.FeatureChart"><tt class="xref py py-class docutils literal"><span class="pre">nltk.parse.featurechart.FeatureChart</span></tt></a></p>
<dl class="method">
<dt id="nltk.parse.earleychart.FeatureIncrementalChart.select">
<tt class="descname">select</tt><big>(</big><em>end</em>, <em>**restrictions</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/earleychart.html#FeatureIncrementalChart.select"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.earleychart.FeatureIncrementalChart.select" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.parse.earleychart.FeatureIncrementalChartParser">
<em class="property">class </em><tt class="descclassname">nltk.parse.earleychart.</tt><tt class="descname">FeatureIncrementalChartParser</tt><big>(</big><em>grammar, strategy=[&lt;nltk.parse.chart.LeafInitRule object at 0x44d6f10&gt;, &lt;nltk.parse.featurechart.FeatureEmptyPredictRule object at 0x44d6f50&gt;, &lt;nltk.parse.featurechart.FeatureBottomUpPredictCombineRule object at 0x44d6f90&gt;, &lt;nltk.parse.earleychart.FeatureCompleteFundamentalRule object at 0x44d6fd0&gt;], trace_chart_width=20, chart_class=&lt;class 'nltk.parse.earleychart.FeatureIncrementalChart'&gt;, **parser_args</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/earleychart.html#FeatureIncrementalChartParser"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.earleychart.FeatureIncrementalChartParser" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.parse.earleychart.IncrementalChartParser" title="nltk.parse.earleychart.IncrementalChartParser"><tt class="xref py py-class docutils literal"><span class="pre">nltk.parse.earleychart.IncrementalChartParser</span></tt></a>, <a class="reference internal" href="#nltk.parse.featurechart.FeatureChartParser" title="nltk.parse.featurechart.FeatureChartParser"><tt class="xref py py-class docutils literal"><span class="pre">nltk.parse.featurechart.FeatureChartParser</span></tt></a></p>
</dd></dl>

<dl class="class">
<dt id="nltk.parse.earleychart.FeatureIncrementalTopDownChartParser">
<em class="property">class </em><tt class="descclassname">nltk.parse.earleychart.</tt><tt class="descname">FeatureIncrementalTopDownChartParser</tt><big>(</big><em>grammar</em>, <em>**parser_args</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/earleychart.html#FeatureIncrementalTopDownChartParser"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.earleychart.FeatureIncrementalTopDownChartParser" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.parse.earleychart.FeatureIncrementalChartParser" title="nltk.parse.earleychart.FeatureIncrementalChartParser"><tt class="xref py py-class docutils literal"><span class="pre">nltk.parse.earleychart.FeatureIncrementalChartParser</span></tt></a></p>
</dd></dl>

<dl class="class">
<dt id="nltk.parse.earleychart.FeaturePredictorRule">
<em class="property">class </em><tt class="descclassname">nltk.parse.earleychart.</tt><tt class="descname">FeaturePredictorRule</tt><a class="reference internal" href="../_modules/nltk/parse/earleychart.html#FeaturePredictorRule"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.earleychart.FeaturePredictorRule" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.parse.featurechart.FeatureTopDownPredictRule" title="nltk.parse.featurechart.FeatureTopDownPredictRule"><tt class="xref py py-class docutils literal"><span class="pre">nltk.parse.featurechart.FeatureTopDownPredictRule</span></tt></a></p>
</dd></dl>

<dl class="class">
<dt id="nltk.parse.earleychart.FeatureScannerRule">
<em class="property">class </em><tt class="descclassname">nltk.parse.earleychart.</tt><tt class="descname">FeatureScannerRule</tt><a class="reference internal" href="../_modules/nltk/parse/earleychart.html#FeatureScannerRule"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.earleychart.FeatureScannerRule" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.parse.earleychart.ScannerRule" title="nltk.parse.earleychart.ScannerRule"><tt class="xref py py-class docutils literal"><span class="pre">nltk.parse.earleychart.ScannerRule</span></tt></a></p>
</dd></dl>

<dl class="class">
<dt id="nltk.parse.earleychart.FilteredCompleteFundamentalRule">
<em class="property">class </em><tt class="descclassname">nltk.parse.earleychart.</tt><tt class="descname">FilteredCompleteFundamentalRule</tt><a class="reference internal" href="../_modules/nltk/parse/earleychart.html#FilteredCompleteFundamentalRule"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.earleychart.FilteredCompleteFundamentalRule" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.parse.chart.FilteredSingleEdgeFundamentalRule" title="nltk.parse.chart.FilteredSingleEdgeFundamentalRule"><tt class="xref py py-class docutils literal"><span class="pre">nltk.parse.chart.FilteredSingleEdgeFundamentalRule</span></tt></a></p>
<dl class="method">
<dt id="nltk.parse.earleychart.FilteredCompleteFundamentalRule.apply_iter">
<tt class="descname">apply_iter</tt><big>(</big><em>chart</em>, <em>grammar</em>, <em>edge</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/earleychart.html#FilteredCompleteFundamentalRule.apply_iter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.earleychart.FilteredCompleteFundamentalRule.apply_iter" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.parse.earleychart.IncrementalBottomUpChartParser">
<em class="property">class </em><tt class="descclassname">nltk.parse.earleychart.</tt><tt class="descname">IncrementalBottomUpChartParser</tt><big>(</big><em>grammar</em>, <em>**parser_args</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/earleychart.html#IncrementalBottomUpChartParser"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.earleychart.IncrementalBottomUpChartParser" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.parse.earleychart.IncrementalChartParser" title="nltk.parse.earleychart.IncrementalChartParser"><tt class="xref py py-class docutils literal"><span class="pre">nltk.parse.earleychart.IncrementalChartParser</span></tt></a></p>
</dd></dl>

<dl class="class">
<dt id="nltk.parse.earleychart.IncrementalBottomUpLeftCornerChartParser">
<em class="property">class </em><tt class="descclassname">nltk.parse.earleychart.</tt><tt class="descname">IncrementalBottomUpLeftCornerChartParser</tt><big>(</big><em>grammar</em>, <em>**parser_args</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/earleychart.html#IncrementalBottomUpLeftCornerChartParser"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.earleychart.IncrementalBottomUpLeftCornerChartParser" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.parse.earleychart.IncrementalChartParser" title="nltk.parse.earleychart.IncrementalChartParser"><tt class="xref py py-class docutils literal"><span class="pre">nltk.parse.earleychart.IncrementalChartParser</span></tt></a></p>
</dd></dl>

<dl class="class">
<dt id="nltk.parse.earleychart.IncrementalChart">
<em class="property">class </em><tt class="descclassname">nltk.parse.earleychart.</tt><tt class="descname">IncrementalChart</tt><big>(</big><em>tokens</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/earleychart.html#IncrementalChart"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.earleychart.IncrementalChart" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.parse.chart.Chart" title="nltk.parse.chart.Chart"><tt class="xref py py-class docutils literal"><span class="pre">nltk.parse.chart.Chart</span></tt></a></p>
<dl class="method">
<dt id="nltk.parse.earleychart.IncrementalChart.edges">
<tt class="descname">edges</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/parse/earleychart.html#IncrementalChart.edges"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.earleychart.IncrementalChart.edges" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nltk.parse.earleychart.IncrementalChart.initialize">
<tt class="descname">initialize</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/parse/earleychart.html#IncrementalChart.initialize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.earleychart.IncrementalChart.initialize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nltk.parse.earleychart.IncrementalChart.iteredges">
<tt class="descname">iteredges</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/parse/earleychart.html#IncrementalChart.iteredges"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.earleychart.IncrementalChart.iteredges" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nltk.parse.earleychart.IncrementalChart.select">
<tt class="descname">select</tt><big>(</big><em>end</em>, <em>**restrictions</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/earleychart.html#IncrementalChart.select"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.earleychart.IncrementalChart.select" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.parse.earleychart.IncrementalChartParser">
<em class="property">class </em><tt class="descclassname">nltk.parse.earleychart.</tt><tt class="descname">IncrementalChartParser</tt><big>(</big><em>grammar, strategy=[&lt;nltk.parse.chart.LeafInitRule object at 0x44d6850&gt;, &lt;nltk.parse.chart.EmptyPredictRule object at 0x44d6890&gt;, &lt;nltk.parse.chart.BottomUpPredictCombineRule object at 0x44d68d0&gt;, &lt;nltk.parse.earleychart.CompleteFundamentalRule object at 0x44d6910&gt;], trace=0, trace_chart_width=50, chart_class=&lt;class 'nltk.parse.earleychart.IncrementalChart'&gt;</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/earleychart.html#IncrementalChartParser"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.earleychart.IncrementalChartParser" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.parse.chart.ChartParser" title="nltk.parse.chart.ChartParser"><tt class="xref py py-class docutils literal"><span class="pre">nltk.parse.chart.ChartParser</span></tt></a></p>
<p>An I{incremental} chart parser implementing Jay Earley&#8217;s 
parsing algorithm:</p>
<blockquote>
<div><ul>
<li><p class="first">For each index I{end} in [0, 1, ..., N]:
- For each I{edge} s.t. I{edge}.end = I{end}:</p>
<blockquote>
<div><ul>
<li><p class="first">If I{edge} is incomplete, and I{edge}.next is not a part
of speech:</p>
<blockquote>
<div><ul class="simple">
<li>Apply PredictorRule to I{edge}</li>
</ul>
</div></blockquote>
</li>
<li><p class="first">If I{edge} is incomplete, and I{edge}.next is a part of
speech:</p>
<blockquote>
<div><ul class="simple">
<li>Apply ScannerRule to I{edge}</li>
</ul>
</div></blockquote>
</li>
<li><dl class="first docutils">
<dt>If I{edge} is complete:</dt>
<dd><ul class="first last simple">
<li>Apply CompleterRule to I{edge}</li>
</ul>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
</li>
<li><p class="first">Return any complete parses in the chart</p>
</li>
</ul>
</div></blockquote>
<dl class="method">
<dt id="nltk.parse.earleychart.IncrementalChartParser.chart_parse">
<tt class="descname">chart_parse</tt><big>(</big><em>tokens</em>, <em>trace=None</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/earleychart.html#IncrementalChartParser.chart_parse"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.earleychart.IncrementalChartParser.chart_parse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.parse.earleychart.IncrementalLeftCornerChartParser">
<em class="property">class </em><tt class="descclassname">nltk.parse.earleychart.</tt><tt class="descname">IncrementalLeftCornerChartParser</tt><big>(</big><em>grammar</em>, <em>**parser_args</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/earleychart.html#IncrementalLeftCornerChartParser"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.earleychart.IncrementalLeftCornerChartParser" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.parse.earleychart.IncrementalChartParser" title="nltk.parse.earleychart.IncrementalChartParser"><tt class="xref py py-class docutils literal"><span class="pre">nltk.parse.earleychart.IncrementalChartParser</span></tt></a></p>
</dd></dl>

<dl class="class">
<dt id="nltk.parse.earleychart.IncrementalTopDownChartParser">
<em class="property">class </em><tt class="descclassname">nltk.parse.earleychart.</tt><tt class="descname">IncrementalTopDownChartParser</tt><big>(</big><em>grammar</em>, <em>**parser_args</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/earleychart.html#IncrementalTopDownChartParser"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.earleychart.IncrementalTopDownChartParser" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.parse.earleychart.IncrementalChartParser" title="nltk.parse.earleychart.IncrementalChartParser"><tt class="xref py py-class docutils literal"><span class="pre">nltk.parse.earleychart.IncrementalChartParser</span></tt></a></p>
</dd></dl>

<dl class="class">
<dt id="nltk.parse.earleychart.PredictorRule">
<em class="property">class </em><tt class="descclassname">nltk.parse.earleychart.</tt><tt class="descname">PredictorRule</tt><a class="reference internal" href="../_modules/nltk/parse/earleychart.html#PredictorRule"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.earleychart.PredictorRule" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.parse.chart.CachedTopDownPredictRule" title="nltk.parse.chart.CachedTopDownPredictRule"><tt class="xref py py-class docutils literal"><span class="pre">nltk.parse.chart.CachedTopDownPredictRule</span></tt></a></p>
</dd></dl>

<dl class="class">
<dt id="nltk.parse.earleychart.ScannerRule">
<em class="property">class </em><tt class="descclassname">nltk.parse.earleychart.</tt><tt class="descname">ScannerRule</tt><a class="reference internal" href="../_modules/nltk/parse/earleychart.html#ScannerRule"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.earleychart.ScannerRule" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.parse.earleychart.CompleteFundamentalRule" title="nltk.parse.earleychart.CompleteFundamentalRule"><tt class="xref py py-class docutils literal"><span class="pre">nltk.parse.earleychart.CompleteFundamentalRule</span></tt></a></p>
<dl class="method">
<dt id="nltk.parse.earleychart.ScannerRule.apply_iter">
<tt class="descname">apply_iter</tt><big>(</big><em>chart</em>, <em>grammar</em>, <em>edge</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/earleychart.html#ScannerRule.apply_iter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.earleychart.ScannerRule.apply_iter" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="nltk.parse.earleychart.demo">
<tt class="descclassname">nltk.parse.earleychart.</tt><tt class="descname">demo</tt><big>(</big><em>should_print_times=True</em>, <em>should_print_grammar=False</em>, <em>should_print_trees=True</em>, <em>trace=2</em>, <em>sent='I saw John with a dog with my cookie'</em>, <em>numparses=5</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/earleychart.html#demo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.earleychart.demo" title="Permalink to this definition">¶</a></dt>
<dd><p>A demonstration of the Earley parsers.</p>
</dd></dl>

</div>
<div class="section" id="module-nltk.parse.featurechart">
<span id="featurechart-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">featurechart</span></tt> Module<a class="headerlink" href="#module-nltk.parse.featurechart" title="Permalink to this headline">¶</a></h2>
<p>Extension of chart parsing implementation to handle grammars with
feature structures as nodes.</p>
<dl class="class">
<dt id="nltk.parse.featurechart.FeatureBottomUpChartParser">
<em class="property">class </em><tt class="descclassname">nltk.parse.featurechart.</tt><tt class="descname">FeatureBottomUpChartParser</tt><big>(</big><em>grammar</em>, <em>**parser_args</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/featurechart.html#FeatureBottomUpChartParser"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.featurechart.FeatureBottomUpChartParser" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.parse.featurechart.FeatureChartParser" title="nltk.parse.featurechart.FeatureChartParser"><tt class="xref py py-class docutils literal"><span class="pre">nltk.parse.featurechart.FeatureChartParser</span></tt></a></p>
</dd></dl>

<dl class="class">
<dt id="nltk.parse.featurechart.FeatureBottomUpLeftCornerChartParser">
<em class="property">class </em><tt class="descclassname">nltk.parse.featurechart.</tt><tt class="descname">FeatureBottomUpLeftCornerChartParser</tt><big>(</big><em>grammar</em>, <em>**parser_args</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/featurechart.html#FeatureBottomUpLeftCornerChartParser"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.featurechart.FeatureBottomUpLeftCornerChartParser" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.parse.featurechart.FeatureChartParser" title="nltk.parse.featurechart.FeatureChartParser"><tt class="xref py py-class docutils literal"><span class="pre">nltk.parse.featurechart.FeatureChartParser</span></tt></a></p>
</dd></dl>

<dl class="class">
<dt id="nltk.parse.featurechart.FeatureBottomUpPredictCombineRule">
<em class="property">class </em><tt class="descclassname">nltk.parse.featurechart.</tt><tt class="descname">FeatureBottomUpPredictCombineRule</tt><a class="reference internal" href="../_modules/nltk/parse/featurechart.html#FeatureBottomUpPredictCombineRule"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.featurechart.FeatureBottomUpPredictCombineRule" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.parse.chart.BottomUpPredictCombineRule" title="nltk.parse.chart.BottomUpPredictCombineRule"><tt class="xref py py-class docutils literal"><span class="pre">nltk.parse.chart.BottomUpPredictCombineRule</span></tt></a></p>
<dl class="method">
<dt id="nltk.parse.featurechart.FeatureBottomUpPredictCombineRule.apply_iter">
<tt class="descname">apply_iter</tt><big>(</big><em>chart</em>, <em>grammar</em>, <em>edge</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/featurechart.html#FeatureBottomUpPredictCombineRule.apply_iter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.featurechart.FeatureBottomUpPredictCombineRule.apply_iter" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.parse.featurechart.FeatureBottomUpPredictRule">
<em class="property">class </em><tt class="descclassname">nltk.parse.featurechart.</tt><tt class="descname">FeatureBottomUpPredictRule</tt><a class="reference internal" href="../_modules/nltk/parse/featurechart.html#FeatureBottomUpPredictRule"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.featurechart.FeatureBottomUpPredictRule" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.parse.chart.BottomUpPredictRule" title="nltk.parse.chart.BottomUpPredictRule"><tt class="xref py py-class docutils literal"><span class="pre">nltk.parse.chart.BottomUpPredictRule</span></tt></a></p>
<dl class="method">
<dt id="nltk.parse.featurechart.FeatureBottomUpPredictRule.apply_iter">
<tt class="descname">apply_iter</tt><big>(</big><em>chart</em>, <em>grammar</em>, <em>edge</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/featurechart.html#FeatureBottomUpPredictRule.apply_iter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.featurechart.FeatureBottomUpPredictRule.apply_iter" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.parse.featurechart.FeatureChart">
<em class="property">class </em><tt class="descclassname">nltk.parse.featurechart.</tt><tt class="descname">FeatureChart</tt><big>(</big><em>tokens</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/featurechart.html#FeatureChart"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.featurechart.FeatureChart" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.parse.chart.Chart" title="nltk.parse.chart.Chart"><tt class="xref py py-class docutils literal"><span class="pre">nltk.parse.chart.Chart</span></tt></a></p>
<p>A Chart for feature grammars.
:see: L{Chart} for more information.</p>
<dl class="method">
<dt id="nltk.parse.featurechart.FeatureChart.parses">
<tt class="descname">parses</tt><big>(</big><em>start</em>, <em>tree_class=&lt;class 'nltk.tree.Tree'&gt;</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/featurechart.html#FeatureChart.parses"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.featurechart.FeatureChart.parses" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nltk.parse.featurechart.FeatureChart.select">
<tt class="descname">select</tt><big>(</big><em>**restrictions</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/featurechart.html#FeatureChart.select"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.featurechart.FeatureChart.select" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an iterator over the edges in this chart. 
See L{Chart.select} for more information about the
C{restrictions} on the edges.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.parse.featurechart.FeatureChartParser">
<em class="property">class </em><tt class="descclassname">nltk.parse.featurechart.</tt><tt class="descname">FeatureChartParser</tt><big>(</big><em>grammar, strategy=[&lt;nltk.parse.chart.LeafInitRule object at 0x417dfd0&gt;, &lt;nltk.parse.featurechart.FeatureEmptyPredictRule object at 0x417df10&gt;, &lt;nltk.parse.featurechart.FeatureBottomUpPredictCombineRule object at 0x417de10&gt;, &lt;nltk.parse.featurechart.FeatureSingleEdgeFundamentalRule object at 0x417dd10&gt;], trace_chart_width=20, chart_class=&lt;class 'nltk.parse.featurechart.FeatureChart'&gt;, **parser_args</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/featurechart.html#FeatureChartParser"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.featurechart.FeatureChartParser" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.parse.chart.ChartParser" title="nltk.parse.chart.ChartParser"><tt class="xref py py-class docutils literal"><span class="pre">nltk.parse.chart.ChartParser</span></tt></a></p>
</dd></dl>

<dl class="class">
<dt id="nltk.parse.featurechart.FeatureEmptyPredictRule">
<em class="property">class </em><tt class="descclassname">nltk.parse.featurechart.</tt><tt class="descname">FeatureEmptyPredictRule</tt><a class="reference internal" href="../_modules/nltk/parse/featurechart.html#FeatureEmptyPredictRule"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.featurechart.FeatureEmptyPredictRule" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.parse.chart.EmptyPredictRule" title="nltk.parse.chart.EmptyPredictRule"><tt class="xref py py-class docutils literal"><span class="pre">nltk.parse.chart.EmptyPredictRule</span></tt></a></p>
<dl class="method">
<dt id="nltk.parse.featurechart.FeatureEmptyPredictRule.apply_iter">
<tt class="descname">apply_iter</tt><big>(</big><em>chart</em>, <em>grammar</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/featurechart.html#FeatureEmptyPredictRule.apply_iter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.featurechart.FeatureEmptyPredictRule.apply_iter" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.parse.featurechart.FeatureFundamentalRule">
<em class="property">class </em><tt class="descclassname">nltk.parse.featurechart.</tt><tt class="descname">FeatureFundamentalRule</tt><a class="reference internal" href="../_modules/nltk/parse/featurechart.html#FeatureFundamentalRule"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.featurechart.FeatureFundamentalRule" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.parse.chart.FundamentalRule" title="nltk.parse.chart.FundamentalRule"><tt class="xref py py-class docutils literal"><span class="pre">nltk.parse.chart.FundamentalRule</span></tt></a></p>
<p>A specialized version of the fundamental rule that operates on
nonterminals whose symbols are C{FeatStructNonterminal}s.  Rather
tha simply comparing the nonterminals for equality, they are
unified.  Variable bindings from these unifications are collected
and stored in the chart using a L{FeatureTreeEdge}.  When a
complete edge is generated, these bindings are applied to all
nonterminals in the edge.</p>
<dl class="docutils">
<dt>The fundamental rule states that:</dt>
<dd><ul class="first last simple">
<li>[A S{-&gt;} S{alpha} * B1 S{beta}][i:j]</li>
<li>[B2 S{-&gt;} S{gamma} <a href="#id10"><span class="problematic" id="id11">*</span></a>][j:k]</li>
</ul>
</dd>
<dt>licenses the edge:</dt>
<dd><ul class="first last simple">
<li>[A S{-&gt;} S{alpha} B3 * S{beta}][i:j]</li>
</ul>
</dd>
</dl>
<p>assuming that B1 and B2 can be unified to generate B3.</p>
<dl class="method">
<dt id="nltk.parse.featurechart.FeatureFundamentalRule.apply_iter">
<tt class="descname">apply_iter</tt><big>(</big><em>chart</em>, <em>grammar</em>, <em>left_edge</em>, <em>right_edge</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/featurechart.html#FeatureFundamentalRule.apply_iter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.featurechart.FeatureFundamentalRule.apply_iter" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.parse.featurechart.FeatureSingleEdgeFundamentalRule">
<em class="property">class </em><tt class="descclassname">nltk.parse.featurechart.</tt><tt class="descname">FeatureSingleEdgeFundamentalRule</tt><a class="reference internal" href="../_modules/nltk/parse/featurechart.html#FeatureSingleEdgeFundamentalRule"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.featurechart.FeatureSingleEdgeFundamentalRule" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.parse.chart.SingleEdgeFundamentalRule" title="nltk.parse.chart.SingleEdgeFundamentalRule"><tt class="xref py py-class docutils literal"><span class="pre">nltk.parse.chart.SingleEdgeFundamentalRule</span></tt></a></p>
<p>A specialized version of the completer / single edge fundamental rule 
that operates on nonterminals whose symbols are C{FeatStructNonterminal}s.  
Rather than simply comparing the nonterminals for equality, they are
unified.</p>
</dd></dl>

<dl class="class">
<dt id="nltk.parse.featurechart.FeatureTopDownChartParser">
<em class="property">class </em><tt class="descclassname">nltk.parse.featurechart.</tt><tt class="descname">FeatureTopDownChartParser</tt><big>(</big><em>grammar</em>, <em>**parser_args</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/featurechart.html#FeatureTopDownChartParser"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.featurechart.FeatureTopDownChartParser" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.parse.featurechart.FeatureChartParser" title="nltk.parse.featurechart.FeatureChartParser"><tt class="xref py py-class docutils literal"><span class="pre">nltk.parse.featurechart.FeatureChartParser</span></tt></a></p>
</dd></dl>

<dl class="class">
<dt id="nltk.parse.featurechart.FeatureTopDownInitRule">
<em class="property">class </em><tt class="descclassname">nltk.parse.featurechart.</tt><tt class="descname">FeatureTopDownInitRule</tt><a class="reference internal" href="../_modules/nltk/parse/featurechart.html#FeatureTopDownInitRule"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.featurechart.FeatureTopDownInitRule" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.parse.chart.TopDownInitRule" title="nltk.parse.chart.TopDownInitRule"><tt class="xref py py-class docutils literal"><span class="pre">nltk.parse.chart.TopDownInitRule</span></tt></a></p>
<dl class="method">
<dt id="nltk.parse.featurechart.FeatureTopDownInitRule.apply_iter">
<tt class="descname">apply_iter</tt><big>(</big><em>chart</em>, <em>grammar</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/featurechart.html#FeatureTopDownInitRule.apply_iter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.featurechart.FeatureTopDownInitRule.apply_iter" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.parse.featurechart.FeatureTopDownPredictRule">
<em class="property">class </em><tt class="descclassname">nltk.parse.featurechart.</tt><tt class="descname">FeatureTopDownPredictRule</tt><a class="reference internal" href="../_modules/nltk/parse/featurechart.html#FeatureTopDownPredictRule"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.featurechart.FeatureTopDownPredictRule" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.parse.chart.CachedTopDownPredictRule" title="nltk.parse.chart.CachedTopDownPredictRule"><tt class="xref py py-class docutils literal"><span class="pre">nltk.parse.chart.CachedTopDownPredictRule</span></tt></a></p>
<p>A specialized version of the (cached) top down predict rule that operates
on nonterminals whose symbols are C{FeatStructNonterminal}s.  Rather
than simply comparing the nonterminals for equality, they are
unified.</p>
<dl class="docutils">
<dt>The top down expand rule states that:</dt>
<dd><ul class="first last simple">
<li>[A S{-&gt;} S{alpha} * B1 S{beta}][i:j]</li>
</ul>
</dd>
<dt>licenses the edge:</dt>
<dd><ul class="first last simple">
<li>[B2 S{-&gt;} * S{gamma}][j:j]</li>
</ul>
</dd>
</dl>
<p>for each grammar production C{B2 S{-&gt;} S{gamma}}, assuming that B1
and B2 can be unified.</p>
<dl class="method">
<dt id="nltk.parse.featurechart.FeatureTopDownPredictRule.apply_iter">
<tt class="descname">apply_iter</tt><big>(</big><em>chart</em>, <em>grammar</em>, <em>edge</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/featurechart.html#FeatureTopDownPredictRule.apply_iter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.featurechart.FeatureTopDownPredictRule.apply_iter" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.parse.featurechart.FeatureTreeEdge">
<em class="property">class </em><tt class="descclassname">nltk.parse.featurechart.</tt><tt class="descname">FeatureTreeEdge</tt><big>(</big><em>span</em>, <em>lhs</em>, <em>rhs</em>, <em>dot=0</em>, <em>bindings=None</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/featurechart.html#FeatureTreeEdge"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.featurechart.FeatureTreeEdge" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.parse.chart.TreeEdge" title="nltk.parse.chart.TreeEdge"><tt class="xref py py-class docutils literal"><span class="pre">nltk.parse.chart.TreeEdge</span></tt></a></p>
<p>A specialized tree edge that allows shared variable bindings
between nonterminals on the left-hand side and right-hand side.</p>
<p>Each C{FeatureTreeEdge} contains a set of C{bindings}, i.e., a
dictionary mapping from variables to values.  If the edge is not
complete, then these bindings are simply stored.  However, if the
edge is complete, then the constructor applies these bindings to
every nonterminal in the edge whose symbol implements the
interface L{SubstituteBindingsI}.</p>
<dl class="method">
<dt id="nltk.parse.featurechart.FeatureTreeEdge.bindings">
<tt class="descname">bindings</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/parse/featurechart.html#FeatureTreeEdge.bindings"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.featurechart.FeatureTreeEdge.bindings" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a copy of this edge&#8217;s bindings dictionary.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="nltk.parse.featurechart.FeatureTreeEdge.from_production">
<em class="property">static </em><tt class="descname">from_production</tt><big>(</big><em>production</em>, <em>index</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/featurechart.html#FeatureTreeEdge.from_production"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.featurechart.FeatureTreeEdge.from_production" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A new C{TreeEdge} formed from the given production.
The new edge&#8217;s left-hand side and right-hand side will
be taken from C{production}; its span will be 
C{(index,index)}; and its dot position will be C{0}.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">L{TreeEdge}</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.parse.featurechart.FeatureTreeEdge.move_dot_forward">
<tt class="descname">move_dot_forward</tt><big>(</big><em>new_end</em>, <em>bindings=None</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/featurechart.html#FeatureTreeEdge.move_dot_forward"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.featurechart.FeatureTreeEdge.move_dot_forward" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A new C{FeatureTreeEdge} formed from this edge.
The new edge&#8217;s dot position is increased by C{1}, 
and its end index will be replaced by C{new_end}.</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">L{FeatureTreeEdge}</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>new_end</strong> (<em>int</em>) &#8211; The new end index.</li>
<li><strong>bindings</strong> (<em>dict</em>) &#8211; Bindings for the new edge.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.parse.featurechart.FeatureTreeEdge.next_with_bindings">
<tt class="descname">next_with_bindings</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/parse/featurechart.html#FeatureTreeEdge.next_with_bindings"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.featurechart.FeatureTreeEdge.next_with_bindings" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nltk.parse.featurechart.FeatureTreeEdge.variables">
<tt class="descname">variables</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/parse/featurechart.html#FeatureTreeEdge.variables"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.featurechart.FeatureTreeEdge.variables" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The set of variables used by this edge.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">set of L{Variable}</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.parse.featurechart.InstantiateVarsChart">
<em class="property">class </em><tt class="descclassname">nltk.parse.featurechart.</tt><tt class="descname">InstantiateVarsChart</tt><big>(</big><em>tokens</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/featurechart.html#InstantiateVarsChart"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.featurechart.InstantiateVarsChart" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.parse.featurechart.FeatureChart" title="nltk.parse.featurechart.FeatureChart"><tt class="xref py py-class docutils literal"><span class="pre">nltk.parse.featurechart.FeatureChart</span></tt></a></p>
<p>A specialized chart that &#8216;instantiates&#8217; variables whose names
start with &#8216;&#64;&#8217;, by replacing them with unique new variables.
In particular, whenever a complete edge is added to the chart, any
variables in the edge&#8217;s C{lhs} whose names start with &#8216;&#64;&#8217; will be
replaced by unique new L{Variable}s.</p>
<dl class="method">
<dt id="nltk.parse.featurechart.InstantiateVarsChart.initialize">
<tt class="descname">initialize</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/parse/featurechart.html#InstantiateVarsChart.initialize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.featurechart.InstantiateVarsChart.initialize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nltk.parse.featurechart.InstantiateVarsChart.insert">
<tt class="descname">insert</tt><big>(</big><em>edge</em>, <em>child_pointer_list</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/featurechart.html#InstantiateVarsChart.insert"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.featurechart.InstantiateVarsChart.insert" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nltk.parse.featurechart.InstantiateVarsChart.inst_vars">
<tt class="descname">inst_vars</tt><big>(</big><em>edge</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/featurechart.html#InstantiateVarsChart.inst_vars"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.featurechart.InstantiateVarsChart.inst_vars" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nltk.parse.featurechart.InstantiateVarsChart.instantiate_edge">
<tt class="descname">instantiate_edge</tt><big>(</big><em>edge</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/featurechart.html#InstantiateVarsChart.instantiate_edge"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.featurechart.InstantiateVarsChart.instantiate_edge" title="Permalink to this definition">¶</a></dt>
<dd><p>If the edge is a L{FeatureTreeEdge}, and it is complete, 
then instantiate all variables whose names start with &#8216;&#64;&#8217;,
by replacing them with unique new variables.</p>
<p>Note that instantiation is done in-place, since the
parsing algorithms might already hold a reference to 
the edge for future use.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="nltk.parse.featurechart.demo">
<tt class="descclassname">nltk.parse.featurechart.</tt><tt class="descname">demo</tt><big>(</big><em>should_print_times=True</em>, <em>should_print_grammar=True</em>, <em>should_print_trees=True</em>, <em>should_print_sentence=True</em>, <em>trace=1</em>, <em>parser=&lt;class 'nltk.parse.featurechart.FeatureChartParser'&gt;</em>, <em>sent='I saw John with a dog with my cookie'</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/featurechart.html#demo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.featurechart.demo" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="nltk.parse.featurechart.demo_grammar">
<tt class="descclassname">nltk.parse.featurechart.</tt><tt class="descname">demo_grammar</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/parse/featurechart.html#demo_grammar"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.featurechart.demo_grammar" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="nltk.parse.featurechart.run_profile">
<tt class="descclassname">nltk.parse.featurechart.</tt><tt class="descname">run_profile</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/parse/featurechart.html#run_profile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.featurechart.run_profile" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-nltk.parse.generate">
<span id="generate-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">generate</span></tt> Module<a class="headerlink" href="#module-nltk.parse.generate" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="nltk.parse.generate.generate">
<tt class="descclassname">nltk.parse.generate.</tt><tt class="descname">generate</tt><big>(</big><em>grammar</em>, <em>start=None</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/generate.html#generate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.generate.generate" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-nltk.parse.malt">
<span id="malt-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">malt</span></tt> Module<a class="headerlink" href="#module-nltk.parse.malt" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="nltk.parse.malt.MaltParser">
<em class="property">class </em><tt class="descclassname">nltk.parse.malt.</tt><tt class="descname">MaltParser</tt><big>(</big><em>tagger=None</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/malt.html#MaltParser"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.malt.MaltParser" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.parse.api.ParserI" title="nltk.parse.api.ParserI"><tt class="xref py py-class docutils literal"><span class="pre">nltk.parse.api.ParserI</span></tt></a></p>
<dl class="method">
<dt id="nltk.parse.malt.MaltParser.config_malt">
<tt class="descname">config_malt</tt><big>(</big><em>bin=None</em>, <em>verbose=False</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/malt.html#MaltParser.config_malt"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.malt.MaltParser.config_malt" title="Permalink to this definition">¶</a></dt>
<dd><p>Configure NLTK&#8217;s interface to the C{malt} package.  This
searches for a directory containing the malt jar</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>bin</strong> (<em>str</em>) &#8211; The full path to the C{malt} binary.  If not
specified, then nltk will search the system for a C{malt}
binary; and if one is not found, it will raise a
C{LookupError} exception.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.parse.malt.MaltParser.parse">
<tt class="descname">parse</tt><big>(</big><em>sentence</em>, <em>verbose=False</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/malt.html#MaltParser.parse"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.malt.MaltParser.parse" title="Permalink to this definition">¶</a></dt>
<dd><p>Use MaltParser to parse a sentence. Takes a sentence as a list of
words; it will be automatically tagged with this MaltParser instance&#8217;s
tagger.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>sentence</strong> (<em>L{list} of L{string}</em>) &#8211; Input sentence to parse</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">C{DependencyGraph} the dependency graph representation of the sentence</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.parse.malt.MaltParser.raw_parse">
<tt class="descname">raw_parse</tt><big>(</big><em>sentence</em>, <em>verbose=False</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/malt.html#MaltParser.raw_parse"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.malt.MaltParser.raw_parse" title="Permalink to this definition">¶</a></dt>
<dd><p>Use MaltParser to parse a sentence. Takes a sentence as a string;
before parsing, it will be automatically tokenized and tagged with this
MaltParser instance&#8217;s tagger.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>sentence</strong> (<em>L{string}</em>) &#8211; Input sentence to parse</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">C{DependencyGraph} the dependency graph representation of the sentence</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.parse.malt.MaltParser.tagged_parse">
<tt class="descname">tagged_parse</tt><big>(</big><em>sentence</em>, <em>verbose=False</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/malt.html#MaltParser.tagged_parse"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.malt.MaltParser.tagged_parse" title="Permalink to this definition">¶</a></dt>
<dd><p>Use MaltParser to parse a sentence. Takes a sentence as a list of
(word, tag) tuples; the sentence must have already been tokenized and
tagged.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>sentence</strong> (<em>L{list} of (word, tag) L{tuple}s.</em>) &#8211; Input sentence to parse</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">C{DependencyGraph} the dependency graph representation of the sentence</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.parse.malt.MaltParser.train">
<tt class="descname">train</tt><big>(</big><em>depgraphs</em>, <em>verbose=False</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/malt.html#MaltParser.train"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.malt.MaltParser.train" title="Permalink to this definition">¶</a></dt>
<dd><p>Train MaltParser from a list of C{DependencyGraph}s</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>depgraphs</strong> &#8211; list of C{DependencyGraph}s for training input data</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.parse.malt.MaltParser.train_from_file">
<tt class="descname">train_from_file</tt><big>(</big><em>conll_file</em>, <em>verbose=False</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/malt.html#MaltParser.train_from_file"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.malt.MaltParser.train_from_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Train MaltParser from a file</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>conll_file</strong> &#8211; str for the filename of the training input data</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="nltk.parse.malt.demo">
<tt class="descclassname">nltk.parse.malt.</tt><tt class="descname">demo</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/parse/malt.html#demo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.malt.demo" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-nltk.parse.nonprojectivedependencyparser">
<span id="nonprojectivedependencyparser-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">nonprojectivedependencyparser</span></tt> Module<a class="headerlink" href="#module-nltk.parse.nonprojectivedependencyparser" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="nltk.parse.nonprojectivedependencyparser.DemoScorer">
<em class="property">class </em><tt class="descclassname">nltk.parse.nonprojectivedependencyparser.</tt><tt class="descname">DemoScorer</tt><a class="reference internal" href="../_modules/nltk/parse/nonprojectivedependencyparser.html#DemoScorer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.nonprojectivedependencyparser.DemoScorer" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="nltk.parse.nonprojectivedependencyparser.DemoScorer.score">
<tt class="descname">score</tt><big>(</big><em>graph</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/nonprojectivedependencyparser.html#DemoScorer.score"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.nonprojectivedependencyparser.DemoScorer.score" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nltk.parse.nonprojectivedependencyparser.DemoScorer.train">
<tt class="descname">train</tt><big>(</big><em>graphs</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/nonprojectivedependencyparser.html#DemoScorer.train"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.nonprojectivedependencyparser.DemoScorer.train" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.parse.nonprojectivedependencyparser.DependencyScorerI">
<em class="property">class </em><tt class="descclassname">nltk.parse.nonprojectivedependencyparser.</tt><tt class="descname">DependencyScorerI</tt><a class="reference internal" href="../_modules/nltk/parse/nonprojectivedependencyparser.html#DependencyScorerI"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.nonprojectivedependencyparser.DependencyScorerI" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>A scorer for calculated the weights on the edges of a weighted 
dependency graph.  This is used by a 
C{ProbabilisticNonprojectiveParser} to initialize the edge  
weights of a C{DependencyGraph}.  While typically this would be done 
by training a binary classifier, any class that can return a 
multidimensional list representation of the edge weights can 
implement this interface.  As such, it has no necessary
fields.</p>
<dl class="method">
<dt id="nltk.parse.nonprojectivedependencyparser.DependencyScorerI.score">
<tt class="descname">score</tt><big>(</big><em>graph</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/nonprojectivedependencyparser.html#DependencyScorerI.score"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.nonprojectivedependencyparser.DependencyScorerI.score" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>graph</strong> (<em>A C{DependencyGraph}</em>) &#8211; A dependency graph whose set of edges need to be</td>
</tr>
</tbody>
</table>
<p>scored.  
:rtype: A three-dimensional list of numbers.
:return: The score is returned in a multidimensional(3) list, such
that the outer-dimension refers to the head, and the
inner-dimension refers to the dependencies.  For instance,  
scores[0][1] would reference the list of scores corresponding to 
arcs from node 0 to node 1.  The node&#8217;s &#8216;address&#8217; field can be used 
to determine its number identification.</p>
<p>For further illustration, a score list corresponding to Fig.2 of 
Keith Hall&#8217;s &#8216;K-best Spanning Tree Parsing&#8217; paper:</p>
<blockquote>
<div><dl class="docutils">
<dt>scores = [[[], [5],  [1],  [1]],</dt>
<dd>[[], [],   [11], [4]],
[[], [10], [],   [5]],
[[], [8],  [8],  []]]</dd>
</dl>
</div></blockquote>
<p>When used in conjunction with a MaxEntClassifier, each score would 
correspond to the confidence of a particular edge being classified 
with the positive training examples.</p>
</dd></dl>

<dl class="method">
<dt id="nltk.parse.nonprojectivedependencyparser.DependencyScorerI.train">
<tt class="descname">train</tt><big>(</big><em>graphs</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/nonprojectivedependencyparser.html#DependencyScorerI.train"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.nonprojectivedependencyparser.DependencyScorerI.train" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>graphs</strong> (<em>A list of C{DependencyGraph}</em>) &#8211; A list of dependency graphs to train the scorer.</td>
</tr>
</tbody>
</table>
<p>Typically the edges present in the graphs can be used as
positive training examples, and the edges not present as negative 
examples.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.parse.nonprojectivedependencyparser.NaiveBayesDependencyScorer">
<em class="property">class </em><tt class="descclassname">nltk.parse.nonprojectivedependencyparser.</tt><tt class="descname">NaiveBayesDependencyScorer</tt><a class="reference internal" href="../_modules/nltk/parse/nonprojectivedependencyparser.html#NaiveBayesDependencyScorer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.nonprojectivedependencyparser.NaiveBayesDependencyScorer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.parse.nonprojectivedependencyparser.DependencyScorerI" title="nltk.parse.nonprojectivedependencyparser.DependencyScorerI"><tt class="xref py py-class docutils literal"><span class="pre">nltk.parse.nonprojectivedependencyparser.DependencyScorerI</span></tt></a></p>
<p>A dependency scorer built around a MaxEnt classifier.  In this
particular class that classifier is a C{NaiveBayesClassifier}.
It uses head-word, head-tag, child-word, and child-tag features
for classification.</p>
<dl class="method">
<dt id="nltk.parse.nonprojectivedependencyparser.NaiveBayesDependencyScorer.score">
<tt class="descname">score</tt><big>(</big><em>graph</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/nonprojectivedependencyparser.html#NaiveBayesDependencyScorer.score"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.nonprojectivedependencyparser.NaiveBayesDependencyScorer.score" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts the graph into a feature-based representation of 
each edge, and then assigns a score to each based on the 
confidence of the classifier in assigning it to the 
positive label.  Scores are returned in a multidimensional list.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>graph</strong> (<em>C{DependencyGraph}</em>) &#8211; A dependency graph to score.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">3 dimensional list</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Edge scores for the graph parameter.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.parse.nonprojectivedependencyparser.NaiveBayesDependencyScorer.train">
<tt class="descname">train</tt><big>(</big><em>graphs</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/nonprojectivedependencyparser.html#NaiveBayesDependencyScorer.train"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.nonprojectivedependencyparser.NaiveBayesDependencyScorer.train" title="Permalink to this definition">¶</a></dt>
<dd><p>Trains a C{NaiveBayesClassifier} using the edges present in 
graphs list as positive examples, the edges not present as
negative examples.  Uses a feature vector of head-word,
head-tag, child-word, and child-tag.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>graphs</strong> (<em>A list of C{DependencyGraph}</em>) &#8211; A list of dependency graphs to train the scorer.</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.parse.nonprojectivedependencyparser.NonprojectiveDependencyParser">
<em class="property">class </em><tt class="descclassname">nltk.parse.nonprojectivedependencyparser.</tt><tt class="descname">NonprojectiveDependencyParser</tt><big>(</big><em>dependency_grammar</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/nonprojectivedependencyparser.html#NonprojectiveDependencyParser"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.nonprojectivedependencyparser.NonprojectiveDependencyParser" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>A non-projective, rule-based, dependency parser.  This parser 
will return the set of all possible non-projective parses based on 
the word-to-word relations defined in the parser&#8217;s dependency 
grammar, and will allow the branches of the parse tree to cross 
in order to capture a variety of linguistic phenomena that a 
projective parser will not.</p>
<dl class="method">
<dt id="nltk.parse.nonprojectivedependencyparser.NonprojectiveDependencyParser.parse">
<tt class="descname">parse</tt><big>(</big><em>tokens</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/nonprojectivedependencyparser.html#NonprojectiveDependencyParser.parse"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.nonprojectivedependencyparser.NonprojectiveDependencyParser.parse" title="Permalink to this definition">¶</a></dt>
<dd><p>Parses the input tokens with respect to the parser&#8217;s grammar.  Parsing 
is accomplished by representing the search-space of possible parses as 
a fully-connected directed graph.  Arcs that would lead to ungrammatical 
parses are removed and a lattice is constructed of length n, where n is 
the number of input tokens, to represent all possible grammatical 
traversals.  All possible paths through the lattice are then enumerated
to produce the set of non-projective parses.</p>
<p>param tokens: A list of tokens to parse.
type tokens: A list of L{String}.
return: A set of non-projective parses.
rtype: A list of L{DependencyGraph}</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.parse.nonprojectivedependencyparser.ProbabilisticNonprojectiveParser">
<em class="property">class </em><tt class="descclassname">nltk.parse.nonprojectivedependencyparser.</tt><tt class="descname">ProbabilisticNonprojectiveParser</tt><a class="reference internal" href="../_modules/nltk/parse/nonprojectivedependencyparser.html#ProbabilisticNonprojectiveParser"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.nonprojectivedependencyparser.ProbabilisticNonprojectiveParser" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>A probabilistic non-projective dependency parser.  Nonprojective 
dependencies allows for &#8220;crossing branches&#8221; in the parse tree 
which is necessary for representing particular linguistic 
phenomena, or even typical parses in some languages.  This parser 
follows the MST parsing algorithm, outlined in McDonald(2005), 
which likens the search for the best non-projective parse to 
finding the maximum spanning tree in a weighted directed graph.</p>
<dl class="method">
<dt id="nltk.parse.nonprojectivedependencyparser.ProbabilisticNonprojectiveParser.best_incoming_arc">
<tt class="descname">best_incoming_arc</tt><big>(</big><em>node_index</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/nonprojectivedependencyparser.html#ProbabilisticNonprojectiveParser.best_incoming_arc"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.nonprojectivedependencyparser.ProbabilisticNonprojectiveParser.best_incoming_arc" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the source of the best incoming arc to the 
node with address: node_index</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>node_index</strong> (<em>integer.</em>) &#8211; The address of the &#8216;destination&#8217; node,</td>
</tr>
</tbody>
</table>
<p>the node that is arced to.</p>
</dd></dl>

<dl class="method">
<dt id="nltk.parse.nonprojectivedependencyparser.ProbabilisticNonprojectiveParser.collapse_nodes">
<tt class="descname">collapse_nodes</tt><big>(</big><em>new_node</em>, <em>cycle_path</em>, <em>g_graph</em>, <em>b_graph</em>, <em>c_graph</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/nonprojectivedependencyparser.html#ProbabilisticNonprojectiveParser.collapse_nodes"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.nonprojectivedependencyparser.ProbabilisticNonprojectiveParser.collapse_nodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a list of nodes that have been identified to belong to a cycle,
and collapses them into on larger node.  The arcs of all nodes in 
the graph must be updated to account for this.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>new_node</strong> (<em>Node.</em>) &#8211; A Node (Dictionary) to collapse the cycle nodes into.</li>
<li><strong>cycle_path</strong> (<em>A list of integers.</em>) &#8211; A list of node addresses, each of which is in the cycle.</li>
<li><strong>b_graph, c_graph</strong> (<em>g_graph,</em>) &#8211; Graphs which need to be updated.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.parse.nonprojectivedependencyparser.ProbabilisticNonprojectiveParser.compute_max_subtract_score">
<tt class="descname">compute_max_subtract_score</tt><big>(</big><em>column_index</em>, <em>cycle_indexes</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/nonprojectivedependencyparser.html#ProbabilisticNonprojectiveParser.compute_max_subtract_score"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.nonprojectivedependencyparser.ProbabilisticNonprojectiveParser.compute_max_subtract_score" title="Permalink to this definition">¶</a></dt>
<dd><p>When updating scores the score of the highest-weighted incoming
arc is subtracted upon collapse.  This returns the correct 
amount to subtract from that edge.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>column_index</strong> (<em>integer.</em>) &#8211; A index representing the column of incoming arcs</td>
</tr>
</tbody>
</table>
<p>to a particular node being updated
:type cycle_indexes: A list of integers.
:param cycle_indexes: Only arcs from cycle nodes are considered.  This 
is a list of such nodes addresses.</p>
</dd></dl>

<dl class="method">
<dt id="nltk.parse.nonprojectivedependencyparser.ProbabilisticNonprojectiveParser.compute_original_indexes">
<tt class="descname">compute_original_indexes</tt><big>(</big><em>new_indexes</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/nonprojectivedependencyparser.html#ProbabilisticNonprojectiveParser.compute_original_indexes"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.nonprojectivedependencyparser.ProbabilisticNonprojectiveParser.compute_original_indexes" title="Permalink to this definition">¶</a></dt>
<dd><p>As nodes are collapsed into others, they are replaced 
by the new node in the graph, but it&#8217;s still necessary
to keep track of what these original nodes were.  This
takes a list of node addresses and replaces any collapsed
node addresses with their original addresses.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>new_addresses</strong> &#8211; A list of node addresses to check for</td>
</tr>
</tbody>
</table>
<p>subsumed nodes.</p>
</dd></dl>

<dl class="method">
<dt id="nltk.parse.nonprojectivedependencyparser.ProbabilisticNonprojectiveParser.initialize_edge_scores">
<tt class="descname">initialize_edge_scores</tt><big>(</big><em>graph</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/nonprojectivedependencyparser.html#ProbabilisticNonprojectiveParser.initialize_edge_scores"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.nonprojectivedependencyparser.ProbabilisticNonprojectiveParser.initialize_edge_scores" title="Permalink to this definition">¶</a></dt>
<dd><p>Assigns a score to every edge in the C{DependencyGraph} graph.
These scores are generated via the parser&#8217;s scorer which 
was assigned during the training process.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>graph</strong> (<em>C{DependencyGraph}</em>) &#8211; A dependency graph to assign scores to.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.parse.nonprojectivedependencyparser.ProbabilisticNonprojectiveParser.original_best_arc">
<tt class="descname">original_best_arc</tt><big>(</big><em>node_index</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/nonprojectivedependencyparser.html#ProbabilisticNonprojectiveParser.original_best_arc"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.nonprojectivedependencyparser.ProbabilisticNonprojectiveParser.original_best_arc" title="Permalink to this definition">¶</a></dt>
<dd><p>???</p>
</dd></dl>

<dl class="method">
<dt id="nltk.parse.nonprojectivedependencyparser.ProbabilisticNonprojectiveParser.parse">
<tt class="descname">parse</tt><big>(</big><em>tokens</em>, <em>tags</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/nonprojectivedependencyparser.html#ProbabilisticNonprojectiveParser.parse"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.nonprojectivedependencyparser.ProbabilisticNonprojectiveParser.parse" title="Permalink to this definition">¶</a></dt>
<dd><p>Parses a list of tokens in accordance to the MST parsing algorithm
for non-projective dependency parses.  Assumes that the tokens to 
be parsed have already been tagged and those tags are provided.  Various 
scoring methods can be used by implementing the C{DependencyScorerI}
interface and passing it to the training algorithm.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>tokens</strong> (<em>A list of C{String}.</em>) &#8211; A list of words or punctuation to be parsed.</li>
<li><strong>tags</strong> (<em>A List of C{String}.</em>) &#8211; A list of tags corresponding by index to the words in the tokens list.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.parse.nonprojectivedependencyparser.ProbabilisticNonprojectiveParser.train">
<tt class="descname">train</tt><big>(</big><em>graphs</em>, <em>dependency_scorer</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/nonprojectivedependencyparser.html#ProbabilisticNonprojectiveParser.train"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.nonprojectivedependencyparser.ProbabilisticNonprojectiveParser.train" title="Permalink to this definition">¶</a></dt>
<dd><p>Trains a C{DependencyScorerI} from a set of C{DependencyGraph} objects,
and establishes this as the parser&#8217;s scorer.  This is used to 
initialize the scores on a C{DependencyGraph} during the parsing 
procedure.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>graphs</strong> (<em>A list of C{DependencyGraph}</em>) &#8211; A list of dependency graphs to train the scorer.</li>
<li><strong>dependency_scorer</strong> (<em>C{DependencyScorerI}</em>) &#8211; A scorer which implements the</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>C{DependencyScorerI} interface.</p>
</dd></dl>

<dl class="method">
<dt id="nltk.parse.nonprojectivedependencyparser.ProbabilisticNonprojectiveParser.update_edge_scores">
<tt class="descname">update_edge_scores</tt><big>(</big><em>new_node</em>, <em>cycle_path</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/nonprojectivedependencyparser.html#ProbabilisticNonprojectiveParser.update_edge_scores"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.nonprojectivedependencyparser.ProbabilisticNonprojectiveParser.update_edge_scores" title="Permalink to this definition">¶</a></dt>
<dd><p>Updates the edge scores to reflect a collapse operation into
new_node.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>new_node</strong> (<em>A Node.</em>) &#8211; The node which cycle nodes are collapsed into.</li>
<li><strong>cycle_path</strong> (<em>A list of integers.</em>) &#8211; A list of node addresses that belong to the cycle.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="nltk.parse.nonprojectivedependencyparser.demo">
<tt class="descclassname">nltk.parse.nonprojectivedependencyparser.</tt><tt class="descname">demo</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/parse/nonprojectivedependencyparser.html#demo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.nonprojectivedependencyparser.demo" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="nltk.parse.nonprojectivedependencyparser.hall_demo">
<tt class="descclassname">nltk.parse.nonprojectivedependencyparser.</tt><tt class="descname">hall_demo</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/parse/nonprojectivedependencyparser.html#hall_demo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.nonprojectivedependencyparser.hall_demo" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="nltk.parse.nonprojectivedependencyparser.nonprojective_conll_parse_demo">
<tt class="descclassname">nltk.parse.nonprojectivedependencyparser.</tt><tt class="descname">nonprojective_conll_parse_demo</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/parse/nonprojectivedependencyparser.html#nonprojective_conll_parse_demo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.nonprojectivedependencyparser.nonprojective_conll_parse_demo" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="nltk.parse.nonprojectivedependencyparser.rule_based_demo">
<tt class="descclassname">nltk.parse.nonprojectivedependencyparser.</tt><tt class="descname">rule_based_demo</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/parse/nonprojectivedependencyparser.html#rule_based_demo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.nonprojectivedependencyparser.rule_based_demo" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-nltk.parse.pchart">
<span id="pchart-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">pchart</span></tt> Module<a class="headerlink" href="#module-nltk.parse.pchart" title="Permalink to this headline">¶</a></h2>
<p>Classes and interfaces for associating probabilities with tree
structures that represent the internal organization of a text.  The
probabilistic parser module defines C{BottomUpProbabilisticChartParser}.</p>
<p>C{BottomUpProbabilisticChartParser} is an abstract class that implements 
a bottom-up chart parser for C{PCFG}s.  It maintains a queue of edges,
and adds them to the chart one at a time.  The ordering of this queue
is based on the probabilities associated with the edges, allowing the
parser to expand more likely edges before less likely ones.  Each
subclass implements a different queue ordering, producing different
search strategies.  Currently the following subclasses are defined:</p>
<blockquote>
<div><ul class="simple">
<li>C{InsideChartParser} searches edges in decreasing order of
their trees&#8217; inside probabilities.</li>
<li>C{RandomChartParser} searches edges in random order.</li>
<li>C{LongestChartParser} searches edges in decreasing order of their
location&#8217;s length.</li>
</ul>
</div></blockquote>
<p>The C{BottomUpProbabilisticChartParser} constructor has an optional 
argument beam_size.  If non-zero, this controls the size of the beam 
(aka the edge queue).  This option is most useful with InsideChartParser.</p>
<dl class="class">
<dt id="nltk.parse.pchart.BottomUpProbabilisticChartParser">
<em class="property">class </em><tt class="descclassname">nltk.parse.pchart.</tt><tt class="descname">BottomUpProbabilisticChartParser</tt><big>(</big><em>grammar</em>, <em>beam_size=0</em>, <em>trace=0</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/pchart.html#BottomUpProbabilisticChartParser"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.pchart.BottomUpProbabilisticChartParser" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.parse.api.ParserI" title="nltk.parse.api.ParserI"><tt class="xref py py-class docutils literal"><span class="pre">nltk.parse.api.ParserI</span></tt></a></p>
<p>An abstract bottom-up parser for C{PCFG}s that uses a C{Chart} to
record partial results.  C{BottomUpProbabilisticChartParser} maintains 
a queue of edges that can be added to the chart.  This queue is
initialized with edges for each token in the text that is being
parsed.  C{BottomUpProbabilisticChartParser} inserts these edges into 
the chart one at a time, starting with the most likely edges, and
proceeding to less likely edges.  For each edge that is added to
the chart, it may become possible to insert additional edges into
the chart; these are added to the queue.  This process continues
until enough complete parses have been generated, or until the
queue is empty.</p>
<p>The sorting order for the queue is not specified by
C{BottomUpProbabilisticChartParser}.  Different sorting orders will 
result in different search strategies.  The sorting order for the 
queue is defined by the method C{sort_queue}; subclasses are required
to provide a definition for this method.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><ul class="first last simple">
<li><strong>_grammar</strong> &#8211; The grammar used to parse sentences.</li>
<li><strong>_trace</strong> &#8211; The level of tracing output that should be generated
when parsing a text.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="nltk.parse.pchart.BottomUpProbabilisticChartParser.grammar">
<tt class="descname">grammar</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/parse/pchart.html#BottomUpProbabilisticChartParser.grammar"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.pchart.BottomUpProbabilisticChartParser.grammar" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nltk.parse.pchart.BottomUpProbabilisticChartParser.nbest_parse">
<tt class="descname">nbest_parse</tt><big>(</big><em>tokens</em>, <em>n=None</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/pchart.html#BottomUpProbabilisticChartParser.nbest_parse"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.pchart.BottomUpProbabilisticChartParser.nbest_parse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nltk.parse.pchart.BottomUpProbabilisticChartParser.sort_queue">
<tt class="descname">sort_queue</tt><big>(</big><em>queue</em>, <em>chart</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/pchart.html#BottomUpProbabilisticChartParser.sort_queue"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.pchart.BottomUpProbabilisticChartParser.sort_queue" title="Permalink to this definition">¶</a></dt>
<dd><p>Sort the given queue of C{Edge}s, placing the edge that should
be tried first at the beginning of the queue.  This method
will be called after each C{Edge} is added to the queue.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>queue</strong> (<em>list of C{Edge}</em>) &#8211; The queue of C{Edge}s to sort.  Each edge in
this queue is an edge that could be added to the chart by
the fundamental rule; but that has not yet been added.</li>
<li><strong>chart</strong> (<em>C{Chart}</em>) &#8211; The chart being used to parse the text.  This
chart can be used to provide extra information for sorting
the queue.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">None</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.parse.pchart.BottomUpProbabilisticChartParser.trace">
<tt class="descname">trace</tt><big>(</big><em>trace=2</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/pchart.html#BottomUpProbabilisticChartParser.trace"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.pchart.BottomUpProbabilisticChartParser.trace" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the level of tracing output that should be generated when
parsing a text.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>trace</strong> (<em>int</em>) &#8211; The trace level.  A trace level of C{0} will
generate no tracing output; and higher trace levels will
produce more verbose tracing output.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">None</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.parse.pchart.InsideChartParser">
<em class="property">class </em><tt class="descclassname">nltk.parse.pchart.</tt><tt class="descname">InsideChartParser</tt><big>(</big><em>grammar</em>, <em>beam_size=0</em>, <em>trace=0</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/pchart.html#InsideChartParser"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.pchart.InsideChartParser" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.parse.pchart.BottomUpProbabilisticChartParser" title="nltk.parse.pchart.BottomUpProbabilisticChartParser"><tt class="xref py py-class docutils literal"><span class="pre">nltk.parse.pchart.BottomUpProbabilisticChartParser</span></tt></a></p>
<p>A bottom-up parser for C{PCFG}s that tries edges in descending
order of the inside probabilities of their trees.  The X{inside
probability} of a tree is simply the
probability of the entire tree, ignoring its context.  In
particular, the inside probability of a tree generated by
production M{p} with children M{c[1]}, M{c[2]}, ..., M{c[n]} is
P(M{p})*P(M{c[1]})*P(M{c[2]})*M{...}*P(M{c[n]}); and the inside
probability of a token is 1 if it is present in the text, and 0 if
it is absent.</p>
<p>This sorting order results in a type of lowest-cost-first search
strategy.</p>
<dl class="method">
<dt id="nltk.parse.pchart.InsideChartParser.sort_queue">
<tt class="descname">sort_queue</tt><big>(</big><em>queue</em>, <em>chart</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/pchart.html#InsideChartParser.sort_queue"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.pchart.InsideChartParser.sort_queue" title="Permalink to this definition">¶</a></dt>
<dd><p>Sort the given queue of edges, in descending order of the
inside probabilities of the edges&#8217; trees.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>queue</strong> (<em>list of C{Edge}</em>) &#8211; The queue of C{Edge}s to sort.  Each edge in
this queue is an edge that could be added to the chart by
the fundamental rule; but that has not yet been added.</li>
<li><strong>chart</strong> (<em>C{Chart}</em>) &#8211; The chart being used to parse the text.  This
chart can be used to provide extra information for sorting
the queue.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">None</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.parse.pchart.LongestChartParser">
<em class="property">class </em><tt class="descclassname">nltk.parse.pchart.</tt><tt class="descname">LongestChartParser</tt><big>(</big><em>grammar</em>, <em>beam_size=0</em>, <em>trace=0</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/pchart.html#LongestChartParser"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.pchart.LongestChartParser" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.parse.pchart.BottomUpProbabilisticChartParser" title="nltk.parse.pchart.BottomUpProbabilisticChartParser"><tt class="xref py py-class docutils literal"><span class="pre">nltk.parse.pchart.BottomUpProbabilisticChartParser</span></tt></a></p>
<p>A bottom-up parser for C{PCFG}s that tries longer edges before
shorter ones.  This sorting order results in a type of best-first
search strategy.</p>
<dl class="method">
<dt id="nltk.parse.pchart.LongestChartParser.sort_queue">
<tt class="descname">sort_queue</tt><big>(</big><em>queue</em>, <em>chart</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/pchart.html#LongestChartParser.sort_queue"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.pchart.LongestChartParser.sort_queue" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.parse.pchart.ProbabilisticBottomUpInitRule">
<em class="property">class </em><tt class="descclassname">nltk.parse.pchart.</tt><tt class="descname">ProbabilisticBottomUpInitRule</tt><a class="reference internal" href="../_modules/nltk/parse/pchart.html#ProbabilisticBottomUpInitRule"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.pchart.ProbabilisticBottomUpInitRule" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.parse.chart.AbstractChartRule" title="nltk.parse.chart.AbstractChartRule"><tt class="xref py py-class docutils literal"><span class="pre">nltk.parse.chart.AbstractChartRule</span></tt></a></p>
<dl class="attribute">
<dt id="nltk.parse.pchart.ProbabilisticBottomUpInitRule.NUM_EDGES">
<tt class="descname">NUM_EDGES</tt><em class="property"> = 0</em><a class="headerlink" href="#nltk.parse.pchart.ProbabilisticBottomUpInitRule.NUM_EDGES" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nltk.parse.pchart.ProbabilisticBottomUpInitRule.apply_iter">
<tt class="descname">apply_iter</tt><big>(</big><em>chart</em>, <em>grammar</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/pchart.html#ProbabilisticBottomUpInitRule.apply_iter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.pchart.ProbabilisticBottomUpInitRule.apply_iter" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.parse.pchart.ProbabilisticBottomUpPredictRule">
<em class="property">class </em><tt class="descclassname">nltk.parse.pchart.</tt><tt class="descname">ProbabilisticBottomUpPredictRule</tt><a class="reference internal" href="../_modules/nltk/parse/pchart.html#ProbabilisticBottomUpPredictRule"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.pchart.ProbabilisticBottomUpPredictRule" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.parse.chart.AbstractChartRule" title="nltk.parse.chart.AbstractChartRule"><tt class="xref py py-class docutils literal"><span class="pre">nltk.parse.chart.AbstractChartRule</span></tt></a></p>
<dl class="attribute">
<dt id="nltk.parse.pchart.ProbabilisticBottomUpPredictRule.NUM_EDGES">
<tt class="descname">NUM_EDGES</tt><em class="property"> = 1</em><a class="headerlink" href="#nltk.parse.pchart.ProbabilisticBottomUpPredictRule.NUM_EDGES" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nltk.parse.pchart.ProbabilisticBottomUpPredictRule.apply_iter">
<tt class="descname">apply_iter</tt><big>(</big><em>chart</em>, <em>grammar</em>, <em>edge</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/pchart.html#ProbabilisticBottomUpPredictRule.apply_iter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.pchart.ProbabilisticBottomUpPredictRule.apply_iter" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.parse.pchart.ProbabilisticFundamentalRule">
<em class="property">class </em><tt class="descclassname">nltk.parse.pchart.</tt><tt class="descname">ProbabilisticFundamentalRule</tt><a class="reference internal" href="../_modules/nltk/parse/pchart.html#ProbabilisticFundamentalRule"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.pchart.ProbabilisticFundamentalRule" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.parse.chart.AbstractChartRule" title="nltk.parse.chart.AbstractChartRule"><tt class="xref py py-class docutils literal"><span class="pre">nltk.parse.chart.AbstractChartRule</span></tt></a></p>
<dl class="attribute">
<dt id="nltk.parse.pchart.ProbabilisticFundamentalRule.NUM_EDGES">
<tt class="descname">NUM_EDGES</tt><em class="property"> = 2</em><a class="headerlink" href="#nltk.parse.pchart.ProbabilisticFundamentalRule.NUM_EDGES" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nltk.parse.pchart.ProbabilisticFundamentalRule.apply_iter">
<tt class="descname">apply_iter</tt><big>(</big><em>chart</em>, <em>grammar</em>, <em>left_edge</em>, <em>right_edge</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/pchart.html#ProbabilisticFundamentalRule.apply_iter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.pchart.ProbabilisticFundamentalRule.apply_iter" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.parse.pchart.ProbabilisticLeafEdge">
<em class="property">class </em><tt class="descclassname">nltk.parse.pchart.</tt><tt class="descname">ProbabilisticLeafEdge</tt><big>(</big><em>leaf</em>, <em>index</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/pchart.html#ProbabilisticLeafEdge"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.pchart.ProbabilisticLeafEdge" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.parse.chart.LeafEdge" title="nltk.parse.chart.LeafEdge"><tt class="xref py py-class docutils literal"><span class="pre">nltk.parse.chart.LeafEdge</span></tt></a></p>
<dl class="method">
<dt id="nltk.parse.pchart.ProbabilisticLeafEdge.prob">
<tt class="descname">prob</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/parse/pchart.html#ProbabilisticLeafEdge.prob"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.pchart.ProbabilisticLeafEdge.prob" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.parse.pchart.ProbabilisticTreeEdge">
<em class="property">class </em><tt class="descclassname">nltk.parse.pchart.</tt><tt class="descname">ProbabilisticTreeEdge</tt><big>(</big><em>prob</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/pchart.html#ProbabilisticTreeEdge"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.pchart.ProbabilisticTreeEdge" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.parse.chart.TreeEdge" title="nltk.parse.chart.TreeEdge"><tt class="xref py py-class docutils literal"><span class="pre">nltk.parse.chart.TreeEdge</span></tt></a></p>
<dl class="staticmethod">
<dt id="nltk.parse.pchart.ProbabilisticTreeEdge.from_production">
<em class="property">static </em><tt class="descname">from_production</tt><big>(</big><em>production</em>, <em>index</em>, <em>p</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/pchart.html#ProbabilisticTreeEdge.from_production"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.pchart.ProbabilisticTreeEdge.from_production" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nltk.parse.pchart.ProbabilisticTreeEdge.prob">
<tt class="descname">prob</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/parse/pchart.html#ProbabilisticTreeEdge.prob"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.pchart.ProbabilisticTreeEdge.prob" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.parse.pchart.RandomChartParser">
<em class="property">class </em><tt class="descclassname">nltk.parse.pchart.</tt><tt class="descname">RandomChartParser</tt><big>(</big><em>grammar</em>, <em>beam_size=0</em>, <em>trace=0</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/pchart.html#RandomChartParser"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.pchart.RandomChartParser" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.parse.pchart.BottomUpProbabilisticChartParser" title="nltk.parse.pchart.BottomUpProbabilisticChartParser"><tt class="xref py py-class docutils literal"><span class="pre">nltk.parse.pchart.BottomUpProbabilisticChartParser</span></tt></a></p>
<p>A bottom-up parser for C{PCFG}s that tries edges in random order.
This sorting order results in a random search strategy.</p>
<dl class="method">
<dt id="nltk.parse.pchart.RandomChartParser.sort_queue">
<tt class="descname">sort_queue</tt><big>(</big><em>queue</em>, <em>chart</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/pchart.html#RandomChartParser.sort_queue"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.pchart.RandomChartParser.sort_queue" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.parse.pchart.SingleEdgeProbabilisticFundamentalRule">
<em class="property">class </em><tt class="descclassname">nltk.parse.pchart.</tt><tt class="descname">SingleEdgeProbabilisticFundamentalRule</tt><a class="reference internal" href="../_modules/nltk/parse/pchart.html#SingleEdgeProbabilisticFundamentalRule"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.pchart.SingleEdgeProbabilisticFundamentalRule" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.parse.chart.AbstractChartRule" title="nltk.parse.chart.AbstractChartRule"><tt class="xref py py-class docutils literal"><span class="pre">nltk.parse.chart.AbstractChartRule</span></tt></a></p>
<dl class="attribute">
<dt id="nltk.parse.pchart.SingleEdgeProbabilisticFundamentalRule.NUM_EDGES">
<tt class="descname">NUM_EDGES</tt><em class="property"> = 1</em><a class="headerlink" href="#nltk.parse.pchart.SingleEdgeProbabilisticFundamentalRule.NUM_EDGES" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nltk.parse.pchart.SingleEdgeProbabilisticFundamentalRule.apply_iter">
<tt class="descname">apply_iter</tt><big>(</big><em>chart</em>, <em>grammar</em>, <em>edge1</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/pchart.html#SingleEdgeProbabilisticFundamentalRule.apply_iter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.pchart.SingleEdgeProbabilisticFundamentalRule.apply_iter" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.parse.pchart.UnsortedChartParser">
<em class="property">class </em><tt class="descclassname">nltk.parse.pchart.</tt><tt class="descname">UnsortedChartParser</tt><big>(</big><em>grammar</em>, <em>beam_size=0</em>, <em>trace=0</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/pchart.html#UnsortedChartParser"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.pchart.UnsortedChartParser" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.parse.pchart.BottomUpProbabilisticChartParser" title="nltk.parse.pchart.BottomUpProbabilisticChartParser"><tt class="xref py py-class docutils literal"><span class="pre">nltk.parse.pchart.BottomUpProbabilisticChartParser</span></tt></a></p>
<p>A bottom-up parser for C{PCFG}s that tries edges in whatever order.</p>
<dl class="method">
<dt id="nltk.parse.pchart.UnsortedChartParser.sort_queue">
<tt class="descname">sort_queue</tt><big>(</big><em>queue</em>, <em>chart</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/pchart.html#UnsortedChartParser.sort_queue"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.pchart.UnsortedChartParser.sort_queue" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="nltk.parse.pchart.demo">
<tt class="descclassname">nltk.parse.pchart.</tt><tt class="descname">demo</tt><big>(</big><em>choice=None</em>, <em>draw_parses=None</em>, <em>print_parses=None</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/pchart.html#demo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.pchart.demo" title="Permalink to this definition">¶</a></dt>
<dd><p>A demonstration of the probabilistic parsers.  The user is
prompted to select which demo to run, and how many parses should
be found; and then each parser is run on the same demo, and a
summary of the results are displayed.</p>
</dd></dl>

</div>
<div class="section" id="module-nltk.parse.projectivedependencyparser">
<span id="projectivedependencyparser-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">projectivedependencyparser</span></tt> Module<a class="headerlink" href="#module-nltk.parse.projectivedependencyparser" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="nltk.parse.projectivedependencyparser.ChartCell">
<em class="property">class </em><tt class="descclassname">nltk.parse.projectivedependencyparser.</tt><tt class="descname">ChartCell</tt><big>(</big><em>x</em>, <em>y</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/projectivedependencyparser.html#ChartCell"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.projectivedependencyparser.ChartCell" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>A cell from the parse chart formed when performing the CYK algorithm.
Each cell keeps track of its x and y coordinates (though this will probably
be discarded), and a list of spans serving as the cell&#8217;s entries.</p>
<dl class="method">
<dt id="nltk.parse.projectivedependencyparser.ChartCell.add">
<tt class="descname">add</tt><big>(</big><em>span</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/projectivedependencyparser.html#ChartCell.add"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.projectivedependencyparser.ChartCell.add" title="Permalink to this definition">¶</a></dt>
<dd><p>Appends the given span to the list of spans
representing the chart cell&#8217;s entries.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>span</strong> (<em>C{DependencySpan}.</em>) &#8211; The span to add.</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.parse.projectivedependencyparser.DependencySpan">
<em class="property">class </em><tt class="descclassname">nltk.parse.projectivedependencyparser.</tt><tt class="descname">DependencySpan</tt><big>(</big><em>start_index</em>, <em>end_index</em>, <em>head_index</em>, <em>arcs</em>, <em>tags</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/projectivedependencyparser.html#DependencySpan"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.projectivedependencyparser.DependencySpan" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>A contiguous span over some part of the input string representing 
dependency (head -&gt; modifier) relationships amongst words.  An atomic 
span corresponds to only one word so it isn&#8217;t a &#8216;span&#8217; in the conventional
sense, as its _start_index = _end_index = _head_index for concatenation
purposes.  All other spans are assumed to have arcs between all nodes
within the start and end indexes of the span, and one head index corresponding
to the head word for the entire span.  This is the same as the root node if 
the dependency structure were depicted as a graph.</p>
<dl class="method">
<dt id="nltk.parse.projectivedependencyparser.DependencySpan.head_index">
<tt class="descname">head_index</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/parse/projectivedependencyparser.html#DependencySpan.head_index"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.projectivedependencyparser.DependencySpan.head_index" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">An value indexing the head of the entire C{DependencySpan}.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">int.</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.parse.projectivedependencyparser.ProbabilisticProjectiveDependencyParser">
<em class="property">class </em><tt class="descclassname">nltk.parse.projectivedependencyparser.</tt><tt class="descname">ProbabilisticProjectiveDependencyParser</tt><a class="reference internal" href="../_modules/nltk/parse/projectivedependencyparser.html#ProbabilisticProjectiveDependencyParser"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.projectivedependencyparser.ProbabilisticProjectiveDependencyParser" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>A probabilistic, projective dependency parser.  This parser returns 
the most probable projective parse derived from the probabilistic 
dependency grammar derived from the train() method.  The probabilistic 
model is an implementation of Eisner&#8217;s (1996) Model C, which conditions 
on head-word, head-tag, child-word, and child-tag.  The decoding 
uses a bottom-up chart-based span concatenation algorithm that&#8217;s 
identical to the one utilized by the rule-based projective parser.</p>
<dl class="method">
<dt id="nltk.parse.projectivedependencyparser.ProbabilisticProjectiveDependencyParser.compute_prob">
<tt class="descname">compute_prob</tt><big>(</big><em>dg</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/projectivedependencyparser.html#ProbabilisticProjectiveDependencyParser.compute_prob"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.projectivedependencyparser.ProbabilisticProjectiveDependencyParser.compute_prob" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the probability of a dependency graph based 
on the parser&#8217;s probability model (defined by the parser&#8217;s
statistical dependency grammar).</p>
<p>param dg: A dependency graph to score.
type dg: a C{DependencyGraph}
return: The probability of the dependency graph.
rtype: A number/double.</p>
</dd></dl>

<dl class="method">
<dt id="nltk.parse.projectivedependencyparser.ProbabilisticProjectiveDependencyParser.concatenate">
<tt class="descname">concatenate</tt><big>(</big><em>span1</em>, <em>span2</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/projectivedependencyparser.html#ProbabilisticProjectiveDependencyParser.concatenate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.projectivedependencyparser.ProbabilisticProjectiveDependencyParser.concatenate" title="Permalink to this definition">¶</a></dt>
<dd><p>Concatenates the two spans in whichever way possible.  This
includes rightward concatenation (from the leftmost word of the 
leftmost span to the rightmost word of the rightmost span) and
leftward concatenation (vice-versa) between adjacent spans.  Unlike 
Eisner&#8217;s presentation of span concatenation, these spans do not 
share or pivot on a particular word/word-index.</p>
<p>return: A list of new spans formed through concatenation.
rtype: A list of L{DependencySpan}</p>
</dd></dl>

<dl class="method">
<dt id="nltk.parse.projectivedependencyparser.ProbabilisticProjectiveDependencyParser.parse">
<tt class="descname">parse</tt><big>(</big><em>tokens</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/projectivedependencyparser.html#ProbabilisticProjectiveDependencyParser.parse"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.projectivedependencyparser.ProbabilisticProjectiveDependencyParser.parse" title="Permalink to this definition">¶</a></dt>
<dd><p>Parses the list of tokens subject to the projectivity constraint
and the productions in the parser&#8217;s grammar.  This uses a method 
similar to the span-concatenation algorithm defined in Eisner (1996).
It returns the most probable parse derived from the parser&#8217;s 
probabilistic dependency grammar.</p>
</dd></dl>

<dl class="method">
<dt id="nltk.parse.projectivedependencyparser.ProbabilisticProjectiveDependencyParser.train">
<tt class="descname">train</tt><big>(</big><em>graphs</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/projectivedependencyparser.html#ProbabilisticProjectiveDependencyParser.train"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.projectivedependencyparser.ProbabilisticProjectiveDependencyParser.train" title="Permalink to this definition">¶</a></dt>
<dd><p>Trains a StatisticalDependencyGrammar based on the list of input 
DependencyGraphs.  This model is an implementation of Eisner&#8217;s (1996)
Model C, which derives its statistics from head-word, head-tag, 
child-word, and child-tag relationships.</p>
<p>param graphs: A list of dependency graphs to train from.
type: A list of C{DependencyGraph}</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.parse.projectivedependencyparser.ProjectiveDependencyParser">
<em class="property">class </em><tt class="descclassname">nltk.parse.projectivedependencyparser.</tt><tt class="descname">ProjectiveDependencyParser</tt><big>(</big><em>dependency_grammar</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/projectivedependencyparser.html#ProjectiveDependencyParser"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.projectivedependencyparser.ProjectiveDependencyParser" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>A projective, rule-based, dependency parser.  A ProjectiveDependencyParser
is created with a DependencyGrammar, a set of productions specifying 
word-to-word dependency relations.  The parse() method will then 
return the set of all parses, in tree representation, for a given input
sequence of tokens.  Each parse must meet the requirements of the both
the grammar and the projectivity constraint which specifies that the 
branches of the dependency tree are not allowed to cross.  Alternatively, 
this can be understood as stating that each parent node and its children 
in the parse tree form a continuous substring of the input sequence.</p>
<dl class="method">
<dt id="nltk.parse.projectivedependencyparser.ProjectiveDependencyParser.concatenate">
<tt class="descname">concatenate</tt><big>(</big><em>span1</em>, <em>span2</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/projectivedependencyparser.html#ProjectiveDependencyParser.concatenate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.projectivedependencyparser.ProjectiveDependencyParser.concatenate" title="Permalink to this definition">¶</a></dt>
<dd><p>Concatenates the two spans in whichever way possible.  This
includes rightward concatenation (from the leftmost word of the 
leftmost span to the rightmost word of the rightmost span) and
leftward concatenation (vice-versa) between adjacent spans.  Unlike 
Eisner&#8217;s presentation of span concatenation, these spans do not 
share or pivot on a particular word/word-index.</p>
<p>return: A list of new spans formed through concatenation.
rtype: A list of L{DependencySpan}</p>
</dd></dl>

<dl class="method">
<dt id="nltk.parse.projectivedependencyparser.ProjectiveDependencyParser.parse">
<tt class="descname">parse</tt><big>(</big><em>tokens</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/projectivedependencyparser.html#ProjectiveDependencyParser.parse"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.projectivedependencyparser.ProjectiveDependencyParser.parse" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs a projective dependency parse on the list of tokens using
a chart-based, span-concatenation algorithm similar to Eisner (1996).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>tokens</strong> &#8211; The list of input tokens.</td>
</tr>
</tbody>
</table>
<p>:type tokens:a list of L{String}
:return: A list of parse trees.
:rtype: a list of L{tree}</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="nltk.parse.projectivedependencyparser.arity_parse_demo">
<tt class="descclassname">nltk.parse.projectivedependencyparser.</tt><tt class="descname">arity_parse_demo</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/parse/projectivedependencyparser.html#arity_parse_demo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.projectivedependencyparser.arity_parse_demo" title="Permalink to this definition">¶</a></dt>
<dd><p>A demonstration showing the creation of a C{DependencyGrammar} 
in which a specific number of modifiers is listed for a given 
head.  This can further constrain the number of possible parses
created by a C{ProjectiveDependencyParser}.</p>
</dd></dl>

<dl class="function">
<dt id="nltk.parse.projectivedependencyparser.demo">
<tt class="descclassname">nltk.parse.projectivedependencyparser.</tt><tt class="descname">demo</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/parse/projectivedependencyparser.html#demo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.projectivedependencyparser.demo" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="nltk.parse.projectivedependencyparser.projective_prob_parse_demo">
<tt class="descclassname">nltk.parse.projectivedependencyparser.</tt><tt class="descname">projective_prob_parse_demo</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/parse/projectivedependencyparser.html#projective_prob_parse_demo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.projectivedependencyparser.projective_prob_parse_demo" title="Permalink to this definition">¶</a></dt>
<dd><p>A demo showing the training and use of a projective 
dependency parser.</p>
</dd></dl>

<dl class="function">
<dt id="nltk.parse.projectivedependencyparser.projective_rule_parse_demo">
<tt class="descclassname">nltk.parse.projectivedependencyparser.</tt><tt class="descname">projective_rule_parse_demo</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/parse/projectivedependencyparser.html#projective_rule_parse_demo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.projectivedependencyparser.projective_rule_parse_demo" title="Permalink to this definition">¶</a></dt>
<dd><p>A demonstration showing the creation and use of a 
C{DependencyGrammar} to perform a projective dependency 
parse.</p>
</dd></dl>

</div>
<div class="section" id="module-nltk.parse.rd">
<span id="rd-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">rd</span></tt> Module<a class="headerlink" href="#module-nltk.parse.rd" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="nltk.parse.rd.RecursiveDescentParser">
<em class="property">class </em><tt class="descclassname">nltk.parse.rd.</tt><tt class="descname">RecursiveDescentParser</tt><big>(</big><em>grammar</em>, <em>trace=0</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/rd.html#RecursiveDescentParser"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.rd.RecursiveDescentParser" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.parse.api.ParserI" title="nltk.parse.api.ParserI"><tt class="xref py py-class docutils literal"><span class="pre">nltk.parse.api.ParserI</span></tt></a></p>
<p>A simple top-down CFG parser that parses texts by recursively
expanding the fringe of a Tree, and matching it against a
text.</p>
<p>C{RecursiveDescentParser} uses a list of tree locations called a
X{frontier} to remember which subtrees have not yet been expanded
and which leaves have not yet been matched against the text.  Each
tree location consists of a list of child indices specifying the
path from the root of the tree to a subtree or a leaf; see the
reference documentation for Tree for more information
about tree locations.</p>
<p>When the parser begins parsing a text, it constructs a tree
containing only the start symbol, and a frontier containing the
location of the tree&#8217;s root node.  It then extends the tree to
cover the text, using the following recursive procedure:</p>
<blockquote>
<div><ul class="simple">
<li>If the frontier is empty, and the text is covered by the tree,
then return the tree as a possible parse.</li>
<li>If the frontier is empty, and the text is not covered by the
tree, then return no parses.</li>
<li>If the first element of the frontier is a subtree, then
use CFG productions to X{expand} it.  For each applicable
production, add the expanded subtree&#8217;s children to the
frontier, and recursively find all parses that can be
generated by the new tree and frontier.</li>
<li>If the first element of the frontier is a token, then X{match}
it against the next token from the text.  Remove the token
from the frontier, and recursively find all parses that can be
generated by the new tree and frontier.</li>
</ul>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">See :</th><td class="field-body">C{nltk.grammar}</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="nltk.parse.rd.RecursiveDescentParser.grammar">
<tt class="descname">grammar</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/parse/rd.html#RecursiveDescentParser.grammar"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.rd.RecursiveDescentParser.grammar" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nltk.parse.rd.RecursiveDescentParser.nbest_parse">
<tt class="descname">nbest_parse</tt><big>(</big><em>tokens</em>, <em>n=None</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/rd.html#RecursiveDescentParser.nbest_parse"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.rd.RecursiveDescentParser.nbest_parse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nltk.parse.rd.RecursiveDescentParser.trace">
<tt class="descname">trace</tt><big>(</big><em>trace=2</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/rd.html#RecursiveDescentParser.trace"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.rd.RecursiveDescentParser.trace" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the level of tracing output that should be generated when
parsing a text.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>trace</strong> (<em>int</em>) &#8211; The trace level.  A trace level of C{0} will
generate no tracing output; and higher trace levels will
produce more verbose tracing output.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">None</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.parse.rd.SteppingRecursiveDescentParser">
<em class="property">class </em><tt class="descclassname">nltk.parse.rd.</tt><tt class="descname">SteppingRecursiveDescentParser</tt><big>(</big><em>grammar</em>, <em>trace=0</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/rd.html#SteppingRecursiveDescentParser"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.rd.SteppingRecursiveDescentParser" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.parse.rd.RecursiveDescentParser" title="nltk.parse.rd.RecursiveDescentParser"><tt class="xref py py-class docutils literal"><span class="pre">nltk.parse.rd.RecursiveDescentParser</span></tt></a></p>
<p>A C{RecursiveDescentParser} that allows you to step through the
parsing process, performing a single operation at a time.</p>
<p>The C{initialize} method is used to start parsing a text.
C{expand} expands the first element on the frontier using a single
CFG production, and C{match} matches the first element on the
frontier against the next text token. C{backtrack} undoes the most
recent expand or match operation.  C{step} performs a single
expand, match, or backtrack operation.  C{parses} returns the set
of parses that have been found by the parser.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><ul class="first simple">
<li><strong>_history</strong> &#8211; A list of C{(rtext, tree, frontier)} tripples,
containing the previous states of the parser.  This history is
used to implement the C{backtrack} operation.</li>
<li><strong>_tried_e</strong> &#8211; A record of all productions that have been tried
for a given tree.  This record is used by C{expand} to perform
the next untried production.</li>
<li><strong>_tried_m</strong> &#8211; A record of what tokens have been matched for a
given tree.  This record is used by C{step} to decide whether
or not to match a token.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">See :</th><td class="field-body"><p class="first last">C{nltk.grammar}</p>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="nltk.parse.rd.SteppingRecursiveDescentParser.backtrack">
<tt class="descname">backtrack</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/parse/rd.html#SteppingRecursiveDescentParser.backtrack"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.rd.SteppingRecursiveDescentParser.backtrack" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the parser to its state before the most recent
match or expand operation.  Calling C{undo} repeatedly return
the parser to successively earlier states.  If no match or
expand operations have been performed, C{undo} will make no
changes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">true if an operation was successfully undone.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">bool</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.parse.rd.SteppingRecursiveDescentParser.currently_complete">
<tt class="descname">currently_complete</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/parse/rd.html#SteppingRecursiveDescentParser.currently_complete"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.rd.SteppingRecursiveDescentParser.currently_complete" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Whether the parser&#8217;s current state represents a
complete parse.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">bool</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.parse.rd.SteppingRecursiveDescentParser.expand">
<tt class="descname">expand</tt><big>(</big><em>production=None</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/rd.html#SteppingRecursiveDescentParser.expand"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.rd.SteppingRecursiveDescentParser.expand" title="Permalink to this definition">¶</a></dt>
<dd><p>Expand the first element of the frontier.  In particular, if
the first element of the frontier is a subtree whose node type
is equal to C{production}&#8217;s left hand side, then add a child
to that subtree for each element of C{production}&#8217;s right hand
side.  If C{production} is not specified, then use the first
untried expandable production.  If all expandable productions
have been tried, do nothing.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The production used to expand the frontier, if an
expansion was performed.  If no expansion was performed,
return None.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">C{Production} or None</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.parse.rd.SteppingRecursiveDescentParser.expandable_productions">
<tt class="descname">expandable_productions</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/parse/rd.html#SteppingRecursiveDescentParser.expandable_productions"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.rd.SteppingRecursiveDescentParser.expandable_productions" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A list of all the productions for which expansions
are available for the current parser state.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">list of C{Production}</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.parse.rd.SteppingRecursiveDescentParser.frontier">
<tt class="descname">frontier</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/parse/rd.html#SteppingRecursiveDescentParser.frontier"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.rd.SteppingRecursiveDescentParser.frontier" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A list of the tree locations of all subtrees that
have not yet been expanded, and all leaves that have not
yet been matched.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">list of tuple of int</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.parse.rd.SteppingRecursiveDescentParser.initialize">
<tt class="descname">initialize</tt><big>(</big><em>tokens</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/rd.html#SteppingRecursiveDescentParser.initialize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.rd.SteppingRecursiveDescentParser.initialize" title="Permalink to this definition">¶</a></dt>
<dd><p>Start parsing a given text.  This sets the parser&#8217;s tree to
the start symbol, its frontier to the root node, and its
remaining text to C{token[&#8216;SUBTOKENS&#8217;]}.</p>
</dd></dl>

<dl class="method">
<dt id="nltk.parse.rd.SteppingRecursiveDescentParser.match">
<tt class="descname">match</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/parse/rd.html#SteppingRecursiveDescentParser.match"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.rd.SteppingRecursiveDescentParser.match" title="Permalink to this definition">¶</a></dt>
<dd><p>Match the first element of the frontier.  In particular, if
the first element of the frontier has the same type as the
next text token, then substitute the text token into the tree.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The token matched, if a match operation was
performed.  If no match was performed, return None</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">C{String} or None</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.parse.rd.SteppingRecursiveDescentParser.nbest_parse">
<tt class="descname">nbest_parse</tt><big>(</big><em>tokens</em>, <em>n=None</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/rd.html#SteppingRecursiveDescentParser.nbest_parse"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.rd.SteppingRecursiveDescentParser.nbest_parse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nltk.parse.rd.SteppingRecursiveDescentParser.parses">
<tt class="descname">parses</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/parse/rd.html#SteppingRecursiveDescentParser.parses"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.rd.SteppingRecursiveDescentParser.parses" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A list of the parses that have been found by this
parser so far.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">list of Tree</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.parse.rd.SteppingRecursiveDescentParser.remaining_text">
<tt class="descname">remaining_text</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/parse/rd.html#SteppingRecursiveDescentParser.remaining_text"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.rd.SteppingRecursiveDescentParser.remaining_text" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The portion of the text that is not yet covered by the
tree.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">list of C{String}</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.parse.rd.SteppingRecursiveDescentParser.set_grammar">
<tt class="descname">set_grammar</tt><big>(</big><em>grammar</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/rd.html#SteppingRecursiveDescentParser.set_grammar"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.rd.SteppingRecursiveDescentParser.set_grammar" title="Permalink to this definition">¶</a></dt>
<dd><p>Change the grammar used to parse texts.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>grammar</strong> (<em>C{CFG}</em>) &#8211; The new grammar.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.parse.rd.SteppingRecursiveDescentParser.step">
<tt class="descname">step</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/parse/rd.html#SteppingRecursiveDescentParser.step"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.rd.SteppingRecursiveDescentParser.step" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a single parsing operation.  If an untried match is
possible, then perform the match, and return the matched
token.  If an untried expansion is possible, then perform the
expansion, and return the production that it is based on.  If
backtracking is possible, then backtrack, and return 1.
Otherwise, return 0.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">0 if no operation was performed; a token if a match
was performed; a production if an expansion was performed;
and 1 if a backtrack operation was performed.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">C{Production} or C{String} or bool</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.parse.rd.SteppingRecursiveDescentParser.tree">
<tt class="descname">tree</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/parse/rd.html#SteppingRecursiveDescentParser.tree"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.rd.SteppingRecursiveDescentParser.tree" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A partial structure for the text that is
currently being parsed.  The elements specified by the
frontier have not yet been expanded or matched.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">Tree</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.parse.rd.SteppingRecursiveDescentParser.untried_expandable_productions">
<tt class="descname">untried_expandable_productions</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/parse/rd.html#SteppingRecursiveDescentParser.untried_expandable_productions"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.rd.SteppingRecursiveDescentParser.untried_expandable_productions" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A list of all the untried productions for which
expansions are available for the current parser state.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">list of C{Production}</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.parse.rd.SteppingRecursiveDescentParser.untried_match">
<tt class="descname">untried_match</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/parse/rd.html#SteppingRecursiveDescentParser.untried_match"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.rd.SteppingRecursiveDescentParser.untried_match" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Whether the first element of the frontier is a token
that has not yet been matched.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">bool</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="nltk.parse.rd.demo">
<tt class="descclassname">nltk.parse.rd.</tt><tt class="descname">demo</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/parse/rd.html#demo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.rd.demo" title="Permalink to this definition">¶</a></dt>
<dd><p>A demonstration of the recursive descent parser.</p>
</dd></dl>

</div>
<div class="section" id="module-nltk.parse.sr">
<span id="sr-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">sr</span></tt> Module<a class="headerlink" href="#module-nltk.parse.sr" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="nltk.parse.sr.ShiftReduceParser">
<em class="property">class </em><tt class="descclassname">nltk.parse.sr.</tt><tt class="descname">ShiftReduceParser</tt><big>(</big><em>grammar</em>, <em>trace=0</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/sr.html#ShiftReduceParser"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.sr.ShiftReduceParser" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.parse.api.ParserI" title="nltk.parse.api.ParserI"><tt class="xref py py-class docutils literal"><span class="pre">nltk.parse.api.ParserI</span></tt></a></p>
<p>A simple bottom-up CFG parser that uses two operations, &#8220;shift&#8221;
and &#8220;reduce&#8221;, to find a single parse for a text.</p>
<p>C{ShiftReduceParser} maintains a stack, which records the
structure of a portion of the text.  This stack is a list of
strings and Trees that collectively cover a portion of
the text.  For example, while parsing the sentence &#8220;the dog saw
the man&#8221; with a typical grammar, C{ShiftReduceParser} will produce
the following stack, which covers &#8220;the dog saw&#8221;:</p>
<div class="highlight-python"><pre>[(NP: (Det: 'the') (N: 'dog')), (V: 'saw')]</pre>
</div>
<p>C{ShiftReduceParser} attempts to extend the stack to cover the
entire text, and to combine the stack elements into a single tree,
producing a complete parse for the sentence.</p>
<p>Initially, the stack is empty.  It is extended to cover the text,
from left to right, by repeatedly applying two operations:</p>
<blockquote>
<div><ul class="simple">
<li>X{shift} moves a token from the beginning of the text to the
end of the stack.</li>
<li>X{reduce} uses a CFG production to combine the rightmost stack
elements into a single Tree.</li>
</ul>
</div></blockquote>
<p>Often, more than one operation can be performed on a given stack.
In this case, C{ShiftReduceParser} uses the following heuristics
to decide which operation to perform:</p>
<blockquote>
<div><ul class="simple">
<li>Only shift if no reductions are available.</li>
<li>If multiple reductions are available, then apply the reduction
whose CFG production is listed earliest in the grammar.</li>
</ul>
</div></blockquote>
<p>Note that these heuristics are not guaranteed to choose an
operation that leads to a parse of the text.  Also, if multiple
parses exists, C{ShiftReduceParser} will return at most one of
them.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">See :</th><td class="field-body">C{nltk.grammar}</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="nltk.parse.sr.ShiftReduceParser.grammar">
<tt class="descname">grammar</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/parse/sr.html#ShiftReduceParser.grammar"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.sr.ShiftReduceParser.grammar" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nltk.parse.sr.ShiftReduceParser.parse">
<tt class="descname">parse</tt><big>(</big><em>tokens</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/sr.html#ShiftReduceParser.parse"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.sr.ShiftReduceParser.parse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nltk.parse.sr.ShiftReduceParser.trace">
<tt class="descname">trace</tt><big>(</big><em>trace=2</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/sr.html#ShiftReduceParser.trace"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.sr.ShiftReduceParser.trace" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the level of tracing output that should be generated when
parsing a text.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>trace</strong> (<em>int</em>) &#8211; The trace level.  A trace level of C{0} will
generate no tracing output; and higher trace levels will
produce more verbose tracing output.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">None</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.parse.sr.SteppingShiftReduceParser">
<em class="property">class </em><tt class="descclassname">nltk.parse.sr.</tt><tt class="descname">SteppingShiftReduceParser</tt><big>(</big><em>grammar</em>, <em>trace=0</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/sr.html#SteppingShiftReduceParser"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.sr.SteppingShiftReduceParser" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.parse.sr.ShiftReduceParser" title="nltk.parse.sr.ShiftReduceParser"><tt class="xref py py-class docutils literal"><span class="pre">nltk.parse.sr.ShiftReduceParser</span></tt></a></p>
<p>A C{ShiftReduceParser} that allows you to setp through the parsing
process, performing a single operation at a time.  It also allows
you to change the parser&#8217;s grammar midway through parsing a text.</p>
<p>The C{initialize} method is used to start parsing a text.
C{shift} performs a single shift operation, and C{reduce} performs
a single reduce operation.  C{step} will perform a single reduce
operation if possible; otherwise, it will perform a single shift
operation.  C{parses} returns the set of parses that have been
found by the parser.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><strong>_history</strong> &#8211; A list of C{(stack, remaining_text)} pairs,
containing all of the previous states of the parser.  This
history is used to implement the C{undo} operation.</td>
</tr>
<tr class="field-even field"><th class="field-name">See :</th><td class="field-body">C{nltk.grammar}</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="nltk.parse.sr.SteppingShiftReduceParser.initialize">
<tt class="descname">initialize</tt><big>(</big><em>tokens</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/sr.html#SteppingShiftReduceParser.initialize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.sr.SteppingShiftReduceParser.initialize" title="Permalink to this definition">¶</a></dt>
<dd><p>Start parsing a given text.  This sets the parser&#8217;s stack to
C{[]} and sets its remaining text to C{tokens}.</p>
</dd></dl>

<dl class="method">
<dt id="nltk.parse.sr.SteppingShiftReduceParser.nbest_parse">
<tt class="descname">nbest_parse</tt><big>(</big><em>tokens</em>, <em>n=None</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/sr.html#SteppingShiftReduceParser.nbest_parse"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.sr.SteppingShiftReduceParser.nbest_parse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nltk.parse.sr.SteppingShiftReduceParser.parses">
<tt class="descname">parses</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/parse/sr.html#SteppingShiftReduceParser.parses"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.sr.SteppingShiftReduceParser.parses" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A list of the parses that have been found by this
parser so far.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">list of Tree</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.parse.sr.SteppingShiftReduceParser.reduce">
<tt class="descname">reduce</tt><big>(</big><em>production=None</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/sr.html#SteppingShiftReduceParser.reduce"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.sr.SteppingShiftReduceParser.reduce" title="Permalink to this definition">¶</a></dt>
<dd><p>Use C{production} to combine the rightmost stack elements into
a single Tree.  If C{production} does not match the
rightmost stack elements, then do nothing.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The production used to reduce the stack, if a
reduction was performed.  If no reduction was performed,
return None.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">C{Production} or None</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.parse.sr.SteppingShiftReduceParser.reducible_productions">
<tt class="descname">reducible_productions</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/parse/sr.html#SteppingShiftReduceParser.reducible_productions"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.sr.SteppingShiftReduceParser.reducible_productions" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A list of the productions for which reductions are
available for the current parser state.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">list of C{Production}</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.parse.sr.SteppingShiftReduceParser.remaining_text">
<tt class="descname">remaining_text</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/parse/sr.html#SteppingShiftReduceParser.remaining_text"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.sr.SteppingShiftReduceParser.remaining_text" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The portion of the text that is not yet covered by the
stack.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">list(str)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.parse.sr.SteppingShiftReduceParser.set_grammar">
<tt class="descname">set_grammar</tt><big>(</big><em>grammar</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/sr.html#SteppingShiftReduceParser.set_grammar"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.sr.SteppingShiftReduceParser.set_grammar" title="Permalink to this definition">¶</a></dt>
<dd><p>Change the grammar used to parse texts.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>grammar</strong> (<em>C{CFG}</em>) &#8211; The new grammar.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.parse.sr.SteppingShiftReduceParser.shift">
<tt class="descname">shift</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/parse/sr.html#SteppingShiftReduceParser.shift"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.sr.SteppingShiftReduceParser.shift" title="Permalink to this definition">¶</a></dt>
<dd><p>Move a token from the beginning of the remaining text to the
end of the stack.  If there are no more tokens in the
remaining text, then do nothing.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">True if the shift operation was successful.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">bool</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.parse.sr.SteppingShiftReduceParser.stack">
<tt class="descname">stack</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/parse/sr.html#SteppingShiftReduceParser.stack"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.sr.SteppingShiftReduceParser.stack" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The parser&#8217;s stack.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">list(str and Tree)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.parse.sr.SteppingShiftReduceParser.step">
<tt class="descname">step</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/parse/sr.html#SteppingShiftReduceParser.step"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.sr.SteppingShiftReduceParser.step" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a single parsing operation.  If a reduction is
possible, then perform that reduction, and return the
production that it is based on.  Otherwise, if a shift is
possible, then perform it, and return 1.  Otherwise,
return 0.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">0 if no operation was performed; 1 if a shift was
performed; and the CFG production used to reduce if a
reduction was performed.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">C{Production} or bool</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.parse.sr.SteppingShiftReduceParser.undo">
<tt class="descname">undo</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/parse/sr.html#SteppingShiftReduceParser.undo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.sr.SteppingShiftReduceParser.undo" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the parser to its state before the most recent
shift or reduce operation.  Calling C{undo} repeatedly return
the parser to successively earlier states.  If no shift or
reduce operations have been performed, C{undo} will make no
changes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">true if an operation was successfully undone.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">bool</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="nltk.parse.sr.demo">
<tt class="descclassname">nltk.parse.sr.</tt><tt class="descname">demo</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/parse/sr.html#demo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.sr.demo" title="Permalink to this definition">¶</a></dt>
<dd><p>A demonstration of the shift-reduce parser.</p>
</dd></dl>

</div>
<div class="section" id="module-nltk.parse.util">
<span id="util-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">util</span></tt> Module<a class="headerlink" href="#module-nltk.parse.util" title="Permalink to this headline">¶</a></h2>
<p>Utility functions for parsers.</p>
<dl class="class">
<dt id="nltk.parse.util.TestGrammar">
<em class="property">class </em><tt class="descclassname">nltk.parse.util.</tt><tt class="descname">TestGrammar</tt><big>(</big><em>grammar</em>, <em>suite</em>, <em>accept=None</em>, <em>reject=None</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/util.html#TestGrammar"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.util.TestGrammar" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Unit tests for  CFG.</p>
<dl class="method">
<dt id="nltk.parse.util.TestGrammar.run">
<tt class="descname">run</tt><big>(</big><em>show_trees=False</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/util.html#TestGrammar.run"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.util.TestGrammar.run" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Sentences in the test suite are divided into two classes:</dt>
<dd><ul class="first last simple">
<li>grammatical (C{accept}) and</li>
<li>ungrammatical (C{reject}).</li>
</ul>
</dd>
</dl>
<p>If a sentence should parse accordng to the grammar, the value of
C{trees} will be a non-empty list. If a sentence should be rejected
according to the grammar, then the value of C{trees} will be None.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="nltk.parse.util.extract_test_sentences">
<tt class="descclassname">nltk.parse.util.</tt><tt class="descname">extract_test_sentences</tt><big>(</big><em>string</em>, <em>comment_chars='#%;'</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/util.html#extract_test_sentences"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.util.extract_test_sentences" title="Permalink to this definition">¶</a></dt>
<dd><p>Parses a string with one test sentence per line.
Lines can optionally begin with:</p>
<blockquote>
<div><ul class="simple">
<li>a bool, saying if the sentence is grammatical or not, or</li>
<li>an int, giving the number of parse trees is should have,</li>
</ul>
</div></blockquote>
<p>The result information is followed by a colon, and then the sentence.
Empty lines and lines beginning with a comment char are ignored.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a list of tuple of sentences and expected results,
where a sentence is a list of str,
and a result is None, or bool, or int</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><strong>comment_chars</strong> &#8211; L{str} of possible comment characters.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="nltk.parse.util.load_parser">
<tt class="descclassname">nltk.parse.util.</tt><tt class="descname">load_parser</tt><big>(</big><em>grammar_url</em>, <em>trace=0</em>, <em>parser=None</em>, <em>chart_class=None</em>, <em>beam_size=0</em>, <em>**load_args</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/util.html#load_parser"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.util.load_parser" title="Permalink to this definition">¶</a></dt>
<dd><p>Load a grammar from a file, and build a parser based on that grammar. 
The parser depends on the grammar format, and might also depend
on properties of the grammar itself.</p>
<dl class="docutils">
<dt>The following grammar formats are currently supported:</dt>
<dd><ul class="first last simple">
<li>C{&#8216;cfg&#8217;}  (CFGs: L{ContextFreeGrammar})</li>
<li>C{&#8216;pcfg&#8217;} (probabilistic CFGs: L{WeightedGrammar})</li>
<li>C{&#8216;fcfg&#8217;} (feature-based CFGs: L{ContextFreeGrammar})</li>
</ul>
</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>grammar_url</strong> (<em>str</em>) &#8211; A URL specifying where the grammar is located.
The default protocol is C{&#8220;nltk:&#8221;}, which searches for the file 
in the the NLTK data package.</li>
<li><strong>trace</strong> (<em>int</em>) &#8211; The level of tracing that should be used when
parsing a text.  C{0} will generate no tracing output;
and higher numbers will produce more verbose tracing output.</li>
<li><strong>parser</strong> &#8211; The class used for parsing; should be L{ChartParser}
or a subclass.
If None, the class depends on the grammar format.</li>
<li><strong>chart_class</strong> &#8211; The class used for storing the chart;
should be L{Chart} or a subclass. 
Only used for CFGs and feature CFGs.
If None, the chart class depends on the grammar format.</li>
<li><strong>beam_size</strong> (<em>int</em>) &#8211; The maximum length for the parser&#8217;s edge queue.
Only used for probabilistic CFGs.</li>
<li><strong>load_args</strong> &#8211; Keyword parameters used when loading the grammar.
See L{data.load} for more information.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-nltk.parse.viterbi">
<span id="viterbi-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">viterbi</span></tt> Module<a class="headerlink" href="#module-nltk.parse.viterbi" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="nltk.parse.viterbi.ViterbiParser">
<em class="property">class </em><tt class="descclassname">nltk.parse.viterbi.</tt><tt class="descname">ViterbiParser</tt><big>(</big><em>grammar</em>, <em>trace=0</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/viterbi.html#ViterbiParser"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.viterbi.ViterbiParser" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.parse.api.ParserI" title="nltk.parse.api.ParserI"><tt class="xref py py-class docutils literal"><span class="pre">nltk.parse.api.ParserI</span></tt></a></p>
<p>A bottom-up C{PCFG} parser that uses dynamic programming to find
the single most likely parse for a text.  The C{ViterbiParser} parser
parses texts by filling in a X{most likely constituent table}.
This table records the most probable tree representation for any
given span and node value.  In particular, it has an entry for
every start index, end index, and node value, recording the most
likely subtree that spans from the start index to the end index,
and has the given node value.</p>
<p>The C{ViterbiParser} parser fills in this table incrementally.  It starts
by filling in all entries for constituents that span one element
of text (i.e., entries where the end index is one greater than the
start index).  After it has filled in all table entries for
constituents that span one element of text, it fills in the
entries for constitutants that span two elements of text.  It
continues filling in the entries for constituents spanning larger
and larger portions of the text, until the entire table has been
filled.  Finally, it returns the table entry for a constituent
spanning the entire text, whose node value is the grammar&#8217;s start
symbol.</p>
<p>In order to find the most likely constituent with a given span and
node value, the C{ViterbiParser} parser considers all productions that
could produce that node value.  For each production, it finds all
children that collectively cover the span and have the node values
specified by the production&#8217;s right hand side.  If the probability
of the tree formed by applying the production to the children is
greater than the probability of the current entry in the table,
then the table is updated with this new tree.</p>
<p>A pseudo-code description of the algorithm used by
C{ViterbiParser} is:</p>
<blockquote>
<div><ul>
<li><p class="first">Create an empty most likely constituent table, M{MLC}.</p>
</li>
<li><p class="first">For M{width} in 1...len(M{text}):
- For M{start} in 1...len(M{text})-M{width}:</p>
<blockquote>
<div><ul>
<li><p class="first">For M{prod} in grammar.productions:
- For each sequence of subtrees [M{t[1]}, M{t[2]}, ...,</p>
<blockquote>
<div><p>M{t[n]}] in M{MLC}, where M{t[i]}.node==M{prod}.rhs[i],
and the sequence covers [M{start}:M{start}+M{width}]:</p>
<blockquote>
<div><ul>
<li><p class="first">M{old_p} = M{MLC}[M{start}, M{start+width}, M{prod}.lhs]</p>
</li>
<li><p class="first">M{new_p} = P(M{t[1]})*P(M{t[1]})*...*P(M{t[n]})*P(M{prod})</p>
</li>
<li><p class="first">if M{new_p} &gt; M{old_p}:
- M{new_tree} = Tree(M{prod}.lhs, M{t[1]}, M{t[2]},</p>
<blockquote>
<div><p>..., M{t[n]})</p>
</div></blockquote>
<ul class="simple">
<li>M{MLC}[M{start}, M{start+width}, M{prod}.lhs]
= M{new_tree}</li>
</ul>
</li>
</ul>
</div></blockquote>
</div></blockquote>
</li>
</ul>
</div></blockquote>
</li>
<li><p class="first">Return M{MLC}[0, len(M{text}), M{start_symbol}]</p>
</li>
</ul>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><ul class="first last simple">
<li><strong>_grammar</strong> &#8211; The grammar used to parse sentences.</li>
<li><strong>_trace</strong> &#8211; The level of tracing output that should be generated
when parsing a text.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="nltk.parse.viterbi.ViterbiParser.grammar">
<tt class="descname">grammar</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/parse/viterbi.html#ViterbiParser.grammar"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.viterbi.ViterbiParser.grammar" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nltk.parse.viterbi.ViterbiParser.parse">
<tt class="descname">parse</tt><big>(</big><em>tokens</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/viterbi.html#ViterbiParser.parse"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.viterbi.ViterbiParser.parse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nltk.parse.viterbi.ViterbiParser.trace">
<tt class="descname">trace</tt><big>(</big><em>trace=2</em><big>)</big><a class="reference internal" href="../_modules/nltk/parse/viterbi.html#ViterbiParser.trace"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.viterbi.ViterbiParser.trace" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the level of tracing output that should be generated when
parsing a text.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>trace</strong> (<em>int</em>) &#8211; The trace level.  A trace level of C{0} will
generate no tracing output; and higher trace levels will
produce more verbose tracing output.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">None</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="nltk.parse.viterbi.demo">
<tt class="descclassname">nltk.parse.viterbi.</tt><tt class="descname">demo</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/parse/viterbi.html#demo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.parse.viterbi.demo" title="Permalink to this definition">¶</a></dt>
<dd><p>A demonstration of the probabilistic parsers.  The user is
prompted to select which demo to run, and how many parses should
be found; and then each parser is run on the same demo, and a
summary of the results are displayed.</p>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
        </div>
        <div class="sidebar">
          <h3>Table Of Contents</h3>
          <ul>
<li class="toctree-l1"><a class="reference internal" href="../news.html">NLTK News</a></li>
</ul>

          <h3 style="margin-top: 1.5em;">Search</h3>
          <form class="search" action="../search.html" method="get">
            <input type="text" name="q" />
            <input type="submit" value="Go" />
            <input type="hidden" name="check_keywords" value="yes" />
            <input type="hidden" name="area" value="default" />
          </form>
          <p class="searchtip" style="font-size: 90%">
            Enter search terms or a module, class or function name.
          </p>
        </div>
        <div class="clearer"></div>
      </div>
    </div>

    <div class="footer-wrapper">
      <div class="footer">
        <div class="left">
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |
          <a href="../genindex.html" title="General Index"
             >index</a>
            <br/>
            <a href="../_sources/api/nltk.parse.txt"
               rel="nofollow">Show Source</a>
        </div>

        <div class="right">
          
    <div class="footer">
        &copy; Copyright 2011, Steven Bird.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.2.
    </div>
        </div>
        <div class="clearer"></div>
      </div>
    </div>

  </body>
</html>