<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>nltk.chunk package &#8212; NLTK 3.2.3 documentation</title>
    
    <link rel="stylesheet" href="../_static/agogo.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '3.2.3',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="nltk.classify package" href="nltk.classify.html" />
    <link rel="prev" title="nltk.chat package" href="nltk.chat.html" /> 
  </head>
  <body role="document">
    <div class="header-wrapper" role="banner">
      <div class="header">
        <div class="headertitle"><a
          href="../index.html">NLTK 3.2.3 documentation</a></div>
        <div class="rel" role="navigation" aria-label="related navigation">
          <a href="nltk.chat.html" title="nltk.chat package"
             accesskey="P">previous</a> |
          <a href="nltk.classify.html" title="nltk.classify package"
             accesskey="N">next</a> |
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a>
        </div>
       </div>
    </div>

    <div class="content-wrapper">
      <div class="content">
        <div class="document">
            
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="nltk-chunk-package">
<h1>nltk.chunk package<a class="headerlink" href="#nltk-chunk-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-nltk.chunk.api">
<span id="nltk-chunk-api-module"></span><h2>nltk.chunk.api module<a class="headerlink" href="#module-nltk.chunk.api" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="nltk.chunk.api.ChunkParserI">
<em class="property">class </em><code class="descclassname">nltk.chunk.api.</code><code class="descname">ChunkParserI</code><a class="reference internal" href="../_modules/nltk/chunk/api.html#ChunkParserI"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.api.ChunkParserI" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="nltk.parse.html#nltk.parse.api.ParserI" title="nltk.parse.api.ParserI"><code class="xref py py-class docutils literal"><span class="pre">nltk.parse.api.ParserI</span></code></a></p>
<p>A processing interface for identifying non-overlapping groups in
unrestricted text.  Typically, chunk parsers are used to find base
syntactic constituents, such as base noun phrases.  Unlike
<code class="docutils literal"><span class="pre">ParserI</span></code>, <code class="docutils literal"><span class="pre">ChunkParserI</span></code> guarantees that the <code class="docutils literal"><span class="pre">parse()</span></code> method
will always generate a parse.</p>
<dl class="method">
<dt id="nltk.chunk.api.ChunkParserI.evaluate">
<code class="descname">evaluate</code><span class="sig-paren">(</span><em>gold</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/chunk/api.html#ChunkParserI.evaluate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.api.ChunkParserI.evaluate" title="Permalink to this definition">¶</a></dt>
<dd><p>Score the accuracy of the chunker against the gold standard.
Remove the chunking the gold standard text, rechunk it using
the chunker, and return a <code class="docutils literal"><span class="pre">ChunkScore</span></code> object
reflecting the performance of this chunk peraser.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>gold</strong> (<a class="reference internal" href="nltk.html#nltk.downloader.Downloader.list" title="nltk.downloader.Downloader.list"><em>list</em></a><em>(</em><a class="reference internal" href="nltk.html#nltk.tree.Tree" title="nltk.tree.Tree"><em>Tree</em></a><em>)</em><em></em>) &#8211; The list of chunked sentences to score the chunker on.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#nltk.chunk.util.ChunkScore" title="nltk.chunk.util.ChunkScore">ChunkScore</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.chunk.api.ChunkParserI.parse">
<code class="descname">parse</code><span class="sig-paren">(</span><em>tokens</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/chunk/api.html#ChunkParserI.parse"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.api.ChunkParserI.parse" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the best chunk structure for the given tokens
and return a tree.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>tokens</strong> (<a class="reference internal" href="nltk.html#nltk.downloader.Downloader.list" title="nltk.downloader.Downloader.list"><em>list</em></a><em>(</em><em>tuple</em><em>)</em><em></em>) &#8211; The list of (word, tag) tokens to be chunked.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="nltk.html#nltk.tree.Tree" title="nltk.tree.Tree">Tree</a></td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-nltk.chunk.named_entity">
<span id="nltk-chunk-named-entity-module"></span><h2>nltk.chunk.named_entity module<a class="headerlink" href="#module-nltk.chunk.named_entity" title="Permalink to this headline">¶</a></h2>
<p>Named entity chunker</p>
<dl class="class">
<dt id="nltk.chunk.named_entity.NEChunkParser">
<em class="property">class </em><code class="descclassname">nltk.chunk.named_entity.</code><code class="descname">NEChunkParser</code><span class="sig-paren">(</span><em>train</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/chunk/named_entity.html#NEChunkParser"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.named_entity.NEChunkParser" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.chunk.api.ChunkParserI" title="nltk.chunk.api.ChunkParserI"><code class="xref py py-class docutils literal"><span class="pre">nltk.chunk.api.ChunkParserI</span></code></a></p>
<p>Expected input: list of pos-tagged words</p>
<dl class="method">
<dt id="nltk.chunk.named_entity.NEChunkParser.parse">
<code class="descname">parse</code><span class="sig-paren">(</span><em>tokens</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/chunk/named_entity.html#NEChunkParser.parse"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.named_entity.NEChunkParser.parse" title="Permalink to this definition">¶</a></dt>
<dd><p>Each token should be a pos-tagged word</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.chunk.named_entity.NEChunkParserTagger">
<em class="property">class </em><code class="descclassname">nltk.chunk.named_entity.</code><code class="descname">NEChunkParserTagger</code><span class="sig-paren">(</span><em>train</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/chunk/named_entity.html#NEChunkParserTagger"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.named_entity.NEChunkParserTagger" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="nltk.tag.html#nltk.tag.sequential.ClassifierBasedTagger" title="nltk.tag.sequential.ClassifierBasedTagger"><code class="xref py py-class docutils literal"><span class="pre">nltk.tag.sequential.ClassifierBasedTagger</span></code></a></p>
<p>The IOB tagger used by the chunk parser.</p>
</dd></dl>

<dl class="function">
<dt id="nltk.chunk.named_entity.build_model">
<code class="descclassname">nltk.chunk.named_entity.</code><code class="descname">build_model</code><span class="sig-paren">(</span><em>fmt='binary'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/chunk/named_entity.html#build_model"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.named_entity.build_model" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="nltk.chunk.named_entity.cmp_chunks">
<code class="descclassname">nltk.chunk.named_entity.</code><code class="descname">cmp_chunks</code><span class="sig-paren">(</span><em>correct</em>, <em>guessed</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/chunk/named_entity.html#cmp_chunks"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.named_entity.cmp_chunks" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="nltk.chunk.named_entity.load_ace_data">
<code class="descclassname">nltk.chunk.named_entity.</code><code class="descname">load_ace_data</code><span class="sig-paren">(</span><em>roots</em>, <em>fmt='binary'</em>, <em>skip_bnews=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/chunk/named_entity.html#load_ace_data"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.named_entity.load_ace_data" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="nltk.chunk.named_entity.load_ace_file">
<code class="descclassname">nltk.chunk.named_entity.</code><code class="descname">load_ace_file</code><span class="sig-paren">(</span><em>textfile</em>, <em>fmt</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/chunk/named_entity.html#load_ace_file"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.named_entity.load_ace_file" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="nltk.chunk.named_entity.postag_tree">
<code class="descclassname">nltk.chunk.named_entity.</code><code class="descname">postag_tree</code><span class="sig-paren">(</span><em>tree</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/chunk/named_entity.html#postag_tree"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.named_entity.postag_tree" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="nltk.chunk.named_entity.shape">
<code class="descclassname">nltk.chunk.named_entity.</code><code class="descname">shape</code><span class="sig-paren">(</span><em>word</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/chunk/named_entity.html#shape"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.named_entity.shape" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="nltk.chunk.named_entity.simplify_pos">
<code class="descclassname">nltk.chunk.named_entity.</code><code class="descname">simplify_pos</code><span class="sig-paren">(</span><em>s</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/chunk/named_entity.html#simplify_pos"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.named_entity.simplify_pos" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-nltk.chunk.regexp">
<span id="nltk-chunk-regexp-module"></span><h2>nltk.chunk.regexp module<a class="headerlink" href="#module-nltk.chunk.regexp" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="nltk.chunk.regexp.ChinkRule">
<em class="property">class </em><code class="descclassname">nltk.chunk.regexp.</code><code class="descname">ChinkRule</code><span class="sig-paren">(</span><em>tag_pattern</em>, <em>descr</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/chunk/regexp.html#ChinkRule"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.regexp.ChinkRule" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.chunk.regexp.RegexpChunkRule" title="nltk.chunk.regexp.RegexpChunkRule"><code class="xref py py-class docutils literal"><span class="pre">nltk.chunk.regexp.RegexpChunkRule</span></code></a></p>
<p>A rule specifying how to remove chinks to a <code class="docutils literal"><span class="pre">ChunkString</span></code>,
using a matching tag pattern.  When applied to a
<code class="docutils literal"><span class="pre">ChunkString</span></code>, it will find any substring that matches this
tag pattern and that is contained in a chunk, and remove it
from that chunk, thus creating two new chunks.</p>
<dl class="method">
<dt id="nltk.chunk.regexp.ChinkRule.unicode_repr">
<code class="descname">unicode_repr</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nltk.chunk.regexp.ChinkRule.unicode_repr" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a string representation of this rule.  It has the form:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">ChinkRule</span><span class="p">:</span> <span class="s1">&#39;&lt;IN|VB.*&gt;&#39;</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>Note that this representation does not include the
description string; that string can be accessed
separately with the <code class="docutils literal"><span class="pre">descr()</span></code> method.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="nltk.sem.html#nltk.sem.logic.ComplexType.str" title="nltk.sem.logic.ComplexType.str">str</a></td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.chunk.regexp.ChunkRule">
<em class="property">class </em><code class="descclassname">nltk.chunk.regexp.</code><code class="descname">ChunkRule</code><span class="sig-paren">(</span><em>tag_pattern</em>, <em>descr</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/chunk/regexp.html#ChunkRule"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.regexp.ChunkRule" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.chunk.regexp.RegexpChunkRule" title="nltk.chunk.regexp.RegexpChunkRule"><code class="xref py py-class docutils literal"><span class="pre">nltk.chunk.regexp.RegexpChunkRule</span></code></a></p>
<p>A rule specifying how to add chunks to a <code class="docutils literal"><span class="pre">ChunkString</span></code>, using a
matching tag pattern.  When applied to a <code class="docutils literal"><span class="pre">ChunkString</span></code>, it will
find any substring that matches this tag pattern and that is not
already part of a chunk, and create a new chunk containing that
substring.</p>
<dl class="method">
<dt id="nltk.chunk.regexp.ChunkRule.unicode_repr">
<code class="descname">unicode_repr</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nltk.chunk.regexp.ChunkRule.unicode_repr" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a string representation of this rule.  It has the form:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">ChunkRule</span><span class="p">:</span> <span class="s1">&#39;&lt;IN|VB.*&gt;&#39;</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>Note that this representation does not include the
description string; that string can be accessed
separately with the <code class="docutils literal"><span class="pre">descr()</span></code> method.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="nltk.sem.html#nltk.sem.logic.ComplexType.str" title="nltk.sem.logic.ComplexType.str">str</a></td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.chunk.regexp.ChunkRuleWithContext">
<em class="property">class </em><code class="descclassname">nltk.chunk.regexp.</code><code class="descname">ChunkRuleWithContext</code><span class="sig-paren">(</span><em>left_context_tag_pattern</em>, <em>chunk_tag_pattern</em>, <em>right_context_tag_pattern</em>, <em>descr</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/chunk/regexp.html#ChunkRuleWithContext"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.regexp.ChunkRuleWithContext" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.chunk.regexp.RegexpChunkRule" title="nltk.chunk.regexp.RegexpChunkRule"><code class="xref py py-class docutils literal"><span class="pre">nltk.chunk.regexp.RegexpChunkRule</span></code></a></p>
<p>A rule specifying how to add chunks to a <code class="docutils literal"><span class="pre">ChunkString</span></code>, using
three matching tag patterns: one for the left context, one for the
chunk, and one for the right context.  When applied to a
<code class="docutils literal"><span class="pre">ChunkString</span></code>, it will find any substring that matches the chunk
tag pattern, is surrounded by substrings that match the two
context patterns, and is not already part of a chunk; and create a
new chunk containing the substring that matched the chunk tag
pattern.</p>
<p>Caveat: Both the left and right context are consumed when this
rule matches; therefore, if you need to find overlapping matches,
you will need to apply your rule more than once.</p>
<dl class="method">
<dt id="nltk.chunk.regexp.ChunkRuleWithContext.unicode_repr">
<code class="descname">unicode_repr</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nltk.chunk.regexp.ChunkRuleWithContext.unicode_repr" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a string representation of this rule.  It has the form:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">ChunkRuleWithContext</span><span class="p">:</span> <span class="s1">&#39;&lt;IN&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;NN&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;DT&gt;&#39;</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>Note that this representation does not include the
description string; that string can be accessed
separately with the <code class="docutils literal"><span class="pre">descr()</span></code> method.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="nltk.sem.html#nltk.sem.logic.ComplexType.str" title="nltk.sem.logic.ComplexType.str">str</a></td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.chunk.regexp.ChunkString">
<em class="property">class </em><code class="descclassname">nltk.chunk.regexp.</code><code class="descname">ChunkString</code><span class="sig-paren">(</span><em>chunk_struct</em>, <em>debug_level=1</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/chunk/regexp.html#ChunkString"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.regexp.ChunkString" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>A string-based encoding of a particular chunking of a text.
Internally, the <code class="docutils literal"><span class="pre">ChunkString</span></code> class uses a single string to
encode the chunking of the input text.  This string contains a
sequence of angle-bracket delimited tags, with chunking indicated
by braces.  An example of this encoding is:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">{</span><span class="o">&lt;</span><span class="n">DT</span><span class="o">&gt;&lt;</span><span class="n">JJ</span><span class="o">&gt;&lt;</span><span class="n">NN</span><span class="o">&gt;</span><span class="p">}</span><span class="o">&lt;</span><span class="n">VBN</span><span class="o">&gt;&lt;</span><span class="n">IN</span><span class="o">&gt;</span><span class="p">{</span><span class="o">&lt;</span><span class="n">DT</span><span class="o">&gt;&lt;</span><span class="n">NN</span><span class="o">&gt;</span><span class="p">}</span><span class="o">&lt;.&gt;</span><span class="p">{</span><span class="o">&lt;</span><span class="n">DT</span><span class="o">&gt;&lt;</span><span class="n">NN</span><span class="o">&gt;</span><span class="p">}</span><span class="o">&lt;</span><span class="n">VBD</span><span class="o">&gt;&lt;.&gt;</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">ChunkString</span></code> are created from tagged texts (i.e., lists of
<code class="docutils literal"><span class="pre">tokens</span></code> whose type is <code class="docutils literal"><span class="pre">TaggedType</span></code>).  Initially, nothing is
chunked.</p>
<p>The chunking of a <code class="docutils literal"><span class="pre">ChunkString</span></code> can be modified with the <code class="docutils literal"><span class="pre">xform()</span></code>
method, which uses a regular expression to transform the string
representation.  These transformations should only add and remove
braces; they should <em>not</em> modify the sequence of angle-bracket
delimited tags.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><ul class="first last simple">
<li><strong>_str</strong> &#8211; <p>The internal string representation of the text&#8217;s
encoding.  This string representation contains a sequence of
angle-bracket delimited tags, with chunking indicated by
braces.  An example of this encoding is:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">{</span><span class="o">&lt;</span><span class="n">DT</span><span class="o">&gt;&lt;</span><span class="n">JJ</span><span class="o">&gt;&lt;</span><span class="n">NN</span><span class="o">&gt;</span><span class="p">}</span><span class="o">&lt;</span><span class="n">VBN</span><span class="o">&gt;&lt;</span><span class="n">IN</span><span class="o">&gt;</span><span class="p">{</span><span class="o">&lt;</span><span class="n">DT</span><span class="o">&gt;&lt;</span><span class="n">NN</span><span class="o">&gt;</span><span class="p">}</span><span class="o">&lt;.&gt;</span><span class="p">{</span><span class="o">&lt;</span><span class="n">DT</span><span class="o">&gt;&lt;</span><span class="n">NN</span><span class="o">&gt;</span><span class="p">}</span><span class="o">&lt;</span><span class="n">VBD</span><span class="o">&gt;&lt;.&gt;</span>
</pre></div>
</div>
</li>
<li><strong>_pieces</strong> &#8211; The tagged tokens and chunks encoded by this <code class="docutils literal"><span class="pre">ChunkString</span></code>.</li>
<li><strong>_debug</strong> &#8211; The debug level.  See the constructor docs.</li>
<li><a class="reference internal" href="#nltk.chunk.regexp.ChunkString.IN_CHUNK_PATTERN" title="nltk.chunk.regexp.ChunkString.IN_CHUNK_PATTERN"><strong>IN_CHUNK_PATTERN</strong></a> &#8211; A zero-width regexp pattern string that
will only match positions that are in chunks.</li>
<li><a class="reference internal" href="#nltk.chunk.regexp.ChunkString.IN_CHINK_PATTERN" title="nltk.chunk.regexp.ChunkString.IN_CHINK_PATTERN"><strong>IN_CHINK_PATTERN</strong></a> &#8211; A zero-width regexp pattern string that
will only match positions that are in chinks.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="nltk.chunk.regexp.ChunkString.CHUNK_TAG">
<code class="descname">CHUNK_TAG</code><em class="property"> = '(&lt;[^\\{\\}&lt;&gt;]+?&gt;)'</em><a class="headerlink" href="#nltk.chunk.regexp.ChunkString.CHUNK_TAG" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nltk.chunk.regexp.ChunkString.CHUNK_TAG_CHAR">
<code class="descname">CHUNK_TAG_CHAR</code><em class="property"> = '[^\\{\\}&lt;&gt;]'</em><a class="headerlink" href="#nltk.chunk.regexp.ChunkString.CHUNK_TAG_CHAR" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nltk.chunk.regexp.ChunkString.IN_CHINK_PATTERN">
<code class="descname">IN_CHINK_PATTERN</code><em class="property"> = '(?=[^\\}]*(\\{|$))'</em><a class="headerlink" href="#nltk.chunk.regexp.ChunkString.IN_CHINK_PATTERN" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nltk.chunk.regexp.ChunkString.IN_CHUNK_PATTERN">
<code class="descname">IN_CHUNK_PATTERN</code><em class="property"> = '(?=[^\\{]*\\})'</em><a class="headerlink" href="#nltk.chunk.regexp.ChunkString.IN_CHUNK_PATTERN" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nltk.chunk.regexp.ChunkString.to_chunkstruct">
<code class="descname">to_chunkstruct</code><span class="sig-paren">(</span><em>chunk_label='CHUNK'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/chunk/regexp.html#ChunkString.to_chunkstruct"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.regexp.ChunkString.to_chunkstruct" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the chunk structure encoded by this <code class="docutils literal"><span class="pre">ChunkString</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="nltk.html#nltk.tree.Tree" title="nltk.tree.Tree">Tree</a></td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><strong>ValueError</strong> &#8211; If a transformation has generated an
invalid chunkstring.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.chunk.regexp.ChunkString.unicode_repr">
<code class="descname">unicode_repr</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nltk.chunk.regexp.ChunkString.unicode_repr" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a string representation of this <code class="docutils literal"><span class="pre">ChunkString</span></code>.
It has the form:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">ChunkString</span><span class="p">:</span> <span class="s1">&#39;{&lt;DT&gt;&lt;JJ&gt;&lt;NN&gt;}&lt;VBN&gt;&lt;IN&gt;{&lt;DT&gt;&lt;NN&gt;}&#39;</span><span class="o">&gt;</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="nltk.sem.html#nltk.sem.logic.ComplexType.str" title="nltk.sem.logic.ComplexType.str">str</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.chunk.regexp.ChunkString.xform">
<code class="descname">xform</code><span class="sig-paren">(</span><em>regexp</em>, <em>repl</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/chunk/regexp.html#ChunkString.xform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.regexp.ChunkString.xform" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply the given transformation to the string encoding of this
<code class="docutils literal"><span class="pre">ChunkString</span></code>.  In particular, find all occurrences that match
<code class="docutils literal"><span class="pre">regexp</span></code>, and replace them using <code class="docutils literal"><span class="pre">repl</span></code> (as done by
<code class="docutils literal"><span class="pre">re.sub</span></code>).</p>
<p>This transformation should only add and remove braces; it
should <em>not</em> modify the sequence of angle-bracket delimited
tags.  Furthermore, this transformation may not result in
improper bracketing.  Note, in particular, that bracketing may
not be nested.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>regexp</strong> (<a class="reference internal" href="nltk.sem.html#nltk.sem.logic.ComplexType.str" title="nltk.sem.logic.ComplexType.str"><em>str</em></a><em> or </em><a class="reference internal" href="#module-nltk.chunk.regexp" title="nltk.chunk.regexp"><em>regexp</em></a>) &#8211; A regular expression matching the substring
that should be replaced.  This will typically include a
named group, which can be used by <code class="docutils literal"><span class="pre">repl</span></code>.</li>
<li><strong>repl</strong> (<a class="reference internal" href="nltk.sem.html#nltk.sem.logic.ComplexType.str" title="nltk.sem.logic.ComplexType.str"><em>str</em></a>) &#8211; An expression specifying what should replace the
matched substring.  Typically, this will include a named
replacement group, specified by <code class="docutils literal"><span class="pre">regexp</span></code>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">None</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><strong>ValueError</strong> &#8211; If this transformation generated an
invalid chunkstring.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.chunk.regexp.ExpandLeftRule">
<em class="property">class </em><code class="descclassname">nltk.chunk.regexp.</code><code class="descname">ExpandLeftRule</code><span class="sig-paren">(</span><em>left_tag_pattern</em>, <em>right_tag_pattern</em>, <em>descr</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/chunk/regexp.html#ExpandLeftRule"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.regexp.ExpandLeftRule" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.chunk.regexp.RegexpChunkRule" title="nltk.chunk.regexp.RegexpChunkRule"><code class="xref py py-class docutils literal"><span class="pre">nltk.chunk.regexp.RegexpChunkRule</span></code></a></p>
<p>A rule specifying how to expand chunks in a <code class="docutils literal"><span class="pre">ChunkString</span></code> to the left,
using two matching tag patterns: a left pattern, and a right pattern.
When applied to a <code class="docutils literal"><span class="pre">ChunkString</span></code>, it will find any chunk whose beginning
matches right pattern, and immediately preceded by a chink whose
end matches left pattern.  It will then expand the chunk to incorporate
the new material on the left.</p>
<dl class="method">
<dt id="nltk.chunk.regexp.ExpandLeftRule.unicode_repr">
<code class="descname">unicode_repr</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nltk.chunk.regexp.ExpandLeftRule.unicode_repr" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a string representation of this rule.  It has the form:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">ExpandLeftRule</span><span class="p">:</span> <span class="s1">&#39;&lt;NN|DT|JJ&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;NN|JJ&gt;&#39;</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>Note that this representation does not include the
description string; that string can be accessed
separately with the <code class="docutils literal"><span class="pre">descr()</span></code> method.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="nltk.sem.html#nltk.sem.logic.ComplexType.str" title="nltk.sem.logic.ComplexType.str">str</a></td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.chunk.regexp.ExpandRightRule">
<em class="property">class </em><code class="descclassname">nltk.chunk.regexp.</code><code class="descname">ExpandRightRule</code><span class="sig-paren">(</span><em>left_tag_pattern</em>, <em>right_tag_pattern</em>, <em>descr</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/chunk/regexp.html#ExpandRightRule"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.regexp.ExpandRightRule" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.chunk.regexp.RegexpChunkRule" title="nltk.chunk.regexp.RegexpChunkRule"><code class="xref py py-class docutils literal"><span class="pre">nltk.chunk.regexp.RegexpChunkRule</span></code></a></p>
<p>A rule specifying how to expand chunks in a <code class="docutils literal"><span class="pre">ChunkString</span></code> to the
right, using two matching tag patterns: a left pattern, and a
right pattern.  When applied to a <code class="docutils literal"><span class="pre">ChunkString</span></code>, it will find any
chunk whose end matches left pattern, and immediately followed by
a chink whose beginning matches right pattern.  It will then
expand the chunk to incorporate the new material on the right.</p>
<dl class="method">
<dt id="nltk.chunk.regexp.ExpandRightRule.unicode_repr">
<code class="descname">unicode_repr</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nltk.chunk.regexp.ExpandRightRule.unicode_repr" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a string representation of this rule.  It has the form:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">ExpandRightRule</span><span class="p">:</span> <span class="s1">&#39;&lt;NN|DT|JJ&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;NN|JJ&gt;&#39;</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>Note that this representation does not include the
description string; that string can be accessed
separately with the <code class="docutils literal"><span class="pre">descr()</span></code> method.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="nltk.sem.html#nltk.sem.logic.ComplexType.str" title="nltk.sem.logic.ComplexType.str">str</a></td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.chunk.regexp.MergeRule">
<em class="property">class </em><code class="descclassname">nltk.chunk.regexp.</code><code class="descname">MergeRule</code><span class="sig-paren">(</span><em>left_tag_pattern</em>, <em>right_tag_pattern</em>, <em>descr</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/chunk/regexp.html#MergeRule"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.regexp.MergeRule" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.chunk.regexp.RegexpChunkRule" title="nltk.chunk.regexp.RegexpChunkRule"><code class="xref py py-class docutils literal"><span class="pre">nltk.chunk.regexp.RegexpChunkRule</span></code></a></p>
<p>A rule specifying how to merge chunks in a <code class="docutils literal"><span class="pre">ChunkString</span></code>, using
two matching tag patterns: a left pattern, and a right pattern.
When applied to a <code class="docutils literal"><span class="pre">ChunkString</span></code>, it will find any chunk whose end
matches left pattern, and immediately followed by a chunk whose
beginning matches right pattern.  It will then merge those two
chunks into a single chunk.</p>
<dl class="method">
<dt id="nltk.chunk.regexp.MergeRule.unicode_repr">
<code class="descname">unicode_repr</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nltk.chunk.regexp.MergeRule.unicode_repr" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a string representation of this rule.  It has the form:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">MergeRule</span><span class="p">:</span> <span class="s1">&#39;&lt;NN|DT|JJ&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;NN|JJ&gt;&#39;</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>Note that this representation does not include the
description string; that string can be accessed
separately with the <code class="docutils literal"><span class="pre">descr()</span></code> method.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="nltk.sem.html#nltk.sem.logic.ComplexType.str" title="nltk.sem.logic.ComplexType.str">str</a></td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.chunk.regexp.RegexpChunkParser">
<em class="property">class </em><code class="descclassname">nltk.chunk.regexp.</code><code class="descname">RegexpChunkParser</code><span class="sig-paren">(</span><em>rules</em>, <em>chunk_label='NP'</em>, <em>root_label='S'</em>, <em>trace=0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/chunk/regexp.html#RegexpChunkParser"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.regexp.RegexpChunkParser" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.chunk.api.ChunkParserI" title="nltk.chunk.api.ChunkParserI"><code class="xref py py-class docutils literal"><span class="pre">nltk.chunk.api.ChunkParserI</span></code></a></p>
<p>A regular expression based chunk parser.  <code class="docutils literal"><span class="pre">RegexpChunkParser</span></code> uses a
sequence of &#8220;rules&#8221; to find chunks of a single type within a
text.  The chunking of the text is encoded using a <code class="docutils literal"><span class="pre">ChunkString</span></code>,
and each rule acts by modifying the chunking in the
<code class="docutils literal"><span class="pre">ChunkString</span></code>.  The rules are all implemented using regular
expression matching and substitution.</p>
<p>The <code class="docutils literal"><span class="pre">RegexpChunkRule</span></code> class and its subclasses (<code class="docutils literal"><span class="pre">ChunkRule</span></code>,
<code class="docutils literal"><span class="pre">ChinkRule</span></code>, <code class="docutils literal"><span class="pre">UnChunkRule</span></code>, <code class="docutils literal"><span class="pre">MergeRule</span></code>, and <code class="docutils literal"><span class="pre">SplitRule</span></code>)
define the rules that are used by <code class="docutils literal"><span class="pre">RegexpChunkParser</span></code>.  Each rule
defines an <code class="docutils literal"><span class="pre">apply()</span></code> method, which modifies the chunking encoded
by a given <code class="docutils literal"><span class="pre">ChunkString</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><ul class="first last simple">
<li><strong>_rules</strong> &#8211; The list of rules that should be applied to a text.</li>
<li><strong>_trace</strong> &#8211; The default level of tracing.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="nltk.chunk.regexp.RegexpChunkParser.parse">
<code class="descname">parse</code><span class="sig-paren">(</span><em>chunk_struct</em>, <em>trace=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/chunk/regexp.html#RegexpChunkParser.parse"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.regexp.RegexpChunkParser.parse" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>chunk_struct</strong> (<a class="reference internal" href="nltk.html#nltk.tree.Tree" title="nltk.tree.Tree"><em>Tree</em></a>) &#8211; the chunk structure to be (further) chunked</li>
<li><strong>trace</strong> (<em>int</em>) &#8211; The level of tracing that should be used when
parsing a text.  <code class="docutils literal"><span class="pre">0</span></code> will generate no tracing output;
<code class="docutils literal"><span class="pre">1</span></code> will generate normal tracing output; and <code class="docutils literal"><span class="pre">2</span></code> or
highter will generate verbose tracing output.  This value
overrides the trace level value that was given to the
constructor.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first"><a class="reference internal" href="nltk.html#nltk.tree.Tree" title="nltk.tree.Tree">Tree</a></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">a chunk structure that encodes the chunks in a given
tagged sentence.  A chunk is a non-overlapping linguistic
group, such as a noun phrase.  The set of chunks
identified in the chunk structure depends on the rules
used to define this <code class="docutils literal"><span class="pre">RegexpChunkParser</span></code>.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.chunk.regexp.RegexpChunkParser.rules">
<code class="descname">rules</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/chunk/regexp.html#RegexpChunkParser.rules"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.regexp.RegexpChunkParser.rules" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">the sequence of rules used by <code class="docutils literal"><span class="pre">RegexpChunkParser</span></code>.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="nltk.html#nltk.downloader.Downloader.list" title="nltk.downloader.Downloader.list">list</a>(<a class="reference internal" href="#nltk.chunk.regexp.RegexpChunkRule" title="nltk.chunk.regexp.RegexpChunkRule">RegexpChunkRule</a>)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.chunk.regexp.RegexpChunkParser.unicode_repr">
<code class="descname">unicode_repr</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nltk.chunk.regexp.RegexpChunkParser.unicode_repr" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a concise string representation of this
<code class="docutils literal"><span class="pre">RegexpChunkParser</span></code>.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="nltk.sem.html#nltk.sem.logic.ComplexType.str" title="nltk.sem.logic.ComplexType.str">str</a></td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.chunk.regexp.RegexpChunkRule">
<em class="property">class </em><code class="descclassname">nltk.chunk.regexp.</code><code class="descname">RegexpChunkRule</code><span class="sig-paren">(</span><em>regexp</em>, <em>repl</em>, <em>descr</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/chunk/regexp.html#RegexpChunkRule"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.regexp.RegexpChunkRule" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>A rule specifying how to modify the chunking in a <code class="docutils literal"><span class="pre">ChunkString</span></code>,
using a transformational regular expression.  The
<code class="docutils literal"><span class="pre">RegexpChunkRule</span></code> class itself can be used to implement any
transformational rule based on regular expressions.  There are
also a number of subclasses, which can be used to implement
simpler types of rules, based on matching regular expressions.</p>
<p>Each <code class="docutils literal"><span class="pre">RegexpChunkRule</span></code> has a regular expression and a
replacement expression.  When a <code class="docutils literal"><span class="pre">RegexpChunkRule</span></code> is &#8220;applied&#8221;
to a <code class="docutils literal"><span class="pre">ChunkString</span></code>, it searches the <code class="docutils literal"><span class="pre">ChunkString</span></code> for any
substring that matches the regular expression, and replaces it
using the replacement expression.  This search/replace operation
has the same semantics as <code class="docutils literal"><span class="pre">re.sub</span></code>.</p>
<p>Each <code class="docutils literal"><span class="pre">RegexpChunkRule</span></code> also has a description string, which
gives a short (typically less than 75 characters) description of
the purpose of the rule.</p>
<p>This transformation defined by this <code class="docutils literal"><span class="pre">RegexpChunkRule</span></code> should
only add and remove braces; it should <em>not</em> modify the sequence
of angle-bracket delimited tags.  Furthermore, this transformation
may not result in nested or mismatched bracketing.</p>
<dl class="method">
<dt id="nltk.chunk.regexp.RegexpChunkRule.apply">
<code class="descname">apply</code><span class="sig-paren">(</span><em>chunkstr</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/chunk/regexp.html#RegexpChunkRule.apply"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.regexp.RegexpChunkRule.apply" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply this rule to the given <code class="docutils literal"><span class="pre">ChunkString</span></code>.  See the
class reference documentation for a description of what it
means to apply a rule.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>chunkstr</strong> (<a class="reference internal" href="#nltk.chunk.regexp.ChunkString" title="nltk.chunk.regexp.ChunkString"><em>ChunkString</em></a>) &#8211; The chunkstring to which this rule is applied.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">None</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><strong>ValueError</strong> &#8211; If this transformation generated an
invalid chunkstring.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.chunk.regexp.RegexpChunkRule.descr">
<code class="descname">descr</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/chunk/regexp.html#RegexpChunkRule.descr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.regexp.RegexpChunkRule.descr" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a short description of the purpose and/or effect of
this rule.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="nltk.sem.html#nltk.sem.logic.ComplexType.str" title="nltk.sem.logic.ComplexType.str">str</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="nltk.chunk.regexp.RegexpChunkRule.fromstring">
<em class="property">static </em><code class="descname">fromstring</code><span class="sig-paren">(</span><em>s</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/chunk/regexp.html#RegexpChunkRule.fromstring"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.regexp.RegexpChunkRule.fromstring" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a RegexpChunkRule from a string description.
Currently, the following formats are supported:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">{</span><span class="n">regexp</span><span class="p">}</span>         <span class="c1"># chunk rule</span>
<span class="p">}</span><span class="n">regexp</span><span class="p">{</span>         <span class="c1"># chink rule</span>
<span class="n">regexp</span><span class="p">}{</span><span class="n">regexp</span>   <span class="c1"># split rule</span>
<span class="n">regexp</span><span class="p">{}</span><span class="n">regexp</span>   <span class="c1"># merge rule</span>
</pre></div>
</div>
<p>Where <code class="docutils literal"><span class="pre">regexp</span></code> is a regular expression for the rule.  Any
text following the comment marker (<code class="docutils literal"><span class="pre">#</span></code>) will be used as
the rule&#8217;s description:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">nltk.chunk.regexp</span> <span class="k">import</span> <span class="n">RegexpChunkRule</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">RegexpChunkRule</span><span class="o">.</span><span class="n">fromstring</span><span class="p">(</span><span class="s1">&#39;{&lt;DT&gt;?&lt;NN.*&gt;+}&#39;</span><span class="p">)</span>
<span class="go">&lt;ChunkRule: &#39;&lt;DT&gt;?&lt;NN.*&gt;+&#39;&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nltk.chunk.regexp.RegexpChunkRule.unicode_repr">
<code class="descname">unicode_repr</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nltk.chunk.regexp.RegexpChunkRule.unicode_repr" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a string representation of this rule.  It has the form:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">RegexpChunkRule</span><span class="p">:</span> <span class="s1">&#39;{&lt;IN|VB.*&gt;}&#39;</span><span class="o">-&gt;</span><span class="s1">&#39;&lt;IN&gt;&#39;</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>Note that this representation does not include the
description string; that string can be accessed
separately with the <code class="docutils literal"><span class="pre">descr()</span></code> method.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="nltk.sem.html#nltk.sem.logic.ComplexType.str" title="nltk.sem.logic.ComplexType.str">str</a></td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.chunk.regexp.RegexpParser">
<em class="property">class </em><code class="descclassname">nltk.chunk.regexp.</code><code class="descname">RegexpParser</code><span class="sig-paren">(</span><em>grammar</em>, <em>root_label='S'</em>, <em>loop=1</em>, <em>trace=0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/chunk/regexp.html#RegexpParser"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.regexp.RegexpParser" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.chunk.api.ChunkParserI" title="nltk.chunk.api.ChunkParserI"><code class="xref py py-class docutils literal"><span class="pre">nltk.chunk.api.ChunkParserI</span></code></a></p>
<p>A grammar based chunk parser.  <code class="docutils literal"><span class="pre">chunk.RegexpParser</span></code> uses a set of
regular expression patterns to specify the behavior of the parser.
The chunking of the text is encoded using a <code class="docutils literal"><span class="pre">ChunkString</span></code>, and
each rule acts by modifying the chunking in the <code class="docutils literal"><span class="pre">ChunkString</span></code>.
The rules are all implemented using regular expression matching
and substitution.</p>
<p>A grammar contains one or more clauses in the following form:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">NP</span><span class="p">:</span>
  <span class="p">{</span><span class="o">&lt;</span><span class="n">DT</span><span class="o">|</span><span class="n">JJ</span><span class="o">&gt;</span><span class="p">}</span>          <span class="c1"># chunk determiners and adjectives</span>
  <span class="p">}</span><span class="o">&lt;</span><span class="p">[</span>\<span class="o">.</span><span class="n">VI</span><span class="p">]</span><span class="o">.*&gt;+</span><span class="p">{</span>      <span class="c1"># chink any tag beginning with V, I, or .</span>
  <span class="o">&lt;.*&gt;</span><span class="p">}{</span><span class="o">&lt;</span><span class="n">DT</span><span class="o">&gt;</span>         <span class="c1"># split a chunk at a determiner</span>
  <span class="o">&lt;</span><span class="n">DT</span><span class="o">|</span><span class="n">JJ</span><span class="o">&gt;</span><span class="p">{}</span><span class="o">&lt;</span><span class="n">NN</span><span class="o">.*&gt;</span>    <span class="c1"># merge chunk ending with det/adj</span>
                     <span class="c1"># with one starting with a noun</span>
</pre></div>
</div>
<p>The patterns of a clause are executed in order.  An earlier
pattern may introduce a chunk boundary that prevents a later
pattern from executing.  Sometimes an individual pattern will
match on multiple, overlapping extents of the input.  As with
regular expression substitution more generally, the chunker will
identify the first match possible, then continue looking for matches
after this one has ended.</p>
<p>The clauses of a grammar are also executed in order.  A cascaded
chunk parser is one having more than one clause.  The maximum depth
of a parse tree created by this chunk parser is the same as the
number of clauses in the grammar.</p>
<p>When tracing is turned on, the comment portion of a line is displayed
each time the corresponding pattern is applied.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><ul class="first last simple">
<li><strong>_start</strong> &#8211; The start symbol of the grammar (the root node of
resulting trees)</li>
<li><strong>_stages</strong> &#8211; The list of parsing stages corresponding to the grammar</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="nltk.chunk.regexp.RegexpParser.parse">
<code class="descname">parse</code><span class="sig-paren">(</span><em>chunk_struct</em>, <em>trace=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/chunk/regexp.html#RegexpParser.parse"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.regexp.RegexpParser.parse" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply the chunk parser to this input.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>chunk_struct</strong> (<a class="reference internal" href="nltk.html#nltk.tree.Tree" title="nltk.tree.Tree"><em>Tree</em></a>) &#8211; the chunk structure to be (further) chunked
(this tree is modified, and is also returned)</li>
<li><strong>trace</strong> (<em>int</em>) &#8211; The level of tracing that should be used when
parsing a text.  <code class="docutils literal"><span class="pre">0</span></code> will generate no tracing output;
<code class="docutils literal"><span class="pre">1</span></code> will generate normal tracing output; and <code class="docutils literal"><span class="pre">2</span></code> or
highter will generate verbose tracing output.  This value
overrides the trace level value that was given to the
constructor.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">the chunked output.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="nltk.html#nltk.tree.Tree" title="nltk.tree.Tree">Tree</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.chunk.regexp.RegexpParser.unicode_repr">
<code class="descname">unicode_repr</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nltk.chunk.regexp.RegexpParser.unicode_repr" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a concise string representation of this <code class="docutils literal"><span class="pre">chunk.RegexpParser</span></code>.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="nltk.sem.html#nltk.sem.logic.ComplexType.str" title="nltk.sem.logic.ComplexType.str">str</a></td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.chunk.regexp.SplitRule">
<em class="property">class </em><code class="descclassname">nltk.chunk.regexp.</code><code class="descname">SplitRule</code><span class="sig-paren">(</span><em>left_tag_pattern</em>, <em>right_tag_pattern</em>, <em>descr</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/chunk/regexp.html#SplitRule"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.regexp.SplitRule" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.chunk.regexp.RegexpChunkRule" title="nltk.chunk.regexp.RegexpChunkRule"><code class="xref py py-class docutils literal"><span class="pre">nltk.chunk.regexp.RegexpChunkRule</span></code></a></p>
<p>A rule specifying how to split chunks in a <code class="docutils literal"><span class="pre">ChunkString</span></code>, using
two matching tag patterns: a left pattern, and a right pattern.
When applied to a <code class="docutils literal"><span class="pre">ChunkString</span></code>, it will find any chunk that
matches the left pattern followed by the right pattern.  It will
then split the chunk into two new chunks, at the point between the
two pattern matches.</p>
<dl class="method">
<dt id="nltk.chunk.regexp.SplitRule.unicode_repr">
<code class="descname">unicode_repr</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nltk.chunk.regexp.SplitRule.unicode_repr" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Return a string representation of this rule.  It has the form:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">SplitRule</span><span class="p">:</span> <span class="s1">&#39;&lt;NN&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;DT&gt;&#39;</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>Note that this representation does not include the
description string; that string can be accessed
separately with the <code class="docutils literal"><span class="pre">descr()</span></code> method.</p>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="nltk.sem.html#nltk.sem.logic.ComplexType.str" title="nltk.sem.logic.ComplexType.str">str</a></td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.chunk.regexp.UnChunkRule">
<em class="property">class </em><code class="descclassname">nltk.chunk.regexp.</code><code class="descname">UnChunkRule</code><span class="sig-paren">(</span><em>tag_pattern</em>, <em>descr</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/chunk/regexp.html#UnChunkRule"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.regexp.UnChunkRule" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.chunk.regexp.RegexpChunkRule" title="nltk.chunk.regexp.RegexpChunkRule"><code class="xref py py-class docutils literal"><span class="pre">nltk.chunk.regexp.RegexpChunkRule</span></code></a></p>
<p>A rule specifying how to remove chunks to a <code class="docutils literal"><span class="pre">ChunkString</span></code>,
using a matching tag pattern.  When applied to a
<code class="docutils literal"><span class="pre">ChunkString</span></code>, it will find any complete chunk that matches this
tag pattern, and un-chunk it.</p>
<dl class="method">
<dt id="nltk.chunk.regexp.UnChunkRule.unicode_repr">
<code class="descname">unicode_repr</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nltk.chunk.regexp.UnChunkRule.unicode_repr" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a string representation of this rule.  It has the form:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">UnChunkRule</span><span class="p">:</span> <span class="s1">&#39;&lt;IN|VB.*&gt;&#39;</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>Note that this representation does not include the
description string; that string can be accessed
separately with the <code class="docutils literal"><span class="pre">descr()</span></code> method.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="nltk.sem.html#nltk.sem.logic.ComplexType.str" title="nltk.sem.logic.ComplexType.str">str</a></td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="nltk.chunk.regexp.demo">
<code class="descclassname">nltk.chunk.regexp.</code><code class="descname">demo</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/chunk/regexp.html#demo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.regexp.demo" title="Permalink to this definition">¶</a></dt>
<dd><p>A demonstration for the <code class="docutils literal"><span class="pre">RegexpChunkParser</span></code> class.  A single text is
parsed with four different chunk parsers, using a variety of rules
and strategies.</p>
</dd></dl>

<dl class="function">
<dt id="nltk.chunk.regexp.demo_eval">
<code class="descclassname">nltk.chunk.regexp.</code><code class="descname">demo_eval</code><span class="sig-paren">(</span><em>chunkparser</em>, <em>text</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/chunk/regexp.html#demo_eval"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.regexp.demo_eval" title="Permalink to this definition">¶</a></dt>
<dd><p>Demonstration code for evaluating a chunk parser, using a
<code class="docutils literal"><span class="pre">ChunkScore</span></code>.  This function assumes that <code class="docutils literal"><span class="pre">text</span></code> contains one
sentence per line, and that each sentence has the form expected by
<code class="docutils literal"><span class="pre">tree.chunk</span></code>.  It runs the given chunk parser on each sentence in
the text, and scores the result.  It prints the final score
(precision, recall, and f-measure); and reports the set of chunks
that were missed and the set of chunks that were incorrect.  (At
most 10 missing chunks and 10 incorrect chunks are reported).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>chunkparser</strong> (<a class="reference internal" href="#nltk.chunk.api.ChunkParserI" title="nltk.chunk.api.ChunkParserI"><em>ChunkParserI</em></a>) &#8211; The chunkparser to be tested</li>
<li><strong>text</strong> (<a class="reference internal" href="nltk.sem.html#nltk.sem.logic.ComplexType.str" title="nltk.sem.logic.ComplexType.str"><em>str</em></a>) &#8211; The chunked tagged text that should be used for
evaluation.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="nltk.chunk.regexp.tag_pattern2re_pattern">
<code class="descclassname">nltk.chunk.regexp.</code><code class="descname">tag_pattern2re_pattern</code><span class="sig-paren">(</span><em>tag_pattern</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/chunk/regexp.html#tag_pattern2re_pattern"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.regexp.tag_pattern2re_pattern" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a tag pattern to a regular expression pattern.  A &#8220;tag
pattern&#8221; is a modified version of a regular expression, designed
for matching sequences of tags.  The differences between regular
expression patterns and tag patterns are:</p>
<blockquote>
<div><ul class="simple">
<li>In tag patterns, <code class="docutils literal"><span class="pre">'&lt;'</span></code> and <code class="docutils literal"><span class="pre">'&gt;'</span></code> act as parentheses; so
<code class="docutils literal"><span class="pre">'&lt;NN&gt;+'</span></code> matches one or more repetitions of <code class="docutils literal"><span class="pre">'&lt;NN&gt;'</span></code>, not
<code class="docutils literal"><span class="pre">'&lt;NN'</span></code> followed by one or more repetitions of <code class="docutils literal"><span class="pre">'&gt;'</span></code>.</li>
<li>Whitespace in tag patterns is ignored.  So
<code class="docutils literal"><span class="pre">'&lt;DT&gt;</span> <span class="pre">|</span> <span class="pre">&lt;NN&gt;'</span></code> is equivalant to <code class="docutils literal"><span class="pre">'&lt;DT&gt;|&lt;NN&gt;'</span></code></li>
<li>In tag patterns, <code class="docutils literal"><span class="pre">'.'</span></code> is equivalant to <code class="docutils literal"><span class="pre">'[^{}&lt;&gt;]'</span></code>; so
<code class="docutils literal"><span class="pre">'&lt;NN.*&gt;'</span></code> matches any single tag starting with <code class="docutils literal"><span class="pre">'NN'</span></code>.</li>
</ul>
</div></blockquote>
<p>In particular, <code class="docutils literal"><span class="pre">tag_pattern2re_pattern</span></code> performs the following
transformations on the given pattern:</p>
<blockquote>
<div><ul class="simple">
<li>Replace &#8216;.&#8217; with &#8216;[^&lt;&gt;{}]&#8217;</li>
<li>Remove any whitespace</li>
<li>Add extra parens around &#8216;&lt;&#8217; and &#8216;&gt;&#8217;, to make &#8216;&lt;&#8217; and &#8216;&gt;&#8217; act
like parentheses.  E.g., so that in &#8216;&lt;NN&gt;+&#8217;, the &#8216;+&#8217; has scope
over the entire &#8216;&lt;NN&gt;&#8217;; and so that in &#8216;&lt;NN|IN&gt;&#8217;, the &#8216;|&#8217; has
scope over &#8216;NN&#8217; and &#8216;IN&#8217;, but not &#8216;&lt;&#8217; or &#8216;&gt;&#8217;.</li>
<li>Check to make sure the resulting pattern is valid.</li>
</ul>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>tag_pattern</strong> (<a class="reference internal" href="nltk.sem.html#nltk.sem.logic.ComplexType.str" title="nltk.sem.logic.ComplexType.str"><em>str</em></a>) &#8211; The tag pattern to convert to a regular
expression pattern.</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><strong>ValueError</strong> &#8211; If <code class="docutils literal"><span class="pre">tag_pattern</span></code> is not a valid tag pattern.
In particular, <code class="docutils literal"><span class="pre">tag_pattern</span></code> should not include braces; and it
should not contain nested or mismatched angle-brackets.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="nltk.sem.html#nltk.sem.logic.ComplexType.str" title="nltk.sem.logic.ComplexType.str">str</a></td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A regular expression pattern corresponding to
<code class="docutils literal"><span class="pre">tag_pattern</span></code>.</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-nltk.chunk.util">
<span id="nltk-chunk-util-module"></span><h2>nltk.chunk.util module<a class="headerlink" href="#module-nltk.chunk.util" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="nltk.chunk.util.ChunkScore">
<em class="property">class </em><code class="descclassname">nltk.chunk.util.</code><code class="descname">ChunkScore</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/chunk/util.html#ChunkScore"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.util.ChunkScore" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>A utility class for scoring chunk parsers.  <code class="docutils literal"><span class="pre">ChunkScore</span></code> can
evaluate a chunk parser&#8217;s output, based on a number of statistics
(precision, recall, f-measure, misssed chunks, incorrect chunks).
It can also combine the scores from the parsing of multiple texts;
this makes it significantly easier to evaluate a chunk parser that
operates one sentence at a time.</p>
<p>Texts are evaluated with the <code class="docutils literal"><span class="pre">score</span></code> method.  The results of
evaluation can be accessed via a number of accessor methods, such
as <code class="docutils literal"><span class="pre">precision</span></code> and <code class="docutils literal"><span class="pre">f_measure</span></code>.  A typical use of the
<code class="docutils literal"><span class="pre">ChunkScore</span></code> class is:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">chunkscore</span> <span class="o">=</span> <span class="n">ChunkScore</span><span class="p">()</span>           
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">correct</span> <span class="ow">in</span> <span class="n">correct_sentences</span><span class="p">:</span>   
<span class="gp">... </span>    <span class="n">guess</span> <span class="o">=</span> <span class="n">chunkparser</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">correct</span><span class="o">.</span><span class="n">leaves</span><span class="p">())</span>   
<span class="gp">... </span>    <span class="n">chunkscore</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="n">correct</span><span class="p">,</span> <span class="n">guess</span><span class="p">)</span>              
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;F Measure:&#39;</span><span class="p">,</span> <span class="n">chunkscore</span><span class="o">.</span><span class="n">f_measure</span><span class="p">())</span>       
<span class="go">F Measure: 0.823</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><ul class="first last simple">
<li><strong>kwargs</strong> &#8211; <p>Keyword arguments:</p>
<ul>
<li>max_tp_examples: The maximum number actual examples of true
positives to record.  This affects the <code class="docutils literal"><span class="pre">correct</span></code> member
function: <code class="docutils literal"><span class="pre">correct</span></code> will not return more than this number
of true positive examples.  This does <em>not</em> affect any of
the numerical metrics (precision, recall, or f-measure)</li>
<li>max_fp_examples: The maximum number actual examples of false
positives to record.  This affects the <code class="docutils literal"><span class="pre">incorrect</span></code> member
function and the <code class="docutils literal"><span class="pre">guessed</span></code> member function: <code class="docutils literal"><span class="pre">incorrect</span></code>
will not return more than this number of examples, and
<code class="docutils literal"><span class="pre">guessed</span></code> will not return more than this number of true
positive examples.  This does <em>not</em> affect any of the
numerical metrics (precision, recall, or f-measure)</li>
<li>max_fn_examples: The maximum number actual examples of false
negatives to record.  This affects the <code class="docutils literal"><span class="pre">missed</span></code> member
function and the <code class="docutils literal"><span class="pre">correct</span></code> member function: <code class="docutils literal"><span class="pre">missed</span></code>
will not return more than this number of examples, and
<code class="docutils literal"><span class="pre">correct</span></code> will not return more than this number of true
negative examples.  This does <em>not</em> affect any of the
numerical metrics (precision, recall, or f-measure)</li>
<li>chunk_label: A regular expression indicating which chunks
should be compared.  Defaults to <code class="docutils literal"><span class="pre">'.*'</span></code> (i.e., all chunks).</li>
</ul>
</li>
<li><strong>_tp</strong> &#8211; List of true positives</li>
<li><strong>_fp</strong> &#8211; List of false positives</li>
<li><strong>_fn</strong> &#8211; List of false negatives</li>
<li><strong>_tp_num</strong> &#8211; Number of true positives</li>
<li><strong>_fp_num</strong> &#8211; Number of false positives</li>
<li><strong>_fn_num</strong> &#8211; Number of false negatives.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="nltk.chunk.util.ChunkScore.accuracy">
<code class="descname">accuracy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/chunk/util.html#ChunkScore.accuracy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.util.ChunkScore.accuracy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the overall tag-based accuracy for all text that have
been scored by this <code class="docutils literal"><span class="pre">ChunkScore</span></code>, using the IOB (conll2000)
tag encoding.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">float</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.chunk.util.ChunkScore.correct">
<code class="descname">correct</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/chunk/util.html#ChunkScore.correct"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.util.ChunkScore.correct" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the chunks which were included in the correct
chunk structures, listed in input order.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">list of chunks</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.chunk.util.ChunkScore.f_measure">
<code class="descname">f_measure</code><span class="sig-paren">(</span><em>alpha=0.5</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/chunk/util.html#ChunkScore.f_measure"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.util.ChunkScore.f_measure" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the overall F measure for all texts that have been
scored by this <code class="docutils literal"><span class="pre">ChunkScore</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>alpha</strong> (<em>float</em>) &#8211; the relative weighting of precision and recall.
Larger alpha biases the score towards the precision value,
while smaller alpha biases the score towards the recall
value.  <code class="docutils literal"><span class="pre">alpha</span></code> should have a value in the range [0,1].</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">float</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.chunk.util.ChunkScore.guessed">
<code class="descname">guessed</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/chunk/util.html#ChunkScore.guessed"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.util.ChunkScore.guessed" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the chunks which were included in the guessed
chunk structures, listed in input order.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">list of chunks</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.chunk.util.ChunkScore.incorrect">
<code class="descname">incorrect</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/chunk/util.html#ChunkScore.incorrect"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.util.ChunkScore.incorrect" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the chunks which were included in the guessed chunk structures,
but not in the correct chunk structures, listed in input order.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">list of chunks</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.chunk.util.ChunkScore.missed">
<code class="descname">missed</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/chunk/util.html#ChunkScore.missed"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.util.ChunkScore.missed" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the chunks which were included in the
correct chunk structures, but not in the guessed chunk
structures, listed in input order.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">list of chunks</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.chunk.util.ChunkScore.precision">
<code class="descname">precision</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/chunk/util.html#ChunkScore.precision"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.util.ChunkScore.precision" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the overall precision for all texts that have been
scored by this <code class="docutils literal"><span class="pre">ChunkScore</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">float</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.chunk.util.ChunkScore.recall">
<code class="descname">recall</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/chunk/util.html#ChunkScore.recall"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.util.ChunkScore.recall" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the overall recall for all texts that have been
scored by this <code class="docutils literal"><span class="pre">ChunkScore</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">float</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.chunk.util.ChunkScore.score">
<code class="descname">score</code><span class="sig-paren">(</span><em>correct</em>, <em>guessed</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/chunk/util.html#ChunkScore.score"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.util.ChunkScore.score" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a correctly chunked sentence, score another chunked
version of the same sentence.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>correct</strong> (<em>chunk structure</em>) &#8211; The known-correct (&#8220;gold standard&#8221;) chunked
sentence.</li>
<li><strong>guessed</strong> (<em>chunk structure</em>) &#8211; The chunked sentence to be scored.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="nltk.chunk.util.accuracy">
<code class="descclassname">nltk.chunk.util.</code><code class="descname">accuracy</code><span class="sig-paren">(</span><em>chunker</em>, <em>gold</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/chunk/util.html#accuracy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.util.accuracy" title="Permalink to this definition">¶</a></dt>
<dd><p>Score the accuracy of the chunker against the gold standard.
Strip the chunk information from the gold standard and rechunk it using
the chunker, then compute the accuracy score.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>chunker</strong> (<a class="reference internal" href="#nltk.chunk.api.ChunkParserI" title="nltk.chunk.api.ChunkParserI"><em>ChunkParserI</em></a>) &#8211; The chunker being evaluated.</li>
<li><strong>gold</strong> (<a class="reference internal" href="nltk.corpus.reader.html#nltk.corpus.reader.conll.ConllSRLInstance.tree" title="nltk.corpus.reader.conll.ConllSRLInstance.tree"><em>tree</em></a>) &#8211; The chunk structures to score the chunker on.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">float</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="nltk.chunk.util.conllstr2tree">
<code class="descclassname">nltk.chunk.util.</code><code class="descname">conllstr2tree</code><span class="sig-paren">(</span><em>s</em>, <em>chunk_types=('NP'</em>, <em>'PP'</em>, <em>'VP')</em>, <em>root_label='S'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/chunk/util.html#conllstr2tree"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.util.conllstr2tree" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a chunk structure for a single sentence
encoded in the given CONLL 2000 style string.
This function converts a CoNLL IOB string into a tree.
It uses the specified chunk types
(defaults to NP, PP and VP), and creates a tree rooted at a node
labeled S (by default).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>s</strong> (<a class="reference internal" href="nltk.sem.html#nltk.sem.logic.ComplexType.str" title="nltk.sem.logic.ComplexType.str"><em>str</em></a>) &#8211; The CoNLL string to be converted.</li>
<li><strong>chunk_types</strong> (<em>tuple</em>) &#8211; The chunk types to be converted.</li>
<li><strong>root_label</strong> (<a class="reference internal" href="nltk.sem.html#nltk.sem.logic.ComplexType.str" title="nltk.sem.logic.ComplexType.str"><em>str</em></a>) &#8211; The node label to use for the root.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="nltk.html#nltk.tree.Tree" title="nltk.tree.Tree">Tree</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="nltk.chunk.util.conlltags2tree">
<code class="descclassname">nltk.chunk.util.</code><code class="descname">conlltags2tree</code><span class="sig-paren">(</span><em>sentence</em>, <em>chunk_types=('NP'</em>, <em>'PP'</em>, <em>'VP')</em>, <em>root_label='S'</em>, <em>strict=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/chunk/util.html#conlltags2tree"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.util.conlltags2tree" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the CoNLL IOB format to a tree.</p>
</dd></dl>

<dl class="function">
<dt id="nltk.chunk.util.demo">
<code class="descclassname">nltk.chunk.util.</code><code class="descname">demo</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/chunk/util.html#demo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.util.demo" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="nltk.chunk.util.ieerstr2tree">
<code class="descclassname">nltk.chunk.util.</code><code class="descname">ieerstr2tree</code><span class="sig-paren">(</span><em>s, chunk_types=['LOCATION', 'ORGANIZATION', 'PERSON', 'DURATION', 'DATE', 'CARDINAL', 'PERCENT', 'MONEY', 'MEASURE'], root_label='S'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/chunk/util.html#ieerstr2tree"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.util.ieerstr2tree" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a chunk structure containing the chunked tagged text that is
encoded in the given IEER style string.
Convert a string of chunked tagged text in the IEER named
entity format into a chunk structure.  Chunks are of several
types, LOCATION, ORGANIZATION, PERSON, DURATION, DATE, CARDINAL,
PERCENT, MONEY, and MEASURE.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="nltk.html#nltk.tree.Tree" title="nltk.tree.Tree">Tree</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="nltk.chunk.util.tagstr2tree">
<code class="descclassname">nltk.chunk.util.</code><code class="descname">tagstr2tree</code><span class="sig-paren">(</span><em>s</em>, <em>chunk_label='NP'</em>, <em>root_label='S'</em>, <em>sep='/'</em>, <em>source_tagset=None</em>, <em>target_tagset=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/chunk/util.html#tagstr2tree"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.util.tagstr2tree" title="Permalink to this definition">¶</a></dt>
<dd><p>Divide a string of bracketted tagged text into
chunks and unchunked tokens, and produce a Tree.
Chunks are marked by square brackets (<code class="docutils literal"><span class="pre">[...]</span></code>).  Words are
delimited by whitespace, and each word should have the form
<code class="docutils literal"><span class="pre">text/tag</span></code>.  Words that do not contain a slash are
assigned a <code class="docutils literal"><span class="pre">tag</span></code> of None.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>s</strong> (<a class="reference internal" href="nltk.sem.html#nltk.sem.logic.ComplexType.str" title="nltk.sem.logic.ComplexType.str"><em>str</em></a>) &#8211; The string to be converted</li>
<li><strong>chunk_label</strong> (<a class="reference internal" href="nltk.sem.html#nltk.sem.logic.ComplexType.str" title="nltk.sem.logic.ComplexType.str"><em>str</em></a>) &#8211; The label to use for chunk nodes</li>
<li><strong>root_label</strong> (<a class="reference internal" href="nltk.sem.html#nltk.sem.logic.ComplexType.str" title="nltk.sem.logic.ComplexType.str"><em>str</em></a>) &#8211; The label to use for the root of the tree</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="nltk.html#nltk.tree.Tree" title="nltk.tree.Tree">Tree</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="nltk.chunk.util.tree2conllstr">
<code class="descclassname">nltk.chunk.util.</code><code class="descname">tree2conllstr</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/chunk/util.html#tree2conllstr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.util.tree2conllstr" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a multiline string where each line contains a word, tag and IOB tag.
Convert a tree to the CoNLL IOB string format</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>t</strong> (<a class="reference internal" href="nltk.html#nltk.tree.Tree" title="nltk.tree.Tree"><em>Tree</em></a>) &#8211; The tree to be converted.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="nltk.sem.html#nltk.sem.logic.ComplexType.str" title="nltk.sem.logic.ComplexType.str">str</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="nltk.chunk.util.tree2conlltags">
<code class="descclassname">nltk.chunk.util.</code><code class="descname">tree2conlltags</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/chunk/util.html#tree2conlltags"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.util.tree2conlltags" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of 3-tuples containing <code class="docutils literal"><span class="pre">(word,</span> <span class="pre">tag,</span> <span class="pre">IOB-tag)</span></code>.
Convert a tree to the CoNLL IOB tag format.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>t</strong> (<a class="reference internal" href="nltk.html#nltk.tree.Tree" title="nltk.tree.Tree"><em>Tree</em></a>) &#8211; The tree to be converted.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="nltk.html#nltk.downloader.Downloader.list" title="nltk.downloader.Downloader.list">list</a>(tuple)</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-nltk.chunk">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-nltk.chunk" title="Permalink to this headline">¶</a></h2>
<p>Classes and interfaces for identifying non-overlapping linguistic
groups (such as base noun phrases) in unrestricted text.  This task is
called &#8220;chunk parsing&#8221; or &#8220;chunking&#8221;, and the identified groups are
called &#8220;chunks&#8221;.  The chunked text is represented using a shallow
tree called a &#8220;chunk structure.&#8221;  A chunk structure is a tree
containing tokens and chunks, where each chunk is a subtree containing
only tokens.  For example, the chunk structure for base noun phrase
chunks in the sentence &#8220;I saw the big dog on the hill&#8221; is:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">SENTENCE</span><span class="p">:</span>
  <span class="p">(</span><span class="n">NP</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">I</span><span class="o">&gt;</span><span class="p">)</span>
  <span class="o">&lt;</span><span class="n">saw</span><span class="o">&gt;</span>
  <span class="p">(</span><span class="n">NP</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">the</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">big</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">dog</span><span class="o">&gt;</span><span class="p">)</span>
  <span class="o">&lt;</span><span class="n">on</span><span class="o">&gt;</span>
  <span class="p">(</span><span class="n">NP</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">the</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">hill</span><span class="o">&gt;</span><span class="p">))</span>
</pre></div>
</div>
<p>To convert a chunk structure back to a list of tokens, simply use the
chunk structure&#8217;s <code class="docutils literal"><span class="pre">leaves()</span></code> method.</p>
<p>This module defines <code class="docutils literal"><span class="pre">ChunkParserI</span></code>, a standard interface for
chunking texts; and <code class="docutils literal"><span class="pre">RegexpChunkParser</span></code>, a regular-expression based
implementation of that interface. It also defines <code class="docutils literal"><span class="pre">ChunkScore</span></code>, a
utility class for scoring chunk parsers.</p>
<div class="section" id="regexpchunkparser">
<h3>RegexpChunkParser<a class="headerlink" href="#regexpchunkparser" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal"><span class="pre">RegexpChunkParser</span></code> is an implementation of the chunk parser interface
that uses regular-expressions over tags to chunk a text.  Its
<code class="docutils literal"><span class="pre">parse()</span></code> method first constructs a <code class="docutils literal"><span class="pre">ChunkString</span></code>, which encodes a
particular chunking of the input text.  Initially, nothing is
chunked.  <code class="docutils literal"><span class="pre">parse.RegexpChunkParser</span></code> then applies a sequence of
<code class="docutils literal"><span class="pre">RegexpChunkRule</span></code> rules to the <code class="docutils literal"><span class="pre">ChunkString</span></code>, each of which modifies
the chunking that it encodes.  Finally, the <code class="docutils literal"><span class="pre">ChunkString</span></code> is
transformed back into a chunk structure, which is returned.</p>
<p><code class="docutils literal"><span class="pre">RegexpChunkParser</span></code> can only be used to chunk a single kind of phrase.
For example, you can use an <code class="docutils literal"><span class="pre">RegexpChunkParser</span></code> to chunk the noun
phrases in a text, or the verb phrases in a text; but you can not
use it to simultaneously chunk both noun phrases and verb phrases in
the same text.  (This is a limitation of <code class="docutils literal"><span class="pre">RegexpChunkParser</span></code>, not of
chunk parsers in general.)</p>
<div class="section" id="regexpchunkrules">
<h4>RegexpChunkRules<a class="headerlink" href="#regexpchunkrules" title="Permalink to this headline">¶</a></h4>
<p>A <code class="docutils literal"><span class="pre">RegexpChunkRule</span></code> is a transformational rule that updates the
chunking of a text by modifying its <code class="docutils literal"><span class="pre">ChunkString</span></code>.  Each
<code class="docutils literal"><span class="pre">RegexpChunkRule</span></code> defines the <code class="docutils literal"><span class="pre">apply()</span></code> method, which modifies
the chunking encoded by a <code class="docutils literal"><span class="pre">ChunkString</span></code>.  The
<code class="docutils literal"><span class="pre">RegexpChunkRule</span></code> class itself can be used to implement any
transformational rule based on regular expressions.  There are
also a number of subclasses, which can be used to implement
simpler types of rules:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">ChunkRule</span></code> chunks anything that matches a given regular
expression.</li>
<li><code class="docutils literal"><span class="pre">ChinkRule</span></code> chinks anything that matches a given regular
expression.</li>
<li><code class="docutils literal"><span class="pre">UnChunkRule</span></code> will un-chunk any chunk that matches a given
regular expression.</li>
<li><code class="docutils literal"><span class="pre">MergeRule</span></code> can be used to merge two contiguous chunks.</li>
<li><code class="docutils literal"><span class="pre">SplitRule</span></code> can be used to split a single chunk into two
smaller chunks.</li>
<li><code class="docutils literal"><span class="pre">ExpandLeftRule</span></code> will expand a chunk to incorporate new
unchunked material on the left.</li>
<li><code class="docutils literal"><span class="pre">ExpandRightRule</span></code> will expand a chunk to incorporate new
unchunked material on the right.</li>
</ul>
</div></blockquote>
<div class="section" id="tag-patterns">
<h5>Tag Patterns<a class="headerlink" href="#tag-patterns" title="Permalink to this headline">¶</a></h5>
<p>A <code class="docutils literal"><span class="pre">RegexpChunkRule</span></code> uses a modified version of regular
expression patterns, called &#8220;tag patterns&#8221;.  Tag patterns are
used to match sequences of tags.  Examples of tag patterns are:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="sa">r</span><span class="s1">&#39;(&lt;DT&gt;|&lt;JJ&gt;|&lt;NN&gt;)+&#39;</span>
<span class="sa">r</span><span class="s1">&#39;&lt;NN&gt;+&#39;</span>
<span class="sa">r</span><span class="s1">&#39;&lt;NN.*&gt;&#39;</span>
</pre></div>
</div>
<p>The differences between regular expression patterns and tag
patterns are:</p>
<blockquote>
<div><ul class="simple">
<li>In tag patterns, <code class="docutils literal"><span class="pre">'&lt;'</span></code> and <code class="docutils literal"><span class="pre">'&gt;'</span></code> act as parentheses; so
<code class="docutils literal"><span class="pre">'&lt;NN&gt;+'</span></code> matches one or more repetitions of <code class="docutils literal"><span class="pre">'&lt;NN&gt;'</span></code>, not
<code class="docutils literal"><span class="pre">'&lt;NN'</span></code> followed by one or more repetitions of <code class="docutils literal"><span class="pre">'&gt;'</span></code>.</li>
<li>Whitespace in tag patterns is ignored.  So
<code class="docutils literal"><span class="pre">'&lt;DT&gt;</span> <span class="pre">|</span> <span class="pre">&lt;NN&gt;'</span></code> is equivalant to <code class="docutils literal"><span class="pre">'&lt;DT&gt;|&lt;NN&gt;'</span></code></li>
<li>In tag patterns, <code class="docutils literal"><span class="pre">'.'</span></code> is equivalant to <code class="docutils literal"><span class="pre">'[^{}&lt;&gt;]'</span></code>; so
<code class="docutils literal"><span class="pre">'&lt;NN.*&gt;'</span></code> matches any single tag starting with <code class="docutils literal"><span class="pre">'NN'</span></code>.</li>
</ul>
</div></blockquote>
<p>The function <code class="docutils literal"><span class="pre">tag_pattern2re_pattern</span></code> can be used to transform
a tag pattern to an equivalent regular expression pattern.</p>
</div>
</div>
<div class="section" id="efficiency">
<h4>Efficiency<a class="headerlink" href="#efficiency" title="Permalink to this headline">¶</a></h4>
<p>Preliminary tests indicate that <code class="docutils literal"><span class="pre">RegexpChunkParser</span></code> can chunk at a
rate of about 300 tokens/second, with a moderately complex rule set.</p>
<p>There may be problems if <code class="docutils literal"><span class="pre">RegexpChunkParser</span></code> is used with more than
5,000 tokens at a time.  In particular, evaluation of some regular
expressions may cause the Python regular expression engine to
exceed its maximum recursion depth.  We have attempted to minimize
these problems, but it is impossible to avoid them completely.  We
therefore recommend that you apply the chunk parser to a single
sentence at a time.</p>
</div>
<div class="section" id="emacs-tip">
<h4>Emacs Tip<a class="headerlink" href="#emacs-tip" title="Permalink to this headline">¶</a></h4>
<p>If you evaluate the following elisp expression in emacs, it will
colorize a <code class="docutils literal"><span class="pre">ChunkString</span></code> when you use an interactive python shell
with emacs or xemacs (&#8220;C-c !&#8221;):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">let</span> <span class="p">()</span>
  <span class="p">(</span><span class="n">defconst</span> <span class="n">comint</span><span class="o">-</span><span class="n">mode</span><span class="o">-</span><span class="n">font</span><span class="o">-</span><span class="n">lock</span><span class="o">-</span><span class="n">keywords</span>
    <span class="s1">&#39;((&quot;&lt;[^&gt;]+&gt;&quot; 0 &#39;</span><span class="n">font</span><span class="o">-</span><span class="n">lock</span><span class="o">-</span><span class="n">reference</span><span class="o">-</span><span class="n">face</span><span class="p">)</span>
      <span class="p">(</span><span class="s2">&quot;[</span><span class="si">{}</span><span class="s2">]&quot;</span> <span class="mi">0</span> <span class="s1">&#39;font-lock-function-name-face)))</span>
  <span class="p">(</span><span class="n">add</span><span class="o">-</span><span class="n">hook</span> <span class="s1">&#39;comint-mode-hook (lambda () (turn-on-font-lock))))</span>
</pre></div>
</div>
<p>You can evaluate this code by copying it to a temporary buffer,
placing the cursor after the last close parenthesis, and typing
&#8220;<code class="docutils literal"><span class="pre">C-x</span> <span class="pre">C-e</span></code>&#8221;.  You should evaluate it before running the interactive
session.  The change will last until you close emacs.</p>
</div>
<div class="section" id="unresolved-issues">
<h4>Unresolved Issues<a class="headerlink" href="#unresolved-issues" title="Permalink to this headline">¶</a></h4>
<p>If we use the <code class="docutils literal"><span class="pre">re</span></code> module for regular expressions, Python&#8217;s
regular expression engine generates &#8220;maximum recursion depth
exceeded&#8221; errors when processing very large texts, even for
regular expressions that should not require any recursion.  We
therefore use the <code class="docutils literal"><span class="pre">pre</span></code> module instead.  But note that <code class="docutils literal"><span class="pre">pre</span></code>
does not include Unicode support, so this module will not work
with unicode strings.  Note also that <code class="docutils literal"><span class="pre">pre</span></code> regular expressions
are not quite as advanced as <code class="docutils literal"><span class="pre">re</span></code> ones (e.g., no leftward
zero-length assertions).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">type CHUNK_TAG_PATTERN:</th></tr>
<tr class="field-odd field"><td>&#160;</td><td class="field-body">regexp</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">var CHUNK_TAG_PATTERN:</th></tr>
<tr class="field-even field"><td>&#160;</td><td class="field-body">A regular expression to test whether a tag
pattern is valid.</td>
</tr>
</tbody>
</table>
<dl class="function">
<dt id="nltk.chunk.ne_chunk">
<code class="descclassname">nltk.chunk.</code><code class="descname">ne_chunk</code><span class="sig-paren">(</span><em>tagged_tokens</em>, <em>binary=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/chunk.html#ne_chunk"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.ne_chunk" title="Permalink to this definition">¶</a></dt>
<dd><p>Use NLTK&#8217;s currently recommended named entity chunker to
chunk the given list of tagged tokens.</p>
</dd></dl>

<dl class="function">
<dt id="nltk.chunk.ne_chunk_sents">
<code class="descclassname">nltk.chunk.</code><code class="descname">ne_chunk_sents</code><span class="sig-paren">(</span><em>tagged_sentences</em>, <em>binary=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/chunk.html#ne_chunk_sents"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.ne_chunk_sents" title="Permalink to this definition">¶</a></dt>
<dd><p>Use NLTK&#8217;s currently recommended named entity chunker to chunk the
given list of tagged sentences, each consisting of a list of tagged tokens.</p>
</dd></dl>

</div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
        </div>
        <div class="sidebar">
          <h3>Table Of Contents</h3>
          <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../news.html">NLTK News</a></li>
<li class="toctree-l1"><a class="reference internal" href="../install.html">Installing NLTK</a></li>
<li class="toctree-l1"><a class="reference internal" href="../data.html">Installing NLTK Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contribute.html">Contribute to NLTK</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/nltk/nltk/wiki/FAQ">FAQ</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/nltk/nltk/wiki">Wiki</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="nltk.html">API</a></li>
<li class="toctree-l1"><a class="reference external" href="http://www.nltk.org/howto">HOWTO</a></li>
</ul>

          <div role="search">
            <h3 style="margin-top: 1.5em;">Search</h3>
            <form class="search" action="../search.html" method="get">
                <input type="text" name="q" />
                <input type="submit" value="Go" />
                <input type="hidden" name="check_keywords" value="yes" />
                <input type="hidden" name="area" value="default" />
            </form>
          </div>
        </div>
        <div class="clearer"></div>
      </div>
    </div>

    <div class="footer-wrapper">
      <div class="footer">
        <div class="left">
          <div role="navigation" aria-label="related navigaton">
            <a href="nltk.chat.html" title="nltk.chat package"
              >previous</a> |
            <a href="nltk.classify.html" title="nltk.classify package"
              >next</a> |
            <a href="../py-modindex.html" title="Python Module Index"
              >modules</a> |
            <a href="../genindex.html" title="General Index"
              >index</a>
          </div>
          <div role="note" aria-label="source link">
              <br/>
              <a href="../_sources/api/nltk.chunk.rst.txt"
                rel="nofollow">Show Source</a>
          </div>
        </div>

        <div class="right">
          
    <div class="footer" role="contentinfo">
        &#169; Copyright 2017, NLTK Project.
      Last updated on May 18, 2017.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.5.5.
    </div>
        </div>
        <div class="clearer"></div>
      </div>
    </div>

  </body>
</html>