

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>chunk Package &mdash; NLTK 2.0 documentation</title>
    
    <link rel="stylesheet" href="../_static/agogo.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="NLTK 2.0 documentation" href="../index.html" /> 
  </head>
  <body>
    <div class="header-wrapper">
      <div class="header">
        <div class="headertitle"><a
          href="../index.html">NLTK 2.0 documentation</a></div>
        <div class="rel">
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a>
        </div>
       </div>
    </div>

    <div class="content-wrapper">
      <div class="content">
        <div class="document">
            
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="chunk-package">
<h1>chunk Package<a class="headerlink" href="#chunk-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="id1">
<h2><tt class="xref py py-mod docutils literal"><span class="pre">chunk</span></tt> Package<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<span class="target" id="module-nltk.chunk"></span><p>Classes and interfaces for identifying non-overlapping linguistic
groups (such as base noun phrases) in unrestricted text.  This task is
called X{chunk parsing} or X{chunking}, and the identified groups are
called X{chunks}.  The chunked text is represented using a shallow
tree called a &#8220;chunk structure.&#8221;  A X{chunk structure} is a tree
containing tokens and chunks, where each chunk is a subtree containing
only tokens.  For example, the chunk structure for base noun phrase
chunks in the sentence &#8220;I saw the big dog on the hill&#8221; is:</p>
<div class="highlight-python"><pre>(SENTENCE:
  (NP: &lt;I&gt;)
  &lt;saw&gt;
  (NP: &lt;the&gt; &lt;big&gt; &lt;dog&gt;)
  &lt;on&gt;
  (NP: &lt;the&gt; &lt;hill&gt;))</pre>
</div>
<p>To convert a chunk structure back to a list of tokens, simply use the
chunk structure&#8217;s L{leaves&lt;Tree.leaves&gt;} method.</p>
<p>The C{parser.chunk} module defines L{ChunkParserI}, a standard interface for
chunking texts; and L{RegexpChunkParser}, a regular-expression based
implementation of that interface. It also defines L{ChunkScore}, a
utility class for scoring chunk parsers.</p>
<div class="section" id="regexpchunkparser">
<h3>RegexpChunkParser<a class="headerlink" href="#regexpchunkparser" title="Permalink to this headline">¶</a></h3>
<p>C{parse.RegexpChunkParser} is an implementation of the chunk parser interface
that uses regular-expressions over tags to chunk a text.  Its
C{parse} method first constructs a C{ChunkString}, which encodes a
particular chunking of the input text.  Initially, nothing is
chunked.  C{parse.RegexpChunkParser} then applies a sequence of
C{RegexpChunkRule}s to the C{ChunkString}, each of which modifies
the chunking that it encodes.  Finally, the C{ChunkString} is
transformed back into a chunk structure, which is returned.</p>
<p>C{RegexpChunkParser} can only be used to chunk a single kind of phrase.
For example, you can use an C{RegexpChunkParser} to chunk the noun
phrases in a text, or the verb phrases in a text; but you can not
use it to simultaneously chunk both noun phrases and verb phrases in
the same text.  (This is a limitation of C{RegexpChunkParser}, not of
chunk parsers in general.)</p>
<div class="section" id="regexpchunkrules">
<h4>RegexpChunkRules<a class="headerlink" href="#regexpchunkrules" title="Permalink to this headline">¶</a></h4>
<p>C{RegexpChunkRule}s are transformational rules that update the
chunking of a text by modifying its C{ChunkString}.  Each
C{RegexpChunkRule} defines the C{apply} method, which modifies
the chunking encoded by a C{ChunkString}.  The
L{RegexpChunkRule} class itself can be used to implement any
transformational rule based on regular expressions.  There are
also a number of subclasses, which can be used to implement
simpler types of rules:</p>
<blockquote>
<div><ul class="simple">
<li>L{ChunkRule} chunks anything that matches a given regular
expression.</li>
<li>L{ChinkRule} chinks anything that matches a given regular
expression.</li>
<li>L{UnChunkRule} will un-chunk any chunk that matches a given
regular expression.</li>
<li>L{MergeRule} can be used to merge two contiguous chunks.</li>
<li>L{SplitRule} can be used to split a single chunk into two
smaller chunks.</li>
<li>L{ExpandLeftRule} will expand a chunk to incorporate new
unchunked material on the left.</li>
<li>L{ExpandRightRule} will expand a chunk to incorporate new
unchunked material on the right.</li>
</ul>
</div></blockquote>
<div class="section" id="tag-patterns">
<h5>Tag Patterns<a class="headerlink" href="#tag-patterns" title="Permalink to this headline">¶</a></h5>
<p>C{RegexpChunkRule}s use a modified version of regular
expression patterns, called X{tag patterns}.  Tag patterns are
used to match sequences of tags.  Examples of tag patterns are:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="s">r&#39;(&lt;DT&gt;|&lt;JJ&gt;|&lt;NN&gt;)+&#39;</span>
<span class="s">r&#39;&lt;NN&gt;+&#39;</span>
<span class="s">r&#39;&lt;NN.*&gt;&#39;</span>
</pre></div>
</div>
<p>The differences between regular expression patterns and tag
patterns are:</p>
<blockquote>
<div><ul class="simple">
<li>In tag patterns, C{&#8216;&lt;&#8217;} and C{&#8216;&gt;&#8217;} act as parentheses; so
C{&#8216;&lt;NN&gt;+&#8217;} matches one or more repetitions of C{&#8216;&lt;NN&gt;&#8217;}, not
C{&#8216;&lt;NN&#8217;} followed by one or more repetitions of C{&#8216;&gt;&#8217;}.</li>
<li>Whitespace in tag patterns is ignored.  So
C{&#8216;&lt;DT&gt; | &lt;NN&gt;&#8217;} is equivalant to C{&#8216;&lt;DT&gt;|&lt;NN&gt;&#8217;}</li>
<li>In tag patterns, C{&#8216;.&#8217;} is equivalant to C{&#8216;[^{}&lt;&gt;]&#8217;}; so
C{&#8216;&lt;NN.*&gt;&#8217;} matches any single tag starting with C{&#8216;NN&#8217;}.</li>
</ul>
</div></blockquote>
<p>The function L{tag_pattern2re_pattern} can be used to transform
a tag pattern to an equivalent regular expression pattern.</p>
</div>
</div>
<div class="section" id="efficiency">
<h4>Efficiency<a class="headerlink" href="#efficiency" title="Permalink to this headline">¶</a></h4>
<p>Preliminary tests indicate that C{RegexpChunkParser} can chunk at a
rate of about 300 tokens/second, with a moderately complex rule set.</p>
<p>There may be problems if C{RegexpChunkParser} is used with more than
5,000 tokens at a time.  In particular, evaluation of some regular
expressions may cause the Python regular expression engine to
exceed its maximum recursion depth.  We have attempted to minimize
these problems, but it is impossible to avoid them completely.  We
therefore recommend that you apply the chunk parser to a single
sentence at a time.</p>
</div>
<div class="section" id="emacs-tip">
<h4>Emacs Tip<a class="headerlink" href="#emacs-tip" title="Permalink to this headline">¶</a></h4>
<p>If you evaluate the following elisp expression in emacs, it will
colorize C{ChunkString}s when you use an interactive python shell
with emacs or xemacs (&#8220;C-c !&#8221;):</p>
<div class="highlight-python"><pre>(let ()
  (defconst comint-mode-font-lock-keywords 
    '(("&lt;[^&gt;]+&gt;" 0 'font-lock-reference-face)
      ("[{}]" 0 'font-lock-function-name-face)))
  (add-hook 'comint-mode-hook (lambda () (turn-on-font-lock))))</pre>
</div>
<p>You can evaluate this code by copying it to a temporary buffer,
placing the cursor after the last close parenthesis, and typing
&#8220;C{C-x C-e}&#8221;.  You should evaluate it before running the interactive
session.  The change will last until you close emacs.</p>
</div>
<div class="section" id="unresolved-issues">
<h4>Unresolved Issues<a class="headerlink" href="#unresolved-issues" title="Permalink to this headline">¶</a></h4>
<p>If we use the C{re} module for regular expressions, Python&#8217;s
regular expression engine generates &#8220;maximum recursion depth
exceeded&#8221; errors when processing very large texts, even for
regular expressions that should not require any recursion.  We
therefore use the C{pre} module instead.  But note that C{pre}
does not include Unicode support, so this module will not work
with unicode strings.  Note also that C{pre} regular expressions
are not quite as advanced as C{re} ones (e.g., no leftward
zero-length assertions).</p>
<p>&#64;type CHUNK_TAG_PATTERN: C{regexp}
&#64;var CHUNK_TAG_PATTERN: A regular expression to test whether a tag</p>
<blockquote>
<div>pattern is valid.</div></blockquote>
<dl class="class">
<dt id="nltk.chunk.ChunkParserI">
<em class="property">class </em><tt class="descclassname">nltk.chunk.</tt><tt class="descname">ChunkParserI</tt><a class="headerlink" href="#nltk.chunk.ChunkParserI" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="nltk.parse.html#nltk.parse.api.ParserI" title="nltk.parse.api.ParserI"><tt class="xref py py-class docutils literal"><span class="pre">nltk.parse.api.ParserI</span></tt></a></p>
<p>A processing interface for identifying non-overlapping groups in
unrestricted text.  Typically, chunk parsers are used to find base
syntactic constituants, such as base noun phrases.  Unlike
L{ParserI}, C{ChunkParserI} guarantees that the C{parse} method
will always generate a parse.</p>
<dl class="method">
<dt id="nltk.chunk.ChunkParserI.evaluate">
<tt class="descname">evaluate</tt><big>(</big><em>gold</em><big>)</big><a class="headerlink" href="#nltk.chunk.ChunkParserI.evaluate" title="Permalink to this definition">¶</a></dt>
<dd><p>Score the accuracy of the chunker against the gold standard.
Remove the chunking the gold standard text, rechunk it using
the chunker, and return a L{ChunkScore&lt;nltk.chunk.util.ChunkScore&gt;}
object reflecting the performance of this chunk peraser.</p>
<p>&#64;type gold: C{list} of L{Tree}
&#64;param gold: The list of chunked sentences to score the chunker on.
&#64;rtype:  L{ChunkScore&lt;nltk.chunk.util.ChunkScore&gt;}</p>
</dd></dl>

<dl class="method">
<dt id="nltk.chunk.ChunkParserI.parse">
<tt class="descname">parse</tt><big>(</big><em>tokens</em><big>)</big><a class="headerlink" href="#nltk.chunk.ChunkParserI.parse" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;return: the best chunk structure for the given tokens
and return a tree.</p>
<p>&#64;param tokens: The list of (word, tag) tokens to be chunked.
&#64;type tokens: C{list} of L{tuple}
&#64;rtype: L{Tree}</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.chunk.RegexpChunkParser">
<em class="property">class </em><tt class="descclassname">nltk.chunk.</tt><tt class="descname">RegexpChunkParser</tt><big>(</big><em>rules</em>, <em>chunk_node='NP'</em>, <em>top_node='S'</em>, <em>trace=0</em><big>)</big><a class="headerlink" href="#nltk.chunk.RegexpChunkParser" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.chunk.api.ChunkParserI" title="nltk.chunk.api.ChunkParserI"><tt class="xref py py-class docutils literal"><span class="pre">nltk.chunk.api.ChunkParserI</span></tt></a></p>
<p>A regular expression based chunk parser.  C{RegexpChunkParser} uses a
sequence of X{rules} to find chunks of a single type within a
text.  The chunking of the text is encoded using a C{ChunkString},
and each rule acts by modifying the chunking in the
C{ChunkString}.  The rules are all implemented using regular
expression matching and substitution.</p>
<p>The C{RegexpChunkRule} class and its subclasses (C{ChunkRule},
C{ChinkRule}, C{UnChunkRule}, C{MergeRule}, and C{SplitRule})
define the rules that are used by C{RegexpChunkParser}.  Each rule
defines an C{apply} method, which modifies the chunking encoded
by a given C{ChunkString}.</p>
<p>&#64;type _rules: C{list} of C{RegexpChunkRule}
&#64;ivar _rules: The list of rules that should be applied to a text.
&#64;type _trace: C{int}
&#64;ivar _trace: The default level of tracing.</p>
<dl class="method">
<dt id="nltk.chunk.RegexpChunkParser.parse">
<tt class="descname">parse</tt><big>(</big><em>chunk_struct</em>, <em>trace=None</em><big>)</big><a class="headerlink" href="#nltk.chunk.RegexpChunkParser.parse" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;type chunk_struct: C{Tree}
&#64;param chunk_struct: the chunk structure to be (further) chunked
&#64;type trace: C{int}
&#64;param trace: The level of tracing that should be used when</p>
<blockquote>
<div>parsing a text.  C{0} will generate no tracing output;
C{1} will generate normal tracing output; and C{2} or
highter will generate verbose tracing output.  This value
overrides the trace level value that was given to the
constructor.</div></blockquote>
<p>&#64;rtype: C{Tree}
&#64;return: a chunk structure that encodes the chunks in a given</p>
<blockquote>
<div>tagged sentence.  A chunk is a non-overlapping linguistic
group, such as a noun phrase.  The set of chunks
identified in the chunk structure depends on the rules
used to define this C{RegexpChunkParser}.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="nltk.chunk.RegexpChunkParser.rules">
<tt class="descname">rules</tt><big>(</big><big>)</big><a class="headerlink" href="#nltk.chunk.RegexpChunkParser.rules" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;return: the sequence of rules used by C{RegexpChunkParser}.
&#64;rtype: C{list} of C{RegexpChunkRule}</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.chunk.RegexpParser">
<em class="property">class </em><tt class="descclassname">nltk.chunk.</tt><tt class="descname">RegexpParser</tt><big>(</big><em>grammar</em>, <em>top_node='S'</em>, <em>loop=1</em>, <em>trace=0</em><big>)</big><a class="headerlink" href="#nltk.chunk.RegexpParser" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.chunk.api.ChunkParserI" title="nltk.chunk.api.ChunkParserI"><tt class="xref py py-class docutils literal"><span class="pre">nltk.chunk.api.ChunkParserI</span></tt></a></p>
<p>A grammar based chunk parser.  C{chunk.RegexpParser} uses a set of
regular expression patterns to specify the behavior of the parser.
The chunking of the text is encoded using a C{ChunkString}, and
each rule acts by modifying the chunking in the C{ChunkString}.
The rules are all implemented using regular expression matching
and substitution.</p>
<p>A grammar contains one or more clauses in the following form:</p>
<div class="highlight-python"><pre>NP:
  {&lt;DT|JJ&gt;}          # chunk determiners and adjectives
  }&lt;[\.VI].*&gt;+{      # chink any tag beginning with V, I, or .
  &lt;.*&gt;}{&lt;DT&gt;         # split a chunk at a determiner
  &lt;DT|JJ&gt;{}&lt;NN.*&gt;    # merge chunk ending with det/adj
                     # with one starting with a noun</pre>
</div>
<p>The patterns of a clause are executed in order.  An earlier
pattern may introduce a chunk boundary that prevents a later
pattern from executing.  Sometimes an individual pattern will
match on multiple, overlapping extents of the input.  As with
regular expression substitution more generally, the chunker will
identify the first match possible, then continue looking for matches
after this one has ended.</p>
<p>The clauses of a grammar are also executed in order.  A cascaded
chunk parser is one having more than one clause.  The maximum depth
of a parse tree created by this chunk parser is the same as the
number of clauses in the grammar.</p>
<p>When tracing is turned on, the comment portion of a line is displayed
each time the corresponding pattern is applied.</p>
<p>&#64;type _start: C{string}
&#64;ivar _start: The start symbol of the grammar (the root node of</p>
<blockquote>
<div>resulting trees)</div></blockquote>
<p>&#64;type _stages: C{int}
&#64;ivar _stages: The list of parsing stages corresponding to the grammar</p>
<dl class="method">
<dt id="nltk.chunk.RegexpParser.parse">
<tt class="descname">parse</tt><big>(</big><em>chunk_struct</em>, <em>trace=None</em><big>)</big><a class="headerlink" href="#nltk.chunk.RegexpParser.parse" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply the chunk parser to this input.</p>
<p>&#64;type chunk_struct: C{Tree}
&#64;param chunk_struct: the chunk structure to be (further) chunked</p>
<blockquote>
<div>(this tree is modified, and is also returned)</div></blockquote>
<p>&#64;type trace: C{int}
&#64;param trace: The level of tracing that should be used when</p>
<blockquote>
<div>parsing a text.  C{0} will generate no tracing output;
C{1} will generate normal tracing output; and C{2} or
highter will generate verbose tracing output.  This value
overrides the trace level value that was given to the
constructor.</div></blockquote>
<p>&#64;return: the chunked output.
&#64;rtype: C{Tree}</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="nltk.chunk.ne_chunk">
<tt class="descclassname">nltk.chunk.</tt><tt class="descname">ne_chunk</tt><big>(</big><em>tagged_tokens</em>, <em>binary=False</em><big>)</big><a class="reference internal" href="../_modules/nltk/chunk.html#ne_chunk"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.ne_chunk" title="Permalink to this definition">¶</a></dt>
<dd><p>Use NLTK&#8217;s currently recommended named entity chunker to
chunk the given list of tagged tokens.</p>
</dd></dl>

<dl class="function">
<dt id="nltk.chunk.batch_ne_chunk">
<tt class="descclassname">nltk.chunk.</tt><tt class="descname">batch_ne_chunk</tt><big>(</big><em>tagged_sentences</em>, <em>binary=False</em><big>)</big><a class="reference internal" href="../_modules/nltk/chunk.html#batch_ne_chunk"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.batch_ne_chunk" title="Permalink to this definition">¶</a></dt>
<dd><p>Use NLTK&#8217;s currently recommended named entity chunker to chunk the
given list of tagged sentences, each consisting of a list of tagged tokens.</p>
</dd></dl>

</div>
</div>
</div>
<div class="section" id="module-nltk.chunk.api">
<span id="api-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">api</span></tt> Module<a class="headerlink" href="#module-nltk.chunk.api" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="nltk.chunk.api.ChunkParserI">
<em class="property">class </em><tt class="descclassname">nltk.chunk.api.</tt><tt class="descname">ChunkParserI</tt><a class="reference internal" href="../_modules/nltk/chunk/api.html#ChunkParserI"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.api.ChunkParserI" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="nltk.parse.html#nltk.parse.api.ParserI" title="nltk.parse.api.ParserI"><tt class="xref py py-class docutils literal"><span class="pre">nltk.parse.api.ParserI</span></tt></a></p>
<p>A processing interface for identifying non-overlapping groups in
unrestricted text.  Typically, chunk parsers are used to find base
syntactic constituants, such as base noun phrases.  Unlike
L{ParserI}, C{ChunkParserI} guarantees that the C{parse} method
will always generate a parse.</p>
<dl class="method">
<dt id="nltk.chunk.api.ChunkParserI.evaluate">
<tt class="descname">evaluate</tt><big>(</big><em>gold</em><big>)</big><a class="reference internal" href="../_modules/nltk/chunk/api.html#ChunkParserI.evaluate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.api.ChunkParserI.evaluate" title="Permalink to this definition">¶</a></dt>
<dd><p>Score the accuracy of the chunker against the gold standard.
Remove the chunking the gold standard text, rechunk it using
the chunker, and return a L{ChunkScore&lt;nltk.chunk.util.ChunkScore&gt;}
object reflecting the performance of this chunk peraser.</p>
<p>&#64;type gold: C{list} of L{Tree}
&#64;param gold: The list of chunked sentences to score the chunker on.
&#64;rtype:  L{ChunkScore&lt;nltk.chunk.util.ChunkScore&gt;}</p>
</dd></dl>

<dl class="method">
<dt id="nltk.chunk.api.ChunkParserI.parse">
<tt class="descname">parse</tt><big>(</big><em>tokens</em><big>)</big><a class="reference internal" href="../_modules/nltk/chunk/api.html#ChunkParserI.parse"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.api.ChunkParserI.parse" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;return: the best chunk structure for the given tokens
and return a tree.</p>
<p>&#64;param tokens: The list of (word, tag) tokens to be chunked.
&#64;type tokens: C{list} of L{tuple}
&#64;rtype: L{Tree}</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-nltk.chunk.named_entity">
<span id="named-entity-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">named_entity</span></tt> Module<a class="headerlink" href="#module-nltk.chunk.named_entity" title="Permalink to this headline">¶</a></h2>
<p>Named entity chunker</p>
<dl class="class">
<dt id="nltk.chunk.named_entity.NEChunkParser">
<em class="property">class </em><tt class="descclassname">nltk.chunk.named_entity.</tt><tt class="descname">NEChunkParser</tt><big>(</big><em>train</em><big>)</big><a class="reference internal" href="../_modules/nltk/chunk/named_entity.html#NEChunkParser"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.named_entity.NEChunkParser" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.chunk.api.ChunkParserI" title="nltk.chunk.api.ChunkParserI"><tt class="xref py py-class docutils literal"><span class="pre">nltk.chunk.api.ChunkParserI</span></tt></a></p>
<p>Expected input: list of pos-tagged words</p>
<dl class="method">
<dt id="nltk.chunk.named_entity.NEChunkParser.parse">
<tt class="descname">parse</tt><big>(</big><em>tokens</em><big>)</big><a class="reference internal" href="../_modules/nltk/chunk/named_entity.html#NEChunkParser.parse"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.named_entity.NEChunkParser.parse" title="Permalink to this definition">¶</a></dt>
<dd><p>Each token should be a pos-tagged word</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.chunk.named_entity.NEChunkParserTagger">
<em class="property">class </em><tt class="descclassname">nltk.chunk.named_entity.</tt><tt class="descname">NEChunkParserTagger</tt><big>(</big><em>train</em><big>)</big><a class="reference internal" href="../_modules/nltk/chunk/named_entity.html#NEChunkParserTagger"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.named_entity.NEChunkParserTagger" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="nltk.tag.html#nltk.tag.sequential.ClassifierBasedTagger" title="nltk.tag.sequential.ClassifierBasedTagger"><tt class="xref py py-class docutils literal"><span class="pre">nltk.tag.sequential.ClassifierBasedTagger</span></tt></a></p>
<p>The IOB tagger used by the chunk parser.</p>
</dd></dl>

<dl class="function">
<dt id="nltk.chunk.named_entity.build_model">
<tt class="descclassname">nltk.chunk.named_entity.</tt><tt class="descname">build_model</tt><big>(</big><em>fmt='binary'</em><big>)</big><a class="reference internal" href="../_modules/nltk/chunk/named_entity.html#build_model"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.named_entity.build_model" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="nltk.chunk.named_entity.cmp_chunks">
<tt class="descclassname">nltk.chunk.named_entity.</tt><tt class="descname">cmp_chunks</tt><big>(</big><em>correct</em>, <em>guessed</em><big>)</big><a class="reference internal" href="../_modules/nltk/chunk/named_entity.html#cmp_chunks"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.named_entity.cmp_chunks" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="nltk.chunk.named_entity.load_ace_data">
<tt class="descclassname">nltk.chunk.named_entity.</tt><tt class="descname">load_ace_data</tt><big>(</big><em>roots</em>, <em>fmt='binary'</em>, <em>skip_bnews=True</em><big>)</big><a class="reference internal" href="../_modules/nltk/chunk/named_entity.html#load_ace_data"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.named_entity.load_ace_data" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="nltk.chunk.named_entity.load_ace_file">
<tt class="descclassname">nltk.chunk.named_entity.</tt><tt class="descname">load_ace_file</tt><big>(</big><em>textfile</em>, <em>fmt</em><big>)</big><a class="reference internal" href="../_modules/nltk/chunk/named_entity.html#load_ace_file"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.named_entity.load_ace_file" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="nltk.chunk.named_entity.postag_tree">
<tt class="descclassname">nltk.chunk.named_entity.</tt><tt class="descname">postag_tree</tt><big>(</big><em>tree</em><big>)</big><a class="reference internal" href="../_modules/nltk/chunk/named_entity.html#postag_tree"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.named_entity.postag_tree" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="nltk.chunk.named_entity.shape">
<tt class="descclassname">nltk.chunk.named_entity.</tt><tt class="descname">shape</tt><big>(</big><em>word</em><big>)</big><a class="reference internal" href="../_modules/nltk/chunk/named_entity.html#shape"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.named_entity.shape" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="nltk.chunk.named_entity.simplify_pos">
<tt class="descclassname">nltk.chunk.named_entity.</tt><tt class="descname">simplify_pos</tt><big>(</big><em>s</em><big>)</big><a class="reference internal" href="../_modules/nltk/chunk/named_entity.html#simplify_pos"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.named_entity.simplify_pos" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-nltk.chunk.regexp">
<span id="regexp-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">regexp</span></tt> Module<a class="headerlink" href="#module-nltk.chunk.regexp" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="nltk.chunk.regexp.ChinkRule">
<em class="property">class </em><tt class="descclassname">nltk.chunk.regexp.</tt><tt class="descname">ChinkRule</tt><big>(</big><em>tag_pattern</em>, <em>descr</em><big>)</big><a class="reference internal" href="../_modules/nltk/chunk/regexp.html#ChinkRule"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.regexp.ChinkRule" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.chunk.regexp.RegexpChunkRule" title="nltk.chunk.regexp.RegexpChunkRule"><tt class="xref py py-class docutils literal"><span class="pre">nltk.chunk.regexp.RegexpChunkRule</span></tt></a></p>
<p>A rule specifying how to remove chinks to a C{ChunkString},
using a matching tag pattern.  When applied to a
C{ChunkString}, it will find any substring that matches this
tag pattern and that is contained in a chunk, and remove it
from that chunk, thus creating two new chunks.</p>
</dd></dl>

<dl class="class">
<dt id="nltk.chunk.regexp.ChunkRule">
<em class="property">class </em><tt class="descclassname">nltk.chunk.regexp.</tt><tt class="descname">ChunkRule</tt><big>(</big><em>tag_pattern</em>, <em>descr</em><big>)</big><a class="reference internal" href="../_modules/nltk/chunk/regexp.html#ChunkRule"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.regexp.ChunkRule" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.chunk.regexp.RegexpChunkRule" title="nltk.chunk.regexp.RegexpChunkRule"><tt class="xref py py-class docutils literal"><span class="pre">nltk.chunk.regexp.RegexpChunkRule</span></tt></a></p>
<p>A rule specifying how to add chunks to a C{ChunkString}, using a
matching tag pattern.  When applied to a C{ChunkString}, it will
find any substring that matches this tag pattern and that is not
already part of a chunk, and create a new chunk containing that
substring.</p>
</dd></dl>

<dl class="class">
<dt id="nltk.chunk.regexp.ChunkRuleWithContext">
<em class="property">class </em><tt class="descclassname">nltk.chunk.regexp.</tt><tt class="descname">ChunkRuleWithContext</tt><big>(</big><em>left_context_tag_pattern</em>, <em>chunk_tag_pattern</em>, <em>right_context_tag_pattern</em>, <em>descr</em><big>)</big><a class="reference internal" href="../_modules/nltk/chunk/regexp.html#ChunkRuleWithContext"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.regexp.ChunkRuleWithContext" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.chunk.regexp.RegexpChunkRule" title="nltk.chunk.regexp.RegexpChunkRule"><tt class="xref py py-class docutils literal"><span class="pre">nltk.chunk.regexp.RegexpChunkRule</span></tt></a></p>
<p>A rule specifying how to add chunks to a C{ChunkString}, using
three matching tag patterns: one for the left context, one for the
chunk, and one for the right context.  When applied to a
C{ChunkString}, it will find any substring that matches the chunk
tag pattern, is surrounded by substrings that match the two
context patterns, and is not already part of a chunk; and create a
new chunk containing the substring that matched the chunk tag
pattern.</p>
<p>Caveat: Both the left and right context are consumed when this
rule matches; therefore, if you need to find overlapping matches,
you will need to apply your rule more than once.</p>
</dd></dl>

<dl class="class">
<dt id="nltk.chunk.regexp.ChunkString">
<em class="property">class </em><tt class="descclassname">nltk.chunk.regexp.</tt><tt class="descname">ChunkString</tt><big>(</big><em>chunk_struct</em>, <em>debug_level=1</em><big>)</big><a class="reference internal" href="../_modules/nltk/chunk/regexp.html#ChunkString"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.regexp.ChunkString" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>A string-based encoding of a particular chunking of a text.
Internally, the C{ChunkString} class uses a single string to
encode the chunking of the input text.  This string contains a
sequence of angle-bracket delimited tags, with chunking indicated
by braces.  An example of this encoding is:</p>
<div class="highlight-python"><pre>{&lt;DT&gt;&lt;JJ&gt;&lt;NN&gt;}&lt;VBN&gt;&lt;IN&gt;{&lt;DT&gt;&lt;NN&gt;}&lt;.&gt;{&lt;DT&gt;&lt;NN&gt;}&lt;VBD&gt;&lt;.&gt;</pre>
</div>
<p>C{ChunkString} are created from tagged texts (i.e., C{list}s of
C{tokens} whose type is C{TaggedType}).  Initially, nothing is
chunked.</p>
<p>The chunking of a C{ChunkString} can be modified with the C{xform}
method, which uses a regular expression to transform the string
representation.  These transformations should only add and remove
braces; they should I{not} modify the sequence of angle-bracket
delimited tags.</p>
<p>&#64;type _str: C{string}
&#64;ivar _str: The internal string representation of the text&#8217;s</p>
<blockquote>
<div><p>encoding.  This string representation contains a sequence of
angle-bracket delimited tags, with chunking indicated by
braces.  An example of this encoding is:</p>
<div class="highlight-python"><pre>{&lt;DT&gt;&lt;JJ&gt;&lt;NN&gt;}&lt;VBN&gt;&lt;IN&gt;{&lt;DT&gt;&lt;NN&gt;}&lt;.&gt;{&lt;DT&gt;&lt;NN&gt;}&lt;VBD&gt;&lt;.&gt;</pre>
</div>
</div></blockquote>
<p>&#64;type _pieces: C{list} of pieces (tagged tokens and chunks)
&#64;ivar _pieces: The tagged tokens and chunks encoded by this C{ChunkString}.
&#64;ivar _debug: The debug level.  See the constructor docs.</p>
<dl class="docutils">
<dt>&#64;cvar IN_CHUNK_PATTERN: A zero-width regexp pattern string that</dt>
<dd>will only match positions that are in chunks.</dd>
<dt>&#64;cvar IN_CHINK_PATTERN: A zero-width regexp pattern string that</dt>
<dd>will only match positions that are in chinks.</dd>
</dl>
<dl class="attribute">
<dt id="nltk.chunk.regexp.ChunkString.CHUNK_TAG">
<tt class="descname">CHUNK_TAG</tt><em class="property"> = '(&lt;[^\\{\\}&lt;&gt;]+?&gt;)'</em><a class="headerlink" href="#nltk.chunk.regexp.ChunkString.CHUNK_TAG" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nltk.chunk.regexp.ChunkString.CHUNK_TAG_CHAR">
<tt class="descname">CHUNK_TAG_CHAR</tt><em class="property"> = '[^\\{\\}&lt;&gt;]'</em><a class="headerlink" href="#nltk.chunk.regexp.ChunkString.CHUNK_TAG_CHAR" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nltk.chunk.regexp.ChunkString.IN_CHINK_PATTERN">
<tt class="descname">IN_CHINK_PATTERN</tt><em class="property"> = '(?=[^\\}]*(\\{|$))'</em><a class="headerlink" href="#nltk.chunk.regexp.ChunkString.IN_CHINK_PATTERN" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nltk.chunk.regexp.ChunkString.IN_CHUNK_PATTERN">
<tt class="descname">IN_CHUNK_PATTERN</tt><em class="property"> = '(?=[^\\{]*\\})'</em><a class="headerlink" href="#nltk.chunk.regexp.ChunkString.IN_CHUNK_PATTERN" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nltk.chunk.regexp.ChunkString.to_chunkstruct">
<tt class="descname">to_chunkstruct</tt><big>(</big><em>chunk_node='CHUNK'</em><big>)</big><a class="reference internal" href="../_modules/nltk/chunk/regexp.html#ChunkString.to_chunkstruct"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.regexp.ChunkString.to_chunkstruct" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;return: the chunk structure encoded by this C{ChunkString}.
&#64;rtype: C{Tree}
&#64;raise ValueError: If a transformation has generated an</p>
<blockquote>
<div>invalid chunkstring.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="nltk.chunk.regexp.ChunkString.xform">
<tt class="descname">xform</tt><big>(</big><em>regexp</em>, <em>repl</em><big>)</big><a class="reference internal" href="../_modules/nltk/chunk/regexp.html#ChunkString.xform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.regexp.ChunkString.xform" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply the given transformation to this C{ChunkString}&#8217;s string
encoding.  In particular, find all occurrences that match
C{regexp}, and replace them using C{repl} (as done by
C{re.sub}).</p>
<p>This transformation should only add and remove braces; it
should I{not} modify the sequence of angle-bracket delimited
tags.  Furthermore, this transformation may not result in
improper bracketing.  Note, in particular, that bracketing may
not be nested.</p>
<p>&#64;type regexp: C{string} or C{regexp}
&#64;param regexp: A regular expression matching the substring</p>
<blockquote>
<div>that should be replaced.  This will typically include a
named group, which can be used by C{repl}.</div></blockquote>
<p>&#64;type repl: C{string}
&#64;param repl: An expression specifying what should replace the</p>
<blockquote>
<div>matched substring.  Typically, this will include a named
replacement group, specified by C{regexp}.</div></blockquote>
<p>&#64;rtype: C{None}
&#64;raise ValueError: If this transformation generated an</p>
<blockquote>
<div>invalid chunkstring.</div></blockquote>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.chunk.regexp.ExpandLeftRule">
<em class="property">class </em><tt class="descclassname">nltk.chunk.regexp.</tt><tt class="descname">ExpandLeftRule</tt><big>(</big><em>left_tag_pattern</em>, <em>right_tag_pattern</em>, <em>descr</em><big>)</big><a class="reference internal" href="../_modules/nltk/chunk/regexp.html#ExpandLeftRule"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.regexp.ExpandLeftRule" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.chunk.regexp.RegexpChunkRule" title="nltk.chunk.regexp.RegexpChunkRule"><tt class="xref py py-class docutils literal"><span class="pre">nltk.chunk.regexp.RegexpChunkRule</span></tt></a></p>
<p>A rule specifying how to expand chunks in a C{ChunkString} to the left,
using two matching tag patterns: a left pattern, and a right pattern.
When applied to a C{ChunkString}, it will find any chunk whose beginning
matches right pattern, and immediately preceded by a chink whose
end matches left pattern.  It will then expand the chunk to incorporate
the new material on the left.</p>
</dd></dl>

<dl class="class">
<dt id="nltk.chunk.regexp.ExpandRightRule">
<em class="property">class </em><tt class="descclassname">nltk.chunk.regexp.</tt><tt class="descname">ExpandRightRule</tt><big>(</big><em>left_tag_pattern</em>, <em>right_tag_pattern</em>, <em>descr</em><big>)</big><a class="reference internal" href="../_modules/nltk/chunk/regexp.html#ExpandRightRule"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.regexp.ExpandRightRule" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.chunk.regexp.RegexpChunkRule" title="nltk.chunk.regexp.RegexpChunkRule"><tt class="xref py py-class docutils literal"><span class="pre">nltk.chunk.regexp.RegexpChunkRule</span></tt></a></p>
<p>A rule specifying how to expand chunks in a C{ChunkString} to the
right, using two matching tag patterns: a left pattern, and a
right pattern.  When applied to a C{ChunkString}, it will find any
chunk whose end matches left pattern, and immediately followed by
a chink whose beginning matches right pattern.  It will then
expand the chunk to incorporate the new material on the right.</p>
</dd></dl>

<dl class="class">
<dt id="nltk.chunk.regexp.MergeRule">
<em class="property">class </em><tt class="descclassname">nltk.chunk.regexp.</tt><tt class="descname">MergeRule</tt><big>(</big><em>left_tag_pattern</em>, <em>right_tag_pattern</em>, <em>descr</em><big>)</big><a class="reference internal" href="../_modules/nltk/chunk/regexp.html#MergeRule"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.regexp.MergeRule" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.chunk.regexp.RegexpChunkRule" title="nltk.chunk.regexp.RegexpChunkRule"><tt class="xref py py-class docutils literal"><span class="pre">nltk.chunk.regexp.RegexpChunkRule</span></tt></a></p>
<p>A rule specifying how to merge chunks in a C{ChunkString}, using
two matching tag patterns: a left pattern, and a right pattern.
When applied to a C{ChunkString}, it will find any chunk whose end
matches left pattern, and immediately followed by a chunk whose
beginning matches right pattern.  It will then merge those two
chunks into a single chunk.</p>
</dd></dl>

<dl class="class">
<dt id="nltk.chunk.regexp.RegexpChunkParser">
<em class="property">class </em><tt class="descclassname">nltk.chunk.regexp.</tt><tt class="descname">RegexpChunkParser</tt><big>(</big><em>rules</em>, <em>chunk_node='NP'</em>, <em>top_node='S'</em>, <em>trace=0</em><big>)</big><a class="reference internal" href="../_modules/nltk/chunk/regexp.html#RegexpChunkParser"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.regexp.RegexpChunkParser" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.chunk.api.ChunkParserI" title="nltk.chunk.api.ChunkParserI"><tt class="xref py py-class docutils literal"><span class="pre">nltk.chunk.api.ChunkParserI</span></tt></a></p>
<p>A regular expression based chunk parser.  C{RegexpChunkParser} uses a
sequence of X{rules} to find chunks of a single type within a
text.  The chunking of the text is encoded using a C{ChunkString},
and each rule acts by modifying the chunking in the
C{ChunkString}.  The rules are all implemented using regular
expression matching and substitution.</p>
<p>The C{RegexpChunkRule} class and its subclasses (C{ChunkRule},
C{ChinkRule}, C{UnChunkRule}, C{MergeRule}, and C{SplitRule})
define the rules that are used by C{RegexpChunkParser}.  Each rule
defines an C{apply} method, which modifies the chunking encoded
by a given C{ChunkString}.</p>
<p>&#64;type _rules: C{list} of C{RegexpChunkRule}
&#64;ivar _rules: The list of rules that should be applied to a text.
&#64;type _trace: C{int}
&#64;ivar _trace: The default level of tracing.</p>
<dl class="method">
<dt id="nltk.chunk.regexp.RegexpChunkParser.parse">
<tt class="descname">parse</tt><big>(</big><em>chunk_struct</em>, <em>trace=None</em><big>)</big><a class="reference internal" href="../_modules/nltk/chunk/regexp.html#RegexpChunkParser.parse"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.regexp.RegexpChunkParser.parse" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;type chunk_struct: C{Tree}
&#64;param chunk_struct: the chunk structure to be (further) chunked
&#64;type trace: C{int}
&#64;param trace: The level of tracing that should be used when</p>
<blockquote>
<div>parsing a text.  C{0} will generate no tracing output;
C{1} will generate normal tracing output; and C{2} or
highter will generate verbose tracing output.  This value
overrides the trace level value that was given to the
constructor.</div></blockquote>
<p>&#64;rtype: C{Tree}
&#64;return: a chunk structure that encodes the chunks in a given</p>
<blockquote>
<div>tagged sentence.  A chunk is a non-overlapping linguistic
group, such as a noun phrase.  The set of chunks
identified in the chunk structure depends on the rules
used to define this C{RegexpChunkParser}.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="nltk.chunk.regexp.RegexpChunkParser.rules">
<tt class="descname">rules</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/chunk/regexp.html#RegexpChunkParser.rules"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.regexp.RegexpChunkParser.rules" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;return: the sequence of rules used by C{RegexpChunkParser}.
&#64;rtype: C{list} of C{RegexpChunkRule}</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.chunk.regexp.RegexpChunkRule">
<em class="property">class </em><tt class="descclassname">nltk.chunk.regexp.</tt><tt class="descname">RegexpChunkRule</tt><big>(</big><em>regexp</em>, <em>repl</em>, <em>descr</em><big>)</big><a class="reference internal" href="../_modules/nltk/chunk/regexp.html#RegexpChunkRule"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.regexp.RegexpChunkRule" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>A rule specifying how to modify the chunking in a C{ChunkString},
using a transformational regular expression.  The
C{RegexpChunkRule} class itself can be used to implement any
transformational rule based on regular expressions.  There are
also a number of subclasses, which can be used to implement
simpler types of rules, based on matching regular expressions.</p>
<p>Each C{RegexpChunkRule} has a regular expression and a
replacement expression.  When a C{RegexpChunkRule} is X{applied}
to a C{ChunkString}, it searches the C{ChunkString} for any
substring that matches the regular expression, and replaces it
using the replacement expression.  This search/replace operation
has the same semantics as C{re.sub}.</p>
<p>Each C{RegexpChunkRule} also has a description string, which
gives a short (typically less than 75 characters) description of
the purpose of the rule.</p>
<p>This transformation defined by this C{RegexpChunkRule} should
only add and remove braces; it should I{not} modify the sequence
of angle-bracket delimited tags.  Furthermore, this transformation
may not result in nested or mismatched bracketing.</p>
<dl class="method">
<dt id="nltk.chunk.regexp.RegexpChunkRule.apply">
<tt class="descname">apply</tt><big>(</big><em>chunkstr</em><big>)</big><a class="reference internal" href="../_modules/nltk/chunk/regexp.html#RegexpChunkRule.apply"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.regexp.RegexpChunkRule.apply" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply this rule to the given C{ChunkString}.  See the
class reference documentation for a description of what it
means to apply a rule.</p>
<p>&#64;type chunkstr: C{ChunkString}
&#64;param chunkstr: The chunkstring to which this rule is</p>
<blockquote>
<div>applied.</div></blockquote>
<p>&#64;rtype: C{None}
&#64;raise ValueError: If this transformation generated an</p>
<blockquote>
<div>invalid chunkstring.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="nltk.chunk.regexp.RegexpChunkRule.descr">
<tt class="descname">descr</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/chunk/regexp.html#RegexpChunkRule.descr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.regexp.RegexpChunkRule.descr" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;rtype: C{string}
&#64;return: a short description of the purpose and/or effect of</p>
<blockquote>
<div>this rule.</div></blockquote>
</dd></dl>

<dl class="staticmethod">
<dt id="nltk.chunk.regexp.RegexpChunkRule.parse">
<em class="property">static </em><tt class="descname">parse</tt><big>(</big><em>s</em><big>)</big><a class="reference internal" href="../_modules/nltk/chunk/regexp.html#RegexpChunkRule.parse"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.regexp.RegexpChunkRule.parse" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a RegexpChunkRule from a string description.
Currently, the following formats are supported:</p>
<div class="highlight-python"><pre>{regexp}         # chunk rule
}regexp{         # chink rule
regexp}{regexp   # split rule
regexp{}regexp   # merge rule</pre>
</div>
<p>Where C{regexp} is a regular expression for the rule.  Any
text following the comment marker (C{#}) will be used as
the rule&#8217;s description:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">RegexpChunkRule</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s">&#39;{&lt;DT&gt;?&lt;NN.*&gt;+}&#39;</span><span class="p">)</span>
<span class="go">&lt;ChunkRule: &#39;&lt;DT&gt;?&lt;NN.*&gt;+&#39;&gt;</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.chunk.regexp.RegexpParser">
<em class="property">class </em><tt class="descclassname">nltk.chunk.regexp.</tt><tt class="descname">RegexpParser</tt><big>(</big><em>grammar</em>, <em>top_node='S'</em>, <em>loop=1</em>, <em>trace=0</em><big>)</big><a class="reference internal" href="../_modules/nltk/chunk/regexp.html#RegexpParser"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.regexp.RegexpParser" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.chunk.api.ChunkParserI" title="nltk.chunk.api.ChunkParserI"><tt class="xref py py-class docutils literal"><span class="pre">nltk.chunk.api.ChunkParserI</span></tt></a></p>
<p>A grammar based chunk parser.  C{chunk.RegexpParser} uses a set of
regular expression patterns to specify the behavior of the parser.
The chunking of the text is encoded using a C{ChunkString}, and
each rule acts by modifying the chunking in the C{ChunkString}.
The rules are all implemented using regular expression matching
and substitution.</p>
<p>A grammar contains one or more clauses in the following form:</p>
<div class="highlight-python"><pre>NP:
  {&lt;DT|JJ&gt;}          # chunk determiners and adjectives
  }&lt;[\.VI].*&gt;+{      # chink any tag beginning with V, I, or .
  &lt;.*&gt;}{&lt;DT&gt;         # split a chunk at a determiner
  &lt;DT|JJ&gt;{}&lt;NN.*&gt;    # merge chunk ending with det/adj
                     # with one starting with a noun</pre>
</div>
<p>The patterns of a clause are executed in order.  An earlier
pattern may introduce a chunk boundary that prevents a later
pattern from executing.  Sometimes an individual pattern will
match on multiple, overlapping extents of the input.  As with
regular expression substitution more generally, the chunker will
identify the first match possible, then continue looking for matches
after this one has ended.</p>
<p>The clauses of a grammar are also executed in order.  A cascaded
chunk parser is one having more than one clause.  The maximum depth
of a parse tree created by this chunk parser is the same as the
number of clauses in the grammar.</p>
<p>When tracing is turned on, the comment portion of a line is displayed
each time the corresponding pattern is applied.</p>
<p>&#64;type _start: C{string}
&#64;ivar _start: The start symbol of the grammar (the root node of</p>
<blockquote>
<div>resulting trees)</div></blockquote>
<p>&#64;type _stages: C{int}
&#64;ivar _stages: The list of parsing stages corresponding to the grammar</p>
<dl class="method">
<dt id="nltk.chunk.regexp.RegexpParser.parse">
<tt class="descname">parse</tt><big>(</big><em>chunk_struct</em>, <em>trace=None</em><big>)</big><a class="reference internal" href="../_modules/nltk/chunk/regexp.html#RegexpParser.parse"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.regexp.RegexpParser.parse" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply the chunk parser to this input.</p>
<p>&#64;type chunk_struct: C{Tree}
&#64;param chunk_struct: the chunk structure to be (further) chunked</p>
<blockquote>
<div>(this tree is modified, and is also returned)</div></blockquote>
<p>&#64;type trace: C{int}
&#64;param trace: The level of tracing that should be used when</p>
<blockquote>
<div>parsing a text.  C{0} will generate no tracing output;
C{1} will generate normal tracing output; and C{2} or
highter will generate verbose tracing output.  This value
overrides the trace level value that was given to the
constructor.</div></blockquote>
<p>&#64;return: the chunked output.
&#64;rtype: C{Tree}</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.chunk.regexp.SplitRule">
<em class="property">class </em><tt class="descclassname">nltk.chunk.regexp.</tt><tt class="descname">SplitRule</tt><big>(</big><em>left_tag_pattern</em>, <em>right_tag_pattern</em>, <em>descr</em><big>)</big><a class="reference internal" href="../_modules/nltk/chunk/regexp.html#SplitRule"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.regexp.SplitRule" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.chunk.regexp.RegexpChunkRule" title="nltk.chunk.regexp.RegexpChunkRule"><tt class="xref py py-class docutils literal"><span class="pre">nltk.chunk.regexp.RegexpChunkRule</span></tt></a></p>
<p>A rule specifying how to split chunks in a C{ChunkString}, using
two matching tag patterns: a left pattern, and a right pattern.
When applied to a C{ChunkString}, it will find any chunk that
matches the left pattern followed by the right pattern.  It will
then split the chunk into two new chunks, at the point between the
two pattern matches.</p>
</dd></dl>

<dl class="class">
<dt id="nltk.chunk.regexp.UnChunkRule">
<em class="property">class </em><tt class="descclassname">nltk.chunk.regexp.</tt><tt class="descname">UnChunkRule</tt><big>(</big><em>tag_pattern</em>, <em>descr</em><big>)</big><a class="reference internal" href="../_modules/nltk/chunk/regexp.html#UnChunkRule"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.regexp.UnChunkRule" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.chunk.regexp.RegexpChunkRule" title="nltk.chunk.regexp.RegexpChunkRule"><tt class="xref py py-class docutils literal"><span class="pre">nltk.chunk.regexp.RegexpChunkRule</span></tt></a></p>
<p>A rule specifying how to remove chunks to a C{ChunkString},
using a matching tag pattern.  When applied to a
C{ChunkString}, it will find any complete chunk that matches this
tag pattern, and un-chunk it.</p>
</dd></dl>

<dl class="function">
<dt id="nltk.chunk.regexp.demo">
<tt class="descclassname">nltk.chunk.regexp.</tt><tt class="descname">demo</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/chunk/regexp.html#demo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.regexp.demo" title="Permalink to this definition">¶</a></dt>
<dd><p>A demonstration for the C{RegexpChunkParser} class.  A single text is
parsed with four different chunk parsers, using a variety of rules
and strategies.</p>
</dd></dl>

<dl class="function">
<dt id="nltk.chunk.regexp.demo_eval">
<tt class="descclassname">nltk.chunk.regexp.</tt><tt class="descname">demo_eval</tt><big>(</big><em>chunkparser</em>, <em>text</em><big>)</big><a class="reference internal" href="../_modules/nltk/chunk/regexp.html#demo_eval"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.regexp.demo_eval" title="Permalink to this definition">¶</a></dt>
<dd><p>Demonstration code for evaluating a chunk parser, using a
C{ChunkScore}.  This function assumes that C{text} contains one
sentence per line, and that each sentence has the form expected by
C{tree.chunk}.  It runs the given chunk parser on each sentence in
the text, and scores the result.  It prints the final score
(precision, recall, and f-measure); and reports the set of chunks
that were missed and the set of chunks that were incorrect.  (At
most 10 missing chunks and 10 incorrect chunks are reported).</p>
<p>&#64;param chunkparser: The chunkparser to be tested
&#64;type chunkparser: C{ChunkParserI}
&#64;param text: The chunked tagged text that should be used for</p>
<blockquote>
<div>evaluation.</div></blockquote>
<p>&#64;type text: C{string}</p>
</dd></dl>

<dl class="function">
<dt id="nltk.chunk.regexp.tag_pattern2re_pattern">
<tt class="descclassname">nltk.chunk.regexp.</tt><tt class="descname">tag_pattern2re_pattern</tt><big>(</big><em>tag_pattern</em><big>)</big><a class="reference internal" href="../_modules/nltk/chunk/regexp.html#tag_pattern2re_pattern"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.regexp.tag_pattern2re_pattern" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a tag pattern to a regular expression pattern.  A X{tag
pattern} is a modified version of a regular expression, designed
for matching sequences of tags.  The differences between regular
expression patterns and tag patterns are:</p>
<blockquote>
<div><ul class="simple">
<li>In tag patterns, C{&#8216;&lt;&#8217;} and C{&#8216;&gt;&#8217;} act as parentheses; so 
C{&#8216;&lt;NN&gt;+&#8217;} matches one or more repetitions of C{&#8216;&lt;NN&gt;&#8217;}, not
C{&#8216;&lt;NN&#8217;} followed by one or more repetitions of C{&#8216;&gt;&#8217;}.</li>
<li>Whitespace in tag patterns is ignored.  So
C{&#8216;&lt;DT&gt; | &lt;NN&gt;&#8217;} is equivalant to C{&#8216;&lt;DT&gt;|&lt;NN&gt;&#8217;}</li>
<li>In tag patterns, C{&#8216;.&#8217;} is equivalant to C{&#8216;[^{}&lt;&gt;]&#8217;}; so
C{&#8216;&lt;NN.*&gt;&#8217;} matches any single tag starting with C{&#8216;NN&#8217;}.</li>
</ul>
</div></blockquote>
<p>In particular, C{tag_pattern2re_pattern} performs the following
transformations on the given pattern:</p>
<blockquote>
<div><ul class="simple">
<li>Replace &#8216;.&#8217; with &#8216;[^&lt;&gt;{}]&#8217;</li>
<li>Remove any whitespace</li>
<li>Add extra parens around &#8216;&lt;&#8217; and &#8216;&gt;&#8217;, to make &#8216;&lt;&#8217; and &#8216;&gt;&#8217; act
like parentheses.  E.g., so that in &#8216;&lt;NN&gt;+&#8217;, the &#8216;+&#8217; has scope
over the entire &#8216;&lt;NN&gt;&#8217;; and so that in &#8216;&lt;NN|IN&gt;&#8217;, the &#8216;|&#8217; has
scope over &#8216;NN&#8217; and &#8216;IN&#8217;, but not &#8216;&lt;&#8217; or &#8216;&gt;&#8217;.</li>
<li>Check to make sure the resulting pattern is valid.</li>
</ul>
</div></blockquote>
<p>&#64;type tag_pattern: C{string}
&#64;param tag_pattern: The tag pattern to convert to a regular</p>
<blockquote>
<div>expression pattern.</div></blockquote>
<dl class="docutils">
<dt>&#64;raise ValueError: If C{tag_pattern} is not a valid tag pattern.</dt>
<dd>In particular, C{tag_pattern} should not include braces; and it
should not contain nested or mismatched angle-brackets.</dd>
</dl>
<p>&#64;rtype: C{string}
&#64;return: A regular expression pattern corresponding to</p>
<blockquote>
<div>C{tag_pattern}.</div></blockquote>
</dd></dl>

</div>
<div class="section" id="module-nltk.chunk.util">
<span id="util-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">util</span></tt> Module<a class="headerlink" href="#module-nltk.chunk.util" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="nltk.chunk.util.ChunkScore">
<em class="property">class </em><tt class="descclassname">nltk.chunk.util.</tt><tt class="descname">ChunkScore</tt><big>(</big><em>**kwargs</em><big>)</big><a class="reference internal" href="../_modules/nltk/chunk/util.html#ChunkScore"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.util.ChunkScore" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>A utility class for scoring chunk parsers.  C{ChunkScore} can
evaluate a chunk parser&#8217;s output, based on a number of statistics
(precision, recall, f-measure, misssed chunks, incorrect chunks).
It can also combine the scores from the parsing of multiple texts;
this makes it signifigantly easier to evaluate a chunk parser that
operates one sentence at a time.</p>
<p>Texts are evaluated with the C{score} method.  The results of
evaluation can be accessed via a number of accessor methods, such
as C{precision} and C{f_measure}.  A typical use of the
C{ChunkScore} class is:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">chunkscore</span> <span class="o">=</span> <span class="n">ChunkScore</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">correct</span> <span class="ow">in</span> <span class="n">correct_sentences</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">guess</span> <span class="o">=</span> <span class="n">chunkparser</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">correct</span><span class="o">.</span><span class="n">leaves</span><span class="p">())</span>
<span class="gp">... </span>    <span class="n">chunkscore</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="n">correct</span><span class="p">,</span> <span class="n">guess</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="s">&#39;F Measure:&#39;</span><span class="p">,</span> <span class="n">chunkscore</span><span class="o">.</span><span class="n">f_measure</span><span class="p">()</span>
<span class="go">F Measure: 0.823</span>
</pre></div>
</div>
<p>&#64;ivar kwargs: Keyword arguments:</p>
<blockquote>
<div><ul class="simple">
<li>max_tp_examples: The maximum number actual examples of true
positives to record.  This affects the C{correct} member
function: C{correct} will not return more than this number
of true positive examples.  This does <em>not</em> affect any of
the numerical metrics (precision, recall, or f-measure)</li>
<li>max_fp_examples: The maximum number actual examples of false
positives to record.  This affects the C{incorrect} member
function and the C{guessed} member function: C{incorrect}
will not return more than this number of examples, and
C{guessed} will not return more than this number of true
positive examples.  This does <em>not</em> affect any of the
numerical metrics (precision, recall, or f-measure)</li>
<li>max_fn_examples: The maximum number actual examples of false
negatives to record.  This affects the C{missed} member
function and the C{correct} member function: C{missed}
will not return more than this number of examples, and
C{correct} will not return more than this number of true
negative examples.  This does <em>not</em> affect any of the
numerical metrics (precision, recall, or f-measure)</li>
<li>chunk_node: A regular expression indicating which chunks
should be compared.  Defaults to C{&#8216;.*&#8217;} (i.e., all chunks).</li>
</ul>
</div></blockquote>
<p>&#64;type _tp: C{list} of C{Token}
&#64;ivar _tp: List of true positives
&#64;type _fp: C{list} of C{Token}
&#64;ivar _fp: List of false positives
&#64;type _fn: C{list} of C{Token}
&#64;ivar _fn: List of false negatives</p>
<p>&#64;type _tp_num: C{int}
&#64;ivar _tp_num: Number of true positives
&#64;type _fp_num: C{int}
&#64;ivar _fp_num: Number of false positives
&#64;type _fn_num: C{int}
&#64;ivar _fn_num: Number of false negatives.</p>
<dl class="method">
<dt id="nltk.chunk.util.ChunkScore.accuracy">
<tt class="descname">accuracy</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/chunk/util.html#ChunkScore.accuracy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.util.ChunkScore.accuracy" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;return: The overall tag-based accuracy for all text that have
been scored by this C{ChunkScore}, using the IOB (conll2000)
tag encoding.</p>
</dd></dl>

<dl class="method">
<dt id="nltk.chunk.util.ChunkScore.correct">
<tt class="descname">correct</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/chunk/util.html#ChunkScore.correct"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.util.ChunkScore.correct" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;rtype: C{list} of chunks
&#64;return: the chunks which were included in the correct</p>
<blockquote>
<div>chunk structures, listed in input order.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="nltk.chunk.util.ChunkScore.f_measure">
<tt class="descname">f_measure</tt><big>(</big><em>alpha=0.5</em><big>)</big><a class="reference internal" href="../_modules/nltk/chunk/util.html#ChunkScore.f_measure"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.util.ChunkScore.f_measure" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>&#64;return: the overall F measure for all texts that have been</dt>
<dd>scored by this C{ChunkScore}.</dd>
</dl>
<p>&#64;rtype: C{float}</p>
<dl class="docutils">
<dt>&#64;param alpha: the relative weighting of precision and recall.</dt>
<dd>Larger alpha biases the score towards the precision value,
while smaller alpha biases the score towards the recall
value.  C{alpha} should have a value in the range [0,1].</dd>
</dl>
<p>&#64;type alpha: C{float}</p>
</dd></dl>

<dl class="method">
<dt id="nltk.chunk.util.ChunkScore.guessed">
<tt class="descname">guessed</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/chunk/util.html#ChunkScore.guessed"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.util.ChunkScore.guessed" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;rtype: C{list} of chunks
&#64;return: the chunks which were included in the guessed</p>
<blockquote>
<div>chunk structures, listed in input order.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="nltk.chunk.util.ChunkScore.incorrect">
<tt class="descname">incorrect</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/chunk/util.html#ChunkScore.incorrect"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.util.ChunkScore.incorrect" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;rtype: C{list} of chunks
&#64;return: the chunks which were included in the</p>
<blockquote>
<div>guessed chunk structures, but not in the correct chunk
structures, listed in input order.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="nltk.chunk.util.ChunkScore.missed">
<tt class="descname">missed</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/chunk/util.html#ChunkScore.missed"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.util.ChunkScore.missed" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;rtype: C{list} of chunks
&#64;return: the chunks which were included in the</p>
<blockquote>
<div>correct chunk structures, but not in the guessed chunk
structures, listed in input order.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="nltk.chunk.util.ChunkScore.precision">
<tt class="descname">precision</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/chunk/util.html#ChunkScore.precision"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.util.ChunkScore.precision" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>&#64;return: the overall precision for all texts that have been</dt>
<dd>scored by this C{ChunkScore}.</dd>
</dl>
<p>&#64;rtype: C{float}</p>
</dd></dl>

<dl class="method">
<dt id="nltk.chunk.util.ChunkScore.recall">
<tt class="descname">recall</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/chunk/util.html#ChunkScore.recall"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.util.ChunkScore.recall" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>&#64;return: the overall recall for all texts that have been</dt>
<dd>scored by this C{ChunkScore}.</dd>
</dl>
<p>&#64;rtype: C{float}</p>
</dd></dl>

<dl class="method">
<dt id="nltk.chunk.util.ChunkScore.score">
<tt class="descname">score</tt><big>(</big><em>correct</em>, <em>guessed</em><big>)</big><a class="reference internal" href="../_modules/nltk/chunk/util.html#ChunkScore.score"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.util.ChunkScore.score" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a correctly chunked sentence, score another chunked
version of the same sentence.</p>
<p>&#64;type correct: chunk structure
&#64;param correct: The known-correct (&#8220;gold standard&#8221;) chunked</p>
<blockquote>
<div>sentence.</div></blockquote>
<p>&#64;type guessed: chunk structure
&#64;param guessed: The chunked sentence to be scored.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="nltk.chunk.util.accuracy">
<tt class="descclassname">nltk.chunk.util.</tt><tt class="descname">accuracy</tt><big>(</big><em>chunker</em>, <em>gold</em><big>)</big><a class="reference internal" href="../_modules/nltk/chunk/util.html#accuracy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.util.accuracy" title="Permalink to this definition">¶</a></dt>
<dd><p>Score the accuracy of the chunker against the gold standard.
Strip the chunk information from the gold standard and rechunk it using
the chunker, then compute the accuracy score.</p>
<p>&#64;type chunker: C{ChunkParserI}
&#64;param chunker: The chunker being evaluated.
&#64;type gold: C{tree}
&#64;param gold: The chunk structures to score the chunker on.
&#64;rtype: C{float}</p>
</dd></dl>

<dl class="function">
<dt id="nltk.chunk.util.conllstr2tree">
<tt class="descclassname">nltk.chunk.util.</tt><tt class="descname">conllstr2tree</tt><big>(</big><em>s</em>, <em>chunk_types=('NP'</em>, <em>'PP'</em>, <em>'VP')</em>, <em>top_node='S'</em><big>)</big><a class="reference internal" href="../_modules/nltk/chunk/util.html#conllstr2tree"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.util.conllstr2tree" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a CoNLL IOB string into a tree.  Uses the specified chunk types
(defaults to NP, PP and VP), and creates a tree rooted at a node
labeled S (by default).</p>
<p>&#64;param s: The CoNLL string to be converted.
&#64;type s: C{string}
&#64;param chunk_types: The chunk types to be converted.
&#64;type chunk_types: C{tuple}
&#64;param top_node: The node label to use for the root.
&#64;type top_node: C{string}
&#64;return: A chunk structure for a single sentence</p>
<blockquote>
<div>encoded in the given CONLL 2000 style string.</div></blockquote>
<p>&#64;rtype: L{Tree}</p>
</dd></dl>

<dl class="function">
<dt id="nltk.chunk.util.conlltags2tree">
<tt class="descclassname">nltk.chunk.util.</tt><tt class="descname">conlltags2tree</tt><big>(</big><em>sentence</em>, <em>chunk_types=('NP'</em>, <em>'PP'</em>, <em>'VP')</em>, <em>top_node='S'</em>, <em>strict=False</em><big>)</big><a class="reference internal" href="../_modules/nltk/chunk/util.html#conlltags2tree"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.util.conlltags2tree" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the CoNLL IOB format to a tree.</p>
</dd></dl>

<dl class="function">
<dt id="nltk.chunk.util.demo">
<tt class="descclassname">nltk.chunk.util.</tt><tt class="descname">demo</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/chunk/util.html#demo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.util.demo" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="nltk.chunk.util.ieerstr2tree">
<tt class="descclassname">nltk.chunk.util.</tt><tt class="descname">ieerstr2tree</tt><big>(</big><em>s, chunk_types=['LOCATION', 'ORGANIZATION', 'PERSON', 'DURATION', 'DATE', 'CARDINAL', 'PERCENT', 'MONEY', 'MEASURE'], top_node='S'</em><big>)</big><a class="reference internal" href="../_modules/nltk/chunk/util.html#ieerstr2tree"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.util.ieerstr2tree" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a string of chunked tagged text in the IEER named
entity format into a chunk structure.  Chunks are of several
types, LOCATION, ORGANIZATION, PERSON, DURATION, DATE, CARDINAL,
PERCENT, MONEY, and MEASURE.</p>
<dl class="docutils">
<dt>&#64;return: A chunk structure containing the chunked tagged text that is</dt>
<dd>encoded in the given IEER style string.</dd>
</dl>
<p>&#64;rtype: L{Tree}</p>
</dd></dl>

<dl class="function">
<dt id="nltk.chunk.util.tagstr2tree">
<tt class="descclassname">nltk.chunk.util.</tt><tt class="descname">tagstr2tree</tt><big>(</big><em>s</em>, <em>chunk_node='NP'</em>, <em>top_node='S'</em>, <em>sep='/'</em><big>)</big><a class="reference internal" href="../_modules/nltk/chunk/util.html#tagstr2tree"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.util.tagstr2tree" title="Permalink to this definition">¶</a></dt>
<dd><p>Divide a string of bracketted tagged text into
chunks and unchunked tokens, and produce a C{Tree}.
Chunks are marked by square brackets (C{[...]}).  Words are
delimited by whitespace, and each word should have the form
C{I{text}/I{tag}}.  Words that do not contain a slash are
assigned a C{tag} of C{None}.</p>
<p>&#64;return: A tree corresponding to the string representation.
&#64;rtype: C{tree}
&#64;param s: The string to be converted
&#64;type s: C{string}
&#64;param chunk_node: The label to use for chunk nodes
&#64;type chunk_node: C{string}
&#64;param top_node: The label to use for the root of the tree
&#64;type top_node: C{string}</p>
</dd></dl>

<dl class="function">
<dt id="nltk.chunk.util.tree2conllstr">
<tt class="descclassname">nltk.chunk.util.</tt><tt class="descname">tree2conllstr</tt><big>(</big><em>t</em><big>)</big><a class="reference internal" href="../_modules/nltk/chunk/util.html#tree2conllstr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.util.tree2conllstr" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a tree to the CoNLL IOB string format</p>
<p>&#64;param t: The tree to be converted.
&#64;type t: C{Tree}
&#64;return: A multiline string where each line contains a word, tag and IOB tag.
&#64;rtype: C{string}</p>
</dd></dl>

<dl class="function">
<dt id="nltk.chunk.util.tree2conlltags">
<tt class="descclassname">nltk.chunk.util.</tt><tt class="descname">tree2conlltags</tt><big>(</big><em>t</em><big>)</big><a class="reference internal" href="../_modules/nltk/chunk/util.html#tree2conlltags"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.util.tree2conlltags" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a tree to the CoNLL IOB tag format</p>
<p>&#64;param t: The tree to be converted.
&#64;type t: C{Tree}
&#64;return: A list of 3-tuples containing word, tag and IOB tag.
&#64;rtype: C{list} of C{tuple}</p>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
        </div>
        <div class="sidebar">
          <h3>Table Of Contents</h3>
          <ul>
<li class="toctree-l1"><a class="reference internal" href="../news.html">NLTK News</a></li>
</ul>

          <h3 style="margin-top: 1.5em;">Search</h3>
          <form class="search" action="../search.html" method="get">
            <input type="text" name="q" />
            <input type="submit" value="Go" />
            <input type="hidden" name="check_keywords" value="yes" />
            <input type="hidden" name="area" value="default" />
          </form>
          <p class="searchtip" style="font-size: 90%">
            Enter search terms or a module, class or function name.
          </p>
        </div>
        <div class="clearer"></div>
      </div>
    </div>

    <div class="footer-wrapper">
      <div class="footer">
        <div class="left">
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |
          <a href="../genindex.html" title="General Index"
             >index</a>
            <br/>
            <a href="../_sources/api/nltk.chunk.txt"
               rel="nofollow">Show Source</a>
        </div>

        <div class="right">
          
    <div class="footer">
        &copy; Copyright 2011, Steven Bird.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.2.
    </div>
        </div>
        <div class="clearer"></div>
      </div>
    </div>

  </body>
</html>