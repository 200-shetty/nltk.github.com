<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>nltk.chunk package &mdash; NLTK 3.0 documentation</title>
    
    <link rel="stylesheet" href="../_static/agogo.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '3.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="NLTK 3.0 documentation" href="../index.html" />
    <link rel="up" title="nltk Package" href="nltk.html" />
    <link rel="next" title="nltk.classify package" href="nltk.classify.html" />
    <link rel="prev" title="nltk.chat package" href="nltk.chat.html" /> 
  </head>
  <body>
    <div class="header-wrapper">
      <div class="header">
        <div class="headertitle"><a
          href="../index.html">NLTK 3.0 documentation</a></div>
        <div class="rel">
          <a href="nltk.chat.html" title="nltk.chat package"
             accesskey="P">previous</a> |
          <a href="nltk.classify.html" title="nltk.classify package"
             accesskey="N">next</a> |
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a>
        </div>
       </div>
    </div>

    <div class="content-wrapper">
      <div class="content">
        <div class="document">
            
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="nltk-chunk-package">
<h1>nltk.chunk package<a class="headerlink" href="#nltk-chunk-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-nltk.chunk.api">
<span id="nltk-chunk-api-module"></span><h2>nltk.chunk.api module<a class="headerlink" href="#module-nltk.chunk.api" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="nltk.chunk.api.ChunkParserI">
<em class="property">class </em><tt class="descclassname">nltk.chunk.api.</tt><tt class="descname">ChunkParserI</tt><a class="reference internal" href="../_modules/nltk/chunk/api.html#ChunkParserI"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.api.ChunkParserI" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="nltk.parse.html#nltk.parse.api.ParserI" title="nltk.parse.api.ParserI"><tt class="xref py py-class docutils literal"><span class="pre">nltk.parse.api.ParserI</span></tt></a></p>
<p>A processing interface for identifying non-overlapping groups in
unrestricted text.  Typically, chunk parsers are used to find base
syntactic constituents, such as base noun phrases.  Unlike
<tt class="docutils literal"><span class="pre">ParserI</span></tt>, <tt class="docutils literal"><span class="pre">ChunkParserI</span></tt> guarantees that the <tt class="docutils literal"><span class="pre">parse()</span></tt> method
will always generate a parse.</p>
<dl class="method">
<dt id="nltk.chunk.api.ChunkParserI.evaluate">
<tt class="descname">evaluate</tt><big>(</big><em>gold</em><big>)</big><a class="reference internal" href="../_modules/nltk/chunk/api.html#ChunkParserI.evaluate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.api.ChunkParserI.evaluate" title="Permalink to this definition">¶</a></dt>
<dd><p>Score the accuracy of the chunker against the gold standard.
Remove the chunking the gold standard text, rechunk it using
the chunker, and return a <tt class="docutils literal"><span class="pre">ChunkScore</span></tt> object
reflecting the performance of this chunk peraser.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>gold</strong> (<em>list(Tree)</em>) &#8211; The list of chunked sentences to score the chunker on.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">ChunkScore</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.chunk.api.ChunkParserI.parse">
<tt class="descname">parse</tt><big>(</big><em>tokens</em><big>)</big><a class="reference internal" href="../_modules/nltk/chunk/api.html#ChunkParserI.parse"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.api.ChunkParserI.parse" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the best chunk structure for the given tokens
and return a tree.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>tokens</strong> (<em>list(tuple)</em>) &#8211; The list of (word, tag) tokens to be chunked.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">Tree</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-nltk.chunk.named_entity">
<span id="nltk-chunk-named-entity-module"></span><h2>nltk.chunk.named_entity module<a class="headerlink" href="#module-nltk.chunk.named_entity" title="Permalink to this headline">¶</a></h2>
<p>Named entity chunker</p>
<dl class="class">
<dt id="nltk.chunk.named_entity.NEChunkParser">
<em class="property">class </em><tt class="descclassname">nltk.chunk.named_entity.</tt><tt class="descname">NEChunkParser</tt><big>(</big><em>train</em><big>)</big><a class="reference internal" href="../_modules/nltk/chunk/named_entity.html#NEChunkParser"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.named_entity.NEChunkParser" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.chunk.api.ChunkParserI" title="nltk.chunk.api.ChunkParserI"><tt class="xref py py-class docutils literal"><span class="pre">nltk.chunk.api.ChunkParserI</span></tt></a></p>
<p>Expected input: list of pos-tagged words</p>
<dl class="method">
<dt id="nltk.chunk.named_entity.NEChunkParser.parse">
<tt class="descname">parse</tt><big>(</big><em>tokens</em><big>)</big><a class="reference internal" href="../_modules/nltk/chunk/named_entity.html#NEChunkParser.parse"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.named_entity.NEChunkParser.parse" title="Permalink to this definition">¶</a></dt>
<dd><p>Each token should be a pos-tagged word</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.chunk.named_entity.NEChunkParserTagger">
<em class="property">class </em><tt class="descclassname">nltk.chunk.named_entity.</tt><tt class="descname">NEChunkParserTagger</tt><big>(</big><em>train</em><big>)</big><a class="reference internal" href="../_modules/nltk/chunk/named_entity.html#NEChunkParserTagger"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.named_entity.NEChunkParserTagger" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="nltk.tag.html#nltk.tag.sequential.ClassifierBasedTagger" title="nltk.tag.sequential.ClassifierBasedTagger"><tt class="xref py py-class docutils literal"><span class="pre">nltk.tag.sequential.ClassifierBasedTagger</span></tt></a></p>
<p>The IOB tagger used by the chunk parser.</p>
</dd></dl>

<dl class="function">
<dt id="nltk.chunk.named_entity.build_model">
<tt class="descclassname">nltk.chunk.named_entity.</tt><tt class="descname">build_model</tt><big>(</big><em>fmt='binary'</em><big>)</big><a class="reference internal" href="../_modules/nltk/chunk/named_entity.html#build_model"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.named_entity.build_model" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="nltk.chunk.named_entity.cmp_chunks">
<tt class="descclassname">nltk.chunk.named_entity.</tt><tt class="descname">cmp_chunks</tt><big>(</big><em>correct</em>, <em>guessed</em><big>)</big><a class="reference internal" href="../_modules/nltk/chunk/named_entity.html#cmp_chunks"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.named_entity.cmp_chunks" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="nltk.chunk.named_entity.load_ace_data">
<tt class="descclassname">nltk.chunk.named_entity.</tt><tt class="descname">load_ace_data</tt><big>(</big><em>roots</em>, <em>fmt='binary'</em>, <em>skip_bnews=True</em><big>)</big><a class="reference internal" href="../_modules/nltk/chunk/named_entity.html#load_ace_data"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.named_entity.load_ace_data" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="nltk.chunk.named_entity.load_ace_file">
<tt class="descclassname">nltk.chunk.named_entity.</tt><tt class="descname">load_ace_file</tt><big>(</big><em>textfile</em>, <em>fmt</em><big>)</big><a class="reference internal" href="../_modules/nltk/chunk/named_entity.html#load_ace_file"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.named_entity.load_ace_file" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="nltk.chunk.named_entity.postag_tree">
<tt class="descclassname">nltk.chunk.named_entity.</tt><tt class="descname">postag_tree</tt><big>(</big><em>tree</em><big>)</big><a class="reference internal" href="../_modules/nltk/chunk/named_entity.html#postag_tree"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.named_entity.postag_tree" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="nltk.chunk.named_entity.shape">
<tt class="descclassname">nltk.chunk.named_entity.</tt><tt class="descname">shape</tt><big>(</big><em>word</em><big>)</big><a class="reference internal" href="../_modules/nltk/chunk/named_entity.html#shape"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.named_entity.shape" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="nltk.chunk.named_entity.simplify_pos">
<tt class="descclassname">nltk.chunk.named_entity.</tt><tt class="descname">simplify_pos</tt><big>(</big><em>s</em><big>)</big><a class="reference internal" href="../_modules/nltk/chunk/named_entity.html#simplify_pos"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.named_entity.simplify_pos" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-nltk.chunk.regexp">
<span id="nltk-chunk-regexp-module"></span><h2>nltk.chunk.regexp module<a class="headerlink" href="#module-nltk.chunk.regexp" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="nltk.chunk.regexp.ChinkRule">
<em class="property">class </em><tt class="descclassname">nltk.chunk.regexp.</tt><tt class="descname">ChinkRule</tt><big>(</big><em>tag_pattern</em>, <em>descr</em><big>)</big><a class="reference internal" href="../_modules/nltk/chunk/regexp.html#ChinkRule"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.regexp.ChinkRule" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.chunk.regexp.RegexpChunkRule" title="nltk.chunk.regexp.RegexpChunkRule"><tt class="xref py py-class docutils literal"><span class="pre">nltk.chunk.regexp.RegexpChunkRule</span></tt></a></p>
<p>A rule specifying how to remove chinks to a <tt class="docutils literal"><span class="pre">ChunkString</span></tt>,
using a matching tag pattern.  When applied to a
<tt class="docutils literal"><span class="pre">ChunkString</span></tt>, it will find any substring that matches this
tag pattern and that is contained in a chunk, and remove it
from that chunk, thus creating two new chunks.</p>
<dl class="method">
<dt id="nltk.chunk.regexp.ChinkRule.unicode_repr">
<tt class="descname">unicode_repr</tt><big>(</big><big>)</big><a class="headerlink" href="#nltk.chunk.regexp.ChinkRule.unicode_repr" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a string representation of this rule.  It has the form:</p>
<div class="highlight-python"><div class="highlight"><pre>&lt;ChinkRule: &#39;&lt;IN|VB.*&gt;&#39;&gt;
</pre></div>
</div>
<p>Note that this representation does not include the
description string; that string can be accessed
separately with the <tt class="docutils literal"><span class="pre">descr()</span></tt> method.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">str</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.chunk.regexp.ChunkRule">
<em class="property">class </em><tt class="descclassname">nltk.chunk.regexp.</tt><tt class="descname">ChunkRule</tt><big>(</big><em>tag_pattern</em>, <em>descr</em><big>)</big><a class="reference internal" href="../_modules/nltk/chunk/regexp.html#ChunkRule"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.regexp.ChunkRule" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.chunk.regexp.RegexpChunkRule" title="nltk.chunk.regexp.RegexpChunkRule"><tt class="xref py py-class docutils literal"><span class="pre">nltk.chunk.regexp.RegexpChunkRule</span></tt></a></p>
<p>A rule specifying how to add chunks to a <tt class="docutils literal"><span class="pre">ChunkString</span></tt>, using a
matching tag pattern.  When applied to a <tt class="docutils literal"><span class="pre">ChunkString</span></tt>, it will
find any substring that matches this tag pattern and that is not
already part of a chunk, and create a new chunk containing that
substring.</p>
<dl class="method">
<dt id="nltk.chunk.regexp.ChunkRule.unicode_repr">
<tt class="descname">unicode_repr</tt><big>(</big><big>)</big><a class="headerlink" href="#nltk.chunk.regexp.ChunkRule.unicode_repr" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a string representation of this rule.  It has the form:</p>
<div class="highlight-python"><div class="highlight"><pre>&lt;ChunkRule: &#39;&lt;IN|VB.*&gt;&#39;&gt;
</pre></div>
</div>
<p>Note that this representation does not include the
description string; that string can be accessed
separately with the <tt class="docutils literal"><span class="pre">descr()</span></tt> method.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">str</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.chunk.regexp.ChunkRuleWithContext">
<em class="property">class </em><tt class="descclassname">nltk.chunk.regexp.</tt><tt class="descname">ChunkRuleWithContext</tt><big>(</big><em>left_context_tag_pattern</em>, <em>chunk_tag_pattern</em>, <em>right_context_tag_pattern</em>, <em>descr</em><big>)</big><a class="reference internal" href="../_modules/nltk/chunk/regexp.html#ChunkRuleWithContext"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.regexp.ChunkRuleWithContext" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.chunk.regexp.RegexpChunkRule" title="nltk.chunk.regexp.RegexpChunkRule"><tt class="xref py py-class docutils literal"><span class="pre">nltk.chunk.regexp.RegexpChunkRule</span></tt></a></p>
<p>A rule specifying how to add chunks to a <tt class="docutils literal"><span class="pre">ChunkString</span></tt>, using
three matching tag patterns: one for the left context, one for the
chunk, and one for the right context.  When applied to a
<tt class="docutils literal"><span class="pre">ChunkString</span></tt>, it will find any substring that matches the chunk
tag pattern, is surrounded by substrings that match the two
context patterns, and is not already part of a chunk; and create a
new chunk containing the substring that matched the chunk tag
pattern.</p>
<p>Caveat: Both the left and right context are consumed when this
rule matches; therefore, if you need to find overlapping matches,
you will need to apply your rule more than once.</p>
<dl class="method">
<dt id="nltk.chunk.regexp.ChunkRuleWithContext.unicode_repr">
<tt class="descname">unicode_repr</tt><big>(</big><big>)</big><a class="headerlink" href="#nltk.chunk.regexp.ChunkRuleWithContext.unicode_repr" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a string representation of this rule.  It has the form:</p>
<div class="highlight-python"><div class="highlight"><pre>&lt;ChunkRuleWithContext: &#39;&lt;IN&gt;&#39;, &#39;&lt;NN&gt;&#39;, &#39;&lt;DT&gt;&#39;&gt;
</pre></div>
</div>
<p>Note that this representation does not include the
description string; that string can be accessed
separately with the <tt class="docutils literal"><span class="pre">descr()</span></tt> method.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">str</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.chunk.regexp.ChunkString">
<em class="property">class </em><tt class="descclassname">nltk.chunk.regexp.</tt><tt class="descname">ChunkString</tt><big>(</big><em>chunk_struct</em>, <em>debug_level=1</em><big>)</big><a class="reference internal" href="../_modules/nltk/chunk/regexp.html#ChunkString"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.regexp.ChunkString" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">builtins.object</span></tt></p>
<p>A string-based encoding of a particular chunking of a text.
Internally, the <tt class="docutils literal"><span class="pre">ChunkString</span></tt> class uses a single string to
encode the chunking of the input text.  This string contains a
sequence of angle-bracket delimited tags, with chunking indicated
by braces.  An example of this encoding is:</p>
<div class="highlight-python"><div class="highlight"><pre>{&lt;DT&gt;&lt;JJ&gt;&lt;NN&gt;}&lt;VBN&gt;&lt;IN&gt;{&lt;DT&gt;&lt;NN&gt;}&lt;.&gt;{&lt;DT&gt;&lt;NN&gt;}&lt;VBD&gt;&lt;.&gt;
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">ChunkString</span></tt> are created from tagged texts (i.e., lists of
<tt class="docutils literal"><span class="pre">tokens</span></tt> whose type is <tt class="docutils literal"><span class="pre">TaggedType</span></tt>).  Initially, nothing is
chunked.</p>
<p>The chunking of a <tt class="docutils literal"><span class="pre">ChunkString</span></tt> can be modified with the <tt class="docutils literal"><span class="pre">xform()</span></tt>
method, which uses a regular expression to transform the string
representation.  These transformations should only add and remove
braces; they should <em>not</em> modify the sequence of angle-bracket
delimited tags.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><ul class="first last simple">
<li><strong>_str</strong> &#8211; <p>The internal string representation of the text&#8217;s
encoding.  This string representation contains a sequence of
angle-bracket delimited tags, with chunking indicated by
braces.  An example of this encoding is:</p>
<div class="highlight-python"><div class="highlight"><pre>{&lt;DT&gt;&lt;JJ&gt;&lt;NN&gt;}&lt;VBN&gt;&lt;IN&gt;{&lt;DT&gt;&lt;NN&gt;}&lt;.&gt;{&lt;DT&gt;&lt;NN&gt;}&lt;VBD&gt;&lt;.&gt;
</pre></div>
</div>
</li>
<li><strong>_pieces</strong> &#8211; The tagged tokens and chunks encoded by this <tt class="docutils literal"><span class="pre">ChunkString</span></tt>.</li>
<li><strong>_debug</strong> &#8211; The debug level.  See the constructor docs.</li>
<li><strong>IN_CHUNK_PATTERN</strong> &#8211; A zero-width regexp pattern string that
will only match positions that are in chunks.</li>
<li><strong>IN_CHINK_PATTERN</strong> &#8211; A zero-width regexp pattern string that
will only match positions that are in chinks.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="nltk.chunk.regexp.ChunkString.CHUNK_TAG">
<tt class="descname">CHUNK_TAG</tt><em class="property"> = '(&lt;[^\\{\\}&lt;&gt;]+?&gt;)'</em><a class="headerlink" href="#nltk.chunk.regexp.ChunkString.CHUNK_TAG" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nltk.chunk.regexp.ChunkString.CHUNK_TAG_CHAR">
<tt class="descname">CHUNK_TAG_CHAR</tt><em class="property"> = '[^\\{\\}&lt;&gt;]'</em><a class="headerlink" href="#nltk.chunk.regexp.ChunkString.CHUNK_TAG_CHAR" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nltk.chunk.regexp.ChunkString.IN_CHINK_PATTERN">
<tt class="descname">IN_CHINK_PATTERN</tt><em class="property"> = '(?=[^\\}]*(\\{|$))'</em><a class="headerlink" href="#nltk.chunk.regexp.ChunkString.IN_CHINK_PATTERN" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nltk.chunk.regexp.ChunkString.IN_CHUNK_PATTERN">
<tt class="descname">IN_CHUNK_PATTERN</tt><em class="property"> = '(?=[^\\{]*\\})'</em><a class="headerlink" href="#nltk.chunk.regexp.ChunkString.IN_CHUNK_PATTERN" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nltk.chunk.regexp.ChunkString.to_chunkstruct">
<tt class="descname">to_chunkstruct</tt><big>(</big><em>chunk_label='CHUNK'</em><big>)</big><a class="reference internal" href="../_modules/nltk/chunk/regexp.html#ChunkString.to_chunkstruct"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.regexp.ChunkString.to_chunkstruct" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the chunk structure encoded by this <tt class="docutils literal"><span class="pre">ChunkString</span></tt>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">Tree</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Raises ValueError:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body">If a transformation has generated an
invalid chunkstring.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.chunk.regexp.ChunkString.unicode_repr">
<tt class="descname">unicode_repr</tt><big>(</big><big>)</big><a class="headerlink" href="#nltk.chunk.regexp.ChunkString.unicode_repr" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a string representation of this <tt class="docutils literal"><span class="pre">ChunkString</span></tt>.
It has the form:</p>
<div class="highlight-python"><div class="highlight"><pre>&lt;ChunkString: &#39;{&lt;DT&gt;&lt;JJ&gt;&lt;NN&gt;}&lt;VBN&gt;&lt;IN&gt;{&lt;DT&gt;&lt;NN&gt;}&#39;&gt;
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">str</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.chunk.regexp.ChunkString.xform">
<tt class="descname">xform</tt><big>(</big><em>regexp</em>, <em>repl</em><big>)</big><a class="reference internal" href="../_modules/nltk/chunk/regexp.html#ChunkString.xform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.regexp.ChunkString.xform" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply the given transformation to the string encoding of this
<tt class="docutils literal"><span class="pre">ChunkString</span></tt>.  In particular, find all occurrences that match
<tt class="docutils literal"><span class="pre">regexp</span></tt>, and replace them using <tt class="docutils literal"><span class="pre">repl</span></tt> (as done by
<tt class="docutils literal"><span class="pre">re.sub</span></tt>).</p>
<p>This transformation should only add and remove braces; it
should <em>not</em> modify the sequence of angle-bracket delimited
tags.  Furthermore, this transformation may not result in
improper bracketing.  Note, in particular, that bracketing may
not be nested.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>regexp</strong> (<em>str or regexp</em>) &#8211; A regular expression matching the substring
that should be replaced.  This will typically include a
named group, which can be used by <tt class="docutils literal"><span class="pre">repl</span></tt>.</li>
<li><strong>repl</strong> (<em>str</em>) &#8211; An expression specifying what should replace the
matched substring.  Typically, this will include a named
replacement group, specified by <tt class="docutils literal"><span class="pre">regexp</span></tt>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">None</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name" colspan="2">Raises ValueError:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"><p class="first last">If this transformation generated an
invalid chunkstring.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.chunk.regexp.ExpandLeftRule">
<em class="property">class </em><tt class="descclassname">nltk.chunk.regexp.</tt><tt class="descname">ExpandLeftRule</tt><big>(</big><em>left_tag_pattern</em>, <em>right_tag_pattern</em>, <em>descr</em><big>)</big><a class="reference internal" href="../_modules/nltk/chunk/regexp.html#ExpandLeftRule"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.regexp.ExpandLeftRule" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.chunk.regexp.RegexpChunkRule" title="nltk.chunk.regexp.RegexpChunkRule"><tt class="xref py py-class docutils literal"><span class="pre">nltk.chunk.regexp.RegexpChunkRule</span></tt></a></p>
<p>A rule specifying how to expand chunks in a <tt class="docutils literal"><span class="pre">ChunkString</span></tt> to the left,
using two matching tag patterns: a left pattern, and a right pattern.
When applied to a <tt class="docutils literal"><span class="pre">ChunkString</span></tt>, it will find any chunk whose beginning
matches right pattern, and immediately preceded by a chink whose
end matches left pattern.  It will then expand the chunk to incorporate
the new material on the left.</p>
<dl class="method">
<dt id="nltk.chunk.regexp.ExpandLeftRule.unicode_repr">
<tt class="descname">unicode_repr</tt><big>(</big><big>)</big><a class="headerlink" href="#nltk.chunk.regexp.ExpandLeftRule.unicode_repr" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a string representation of this rule.  It has the form:</p>
<div class="highlight-python"><div class="highlight"><pre>&lt;ExpandLeftRule: &#39;&lt;NN|DT|JJ&gt;&#39;, &#39;&lt;NN|JJ&gt;&#39;&gt;
</pre></div>
</div>
<p>Note that this representation does not include the
description string; that string can be accessed
separately with the <tt class="docutils literal"><span class="pre">descr()</span></tt> method.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">str</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.chunk.regexp.ExpandRightRule">
<em class="property">class </em><tt class="descclassname">nltk.chunk.regexp.</tt><tt class="descname">ExpandRightRule</tt><big>(</big><em>left_tag_pattern</em>, <em>right_tag_pattern</em>, <em>descr</em><big>)</big><a class="reference internal" href="../_modules/nltk/chunk/regexp.html#ExpandRightRule"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.regexp.ExpandRightRule" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.chunk.regexp.RegexpChunkRule" title="nltk.chunk.regexp.RegexpChunkRule"><tt class="xref py py-class docutils literal"><span class="pre">nltk.chunk.regexp.RegexpChunkRule</span></tt></a></p>
<p>A rule specifying how to expand chunks in a <tt class="docutils literal"><span class="pre">ChunkString</span></tt> to the
right, using two matching tag patterns: a left pattern, and a
right pattern.  When applied to a <tt class="docutils literal"><span class="pre">ChunkString</span></tt>, it will find any
chunk whose end matches left pattern, and immediately followed by
a chink whose beginning matches right pattern.  It will then
expand the chunk to incorporate the new material on the right.</p>
<dl class="method">
<dt id="nltk.chunk.regexp.ExpandRightRule.unicode_repr">
<tt class="descname">unicode_repr</tt><big>(</big><big>)</big><a class="headerlink" href="#nltk.chunk.regexp.ExpandRightRule.unicode_repr" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a string representation of this rule.  It has the form:</p>
<div class="highlight-python"><div class="highlight"><pre>&lt;ExpandRightRule: &#39;&lt;NN|DT|JJ&gt;&#39;, &#39;&lt;NN|JJ&gt;&#39;&gt;
</pre></div>
</div>
<p>Note that this representation does not include the
description string; that string can be accessed
separately with the <tt class="docutils literal"><span class="pre">descr()</span></tt> method.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">str</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.chunk.regexp.MergeRule">
<em class="property">class </em><tt class="descclassname">nltk.chunk.regexp.</tt><tt class="descname">MergeRule</tt><big>(</big><em>left_tag_pattern</em>, <em>right_tag_pattern</em>, <em>descr</em><big>)</big><a class="reference internal" href="../_modules/nltk/chunk/regexp.html#MergeRule"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.regexp.MergeRule" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.chunk.regexp.RegexpChunkRule" title="nltk.chunk.regexp.RegexpChunkRule"><tt class="xref py py-class docutils literal"><span class="pre">nltk.chunk.regexp.RegexpChunkRule</span></tt></a></p>
<p>A rule specifying how to merge chunks in a <tt class="docutils literal"><span class="pre">ChunkString</span></tt>, using
two matching tag patterns: a left pattern, and a right pattern.
When applied to a <tt class="docutils literal"><span class="pre">ChunkString</span></tt>, it will find any chunk whose end
matches left pattern, and immediately followed by a chunk whose
beginning matches right pattern.  It will then merge those two
chunks into a single chunk.</p>
<dl class="method">
<dt id="nltk.chunk.regexp.MergeRule.unicode_repr">
<tt class="descname">unicode_repr</tt><big>(</big><big>)</big><a class="headerlink" href="#nltk.chunk.regexp.MergeRule.unicode_repr" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a string representation of this rule.  It has the form:</p>
<div class="highlight-python"><div class="highlight"><pre>&lt;MergeRule: &#39;&lt;NN|DT|JJ&gt;&#39;, &#39;&lt;NN|JJ&gt;&#39;&gt;
</pre></div>
</div>
<p>Note that this representation does not include the
description string; that string can be accessed
separately with the <tt class="docutils literal"><span class="pre">descr()</span></tt> method.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">str</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.chunk.regexp.RegexpChunkParser">
<em class="property">class </em><tt class="descclassname">nltk.chunk.regexp.</tt><tt class="descname">RegexpChunkParser</tt><big>(</big><em>rules</em>, <em>chunk_label='NP'</em>, <em>root_label='S'</em>, <em>trace=0</em><big>)</big><a class="reference internal" href="../_modules/nltk/chunk/regexp.html#RegexpChunkParser"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.regexp.RegexpChunkParser" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.chunk.api.ChunkParserI" title="nltk.chunk.api.ChunkParserI"><tt class="xref py py-class docutils literal"><span class="pre">nltk.chunk.api.ChunkParserI</span></tt></a></p>
<p>A regular expression based chunk parser.  <tt class="docutils literal"><span class="pre">RegexpChunkParser</span></tt> uses a
sequence of &#8220;rules&#8221; to find chunks of a single type within a
text.  The chunking of the text is encoded using a <tt class="docutils literal"><span class="pre">ChunkString</span></tt>,
and each rule acts by modifying the chunking in the
<tt class="docutils literal"><span class="pre">ChunkString</span></tt>.  The rules are all implemented using regular
expression matching and substitution.</p>
<p>The <tt class="docutils literal"><span class="pre">RegexpChunkRule</span></tt> class and its subclasses (<tt class="docutils literal"><span class="pre">ChunkRule</span></tt>,
<tt class="docutils literal"><span class="pre">ChinkRule</span></tt>, <tt class="docutils literal"><span class="pre">UnChunkRule</span></tt>, <tt class="docutils literal"><span class="pre">MergeRule</span></tt>, and <tt class="docutils literal"><span class="pre">SplitRule</span></tt>)
define the rules that are used by <tt class="docutils literal"><span class="pre">RegexpChunkParser</span></tt>.  Each rule
defines an <tt class="docutils literal"><span class="pre">apply()</span></tt> method, which modifies the chunking encoded
by a given <tt class="docutils literal"><span class="pre">ChunkString</span></tt>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><ul class="first last simple">
<li><strong>_rules</strong> &#8211; The list of rules that should be applied to a text.</li>
<li><strong>_trace</strong> &#8211; The default level of tracing.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="nltk.chunk.regexp.RegexpChunkParser.parse">
<tt class="descname">parse</tt><big>(</big><em>chunk_struct</em>, <em>trace=None</em><big>)</big><a class="reference internal" href="../_modules/nltk/chunk/regexp.html#RegexpChunkParser.parse"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.regexp.RegexpChunkParser.parse" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>chunk_struct</strong> (<em>Tree</em>) &#8211; the chunk structure to be (further) chunked</li>
<li><strong>trace</strong> (<em>int</em>) &#8211; The level of tracing that should be used when
parsing a text.  <tt class="docutils literal"><span class="pre">0</span></tt> will generate no tracing output;
<tt class="docutils literal"><span class="pre">1</span></tt> will generate normal tracing output; and <tt class="docutils literal"><span class="pre">2</span></tt> or
highter will generate verbose tracing output.  This value
overrides the trace level value that was given to the
constructor.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">Tree</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">a chunk structure that encodes the chunks in a given
tagged sentence.  A chunk is a non-overlapping linguistic
group, such as a noun phrase.  The set of chunks
identified in the chunk structure depends on the rules
used to define this <tt class="docutils literal"><span class="pre">RegexpChunkParser</span></tt>.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.chunk.regexp.RegexpChunkParser.rules">
<tt class="descname">rules</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/chunk/regexp.html#RegexpChunkParser.rules"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.regexp.RegexpChunkParser.rules" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">the sequence of rules used by <tt class="docutils literal"><span class="pre">RegexpChunkParser</span></tt>.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">list(RegexpChunkRule)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.chunk.regexp.RegexpChunkParser.unicode_repr">
<tt class="descname">unicode_repr</tt><big>(</big><big>)</big><a class="headerlink" href="#nltk.chunk.regexp.RegexpChunkParser.unicode_repr" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a concise string representation of this
<tt class="docutils literal"><span class="pre">RegexpChunkParser</span></tt>.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">str</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.chunk.regexp.RegexpChunkRule">
<em class="property">class </em><tt class="descclassname">nltk.chunk.regexp.</tt><tt class="descname">RegexpChunkRule</tt><big>(</big><em>regexp</em>, <em>repl</em>, <em>descr</em><big>)</big><a class="reference internal" href="../_modules/nltk/chunk/regexp.html#RegexpChunkRule"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.regexp.RegexpChunkRule" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">builtins.object</span></tt></p>
<p>A rule specifying how to modify the chunking in a <tt class="docutils literal"><span class="pre">ChunkString</span></tt>,
using a transformational regular expression.  The
<tt class="docutils literal"><span class="pre">RegexpChunkRule</span></tt> class itself can be used to implement any
transformational rule based on regular expressions.  There are
also a number of subclasses, which can be used to implement
simpler types of rules, based on matching regular expressions.</p>
<p>Each <tt class="docutils literal"><span class="pre">RegexpChunkRule</span></tt> has a regular expression and a
replacement expression.  When a <tt class="docutils literal"><span class="pre">RegexpChunkRule</span></tt> is &#8220;applied&#8221;
to a <tt class="docutils literal"><span class="pre">ChunkString</span></tt>, it searches the <tt class="docutils literal"><span class="pre">ChunkString</span></tt> for any
substring that matches the regular expression, and replaces it
using the replacement expression.  This search/replace operation
has the same semantics as <tt class="docutils literal"><span class="pre">re.sub</span></tt>.</p>
<p>Each <tt class="docutils literal"><span class="pre">RegexpChunkRule</span></tt> also has a description string, which
gives a short (typically less than 75 characters) description of
the purpose of the rule.</p>
<p>This transformation defined by this <tt class="docutils literal"><span class="pre">RegexpChunkRule</span></tt> should
only add and remove braces; it should <em>not</em> modify the sequence
of angle-bracket delimited tags.  Furthermore, this transformation
may not result in nested or mismatched bracketing.</p>
<dl class="method">
<dt id="nltk.chunk.regexp.RegexpChunkRule.apply">
<tt class="descname">apply</tt><big>(</big><em>chunkstr</em><big>)</big><a class="reference internal" href="../_modules/nltk/chunk/regexp.html#RegexpChunkRule.apply"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.regexp.RegexpChunkRule.apply" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply this rule to the given <tt class="docutils literal"><span class="pre">ChunkString</span></tt>.  See the
class reference documentation for a description of what it
means to apply a rule.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>chunkstr</strong> (<em>ChunkString</em>) &#8211; The chunkstring to which this rule is applied.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">None</td>
</tr>
<tr class="field-odd field"><th class="field-name" colspan="2">Raises ValueError:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body">If this transformation generated an
invalid chunkstring.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.chunk.regexp.RegexpChunkRule.descr">
<tt class="descname">descr</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/chunk/regexp.html#RegexpChunkRule.descr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.regexp.RegexpChunkRule.descr" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a short description of the purpose and/or effect of
this rule.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">str</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="nltk.chunk.regexp.RegexpChunkRule.fromstring">
<em class="property">static </em><tt class="descname">fromstring</tt><big>(</big><em>s</em><big>)</big><a class="reference internal" href="../_modules/nltk/chunk/regexp.html#RegexpChunkRule.fromstring"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.regexp.RegexpChunkRule.fromstring" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a RegexpChunkRule from a string description.
Currently, the following formats are supported:</p>
<div class="highlight-python"><div class="highlight"><pre>{regexp}         # chunk rule
}regexp{         # chink rule
regexp}{regexp   # split rule
regexp{}regexp   # merge rule
</pre></div>
</div>
<p>Where <tt class="docutils literal"><span class="pre">regexp</span></tt> is a regular expression for the rule.  Any
text following the comment marker (<tt class="docutils literal"><span class="pre">#</span></tt>) will be used as
the rule&#8217;s description:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">nltk.chunk.regexp</span> <span class="kn">import</span> <span class="n">RegexpChunkRule</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">RegexpChunkRule</span><span class="o">.</span><span class="n">fromstring</span><span class="p">(</span><span class="s">&#39;{&lt;DT&gt;?&lt;NN.*&gt;+}&#39;</span><span class="p">)</span>
<span class="go">&lt;ChunkRule: &#39;&lt;DT&gt;?&lt;NN.*&gt;+&#39;&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nltk.chunk.regexp.RegexpChunkRule.unicode_repr">
<tt class="descname">unicode_repr</tt><big>(</big><big>)</big><a class="headerlink" href="#nltk.chunk.regexp.RegexpChunkRule.unicode_repr" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a string representation of this rule.  It has the form:</p>
<div class="highlight-python"><div class="highlight"><pre>&lt;RegexpChunkRule: &#39;{&lt;IN|VB.*&gt;}&#39;-&gt;&#39;&lt;IN&gt;&#39;&gt;
</pre></div>
</div>
<p>Note that this representation does not include the
description string; that string can be accessed
separately with the <tt class="docutils literal"><span class="pre">descr()</span></tt> method.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">str</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.chunk.regexp.RegexpParser">
<em class="property">class </em><tt class="descclassname">nltk.chunk.regexp.</tt><tt class="descname">RegexpParser</tt><big>(</big><em>grammar</em>, <em>root_label='S'</em>, <em>loop=1</em>, <em>trace=0</em><big>)</big><a class="reference internal" href="../_modules/nltk/chunk/regexp.html#RegexpParser"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.regexp.RegexpParser" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.chunk.api.ChunkParserI" title="nltk.chunk.api.ChunkParserI"><tt class="xref py py-class docutils literal"><span class="pre">nltk.chunk.api.ChunkParserI</span></tt></a></p>
<p>A grammar based chunk parser.  <tt class="docutils literal"><span class="pre">chunk.RegexpParser</span></tt> uses a set of
regular expression patterns to specify the behavior of the parser.
The chunking of the text is encoded using a <tt class="docutils literal"><span class="pre">ChunkString</span></tt>, and
each rule acts by modifying the chunking in the <tt class="docutils literal"><span class="pre">ChunkString</span></tt>.
The rules are all implemented using regular expression matching
and substitution.</p>
<p>A grammar contains one or more clauses in the following form:</p>
<div class="highlight-python"><div class="highlight"><pre>NP:
  {&lt;DT|JJ&gt;}          # chunk determiners and adjectives
  }&lt;[\.VI].*&gt;+{      # chink any tag beginning with V, I, or .
  &lt;.*&gt;}{&lt;DT&gt;         # split a chunk at a determiner
  &lt;DT|JJ&gt;{}&lt;NN.*&gt;    # merge chunk ending with det/adj
                     # with one starting with a noun
</pre></div>
</div>
<p>The patterns of a clause are executed in order.  An earlier
pattern may introduce a chunk boundary that prevents a later
pattern from executing.  Sometimes an individual pattern will
match on multiple, overlapping extents of the input.  As with
regular expression substitution more generally, the chunker will
identify the first match possible, then continue looking for matches
after this one has ended.</p>
<p>The clauses of a grammar are also executed in order.  A cascaded
chunk parser is one having more than one clause.  The maximum depth
of a parse tree created by this chunk parser is the same as the
number of clauses in the grammar.</p>
<p>When tracing is turned on, the comment portion of a line is displayed
each time the corresponding pattern is applied.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><ul class="first last simple">
<li><strong>_start</strong> &#8211; The start symbol of the grammar (the root node of
resulting trees)</li>
<li><strong>_stages</strong> &#8211; The list of parsing stages corresponding to the grammar</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="nltk.chunk.regexp.RegexpParser.parse">
<tt class="descname">parse</tt><big>(</big><em>chunk_struct</em>, <em>trace=None</em><big>)</big><a class="reference internal" href="../_modules/nltk/chunk/regexp.html#RegexpParser.parse"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.regexp.RegexpParser.parse" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply the chunk parser to this input.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>chunk_struct</strong> (<em>Tree</em>) &#8211; the chunk structure to be (further) chunked
(this tree is modified, and is also returned)</li>
<li><strong>trace</strong> (<em>int</em>) &#8211; The level of tracing that should be used when
parsing a text.  <tt class="docutils literal"><span class="pre">0</span></tt> will generate no tracing output;
<tt class="docutils literal"><span class="pre">1</span></tt> will generate normal tracing output; and <tt class="docutils literal"><span class="pre">2</span></tt> or
highter will generate verbose tracing output.  This value
overrides the trace level value that was given to the
constructor.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">the chunked output.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">Tree</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.chunk.regexp.RegexpParser.unicode_repr">
<tt class="descname">unicode_repr</tt><big>(</big><big>)</big><a class="headerlink" href="#nltk.chunk.regexp.RegexpParser.unicode_repr" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a concise string representation of this <tt class="docutils literal"><span class="pre">chunk.RegexpParser</span></tt>.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">str</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.chunk.regexp.SplitRule">
<em class="property">class </em><tt class="descclassname">nltk.chunk.regexp.</tt><tt class="descname">SplitRule</tt><big>(</big><em>left_tag_pattern</em>, <em>right_tag_pattern</em>, <em>descr</em><big>)</big><a class="reference internal" href="../_modules/nltk/chunk/regexp.html#SplitRule"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.regexp.SplitRule" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.chunk.regexp.RegexpChunkRule" title="nltk.chunk.regexp.RegexpChunkRule"><tt class="xref py py-class docutils literal"><span class="pre">nltk.chunk.regexp.RegexpChunkRule</span></tt></a></p>
<p>A rule specifying how to split chunks in a <tt class="docutils literal"><span class="pre">ChunkString</span></tt>, using
two matching tag patterns: a left pattern, and a right pattern.
When applied to a <tt class="docutils literal"><span class="pre">ChunkString</span></tt>, it will find any chunk that
matches the left pattern followed by the right pattern.  It will
then split the chunk into two new chunks, at the point between the
two pattern matches.</p>
<dl class="method">
<dt id="nltk.chunk.regexp.SplitRule.unicode_repr">
<tt class="descname">unicode_repr</tt><big>(</big><big>)</big><a class="headerlink" href="#nltk.chunk.regexp.SplitRule.unicode_repr" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Return a string representation of this rule.  It has the form:</p>
<div class="highlight-python"><div class="highlight"><pre>&lt;SplitRule: &#39;&lt;NN&gt;&#39;, &#39;&lt;DT&gt;&#39;&gt;
</pre></div>
</div>
<p>Note that this representation does not include the
description string; that string can be accessed
separately with the <tt class="docutils literal"><span class="pre">descr()</span></tt> method.</p>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">str</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.chunk.regexp.UnChunkRule">
<em class="property">class </em><tt class="descclassname">nltk.chunk.regexp.</tt><tt class="descname">UnChunkRule</tt><big>(</big><em>tag_pattern</em>, <em>descr</em><big>)</big><a class="reference internal" href="../_modules/nltk/chunk/regexp.html#UnChunkRule"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.regexp.UnChunkRule" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.chunk.regexp.RegexpChunkRule" title="nltk.chunk.regexp.RegexpChunkRule"><tt class="xref py py-class docutils literal"><span class="pre">nltk.chunk.regexp.RegexpChunkRule</span></tt></a></p>
<p>A rule specifying how to remove chunks to a <tt class="docutils literal"><span class="pre">ChunkString</span></tt>,
using a matching tag pattern.  When applied to a
<tt class="docutils literal"><span class="pre">ChunkString</span></tt>, it will find any complete chunk that matches this
tag pattern, and un-chunk it.</p>
<dl class="method">
<dt id="nltk.chunk.regexp.UnChunkRule.unicode_repr">
<tt class="descname">unicode_repr</tt><big>(</big><big>)</big><a class="headerlink" href="#nltk.chunk.regexp.UnChunkRule.unicode_repr" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a string representation of this rule.  It has the form:</p>
<div class="highlight-python"><div class="highlight"><pre>&lt;UnChunkRule: &#39;&lt;IN|VB.*&gt;&#39;&gt;
</pre></div>
</div>
<p>Note that this representation does not include the
description string; that string can be accessed
separately with the <tt class="docutils literal"><span class="pre">descr()</span></tt> method.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">str</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="nltk.chunk.regexp.demo">
<tt class="descclassname">nltk.chunk.regexp.</tt><tt class="descname">demo</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/chunk/regexp.html#demo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.regexp.demo" title="Permalink to this definition">¶</a></dt>
<dd><p>A demonstration for the <tt class="docutils literal"><span class="pre">RegexpChunkParser</span></tt> class.  A single text is
parsed with four different chunk parsers, using a variety of rules
and strategies.</p>
</dd></dl>

<dl class="function">
<dt id="nltk.chunk.regexp.demo_eval">
<tt class="descclassname">nltk.chunk.regexp.</tt><tt class="descname">demo_eval</tt><big>(</big><em>chunkparser</em>, <em>text</em><big>)</big><a class="reference internal" href="../_modules/nltk/chunk/regexp.html#demo_eval"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.regexp.demo_eval" title="Permalink to this definition">¶</a></dt>
<dd><p>Demonstration code for evaluating a chunk parser, using a
<tt class="docutils literal"><span class="pre">ChunkScore</span></tt>.  This function assumes that <tt class="docutils literal"><span class="pre">text</span></tt> contains one
sentence per line, and that each sentence has the form expected by
<tt class="docutils literal"><span class="pre">tree.chunk</span></tt>.  It runs the given chunk parser on each sentence in
the text, and scores the result.  It prints the final score
(precision, recall, and f-measure); and reports the set of chunks
that were missed and the set of chunks that were incorrect.  (At
most 10 missing chunks and 10 incorrect chunks are reported).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>chunkparser</strong> (<em>ChunkParserI</em>) &#8211; The chunkparser to be tested</li>
<li><strong>text</strong> (<em>str</em>) &#8211; The chunked tagged text that should be used for
evaluation.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="nltk.chunk.regexp.tag_pattern2re_pattern">
<tt class="descclassname">nltk.chunk.regexp.</tt><tt class="descname">tag_pattern2re_pattern</tt><big>(</big><em>tag_pattern</em><big>)</big><a class="reference internal" href="../_modules/nltk/chunk/regexp.html#tag_pattern2re_pattern"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.regexp.tag_pattern2re_pattern" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a tag pattern to a regular expression pattern.  A &#8220;tag
pattern&#8221; is a modified version of a regular expression, designed
for matching sequences of tags.  The differences between regular
expression patterns and tag patterns are:</p>
<blockquote>
<div><ul class="simple">
<li>In tag patterns, <tt class="docutils literal"><span class="pre">'&lt;'</span></tt> and <tt class="docutils literal"><span class="pre">'&gt;'</span></tt> act as parentheses; so
<tt class="docutils literal"><span class="pre">'&lt;NN&gt;+'</span></tt> matches one or more repetitions of <tt class="docutils literal"><span class="pre">'&lt;NN&gt;'</span></tt>, not
<tt class="docutils literal"><span class="pre">'&lt;NN'</span></tt> followed by one or more repetitions of <tt class="docutils literal"><span class="pre">'&gt;'</span></tt>.</li>
<li>Whitespace in tag patterns is ignored.  So
<tt class="docutils literal"><span class="pre">'&lt;DT&gt;</span> <span class="pre">|</span> <span class="pre">&lt;NN&gt;'</span></tt> is equivalant to <tt class="docutils literal"><span class="pre">'&lt;DT&gt;|&lt;NN&gt;'</span></tt></li>
<li>In tag patterns, <tt class="docutils literal"><span class="pre">'.'</span></tt> is equivalant to <tt class="docutils literal"><span class="pre">'[^{}&lt;&gt;]'</span></tt>; so
<tt class="docutils literal"><span class="pre">'&lt;NN.*&gt;'</span></tt> matches any single tag starting with <tt class="docutils literal"><span class="pre">'NN'</span></tt>.</li>
</ul>
</div></blockquote>
<p>In particular, <tt class="docutils literal"><span class="pre">tag_pattern2re_pattern</span></tt> performs the following
transformations on the given pattern:</p>
<blockquote>
<div><ul class="simple">
<li>Replace &#8216;.&#8217; with &#8216;[^&lt;&gt;{}]&#8217;</li>
<li>Remove any whitespace</li>
<li>Add extra parens around &#8216;&lt;&#8217; and &#8216;&gt;&#8217;, to make &#8216;&lt;&#8217; and &#8216;&gt;&#8217; act
like parentheses.  E.g., so that in &#8216;&lt;NN&gt;+&#8217;, the &#8216;+&#8217; has scope
over the entire &#8216;&lt;NN&gt;&#8217;; and so that in &#8216;&lt;NN|IN&gt;&#8217;, the &#8216;|&#8217; has
scope over &#8216;NN&#8217; and &#8216;IN&#8217;, but not &#8216;&lt;&#8217; or &#8216;&gt;&#8217;.</li>
<li>Check to make sure the resulting pattern is valid.</li>
</ul>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>tag_pattern</strong> (<em>str</em>) &#8211; The tag pattern to convert to a regular
expression pattern.</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Raises ValueError:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body">If <tt class="docutils literal"><span class="pre">tag_pattern</span></tt> is not a valid tag pattern.
In particular, <tt class="docutils literal"><span class="pre">tag_pattern</span></tt> should not include braces; and it
should not contain nested or mismatched angle-brackets.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">str</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A regular expression pattern corresponding to
<tt class="docutils literal"><span class="pre">tag_pattern</span></tt>.</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-nltk.chunk.util">
<span id="nltk-chunk-util-module"></span><h2>nltk.chunk.util module<a class="headerlink" href="#module-nltk.chunk.util" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="nltk.chunk.util.ChunkScore">
<em class="property">class </em><tt class="descclassname">nltk.chunk.util.</tt><tt class="descname">ChunkScore</tt><big>(</big><em>**kwargs</em><big>)</big><a class="reference internal" href="../_modules/nltk/chunk/util.html#ChunkScore"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.util.ChunkScore" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">builtins.object</span></tt></p>
<p>A utility class for scoring chunk parsers.  <tt class="docutils literal"><span class="pre">ChunkScore</span></tt> can
evaluate a chunk parser&#8217;s output, based on a number of statistics
(precision, recall, f-measure, misssed chunks, incorrect chunks).
It can also combine the scores from the parsing of multiple texts;
this makes it significantly easier to evaluate a chunk parser that
operates one sentence at a time.</p>
<p>Texts are evaluated with the <tt class="docutils literal"><span class="pre">score</span></tt> method.  The results of
evaluation can be accessed via a number of accessor methods, such
as <tt class="docutils literal"><span class="pre">precision</span></tt> and <tt class="docutils literal"><span class="pre">f_measure</span></tt>.  A typical use of the
<tt class="docutils literal"><span class="pre">ChunkScore</span></tt> class is:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">chunkscore</span> <span class="o">=</span> <span class="n">ChunkScore</span><span class="p">()</span>           
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">correct</span> <span class="ow">in</span> <span class="n">correct_sentences</span><span class="p">:</span>   
<span class="gp">... </span>    <span class="n">guess</span> <span class="o">=</span> <span class="n">chunkparser</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">correct</span><span class="o">.</span><span class="n">leaves</span><span class="p">())</span>   
<span class="gp">... </span>    <span class="n">chunkscore</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="n">correct</span><span class="p">,</span> <span class="n">guess</span><span class="p">)</span>              
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="s">&#39;F Measure:&#39;</span><span class="p">,</span> <span class="n">chunkscore</span><span class="o">.</span><span class="n">f_measure</span><span class="p">())</span>       
<span class="go">F Measure: 0.823</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><ul class="first last simple">
<li><strong>kwargs</strong> &#8211; <p>Keyword arguments:</p>
<ul>
<li>max_tp_examples: The maximum number actual examples of true
positives to record.  This affects the <tt class="docutils literal"><span class="pre">correct</span></tt> member
function: <tt class="docutils literal"><span class="pre">correct</span></tt> will not return more than this number
of true positive examples.  This does <em>not</em> affect any of
the numerical metrics (precision, recall, or f-measure)</li>
<li>max_fp_examples: The maximum number actual examples of false
positives to record.  This affects the <tt class="docutils literal"><span class="pre">incorrect</span></tt> member
function and the <tt class="docutils literal"><span class="pre">guessed</span></tt> member function: <tt class="docutils literal"><span class="pre">incorrect</span></tt>
will not return more than this number of examples, and
<tt class="docutils literal"><span class="pre">guessed</span></tt> will not return more than this number of true
positive examples.  This does <em>not</em> affect any of the
numerical metrics (precision, recall, or f-measure)</li>
<li>max_fn_examples: The maximum number actual examples of false
negatives to record.  This affects the <tt class="docutils literal"><span class="pre">missed</span></tt> member
function and the <tt class="docutils literal"><span class="pre">correct</span></tt> member function: <tt class="docutils literal"><span class="pre">missed</span></tt>
will not return more than this number of examples, and
<tt class="docutils literal"><span class="pre">correct</span></tt> will not return more than this number of true
negative examples.  This does <em>not</em> affect any of the
numerical metrics (precision, recall, or f-measure)</li>
<li>chunk_label: A regular expression indicating which chunks
should be compared.  Defaults to <tt class="docutils literal"><span class="pre">'.*'</span></tt> (i.e., all chunks).</li>
</ul>
</li>
<li><strong>_tp</strong> &#8211; List of true positives</li>
<li><strong>_fp</strong> &#8211; List of false positives</li>
<li><strong>_fn</strong> &#8211; List of false negatives</li>
<li><strong>_tp_num</strong> &#8211; Number of true positives</li>
<li><strong>_fp_num</strong> &#8211; Number of false positives</li>
<li><strong>_fn_num</strong> &#8211; Number of false negatives.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="nltk.chunk.util.ChunkScore.accuracy">
<tt class="descname">accuracy</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/chunk/util.html#ChunkScore.accuracy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.util.ChunkScore.accuracy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the overall tag-based accuracy for all text that have
been scored by this <tt class="docutils literal"><span class="pre">ChunkScore</span></tt>, using the IOB (conll2000)
tag encoding.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">float</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.chunk.util.ChunkScore.correct">
<tt class="descname">correct</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/chunk/util.html#ChunkScore.correct"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.util.ChunkScore.correct" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the chunks which were included in the correct
chunk structures, listed in input order.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">list of chunks</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.chunk.util.ChunkScore.f_measure">
<tt class="descname">f_measure</tt><big>(</big><em>alpha=0.5</em><big>)</big><a class="reference internal" href="../_modules/nltk/chunk/util.html#ChunkScore.f_measure"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.util.ChunkScore.f_measure" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the overall F measure for all texts that have been
scored by this <tt class="docutils literal"><span class="pre">ChunkScore</span></tt>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>alpha</strong> (<em>float</em>) &#8211; the relative weighting of precision and recall.
Larger alpha biases the score towards the precision value,
while smaller alpha biases the score towards the recall
value.  <tt class="docutils literal"><span class="pre">alpha</span></tt> should have a value in the range [0,1].</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">float</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.chunk.util.ChunkScore.guessed">
<tt class="descname">guessed</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/chunk/util.html#ChunkScore.guessed"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.util.ChunkScore.guessed" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the chunks which were included in the guessed
chunk structures, listed in input order.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">list of chunks</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.chunk.util.ChunkScore.incorrect">
<tt class="descname">incorrect</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/chunk/util.html#ChunkScore.incorrect"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.util.ChunkScore.incorrect" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the chunks which were included in the guessed chunk structures,
but not in the correct chunk structures, listed in input order.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">list of chunks</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.chunk.util.ChunkScore.missed">
<tt class="descname">missed</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/chunk/util.html#ChunkScore.missed"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.util.ChunkScore.missed" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the chunks which were included in the
correct chunk structures, but not in the guessed chunk
structures, listed in input order.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">list of chunks</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.chunk.util.ChunkScore.precision">
<tt class="descname">precision</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/chunk/util.html#ChunkScore.precision"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.util.ChunkScore.precision" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the overall precision for all texts that have been
scored by this <tt class="docutils literal"><span class="pre">ChunkScore</span></tt>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">float</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.chunk.util.ChunkScore.recall">
<tt class="descname">recall</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/chunk/util.html#ChunkScore.recall"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.util.ChunkScore.recall" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the overall recall for all texts that have been
scored by this <tt class="docutils literal"><span class="pre">ChunkScore</span></tt>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">float</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.chunk.util.ChunkScore.score">
<tt class="descname">score</tt><big>(</big><em>correct</em>, <em>guessed</em><big>)</big><a class="reference internal" href="../_modules/nltk/chunk/util.html#ChunkScore.score"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.util.ChunkScore.score" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a correctly chunked sentence, score another chunked
version of the same sentence.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>correct</strong> (<em>chunk structure</em>) &#8211; The known-correct (&#8220;gold standard&#8221;) chunked
sentence.</li>
<li><strong>guessed</strong> (<em>chunk structure</em>) &#8211; The chunked sentence to be scored.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="nltk.chunk.util.accuracy">
<tt class="descclassname">nltk.chunk.util.</tt><tt class="descname">accuracy</tt><big>(</big><em>chunker</em>, <em>gold</em><big>)</big><a class="reference internal" href="../_modules/nltk/chunk/util.html#accuracy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.util.accuracy" title="Permalink to this definition">¶</a></dt>
<dd><p>Score the accuracy of the chunker against the gold standard.
Strip the chunk information from the gold standard and rechunk it using
the chunker, then compute the accuracy score.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>chunker</strong> (<em>ChunkParserI</em>) &#8211; The chunker being evaluated.</li>
<li><strong>gold</strong> (<em>tree</em>) &#8211; The chunk structures to score the chunker on.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">float</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="nltk.chunk.util.conllstr2tree">
<tt class="descclassname">nltk.chunk.util.</tt><tt class="descname">conllstr2tree</tt><big>(</big><em>s</em>, <em>chunk_types=('NP'</em>, <em>'PP'</em>, <em>'VP')</em>, <em>root_label='S'</em><big>)</big><a class="reference internal" href="../_modules/nltk/chunk/util.html#conllstr2tree"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.util.conllstr2tree" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a chunk structure for a single sentence
encoded in the given CONLL 2000 style string.
This function converts a CoNLL IOB string into a tree.
It uses the specified chunk types
(defaults to NP, PP and VP), and creates a tree rooted at a node
labeled S (by default).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>s</strong> (<em>str</em>) &#8211; The CoNLL string to be converted.</li>
<li><strong>chunk_types</strong> (<em>tuple</em>) &#8211; The chunk types to be converted.</li>
<li><strong>root_label</strong> (<em>str</em>) &#8211; The node label to use for the root.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">Tree</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="nltk.chunk.util.conlltags2tree">
<tt class="descclassname">nltk.chunk.util.</tt><tt class="descname">conlltags2tree</tt><big>(</big><em>sentence</em>, <em>chunk_types=('NP'</em>, <em>'PP'</em>, <em>'VP')</em>, <em>root_label='S'</em>, <em>strict=False</em><big>)</big><a class="reference internal" href="../_modules/nltk/chunk/util.html#conlltags2tree"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.util.conlltags2tree" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the CoNLL IOB format to a tree.</p>
</dd></dl>

<dl class="function">
<dt id="nltk.chunk.util.demo">
<tt class="descclassname">nltk.chunk.util.</tt><tt class="descname">demo</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/chunk/util.html#demo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.util.demo" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="nltk.chunk.util.ieerstr2tree">
<tt class="descclassname">nltk.chunk.util.</tt><tt class="descname">ieerstr2tree</tt><big>(</big><em>s, chunk_types=['LOCATION', 'ORGANIZATION', 'PERSON', 'DURATION', 'DATE', 'CARDINAL', 'PERCENT', 'MONEY', 'MEASURE'], root_label='S'</em><big>)</big><a class="reference internal" href="../_modules/nltk/chunk/util.html#ieerstr2tree"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.util.ieerstr2tree" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a chunk structure containing the chunked tagged text that is
encoded in the given IEER style string.
Convert a string of chunked tagged text in the IEER named
entity format into a chunk structure.  Chunks are of several
types, LOCATION, ORGANIZATION, PERSON, DURATION, DATE, CARDINAL,
PERCENT, MONEY, and MEASURE.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">Tree</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="nltk.chunk.util.tagstr2tree">
<tt class="descclassname">nltk.chunk.util.</tt><tt class="descname">tagstr2tree</tt><big>(</big><em>s</em>, <em>chunk_label='NP'</em>, <em>root_label='S'</em>, <em>sep='/'</em><big>)</big><a class="reference internal" href="../_modules/nltk/chunk/util.html#tagstr2tree"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.util.tagstr2tree" title="Permalink to this definition">¶</a></dt>
<dd><p>Divide a string of bracketted tagged text into
chunks and unchunked tokens, and produce a Tree.
Chunks are marked by square brackets (<tt class="docutils literal"><span class="pre">[...]</span></tt>).  Words are
delimited by whitespace, and each word should have the form
<tt class="docutils literal"><span class="pre">text/tag</span></tt>.  Words that do not contain a slash are
assigned a <tt class="docutils literal"><span class="pre">tag</span></tt> of None.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>s</strong> (<em>str</em>) &#8211; The string to be converted</li>
<li><strong>chunk_label</strong> (<em>str</em>) &#8211; The label to use for chunk nodes</li>
<li><strong>root_label</strong> (<em>str</em>) &#8211; The label to use for the root of the tree</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">Tree</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="nltk.chunk.util.tree2conllstr">
<tt class="descclassname">nltk.chunk.util.</tt><tt class="descname">tree2conllstr</tt><big>(</big><em>t</em><big>)</big><a class="reference internal" href="../_modules/nltk/chunk/util.html#tree2conllstr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.util.tree2conllstr" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a multiline string where each line contains a word, tag and IOB tag.
Convert a tree to the CoNLL IOB string format</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>t</strong> (<em>Tree</em>) &#8211; The tree to be converted.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">str</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="nltk.chunk.util.tree2conlltags">
<tt class="descclassname">nltk.chunk.util.</tt><tt class="descname">tree2conlltags</tt><big>(</big><em>t</em><big>)</big><a class="reference internal" href="../_modules/nltk/chunk/util.html#tree2conlltags"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.util.tree2conlltags" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of 3-tuples containing <tt class="docutils literal"><span class="pre">(word,</span> <span class="pre">tag,</span> <span class="pre">IOB-tag)</span></tt>.
Convert a tree to the CoNLL IOB tag format.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>t</strong> (<em>Tree</em>) &#8211; The tree to be converted.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">list(tuple)</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-nltk.chunk">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-nltk.chunk" title="Permalink to this headline">¶</a></h2>
<p>Classes and interfaces for identifying non-overlapping linguistic
groups (such as base noun phrases) in unrestricted text.  This task is
called &#8220;chunk parsing&#8221; or &#8220;chunking&#8221;, and the identified groups are
called &#8220;chunks&#8221;.  The chunked text is represented using a shallow
tree called a &#8220;chunk structure.&#8221;  A chunk structure is a tree
containing tokens and chunks, where each chunk is a subtree containing
only tokens.  For example, the chunk structure for base noun phrase
chunks in the sentence &#8220;I saw the big dog on the hill&#8221; is:</p>
<div class="highlight-python"><div class="highlight"><pre>(SENTENCE:
  (NP: &lt;I&gt;)
  &lt;saw&gt;
  (NP: &lt;the&gt; &lt;big&gt; &lt;dog&gt;)
  &lt;on&gt;
  (NP: &lt;the&gt; &lt;hill&gt;))
</pre></div>
</div>
<p>To convert a chunk structure back to a list of tokens, simply use the
chunk structure&#8217;s <tt class="docutils literal"><span class="pre">leaves()</span></tt> method.</p>
<p>This module defines <tt class="docutils literal"><span class="pre">ChunkParserI</span></tt>, a standard interface for
chunking texts; and <tt class="docutils literal"><span class="pre">RegexpChunkParser</span></tt>, a regular-expression based
implementation of that interface. It also defines <tt class="docutils literal"><span class="pre">ChunkScore</span></tt>, a
utility class for scoring chunk parsers.</p>
<div class="section" id="regexpchunkparser">
<h3>RegexpChunkParser<a class="headerlink" href="#regexpchunkparser" title="Permalink to this headline">¶</a></h3>
<p><tt class="docutils literal"><span class="pre">RegexpChunkParser</span></tt> is an implementation of the chunk parser interface
that uses regular-expressions over tags to chunk a text.  Its
<tt class="docutils literal"><span class="pre">parse()</span></tt> method first constructs a <tt class="docutils literal"><span class="pre">ChunkString</span></tt>, which encodes a
particular chunking of the input text.  Initially, nothing is
chunked.  <tt class="docutils literal"><span class="pre">parse.RegexpChunkParser</span></tt> then applies a sequence of
<tt class="docutils literal"><span class="pre">RegexpChunkRule</span></tt> rules to the <tt class="docutils literal"><span class="pre">ChunkString</span></tt>, each of which modifies
the chunking that it encodes.  Finally, the <tt class="docutils literal"><span class="pre">ChunkString</span></tt> is
transformed back into a chunk structure, which is returned.</p>
<p><tt class="docutils literal"><span class="pre">RegexpChunkParser</span></tt> can only be used to chunk a single kind of phrase.
For example, you can use an <tt class="docutils literal"><span class="pre">RegexpChunkParser</span></tt> to chunk the noun
phrases in a text, or the verb phrases in a text; but you can not
use it to simultaneously chunk both noun phrases and verb phrases in
the same text.  (This is a limitation of <tt class="docutils literal"><span class="pre">RegexpChunkParser</span></tt>, not of
chunk parsers in general.)</p>
<div class="section" id="regexpchunkrules">
<h4>RegexpChunkRules<a class="headerlink" href="#regexpchunkrules" title="Permalink to this headline">¶</a></h4>
<p>A <tt class="docutils literal"><span class="pre">RegexpChunkRule</span></tt> is a transformational rule that updates the
chunking of a text by modifying its <tt class="docutils literal"><span class="pre">ChunkString</span></tt>.  Each
<tt class="docutils literal"><span class="pre">RegexpChunkRule</span></tt> defines the <tt class="docutils literal"><span class="pre">apply()</span></tt> method, which modifies
the chunking encoded by a <tt class="docutils literal"><span class="pre">ChunkString</span></tt>.  The
<tt class="docutils literal"><span class="pre">RegexpChunkRule</span></tt> class itself can be used to implement any
transformational rule based on regular expressions.  There are
also a number of subclasses, which can be used to implement
simpler types of rules:</p>
<blockquote>
<div><ul class="simple">
<li><tt class="docutils literal"><span class="pre">ChunkRule</span></tt> chunks anything that matches a given regular
expression.</li>
<li><tt class="docutils literal"><span class="pre">ChinkRule</span></tt> chinks anything that matches a given regular
expression.</li>
<li><tt class="docutils literal"><span class="pre">UnChunkRule</span></tt> will un-chunk any chunk that matches a given
regular expression.</li>
<li><tt class="docutils literal"><span class="pre">MergeRule</span></tt> can be used to merge two contiguous chunks.</li>
<li><tt class="docutils literal"><span class="pre">SplitRule</span></tt> can be used to split a single chunk into two
smaller chunks.</li>
<li><tt class="docutils literal"><span class="pre">ExpandLeftRule</span></tt> will expand a chunk to incorporate new
unchunked material on the left.</li>
<li><tt class="docutils literal"><span class="pre">ExpandRightRule</span></tt> will expand a chunk to incorporate new
unchunked material on the right.</li>
</ul>
</div></blockquote>
<div class="section" id="tag-patterns">
<h5>Tag Patterns<a class="headerlink" href="#tag-patterns" title="Permalink to this headline">¶</a></h5>
<p>A <tt class="docutils literal"><span class="pre">RegexpChunkRule</span></tt> uses a modified version of regular
expression patterns, called &#8220;tag patterns&#8221;.  Tag patterns are
used to match sequences of tags.  Examples of tag patterns are:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="s">r&#39;(&lt;DT&gt;|&lt;JJ&gt;|&lt;NN&gt;)+&#39;</span>
<span class="s">r&#39;&lt;NN&gt;+&#39;</span>
<span class="s">r&#39;&lt;NN.*&gt;&#39;</span>
</pre></div>
</div>
<p>The differences between regular expression patterns and tag
patterns are:</p>
<blockquote>
<div><ul class="simple">
<li>In tag patterns, <tt class="docutils literal"><span class="pre">'&lt;'</span></tt> and <tt class="docutils literal"><span class="pre">'&gt;'</span></tt> act as parentheses; so
<tt class="docutils literal"><span class="pre">'&lt;NN&gt;+'</span></tt> matches one or more repetitions of <tt class="docutils literal"><span class="pre">'&lt;NN&gt;'</span></tt>, not
<tt class="docutils literal"><span class="pre">'&lt;NN'</span></tt> followed by one or more repetitions of <tt class="docutils literal"><span class="pre">'&gt;'</span></tt>.</li>
<li>Whitespace in tag patterns is ignored.  So
<tt class="docutils literal"><span class="pre">'&lt;DT&gt;</span> <span class="pre">|</span> <span class="pre">&lt;NN&gt;'</span></tt> is equivalant to <tt class="docutils literal"><span class="pre">'&lt;DT&gt;|&lt;NN&gt;'</span></tt></li>
<li>In tag patterns, <tt class="docutils literal"><span class="pre">'.'</span></tt> is equivalant to <tt class="docutils literal"><span class="pre">'[^{}&lt;&gt;]'</span></tt>; so
<tt class="docutils literal"><span class="pre">'&lt;NN.*&gt;'</span></tt> matches any single tag starting with <tt class="docutils literal"><span class="pre">'NN'</span></tt>.</li>
</ul>
</div></blockquote>
<p>The function <tt class="docutils literal"><span class="pre">tag_pattern2re_pattern</span></tt> can be used to transform
a tag pattern to an equivalent regular expression pattern.</p>
</div>
</div>
<div class="section" id="efficiency">
<h4>Efficiency<a class="headerlink" href="#efficiency" title="Permalink to this headline">¶</a></h4>
<p>Preliminary tests indicate that <tt class="docutils literal"><span class="pre">RegexpChunkParser</span></tt> can chunk at a
rate of about 300 tokens/second, with a moderately complex rule set.</p>
<p>There may be problems if <tt class="docutils literal"><span class="pre">RegexpChunkParser</span></tt> is used with more than
5,000 tokens at a time.  In particular, evaluation of some regular
expressions may cause the Python regular expression engine to
exceed its maximum recursion depth.  We have attempted to minimize
these problems, but it is impossible to avoid them completely.  We
therefore recommend that you apply the chunk parser to a single
sentence at a time.</p>
</div>
<div class="section" id="emacs-tip">
<h4>Emacs Tip<a class="headerlink" href="#emacs-tip" title="Permalink to this headline">¶</a></h4>
<p>If you evaluate the following elisp expression in emacs, it will
colorize a <tt class="docutils literal"><span class="pre">ChunkString</span></tt> when you use an interactive python shell
with emacs or xemacs (&#8220;C-c !&#8221;):</p>
<div class="highlight-python"><div class="highlight"><pre>(let ()
  (defconst comint-mode-font-lock-keywords
    &#39;((&quot;&lt;[^&gt;]+&gt;&quot; 0 &#39;font-lock-reference-face)
      (&quot;[{}]&quot; 0 &#39;font-lock-function-name-face)))
  (add-hook &#39;comint-mode-hook (lambda () (turn-on-font-lock))))
</pre></div>
</div>
<p>You can evaluate this code by copying it to a temporary buffer,
placing the cursor after the last close parenthesis, and typing
&#8220;<tt class="docutils literal"><span class="pre">C-x</span> <span class="pre">C-e</span></tt>&#8221;.  You should evaluate it before running the interactive
session.  The change will last until you close emacs.</p>
</div>
<div class="section" id="unresolved-issues">
<h4>Unresolved Issues<a class="headerlink" href="#unresolved-issues" title="Permalink to this headline">¶</a></h4>
<p>If we use the <tt class="docutils literal"><span class="pre">re</span></tt> module for regular expressions, Python&#8217;s
regular expression engine generates &#8220;maximum recursion depth
exceeded&#8221; errors when processing very large texts, even for
regular expressions that should not require any recursion.  We
therefore use the <tt class="docutils literal"><span class="pre">pre</span></tt> module instead.  But note that <tt class="docutils literal"><span class="pre">pre</span></tt>
does not include Unicode support, so this module will not work
with unicode strings.  Note also that <tt class="docutils literal"><span class="pre">pre</span></tt> regular expressions
are not quite as advanced as <tt class="docutils literal"><span class="pre">re</span></tt> ones (e.g., no leftward
zero-length assertions).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">type CHUNK_TAG_PATTERN:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body">regexp</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">var CHUNK_TAG_PATTERN:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body">A regular expression to test whether a tag
pattern is valid.</td>
</tr>
</tbody>
</table>
<dl class="function">
<dt id="nltk.chunk.ne_chunk">
<tt class="descclassname">nltk.chunk.</tt><tt class="descname">ne_chunk</tt><big>(</big><em>tagged_tokens</em>, <em>binary=False</em><big>)</big><a class="reference internal" href="../_modules/nltk/chunk.html#ne_chunk"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.ne_chunk" title="Permalink to this definition">¶</a></dt>
<dd><p>Use NLTK&#8217;s currently recommended named entity chunker to
chunk the given list of tagged tokens.</p>
</dd></dl>

<dl class="function">
<dt id="nltk.chunk.ne_chunk_sents">
<tt class="descclassname">nltk.chunk.</tt><tt class="descname">ne_chunk_sents</tt><big>(</big><em>tagged_sentences</em>, <em>binary=False</em><big>)</big><a class="reference internal" href="../_modules/nltk/chunk.html#ne_chunk_sents"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.chunk.ne_chunk_sents" title="Permalink to this definition">¶</a></dt>
<dd><p>Use NLTK&#8217;s currently recommended named entity chunker to chunk the
given list of tagged sentences, each consisting of a list of tagged tokens.</p>
</dd></dl>

</div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
        </div>
        <div class="sidebar">
          <h3>Table Of Contents</h3>
          <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../news.html">NLTK News</a></li>
<li class="toctree-l1"><a class="reference internal" href="../install.html">Installing NLTK</a></li>
<li class="toctree-l1"><a class="reference internal" href="../data.html">Installing NLTK Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contribute.html">Contribute to NLTK</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/nltk/nltk/wiki/FAQ">FAQ</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/nltk/nltk/wiki">Wiki</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="nltk.html">API</a></li>
<li class="toctree-l1"><a class="reference external" href="http://www.nltk.org/howto">HOWTO</a></li>
</ul>

          <h3 style="margin-top: 1.5em;">Search</h3>
          <form class="search" action="../search.html" method="get">
            <input type="text" name="q" />
            <input type="submit" value="Go" />
            <input type="hidden" name="check_keywords" value="yes" />
            <input type="hidden" name="area" value="default" />
          </form>
          <p class="searchtip" style="font-size: 90%">
            Enter search terms or a module, class or function name.
          </p>
        </div>
        <div class="clearer"></div>
      </div>
    </div>

    <div class="footer-wrapper">
      <div class="footer">
        <div class="left">
          <a href="nltk.chat.html" title="nltk.chat package"
             >previous</a> |
          <a href="nltk.classify.html" title="nltk.classify package"
             >next</a> |
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |
          <a href="../genindex.html" title="General Index"
             >index</a>
            <br/>
            <a href="../_sources/api/nltk.chunk.txt"
               rel="nofollow">Show Source</a>
        </div>

        <div class="right">
          
    <div class="footer">
        &copy; Copyright 2013, NLTK Project.
      Last updated on Aug 21, 2014.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
        </div>
        <div class="clearer"></div>
      </div>
    </div>

  </body>
</html>