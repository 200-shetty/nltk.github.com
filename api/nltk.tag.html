

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>tag Package &mdash; NLTK 2.0 documentation</title>
    
    <link rel="stylesheet" href="../_static/agogo.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="NLTK 2.0 documentation" href="../index.html" />
    <link rel="up" title="nltk Package" href="nltk.html" />
    <link rel="next" title="test Package" href="nltk.test.html" />
    <link rel="prev" title="stem Package" href="nltk.stem.html" /> 
  </head>
  <body>
    <div class="header-wrapper">
      <div class="header">
        <div class="headertitle"><a
          href="../index.html">NLTK 2.0 documentation</a></div>
        <div class="rel">
          <a href="nltk.stem.html" title="stem Package"
             accesskey="P">previous</a> |
          <a href="nltk.test.html" title="test Package"
             accesskey="N">next</a> |
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a>
        </div>
       </div>
    </div>

    <div class="content-wrapper">
      <div class="content">
        <div class="document">
            
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="tag-package">
<h1>tag Package<a class="headerlink" href="#tag-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="id1">
<h2><tt class="xref py py-mod docutils literal"><span class="pre">tag</span></tt> Package<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<span class="target" id="module-nltk.tag"></span><p>NLTK Taggers</p>
<p>This package contains classes and interfaces for part-of-speech
tagging, or simply &#8220;tagging&#8221;.</p>
<p>A &#8220;tag&#8221; is a case-sensitive string that specifies some property of a token,
such as its part of speech.  Tagged tokens are encoded as tuples
<tt class="docutils literal"><span class="pre">(tag,</span> <span class="pre">token)</span></tt>.  For example, the following tagged token combines
the word <tt class="docutils literal"><span class="pre">'fly'</span></tt> with a noun part of speech tag (<tt class="docutils literal"><span class="pre">'NN'</span></tt>):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">tagged_tok</span> <span class="o">=</span> <span class="p">(</span><span class="s">&#39;fly&#39;</span><span class="p">,</span> <span class="s">&#39;NN&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>An off-the-shelf tagger is available.  It uses the Penn Treebank tagset:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">nltk.tag</span> <span class="kn">import</span> <span class="n">pos_tag</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">nltk.tokenize</span> <span class="kn">import</span> <span class="n">word_tokenize</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pos_tag</span><span class="p">(</span><span class="n">word_tokenize</span><span class="p">(</span><span class="s">&quot;John&#39;s big idea isn&#39;t all that bad.&quot;</span><span class="p">))</span>
<span class="go">[(&#39;John&#39;, &#39;NNP&#39;), (&quot;&#39;s&quot;, &#39;POS&#39;), (&#39;big&#39;, &#39;JJ&#39;), (&#39;idea&#39;, &#39;NN&#39;), (&#39;is&#39;,</span>
<span class="go">&#39;VBZ&#39;), (&quot;n&#39;t&quot;, &#39;RB&#39;), (&#39;all&#39;, &#39;DT&#39;), (&#39;that&#39;, &#39;DT&#39;), (&#39;bad&#39;, &#39;JJ&#39;),</span>
<span class="go">(&#39;.&#39;, &#39;.&#39;)]</span>
</pre></div>
</div>
<p>This package defines several taggers, which take a token list (typically a
sentence), assign a tag to each token, and return the resulting list of
tagged tokens.  Most of the taggers are built automatically based on a
training corpus.  For example, the unigram tagger tags each word <em>w</em>
by checking what the most frequent tag for <em>w</em> was in a training corpus:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">nltk.corpus</span> <span class="kn">import</span> <span class="n">brown</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">nltk.tag</span> <span class="kn">import</span> <span class="n">UnigramTagger</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tagger</span> <span class="o">=</span> <span class="n">UnigramTagger</span><span class="p">(</span><span class="n">brown</span><span class="o">.</span><span class="n">tagged_sents</span><span class="p">(</span><span class="n">categories</span><span class="o">=</span><span class="s">&#39;news&#39;</span><span class="p">)[:</span><span class="mi">500</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tagger</span><span class="o">.</span><span class="n">tag</span><span class="p">([</span><span class="s">&#39;Mitchell&#39;</span><span class="p">,</span> <span class="s">&#39;decried&#39;</span><span class="p">,</span> <span class="s">&#39;the&#39;</span><span class="p">,</span> <span class="s">&#39;high&#39;</span><span class="p">,</span> <span class="s">&#39;rate&#39;</span><span class="p">,</span> <span class="s">&#39;of&#39;</span><span class="p">,</span> <span class="s">&#39;unemployment&#39;</span><span class="p">])</span>
<span class="go">[(&#39;Mitchell&#39;, &#39;NP&#39;), (&#39;decried&#39;, None), (&#39;the&#39;, &#39;AT&#39;), (&#39;high&#39;, &#39;JJ&#39;),</span>
<span class="go">(&#39;rate&#39;, &#39;NN&#39;), (&#39;of&#39;, &#39;IN&#39;), (&#39;unemployment&#39;, None)]</span>
</pre></div>
</div>
<p>Note that words that the tagger has not seen during training receive a tag
of <tt class="docutils literal"><span class="pre">None</span></tt>.</p>
<p>We evaluate a tagger on data that was not seen during training:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">tagger</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">brown</span><span class="o">.</span><span class="n">tagged_sents</span><span class="p">(</span><span class="n">categories</span><span class="o">=</span><span class="s">&#39;news&#39;</span><span class="p">)[</span><span class="mi">500</span><span class="p">:</span><span class="mi">600</span><span class="p">])</span> 
<span class="go">0.734...</span>
</pre></div>
</div>
<p>For more information, please consult chapter 5 of the NLTK Book.</p>
<dl class="function">
<dt id="nltk.tag.batch_pos_tag">
<tt class="descclassname">nltk.tag.</tt><tt class="descname">batch_pos_tag</tt><big>(</big><em>sentences</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag.html#batch_pos_tag"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.batch_pos_tag" title="Permalink to this definition">¶</a></dt>
<dd><p>Use NLTK&#8217;s currently recommended part of speech tagger to tag the
given list of sentences, each consisting of a list of tokens.</p>
</dd></dl>

<dl class="function">
<dt id="nltk.tag.pos_tag">
<tt class="descclassname">nltk.tag.</tt><tt class="descname">pos_tag</tt><big>(</big><em>tokens</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag.html#pos_tag"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.pos_tag" title="Permalink to this definition">¶</a></dt>
<dd><p>Use NLTK&#8217;s currently recommended part of speech tagger to
tag the given list of tokens.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">nltk.tag</span> <span class="kn">import</span> <span class="n">pos_tag</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">nltk.tokenize</span> <span class="kn">import</span> <span class="n">word_tokenize</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pos_tag</span><span class="p">(</span><span class="n">word_tokenize</span><span class="p">(</span><span class="s">&quot;John&#39;s big idea isn&#39;t all that bad.&quot;</span><span class="p">))</span>
<span class="go">[(&#39;John&#39;, &#39;NNP&#39;), (&quot;&#39;s&quot;, &#39;POS&#39;), (&#39;big&#39;, &#39;JJ&#39;), (&#39;idea&#39;, &#39;NN&#39;), (&#39;is&#39;,</span>
<span class="go">&#39;VBZ&#39;), (&quot;n&#39;t&quot;, &#39;RB&#39;), (&#39;all&#39;, &#39;DT&#39;), (&#39;that&#39;, &#39;DT&#39;), (&#39;bad&#39;, &#39;JJ&#39;),</span>
<span class="go">(&#39;.&#39;, &#39;.&#39;)]</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>tokens</strong> (<em>list(str)</em>) &#8211; Sequence of tokens to be tagged</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">The tagged tokens</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">list(tuple(str, str))</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-nltk.tag.api">
<span id="api-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">api</span></tt> Module<a class="headerlink" href="#module-nltk.tag.api" title="Permalink to this headline">¶</a></h2>
<p>Interface for tagging each token in a sentence with supplementary
information, such as its part of speech.</p>
<dl class="class">
<dt id="nltk.tag.api.FeaturesetTaggerI">
<em class="property">class </em><tt class="descclassname">nltk.tag.api.</tt><tt class="descname">FeaturesetTaggerI</tt><a class="reference internal" href="../_modules/nltk/tag/api.html#FeaturesetTaggerI"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.api.FeaturesetTaggerI" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.tag.api.TaggerI" title="nltk.tag.api.TaggerI"><tt class="xref py py-class docutils literal"><span class="pre">nltk.tag.api.TaggerI</span></tt></a></p>
<p>A tagger that requires tokens to be <tt class="docutils literal"><span class="pre">featuresets</span></tt>.  A featureset
is a dictionary that maps from feature names to feature
values.  See <tt class="docutils literal"><span class="pre">nltk.classify</span></tt> for more information about features
and featuresets.</p>
</dd></dl>

<dl class="class">
<dt id="nltk.tag.api.HiddenMarkovModelTaggerTransformI">
<em class="property">class </em><tt class="descclassname">nltk.tag.api.</tt><tt class="descname">HiddenMarkovModelTaggerTransformI</tt><a class="reference internal" href="../_modules/nltk/tag/api.html#HiddenMarkovModelTaggerTransformI"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.api.HiddenMarkovModelTaggerTransformI" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>An interface for a transformation to be used as the transform parameter
of <tt class="docutils literal"><span class="pre">HiddenMarkovModelTagger</span></tt>.</p>
<dl class="method">
<dt id="nltk.tag.api.HiddenMarkovModelTaggerTransformI.transform">
<tt class="descname">transform</tt><big>(</big><em>labeled_symbols</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/api.html#HiddenMarkovModelTaggerTransformI.transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.api.HiddenMarkovModelTaggerTransformI.transform" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a list of transformed symbols</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">list</td>
</tr>
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>labeled_symbols</strong> (<em>list</em>) &#8211; a list of labeled untransformed symbols,
i.e. symbols that are not (token, tag) or (word, tag)</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.tag.api.TaggerI">
<em class="property">class </em><tt class="descclassname">nltk.tag.api.</tt><tt class="descname">TaggerI</tt><a class="reference internal" href="../_modules/nltk/tag/api.html#TaggerI"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.api.TaggerI" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>A processing interface for assigning a tag to each token in a list.
Tags are case sensitive strings that identify some property of each
token, such as its part of speech or its sense.</p>
<p>Some taggers require specific types for their tokens.  This is
generally indicated by the use of a sub-interface to <tt class="docutils literal"><span class="pre">TaggerI</span></tt>.
For example, featureset taggers, which are subclassed from
<tt class="docutils literal"><span class="pre">FeaturesetTagger</span></tt>, require that each token be a <tt class="docutils literal"><span class="pre">featureset</span></tt>.</p>
<dl class="docutils">
<dt>Subclasses must define:</dt>
<dd><ul class="first last simple">
<li>either <tt class="docutils literal"><span class="pre">tag()</span></tt> or <tt class="docutils literal"><span class="pre">batch_tag()</span></tt> (or both)</li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="nltk.tag.api.TaggerI.batch_tag">
<tt class="descname">batch_tag</tt><big>(</big><em>sentences</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/api.html#TaggerI.batch_tag"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.api.TaggerI.batch_tag" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply <tt class="docutils literal"><span class="pre">self.tag()</span></tt> to each element of <em>sentences</em>.  I.e.:</p>
<p>return [self.tag(sent) for sent in sentences]</p>
</dd></dl>

<dl class="method">
<dt id="nltk.tag.api.TaggerI.evaluate">
<tt class="descname">evaluate</tt><big>(</big><em>gold</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/api.html#TaggerI.evaluate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.api.TaggerI.evaluate" title="Permalink to this definition">¶</a></dt>
<dd><p>Score the accuracy of the tagger against the gold standard.
Strip the tags from the gold standard text, retag it using
the tagger, then compute the accuracy score.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>gold</strong> (<em>list(list(tuple(str, str)))</em>) &#8211; The list of tagged sentences to score the tagger on.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">float</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.tag.api.TaggerI.tag">
<tt class="descname">tag</tt><big>(</big><em>tokens</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/api.html#TaggerI.tag"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.api.TaggerI.tag" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine the most appropriate tag sequence for the given
token sequence, and return a corresponding list of tagged
tokens.  A tagged token is encoded as a tuple <tt class="docutils literal"><span class="pre">(token,</span> <span class="pre">tag)</span></tt>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">list(tuple(str, str))</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-nltk.tag.brill">
<span id="brill-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">brill</span></tt> Module<a class="headerlink" href="#module-nltk.tag.brill" title="Permalink to this headline">¶</a></h2>
<p>Brill Tagger</p>
<p>The Brill Tagger is a transformational rule-based tagger.
It starts by running an initial tagger, and then
improves the tagging by applying a list of transformation rules.
These transformation rules are automatically learned from the training
corpus, based on one or more &#8220;rule templates.&#8221;</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">nltk.corpus</span> <span class="kn">import</span> <span class="n">brown</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">nltk.tag</span> <span class="kn">import</span> <span class="n">UnigramTagger</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">nltk.tag.brill</span> <span class="kn">import</span> <span class="n">SymmetricProximateTokensTemplate</span><span class="p">,</span> <span class="n">ProximateTokensTemplate</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">nltk.tag.brill</span> <span class="kn">import</span> <span class="n">ProximateTagsRule</span><span class="p">,</span> <span class="n">ProximateWordsRule</span><span class="p">,</span> <span class="n">FastBrillTaggerTrainer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">brown_train</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">brown</span><span class="o">.</span><span class="n">tagged_sents</span><span class="p">(</span><span class="n">categories</span><span class="o">=</span><span class="s">&#39;news&#39;</span><span class="p">)[:</span><span class="mi">500</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">brown_test</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">brown</span><span class="o">.</span><span class="n">tagged_sents</span><span class="p">(</span><span class="n">categories</span><span class="o">=</span><span class="s">&#39;news&#39;</span><span class="p">)[</span><span class="mi">500</span><span class="p">:</span><span class="mi">600</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">unigram_tagger</span> <span class="o">=</span> <span class="n">UnigramTagger</span><span class="p">(</span><span class="n">brown_train</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">templates</span> <span class="o">=</span> <span class="p">[</span>
<span class="gp">... </span>    <span class="n">SymmetricProximateTokensTemplate</span><span class="p">(</span><span class="n">ProximateTagsRule</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)),</span>
<span class="gp">... </span>    <span class="n">SymmetricProximateTokensTemplate</span><span class="p">(</span><span class="n">ProximateTagsRule</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)),</span>
<span class="gp">... </span>    <span class="n">SymmetricProximateTokensTemplate</span><span class="p">(</span><span class="n">ProximateTagsRule</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)),</span>
<span class="gp">... </span>    <span class="n">SymmetricProximateTokensTemplate</span><span class="p">(</span><span class="n">ProximateTagsRule</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)),</span>
<span class="gp">... </span>    <span class="n">SymmetricProximateTokensTemplate</span><span class="p">(</span><span class="n">ProximateWordsRule</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)),</span>
<span class="gp">... </span>    <span class="n">SymmetricProximateTokensTemplate</span><span class="p">(</span><span class="n">ProximateWordsRule</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)),</span>
<span class="gp">... </span>    <span class="n">SymmetricProximateTokensTemplate</span><span class="p">(</span><span class="n">ProximateWordsRule</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)),</span>
<span class="gp">... </span>    <span class="n">SymmetricProximateTokensTemplate</span><span class="p">(</span><span class="n">ProximateWordsRule</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)),</span>
<span class="gp">... </span>    <span class="n">ProximateTokensTemplate</span><span class="p">(</span><span class="n">ProximateTagsRule</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)),</span>
<span class="gp">... </span>    <span class="n">ProximateTokensTemplate</span><span class="p">(</span><span class="n">ProximateWordsRule</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)),</span>
<span class="gp">... </span>    <span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">trainer</span> <span class="o">=</span> <span class="n">FastBrillTaggerTrainer</span><span class="p">(</span><span class="n">initial_tagger</span><span class="o">=</span><span class="n">unigram_tagger</span><span class="p">,</span>
<span class="gp">... </span>                                 <span class="n">templates</span><span class="o">=</span><span class="n">templates</span><span class="p">,</span> <span class="n">trace</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
<span class="gp">... </span>                                 <span class="n">deterministic</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">brill_tagger</span> <span class="o">=</span> <span class="n">trainer</span><span class="o">.</span><span class="n">train</span><span class="p">(</span><span class="n">brown_train</span><span class="p">,</span> <span class="n">max_rules</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="go">Training Brill tagger on 500 sentences...</span>
<span class="go">Finding initial useful rules...</span>
<span class="go">    Found 10210 useful rules.</span>

<span class="go">           B      |</span>
<span class="go">   S   F   r   O  |        Score = Fixed - Broken</span>
<span class="go">   c   i   o   t  |  R     Fixed = num tags changed incorrect -&gt; correct</span>
<span class="go">   o   x   k   h  |  u     Broken = num tags changed correct -&gt; incorrect</span>
<span class="go">   r   e   e   e  |  l     Other = num tags changed incorrect -&gt; incorrect</span>
<span class="go">   e   d   n   r  |  e</span>
<span class="go">------------------+-------------------------------------------------------</span>
<span class="go">  46  46   0   0  | TO -&gt; IN if the tag of the following word is &#39;AT&#39;</span>
<span class="go">  18  20   2   0  | TO -&gt; IN if the tag of words i+1...i+3 is &#39;CD&#39;</span>
<span class="go">  14  14   0   0  | IN -&gt; IN-TL if the tag of the preceding word is</span>
<span class="go">                  |   &#39;NN-TL&#39;, and the tag of the following word is</span>
<span class="go">                  |   &#39;NN-TL&#39;</span>
<span class="go">  11  11   0   1  | TO -&gt; IN if the tag of the following word is &#39;NNS&#39;</span>
<span class="go">  10  10   0   0  | TO -&gt; IN if the tag of the following word is &#39;JJ&#39;</span>
<span class="go">   8   8   0   0  | , -&gt; ,-HL if the tag of the preceding word is &#39;NP-</span>
<span class="go">                  |   HL&#39;</span>
<span class="go">   7   7   0   1  | NN -&gt; VB if the tag of the preceding word is &#39;MD&#39;</span>
<span class="go">   7  13   6   0  | NN -&gt; VB if the tag of the preceding word is &#39;TO&#39;</span>
<span class="go">   7   7   0   0  | NP-TL -&gt; NP if the tag of words i+1...i+2 is &#39;NNS&#39;</span>
<span class="go">   7   7   0   0  | VBN -&gt; VBD if the tag of the preceding word is</span>
<span class="go">                  |   &#39;NP&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">brill_tagger</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">brown_test</span><span class="p">)</span> 
<span class="go">0.742...</span>
</pre></div>
</div>
<dl class="class">
<dt id="nltk.tag.brill.BrillRule">
<em class="property">class </em><tt class="descclassname">nltk.tag.brill.</tt><tt class="descname">BrillRule</tt><big>(</big><em>original_tag</em>, <em>replacement_tag</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/brill.html#BrillRule"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.brill.BrillRule" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">yaml.YAMLObject</span></tt></p>
<p>An interface for tag transformations on a tagged corpus, as
performed by brill taggers.  Each transformation finds all tokens
in the corpus that are tagged with a specific original tag and
satisfy a specific condition, and replaces their tags with a
replacement tag.  For any given transformation, the original
tag, replacement tag, and condition are fixed.  Conditions may
depend on the token under consideration, as well as any other
tokens in the corpus.</p>
<p>Brill rules must be comparable and hashable.</p>
<dl class="method">
<dt id="nltk.tag.brill.BrillRule.applies">
<tt class="descname">applies</tt><big>(</big><em>tokens</em>, <em>index</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/brill.html#BrillRule.applies"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.brill.BrillRule.applies" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">True if the rule would change the tag of
<tt class="docutils literal"><span class="pre">tokens[index]</span></tt>, False otherwise</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">bool</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>tokens</strong> (<em>list(str)</em>) &#8211; A tagged sentence</li>
<li><strong>index</strong> (<em>int</em>) &#8211; The index to check</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.tag.brill.BrillRule.apply">
<tt class="descname">apply</tt><big>(</big><em>tokens</em>, <em>positions=None</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/brill.html#BrillRule.apply"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.brill.BrillRule.apply" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply this rule at every position in positions where it
applies to the given sentence.  I.e., for each position p
in <em>positions</em>, if <em>tokens[p]</em> is tagged with this rule&#8217;s
original tag, and satisfies this rule&#8217;s condition, then set
its tag to be this rule&#8217;s replacement tag.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>tokens</strong> (<em>list(tuple(str, str))</em>) &#8211; The tagged sentence</li>
<li><strong>positions</strong> (<em>list(int)</em>) &#8211; The positions where the transformation is to
be tried.  If not specified, try it at all positions.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The indices of tokens whose tags were changed by this
rule.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">int</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="nltk.tag.brill.BrillRule.original_tag">
<tt class="descname">original_tag</tt><em class="property"> = None</em><a class="headerlink" href="#nltk.tag.brill.BrillRule.original_tag" title="Permalink to this definition">¶</a></dt>
<dd><p>The tag which this BrillRule may cause to be replaced.</p>
</dd></dl>

<dl class="attribute">
<dt id="nltk.tag.brill.BrillRule.replacement_tag">
<tt class="descname">replacement_tag</tt><em class="property"> = None</em><a class="headerlink" href="#nltk.tag.brill.BrillRule.replacement_tag" title="Permalink to this definition">¶</a></dt>
<dd><p>The tag with which this BrillRule may replace another tag.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.tag.brill.BrillTagger">
<em class="property">class </em><tt class="descclassname">nltk.tag.brill.</tt><tt class="descname">BrillTagger</tt><big>(</big><em>initial_tagger</em>, <em>rules</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/brill.html#BrillTagger"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.brill.BrillTagger" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.tag.api.TaggerI" title="nltk.tag.api.TaggerI"><tt class="xref py py-class docutils literal"><span class="pre">nltk.tag.api.TaggerI</span></tt></a>, <tt class="xref py py-class docutils literal"><span class="pre">yaml.YAMLObject</span></tt></p>
<p>Brill&#8217;s transformational rule-based tagger.  Brill taggers use an
initial tagger (such as <tt class="docutils literal"><span class="pre">tag.DefaultTagger</span></tt>) to assign an initial
tag sequence to a text; and then apply an ordered list of
transformational rules to correct the tags of individual tokens.
These transformation rules are specified by the <tt class="docutils literal"><span class="pre">BrillRule</span></tt>
interface.</p>
<p>Brill taggers can be created directly, from an initial tagger and
a list of transformational rules; but more often, Brill taggers
are created by learning rules from a training corpus, using either
<tt class="docutils literal"><span class="pre">BrillTaggerTrainer</span></tt> or <tt class="docutils literal"><span class="pre">FastBrillTaggerTrainer</span></tt>.</p>
<dl class="method">
<dt id="nltk.tag.brill.BrillTagger.rules">
<tt class="descname">rules</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/tag/brill.html#BrillTagger.rules"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.brill.BrillTagger.rules" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nltk.tag.brill.BrillTagger.tag">
<tt class="descname">tag</tt><big>(</big><em>tokens</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/brill.html#BrillTagger.tag"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.brill.BrillTagger.tag" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nltk.tag.brill.BrillTagger.yaml_tag">
<tt class="descname">yaml_tag</tt><em class="property"> = '!nltk.BrillTagger'</em><a class="headerlink" href="#nltk.tag.brill.BrillTagger.yaml_tag" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.tag.brill.BrillTaggerTrainer">
<em class="property">class </em><tt class="descclassname">nltk.tag.brill.</tt><tt class="descname">BrillTaggerTrainer</tt><big>(</big><em>initial_tagger</em>, <em>templates</em>, <em>trace=0</em>, <em>deterministic=None</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/brill.html#BrillTaggerTrainer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.brill.BrillTaggerTrainer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>A trainer for brill taggers.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>deterministic</strong> &#8211; If true, then choose between rules that
have the same score by picking the one whose __repr__
is lexicographically smaller.  If false, then just pick the
first rule we find with a given score &#8211; this will depend
on the order in which keys are returned from dictionaries,
and so may not be the same from one run to the next.  If
not specified, treat as true iff trace &gt; 0.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="nltk.tag.brill.BrillTaggerTrainer.train">
<tt class="descname">train</tt><big>(</big><em>train_sents</em>, <em>max_rules=200</em>, <em>min_score=2</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/brill.html#BrillTaggerTrainer.train"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.brill.BrillTaggerTrainer.train" title="Permalink to this definition">¶</a></dt>
<dd><p>Trains the Brill tagger on the corpus <em>train_sents</em>,
producing at most <em>max_rules</em> transformations, each of which
reduces the net number of errors in the corpus by at least
<em>min_score</em>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>train_sents</strong> (<em>list(list(tuple))</em>) &#8211; The corpus of tagged sentences</li>
<li><strong>max_rules</strong> (<em>int</em>) &#8211; The maximum number of transformations to be created</li>
<li><strong>min_score</strong> (<em>int</em>) &#8211; The minimum acceptable net error reduction
that each transformation must produce in the corpus.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.tag.brill.BrillTemplateI">
<em class="property">class </em><tt class="descclassname">nltk.tag.brill.</tt><tt class="descname">BrillTemplateI</tt><a class="reference internal" href="../_modules/nltk/tag/brill.html#BrillTemplateI"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.brill.BrillTemplateI" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>An interface for generating lists of transformational rules that
apply at given sentence positions.  <tt class="docutils literal"><span class="pre">BrillTemplateI</span></tt> is used by
<tt class="docutils literal"><span class="pre">Brill</span></tt> training algorithms to generate candidate rules.</p>
<dl class="method">
<dt id="nltk.tag.brill.BrillTemplateI.applicable_rules">
<tt class="descname">applicable_rules</tt><big>(</big><em>tokens</em>, <em>i</em>, <em>correctTag</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/brill.html#BrillTemplateI.applicable_rules"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.brill.BrillTemplateI.applicable_rules" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of the transformational rules that would correct
the <em>i*th subtoken&#8217;s tag in the given token.  In particular,
return a list of zero or more rules that would change
*tokens*[i][1] to *correctTag</em>, if applied to <a href="#id2"><span class="problematic" id="id3">*</span></a>token*[i].</p>
<p>If the <a href="#id4"><span class="problematic" id="id5">*</span></a>i*th token already has the correct tag (i.e., if
tagged_tokens[i][1] == correctTag), then
<tt class="docutils literal"><span class="pre">applicable_rules()</span></tt> should return the empty list.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>tokens</strong> (<em>list(tuple)</em>) &#8211; The tagged tokens being tagged.</li>
<li><strong>i</strong> (<em>int</em>) &#8211; The index of the token whose tag should be corrected.</li>
<li><strong>correctTag</strong> (<em>any</em>) &#8211; The correct tag for the <a href="#id6"><span class="problematic" id="id7">*</span></a>i*th token.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">list(BrillRule)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.tag.brill.BrillTemplateI.get_neighborhood">
<tt class="descname">get_neighborhood</tt><big>(</big><em>token</em>, <em>index</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/brill.html#BrillTemplateI.get_neighborhood"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.brill.BrillTemplateI.get_neighborhood" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the set of indices <em>i</em> such that
<tt class="docutils literal"><span class="pre">applicable_rules(token,</span> <span class="pre">i,</span> <span class="pre">...)</span></tt> depends on the value of
the <em>index*th token of *token</em>.</p>
<p>This method is used by the &#8220;fast&#8221; Brill tagger trainer.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>token</strong> (<em>list(tuple)</em>) &#8211; The tokens being tagged.</li>
<li><strong>index</strong> (<em>int</em>) &#8211; The index whose neighborhood should be returned.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">set</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.tag.brill.FastBrillTaggerTrainer">
<em class="property">class </em><tt class="descclassname">nltk.tag.brill.</tt><tt class="descname">FastBrillTaggerTrainer</tt><big>(</big><em>initial_tagger</em>, <em>templates</em>, <em>trace=0</em>, <em>deterministic=False</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/brill.html#FastBrillTaggerTrainer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.brill.FastBrillTaggerTrainer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>A faster trainer for brill taggers.</p>
<dl class="method">
<dt id="nltk.tag.brill.FastBrillTaggerTrainer.train">
<tt class="descname">train</tt><big>(</big><em>train_sents</em>, <em>max_rules=200</em>, <em>min_score=2</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/brill.html#FastBrillTaggerTrainer.train"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.brill.FastBrillTaggerTrainer.train" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.tag.brill.ProximateTagsRule">
<em class="property">class </em><tt class="descclassname">nltk.tag.brill.</tt><tt class="descname">ProximateTagsRule</tt><big>(</big><em>original_tag</em>, <em>replacement_tag</em>, <em>*conditions</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/brill.html#ProximateTagsRule"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.brill.ProximateTagsRule" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.tag.brill.ProximateTokensRule" title="nltk.tag.brill.ProximateTokensRule"><tt class="xref py py-class docutils literal"><span class="pre">nltk.tag.brill.ProximateTokensRule</span></tt></a></p>
<p>A rule which examines the tags of nearby tokens.
See <tt class="docutils literal"><span class="pre">ProximateTokensRule</span></tt> for details.
Also see <tt class="docutils literal"><span class="pre">SymmetricProximateTokensTemplate</span></tt> which generates these rules.</p>
<dl class="attribute">
<dt id="nltk.tag.brill.ProximateTagsRule.PROPERTY_NAME">
<tt class="descname">PROPERTY_NAME</tt><em class="property"> = 'tag'</em><a class="headerlink" href="#nltk.tag.brill.ProximateTagsRule.PROPERTY_NAME" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="staticmethod">
<dt id="nltk.tag.brill.ProximateTagsRule.extract_property">
<em class="property">static </em><tt class="descname">extract_property</tt><big>(</big><em>token</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/brill.html#ProximateTagsRule.extract_property"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.brill.ProximateTagsRule.extract_property" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The given token&#8217;s tag.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="nltk.tag.brill.ProximateTagsRule.yaml_tag">
<tt class="descname">yaml_tag</tt><em class="property"> = '!ProximateTagsRule'</em><a class="headerlink" href="#nltk.tag.brill.ProximateTagsRule.yaml_tag" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.tag.brill.ProximateTokensRule">
<em class="property">class </em><tt class="descclassname">nltk.tag.brill.</tt><tt class="descname">ProximateTokensRule</tt><big>(</big><em>original_tag</em>, <em>replacement_tag</em>, <em>*conditions</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/brill.html#ProximateTokensRule"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.brill.ProximateTokensRule" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.tag.brill.BrillRule" title="nltk.tag.brill.BrillRule"><tt class="xref py py-class docutils literal"><span class="pre">nltk.tag.brill.BrillRule</span></tt></a></p>
<p>An abstract base class for brill rules whose condition checks for
the presence of tokens with given properties at given ranges of
positions, relative to the token.</p>
<p>Each subclass of proximate tokens brill rule defines a method
<tt class="docutils literal"><span class="pre">extract_property()</span></tt>, which extracts a specific property from the
the token, such as its text or tag.  Each instance is
parameterized by a set of tuples, specifying ranges of positions
and property values to check for in those ranges: <tt class="docutils literal"><span class="pre">(start,</span> <span class="pre">end,</span> <span class="pre">value)</span></tt>.</p>
<p>The brill rule is then applicable to the <a href="#id8"><span class="problematic" id="id9">*</span></a>n*th token iff:</p>
<blockquote>
<div><ul class="simple">
<li>The <a href="#id10"><span class="problematic" id="id11">*</span></a>n*th token is tagged with the rule&#8217;s original tag; and</li>
<li>For each (start, end, value) triple, the property value of
at least one token between n+start and n+end (inclusive) is value.</li>
</ul>
</div></blockquote>
<p>For example, a proximate token brill template with start=end=-1
generates rules that check just the property of the preceding
token.  Note that multiple properties may be included in a single
rule; the rule applies if they all hold.</p>
<p>Construct a new brill rule that changes a token&#8217;s tag from
<em>original_tag</em> to <em>replacement_tag</em> if all of the properties
specified in <em>conditions</em> hold.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>conditions</strong> (tuple(int, int, <a href="#id12"><span class="problematic" id="id13">*</span></a>)) &#8211; A list of 3-tuples (start, end, value),
each of which specifies that the property of at least one
token between n+start and n+end (inclusive) is value.</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Raises ValueError:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body">If start&gt;end for any condition.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="nltk.tag.brill.ProximateTokensRule.applies">
<tt class="descname">applies</tt><big>(</big><em>tokens</em>, <em>index</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/brill.html#ProximateTokensRule.applies"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.brill.ProximateTokensRule.applies" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="staticmethod">
<dt id="nltk.tag.brill.ProximateTokensRule.extract_property">
<em class="property">static </em><tt class="descname">extract_property</tt><big>(</big><em>token</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/brill.html#ProximateTokensRule.extract_property"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.brill.ProximateTokensRule.extract_property" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns some property characterizing this token, such as its
base lexical item or its tag.</p>
<p>Each implentation of this method should correspond to an
implementation of the method with the same name in a subclass
of <tt class="docutils literal"><span class="pre">ProximateTokensTemplate</span></tt>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>token</strong> (<em>tuple(str, str)</em>) &#8211; The token</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">The property</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">any</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="nltk.tag.brill.ProximateTokensRule.from_yaml">
<em class="property">classmethod </em><tt class="descname">from_yaml</tt><big>(</big><em>loader</em>, <em>node</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/brill.html#ProximateTokensRule.from_yaml"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.brill.ProximateTokensRule.from_yaml" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="classmethod">
<dt id="nltk.tag.brill.ProximateTokensRule.to_yaml">
<em class="property">classmethod </em><tt class="descname">to_yaml</tt><big>(</big><em>dumper</em>, <em>data</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/brill.html#ProximateTokensRule.to_yaml"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.brill.ProximateTokensRule.to_yaml" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.tag.brill.ProximateTokensTemplate">
<em class="property">class </em><tt class="descclassname">nltk.tag.brill.</tt><tt class="descname">ProximateTokensTemplate</tt><big>(</big><em>rule_class</em>, <em>*boundaries</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/brill.html#ProximateTokensTemplate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.brill.ProximateTokensTemplate" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.tag.brill.BrillTemplateI" title="nltk.tag.brill.BrillTemplateI"><tt class="xref py py-class docutils literal"><span class="pre">nltk.tag.brill.BrillTemplateI</span></tt></a></p>
<p>A brill template that generates a list of
<tt class="docutils literal"><span class="pre">ProximateTokensRule</span></tt> rules that apply at a given sentence
position.  In particular, each <tt class="docutils literal"><span class="pre">ProximateTokensTemplate</span></tt> is
parameterized by a proximate token brill rule class and a list of
boundaries, and generates all rules that:</p>
<blockquote>
<div><ul class="simple">
<li>use the given brill rule class</li>
<li>use the given list of boundaries as the start and end
points for their conditions</li>
<li>are applicable to the given token.</li>
</ul>
</div></blockquote>
<p>Construct a template for generating proximate token brill rules.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>rule_class</strong> (<em>class</em>) &#8211; The proximate token brill rule class that
should be used to generate new rules.  This class must be a
subclass of <tt class="docutils literal"><span class="pre">ProximateTokensRule</span></tt>.</li>
<li><strong>boundaries</strong> (<em>tuple(int, int)</em>) &#8211; A list of (start, end) tuples each of
which specifies a range for which a condition should be
created by each rule.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Raises ValueError:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><p class="first last">If start&gt;end for any boundary.</p>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="nltk.tag.brill.ProximateTokensTemplate.applicable_rules">
<tt class="descname">applicable_rules</tt><big>(</big><em>tokens</em>, <em>index</em>, <em>correct_tag</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/brill.html#ProximateTokensTemplate.applicable_rules"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.brill.ProximateTokensTemplate.applicable_rules" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nltk.tag.brill.ProximateTokensTemplate.get_neighborhood">
<tt class="descname">get_neighborhood</tt><big>(</big><em>tokens</em>, <em>index</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/brill.html#ProximateTokensTemplate.get_neighborhood"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.brill.ProximateTokensTemplate.get_neighborhood" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.tag.brill.ProximateWordsRule">
<em class="property">class </em><tt class="descclassname">nltk.tag.brill.</tt><tt class="descname">ProximateWordsRule</tt><big>(</big><em>original_tag</em>, <em>replacement_tag</em>, <em>*conditions</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/brill.html#ProximateWordsRule"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.brill.ProximateWordsRule" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.tag.brill.ProximateTokensRule" title="nltk.tag.brill.ProximateTokensRule"><tt class="xref py py-class docutils literal"><span class="pre">nltk.tag.brill.ProximateTokensRule</span></tt></a></p>
<p>A rule which examines the base types of nearby tokens.
See <tt class="docutils literal"><span class="pre">ProximateTokensRule</span></tt> for details.
Also see <tt class="docutils literal"><span class="pre">SymmetricProximateTokensTemplate</span></tt> which generates these rules.</p>
<dl class="attribute">
<dt id="nltk.tag.brill.ProximateWordsRule.PROPERTY_NAME">
<tt class="descname">PROPERTY_NAME</tt><em class="property"> = 'text'</em><a class="headerlink" href="#nltk.tag.brill.ProximateWordsRule.PROPERTY_NAME" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="staticmethod">
<dt id="nltk.tag.brill.ProximateWordsRule.extract_property">
<em class="property">static </em><tt class="descname">extract_property</tt><big>(</big><em>token</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/brill.html#ProximateWordsRule.extract_property"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.brill.ProximateWordsRule.extract_property" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The given token&#8217;s text.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="nltk.tag.brill.ProximateWordsRule.yaml_tag">
<tt class="descname">yaml_tag</tt><em class="property"> = '!ProximateWordsRule'</em><a class="headerlink" href="#nltk.tag.brill.ProximateWordsRule.yaml_tag" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.tag.brill.SymmetricProximateTokensTemplate">
<em class="property">class </em><tt class="descclassname">nltk.tag.brill.</tt><tt class="descname">SymmetricProximateTokensTemplate</tt><big>(</big><em>rule_class</em>, <em>*boundaries</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/brill.html#SymmetricProximateTokensTemplate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.brill.SymmetricProximateTokensTemplate" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.tag.brill.BrillTemplateI" title="nltk.tag.brill.BrillTemplateI"><tt class="xref py py-class docutils literal"><span class="pre">nltk.tag.brill.BrillTemplateI</span></tt></a></p>
<p>Simulates two <tt class="docutils literal"><span class="pre">ProximateTokensTemplate</span></tt> templates which are symmetric
across the location of the token.  For rules of the form &#8220;If the
<a href="#id14"><span class="problematic" id="id15">*</span></a>n*th token is tagged <tt class="docutils literal"><span class="pre">A</span></tt>, and any tag preceding or following
the <a href="#id16"><span class="problematic" id="id17">*</span></a>n*th token by a distance between x and y is <tt class="docutils literal"><span class="pre">B</span></tt>, and
... , then change the tag of the <a href="#id18"><span class="problematic" id="id19">*</span></a>n*th token from <tt class="docutils literal"><span class="pre">A</span></tt> to <tt class="docutils literal"><span class="pre">C</span></tt>.&#8221;</p>
<p>One <tt class="docutils literal"><span class="pre">ProximateTokensTemplate</span></tt> is formed by passing in the
same arguments given to this class&#8217;s constructor: tuples
representing intervals in which a tag may be found.  The other
<tt class="docutils literal"><span class="pre">ProximateTokensTemplate</span></tt> is constructed with the negative
of all the arguments in reversed order.  For example, a
<tt class="docutils literal"><span class="pre">SymmetricProximateTokensTemplate</span></tt> using the pair (-2,-1) and the
constructor <tt class="docutils literal"><span class="pre">SymmetricProximateTokensTemplate</span></tt> generates the same rules as a
<tt class="docutils literal"><span class="pre">SymmetricProximateTokensTemplate</span></tt> using (-2,-1) plus a second
<tt class="docutils literal"><span class="pre">SymmetricProximateTokensTemplate</span></tt> using (1,2).</p>
<p>This is useful because we typically don&#8217;t want templates to
specify only &#8220;following&#8221; or only &#8220;preceding&#8221;; we&#8217;d like our
rules to be able to look in either direction.</p>
<p>Construct a template for generating proximate token brill
rules.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>rule_class</strong> (<em>class</em>) &#8211; The proximate token brill rule class that
should be used to generate new rules.  This class must be a
subclass of <tt class="docutils literal"><span class="pre">ProximateTokensRule</span></tt>.</li>
<li><strong>boundaries</strong> (<em>tuple(int, int)</em>) &#8211; A list of tuples (start, end), each of
which specifies a range for which a condition should be
created by each rule.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Raises ValueError:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><p class="first last">If start&gt;end for any boundary.</p>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="nltk.tag.brill.SymmetricProximateTokensTemplate.applicable_rules">
<tt class="descname">applicable_rules</tt><big>(</big><em>tokens</em>, <em>index</em>, <em>correctTag</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/brill.html#SymmetricProximateTokensTemplate.applicable_rules"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.brill.SymmetricProximateTokensTemplate.applicable_rules" title="Permalink to this definition">¶</a></dt>
<dd><p>See <tt class="docutils literal"><span class="pre">BrillTemplateI</span></tt> for full specifications.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">list of ProximateTokensRule</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.tag.brill.SymmetricProximateTokensTemplate.get_neighborhood">
<tt class="descname">get_neighborhood</tt><big>(</big><em>tokens</em>, <em>index</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/brill.html#SymmetricProximateTokensTemplate.get_neighborhood"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.brill.SymmetricProximateTokensTemplate.get_neighborhood" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="nltk.tag.brill.demo">
<tt class="descclassname">nltk.tag.brill.</tt><tt class="descname">demo</tt><big>(</big><em>num_sents=2000</em>, <em>max_rules=200</em>, <em>min_score=3</em>, <em>error_output='errors.out'</em>, <em>rule_output='rules.yaml'</em>, <em>randomize=False</em>, <em>train=0.80000000000000004</em>, <em>trace=3</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/brill.html#demo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.brill.demo" title="Permalink to this definition">¶</a></dt>
<dd><p>Brill Tagger Demonstration</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>num_sents</strong> (<em>int</em>) &#8211; how many sentences of training and testing data to use</li>
<li><strong>max_rules</strong> (<em>int</em>) &#8211; maximum number of rule instances to create</li>
<li><strong>min_score</strong> (<em>int</em>) &#8211; the minimum score for a rule in order for it to
be considered</li>
<li><strong>error_output</strong> (<em>str</em>) &#8211; the file where errors will be saved</li>
<li><strong>rule_output</strong> (<em>str</em>) &#8211; the file where rules will be saved</li>
<li><strong>randomize</strong> (<em>bool</em>) &#8211; whether the training data should be a random subset
of the corpus</li>
<li><strong>train</strong> (<em>float</em>) &#8211; the fraction of the the corpus to be used for training
(1=all)</li>
<li><strong>trace</strong> (<em>int</em>) &#8211; the level of diagnostic tracing output to produce (0-4)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="nltk.tag.brill.error_list">
<tt class="descclassname">nltk.tag.brill.</tt><tt class="descname">error_list</tt><big>(</big><em>train_sents</em>, <em>test_sents</em>, <em>radius=2</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/brill.html#error_list"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.brill.error_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of human-readable strings indicating the errors in the
given tagging of the corpus.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>train_sents</strong> (<em>list(tuple)</em>) &#8211; The correct tagging of the corpus</li>
<li><strong>test_sents</strong> (<em>list(tuple)</em>) &#8211; The tagged corpus</li>
<li><strong>radius</strong> (<em>int</em>) &#8211; How many tokens on either side of a wrongly-tagged token
to include in the error string.  For example, if radius=2,
each error string will show the incorrect token plus two
tokens on either side.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-nltk.tag.crf">
<span id="crf-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">crf</span></tt> Module<a class="headerlink" href="#module-nltk.tag.crf" title="Permalink to this headline">¶</a></h2>
<p>An interface to Mallet &lt;<a class="reference external" href="http://mallet.cs.umass.edu/">http://mallet.cs.umass.edu/</a>&gt;&#8217;s Linear Chain
Conditional Random Field (LC-CRF) implementation.</p>
<p>A user-supplied feature detector function is used to convert each
token to a featureset.  Each feature/value pair is then encoded as a
single binary feature for Mallet.</p>
<dl class="class">
<dt id="nltk.tag.crf.CRFInfo">
<em class="property">class </em><tt class="descclassname">nltk.tag.crf.</tt><tt class="descname">CRFInfo</tt><big>(</big><em>states</em>, <em>gaussian_variance</em>, <em>default_label</em>, <em>max_iterations</em>, <em>transduction_type</em>, <em>weight_groups</em>, <em>add_start_state</em>, <em>add_end_state</em>, <em>model_filename</em>, <em>feature_detector</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/crf.html#CRFInfo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.crf.CRFInfo" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>An object used to record configuration information about a
MalletCRF object.  This configuration information can be
serialized to an XML file, which can then be read by NLTK&#8217;s custom
interface to Mallet&#8217;s CRF.</p>
<p>CRFInfo objects are typically created by the <tt class="docutils literal"><span class="pre">MalletCRF.train()</span></tt>
method.</p>
<p>Advanced users may wish to directly create custom
CRFInfo.WeightGroup objects and pass them to the
<tt class="docutils literal"><span class="pre">MalletCRF.train()</span></tt> function.  See CRFInfo.WeightGroup for
more information.</p>
<dl class="class">
<dt id="nltk.tag.crf.CRFInfo.State">
<em class="property">class </em><tt class="descname">State</tt><big>(</big><em>name</em>, <em>initial_cost</em>, <em>final_cost</em>, <em>transitions</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/crf.html#CRFInfo.State"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.crf.CRFInfo.State" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>A description of a single CRF state.</p>
<dl class="method">
<dt id="nltk.tag.crf.CRFInfo.State.toxml">
<tt class="descname">toxml</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/tag/crf.html#CRFInfo.State.toxml"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.crf.CRFInfo.State.toxml" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.tag.crf.CRFInfo.Transition">
<em class="property">class </em><tt class="descclassname">CRFInfo.</tt><tt class="descname">Transition</tt><big>(</big><em>destination</em>, <em>label</em>, <em>weightgroups</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/crf.html#CRFInfo.Transition"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.crf.CRFInfo.Transition" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>A description of a single CRF transition.</p>
<dl class="method">
<dt id="nltk.tag.crf.CRFInfo.Transition.toxml">
<tt class="descname">toxml</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/tag/crf.html#CRFInfo.Transition.toxml"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.crf.CRFInfo.Transition.toxml" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.tag.crf.CRFInfo.WeightGroup">
<em class="property">class </em><tt class="descclassname">CRFInfo.</tt><tt class="descname">WeightGroup</tt><big>(</big><em>name</em>, <em>src</em>, <em>dst</em>, <em>features='.*'</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/crf.html#CRFInfo.WeightGroup"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.crf.CRFInfo.WeightGroup" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>A configuration object used by MalletCRF to specify how
input-features (which are a function of only the input) should be
mapped to joint-features (which are a function of both the input
and the output tags).</p>
<p>Each weight group specifies that a given set of input features
should be paired with all transitions from a given set of source
tags to a given set of destination tags.</p>
<dl class="method">
<dt id="nltk.tag.crf.CRFInfo.WeightGroup.match">
<tt class="descname">match</tt><big>(</big><em>src</em>, <em>dst</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/crf.html#CRFInfo.WeightGroup.match"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.crf.CRFInfo.WeightGroup.match" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nltk.tag.crf.CRFInfo.WeightGroup.toxml">
<tt class="descname">toxml</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/tag/crf.html#CRFInfo.WeightGroup.toxml"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.crf.CRFInfo.WeightGroup.toxml" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="staticmethod">
<dt id="nltk.tag.crf.CRFInfo.fromstring">
<em class="property">static </em><tt class="descclassname">CRFInfo.</tt><tt class="descname">fromstring</tt><big>(</big><em>s</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/crf.html#CRFInfo.fromstring"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.crf.CRFInfo.fromstring" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nltk.tag.crf.CRFInfo.toxml">
<tt class="descclassname">CRFInfo.</tt><tt class="descname">toxml</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/tag/crf.html#CRFInfo.toxml"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.crf.CRFInfo.toxml" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nltk.tag.crf.CRFInfo.write">
<tt class="descclassname">CRFInfo.</tt><tt class="descname">write</tt><big>(</big><em>filename</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/crf.html#CRFInfo.write"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.crf.CRFInfo.write" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.tag.crf.MalletCRF">
<em class="property">class </em><tt class="descclassname">nltk.tag.crf.</tt><tt class="descname">MalletCRF</tt><big>(</big><em>filename</em>, <em>feature_detector=None</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/crf.html#MalletCRF"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.crf.MalletCRF" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.tag.api.FeaturesetTaggerI" title="nltk.tag.api.FeaturesetTaggerI"><tt class="xref py py-class docutils literal"><span class="pre">nltk.tag.api.FeaturesetTaggerI</span></tt></a></p>
<p>A conditional random field tagger, which is trained and run by
making external calls to Mallet.  Tokens are converted to
featuresets using a feature detector function:</p>
<div class="highlight-python"><pre>feature_detector(tokens, index) -&gt; featureset</pre>
</div>
<p>These featuresets are then encoded into feature vectors by
converting each feature (name, value) pair to a unique binary
feature.</p>
<p>Ecah MalletCRF object is backed by a crf model file.  This
model file is actually a zip file, and it contains one file for
the serialized model <tt class="docutils literal"><span class="pre">crf-model.ser</span></tt> and one file for
information about the structure of the CRF <tt class="docutils literal"><span class="pre">crf-info.xml</span></tt>.</p>
<p>Create a new MalletCRF.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>filename</strong> &#8211; The filename of the model file that backs this CRF.</li>
<li><strong>feature_detector</strong> &#8211; The feature detector function that is
used to convert tokens to featuresets.  This parameter
only needs to be given if the model file does not contain
a pickled pointer to the feature detector (e.g., if the
feature detector was a lambda function).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="nltk.tag.crf.MalletCRF.batch_tag">
<tt class="descname">batch_tag</tt><big>(</big><em>sentences</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/crf.html#MalletCRF.batch_tag"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.crf.MalletCRF.batch_tag" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nltk.tag.crf.MalletCRF.crf_info">
<tt class="descname">crf_info</tt><em class="property"> = None</em><a class="headerlink" href="#nltk.tag.crf.MalletCRF.crf_info" title="Permalink to this definition">¶</a></dt>
<dd><p>A CRFInfo object describing this CRF.</p>
</dd></dl>

<dl class="attribute">
<dt id="nltk.tag.crf.MalletCRF.feature_detector">
<tt class="descname">feature_detector</tt><a class="reference internal" href="../_modules/nltk/tag/crf.html#MalletCRF.feature_detector"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.crf.MalletCRF.feature_detector" title="Permalink to this definition">¶</a></dt>
<dd><p>The feature detector function that is used to convert tokens
to featuresets.  This function has the signature:</p>
<p>feature_detector(tokens, index) -&gt; featureset</p>
</dd></dl>

<dl class="attribute">
<dt id="nltk.tag.crf.MalletCRF.filename">
<tt class="descname">filename</tt><a class="reference internal" href="../_modules/nltk/tag/crf.html#MalletCRF.filename"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.crf.MalletCRF.filename" title="Permalink to this definition">¶</a></dt>
<dd><p>The filename of the crf model file that backs this
MalletCRF.  The crf model file is actually a zip file, and
it contains one file for the serialized model
<tt class="docutils literal"><span class="pre">crf-model.ser</span></tt> and one file for information about the
structure of the CRF <tt class="docutils literal"><span class="pre">crf-info.xml</span></tt>).</p>
</dd></dl>

<dl class="method">
<dt id="nltk.tag.crf.MalletCRF.parse_mallet_output">
<tt class="descname">parse_mallet_output</tt><big>(</big><em>s</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/crf.html#MalletCRF.parse_mallet_output"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.crf.MalletCRF.parse_mallet_output" title="Permalink to this definition">¶</a></dt>
<dd><p>Parse the output that is generated by the java script
org.nltk.mallet.TestCRF, and convert it to a labeled
corpus.</p>
</dd></dl>

<dl class="classmethod">
<dt id="nltk.tag.crf.MalletCRF.train">
<em class="property">classmethod </em><tt class="descname">train</tt><big>(</big><em>feature_detector</em>, <em>corpus</em>, <em>filename=None</em>, <em>weight_groups=None</em>, <em>gaussian_variance=1</em>, <em>default_label='O'</em>, <em>transduction_type='VITERBI'</em>, <em>max_iterations=500</em>, <em>add_start_state=True</em>, <em>add_end_state=True</em>, <em>trace=1</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/crf.html#MalletCRF.train"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.crf.MalletCRF.train" title="Permalink to this definition">¶</a></dt>
<dd><p>Train a new linear chain CRF tagger based on the given corpus
of training sequences.  This tagger will be backed by a crf
model file, containing both a serialized Mallet model and
information about the CRF&#8217;s structure.  This crf model file
will not be automatically deleted &#8211; if you wish to delete
it, you must delete it manually.  The filename of the model
file for a MalletCRF crf is available as <tt class="docutils literal"><span class="pre">crf.filename()</span></tt>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>corpus</strong> (<em>list(tuple(str, str))</em>) &#8211; Training data, represented as a list of
sentences, where each sentence is a list of (token, tag) tuples.</li>
<li><strong>filename</strong> (<em>str</em>) &#8211; The filename that should be used for the crf
model file that backs the new MalletCRF.  If no
filename is given, then a new filename will be chosen
automatically.</li>
<li><strong>weight_groups</strong> (<em>list(CRFInfo.WeightGroup)</em>) &#8211; Specifies how input-features should
be mapped to joint-features.  See CRFInfo.WeightGroup
for more information.</li>
<li><strong>gaussian_variance</strong> (<em>float</em>) &#8211; The gaussian variance of the prior
that should be used to train the new CRF.</li>
<li><strong>default_label</strong> (<em>str</em>) &#8211; The &#8220;label for initial context and
uninteresting tokens&#8221; (from Mallet&#8217;s SimpleTagger.java.)
It&#8217;s unclear whether this currently has any effect.</li>
<li><strong>transduction_type</strong> (<em>str</em>) &#8211; The type of transduction used by
the CRF.  Can be VITERBI, VITERBI_FBEAM, VITERBI_BBEAM,
VITERBI_FBBEAM, or VITERBI_FBEAMKL.</li>
<li><strong>max_iterations</strong> (<em>int</em>) &#8211; The maximum number of iterations that
should be used for training the CRF.</li>
<li><strong>add_start_state</strong> (<em>bool</em>) &#8211; If true, then NLTK will add a special
start state, named &#8216;__start__&#8217;.  The initial cost for
the start state will be set to 0; and the initial cost for
all other states will be set to +inf.</li>
<li><strong>add_end_state</strong> (<em>bool</em>) &#8211; If true, then NLTK will add a special
end state, named &#8216;__end__&#8217;.  The final cost for the end
state will be set to 0; and the final cost for all other
states will be set to +inf.</li>
<li><strong>trace</strong> (<em>int</em>) &#8211; Controls the verbosity of trace output generated
while training the CRF.  Higher numbers generate more verbose
output.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.tag.crf.MalletCRF.write_test_corpus">
<tt class="descname">write_test_corpus</tt><big>(</big><em>corpus</em>, <em>stream</em>, <em>close_stream=True</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/crf.html#MalletCRF.write_test_corpus"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.crf.MalletCRF.write_test_corpus" title="Permalink to this definition">¶</a></dt>
<dd><p>Write a given test corpus to a given stream, in a format that
can be read by the java script org.nltk.mallet.TestCRF.</p>
</dd></dl>

<dl class="method">
<dt id="nltk.tag.crf.MalletCRF.write_training_corpus">
<tt class="descname">write_training_corpus</tt><big>(</big><em>corpus</em>, <em>stream</em>, <em>close_stream=True</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/crf.html#MalletCRF.write_training_corpus"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.crf.MalletCRF.write_training_corpus" title="Permalink to this definition">¶</a></dt>
<dd><p>Write a given training corpus to a given stream, in a format that
can be read by the java script org.nltk.mallet.TrainCRF.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="nltk.tag.crf.demo">
<tt class="descclassname">nltk.tag.crf.</tt><tt class="descname">demo</tt><big>(</big><em>train_size=100</em>, <em>test_size=100</em>, <em>java_home=None</em>, <em>mallet_home=None</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/crf.html#demo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.crf.demo" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-nltk.tag.hmm">
<span id="hmm-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">hmm</span></tt> Module<a class="headerlink" href="#module-nltk.tag.hmm" title="Permalink to this headline">¶</a></h2>
<p>Hidden Markov Models (HMMs) largely used to assign the correct label sequence
to sequential data or assess the probability of a given label and data
sequence. These models are finite state machines characterised by a number of
states, transitions between these states, and output symbols emitted while in
each state. The HMM is an extension to the Markov chain, where each state
corresponds deterministically to a given event. In the HMM the observation is
a probabilistic function of the state. HMMs share the Markov chain&#8217;s
assumption, being that the probability of transition from one state to another
only depends on the current state - i.e. the series of states that led to the
current state are not used. They are also time invariant.</p>
<p>The HMM is a directed graph, with probability weighted edges (representing the
probability of a transition between the source and sink states) where each
vertex emits an output symbol when entered. The symbol (or observation) is
non-deterministically generated. For this reason, knowing that a sequence of
output observations was generated by a given HMM does not mean that the
corresponding sequence of states (and what the current state is) is known.
This is the &#8216;hidden&#8217; in the hidden markov model.</p>
<p>Formally, a HMM can be characterised by:</p>
<ul class="simple">
<li>the output observation alphabet. This is the set of symbols which may be
observed as output of the system.</li>
<li>the set of states.</li>
<li>the transition probabilities <em>a_{ij} = P(s_t = j | s_{t-1} = i)</em>. These
represent the probability of transition to each state from a given state.</li>
<li>the output probability matrix <em>b_i(k) = P(X_t = o_k | s_t = i)</em>. These
represent the probability of observing each symbol in a given state.</li>
<li>the initial state distribution. This gives the probability of starting
in each state.</li>
</ul>
<p>To ground this discussion, take a common NLP application, part-of-speech (POS)
tagging. An HMM is desirable for this task as the highest probability tag
sequence can be calculated for a given sequence of word forms. This differs
from other tagging techniques which often tag each word individually, seeking
to optimise each individual tagging greedily without regard to the optimal
combination of tags for a larger unit, such as a sentence. The HMM does this
with the Viterbi algorithm, which efficiently computes the optimal path
through the graph given the sequence of words forms.</p>
<p>In POS tagging the states usually have a 1:1 correspondence with the tag
alphabet - i.e. each state represents a single tag. The output observation
alphabet is the set of word forms (the lexicon), and the remaining three
parameters are derived by a training regime. With this information the
probability of a given sentence can be easily derived, by simply summing the
probability of each distinct path through the model. Similarly, the highest
probability tagging sequence can be derived with the Viterbi algorithm,
yielding a state sequence which can be mapped into a tag sequence.</p>
<p>This discussion assumes that the HMM has been trained. This is probably the
most difficult task with the model, and requires either MLE estimates of the
parameters or unsupervised learning using the Baum-Welch algorithm, a variant
of EM.</p>
<p>For more information, please consult the source code for this module,
which includes extensive demonstration code.</p>
<dl class="class">
<dt id="nltk.tag.hmm.HiddenMarkovModelTagger">
<em class="property">class </em><tt class="descclassname">nltk.tag.hmm.</tt><tt class="descname">HiddenMarkovModelTagger</tt><big>(</big><em>symbols</em>, <em>states</em>, <em>transitions</em>, <em>outputs</em>, <em>priors</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/hmm.html#HiddenMarkovModelTagger"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.hmm.HiddenMarkovModelTagger" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.tag.api.TaggerI" title="nltk.tag.api.TaggerI"><tt class="xref py py-class docutils literal"><span class="pre">nltk.tag.api.TaggerI</span></tt></a></p>
<p>Hidden Markov model class, a generative model for labelling sequence data.
These models define the joint probability of a sequence of symbols and
their labels (state transitions) as the product of the starting state
probability, the probability of each state transition, and the probability
of each observation being generated from each state. This is described in
more detail in the module documentation.</p>
<p>This implementation is based on the HMM description in Chapter 8, Huang,
Acero and Hon, Spoken Language Processing and includes an extension for
training shallow HMM parsers or specializaed HMMs as in Molina et.
al, 2002.  A specialized HMM modifies training data by applying a
specialization function to create a new training set that is more
appropriate for sequential tagging with an HMM.  A typical use case is
chunking.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>symbols</strong> (<em>seq of any</em>) &#8211; the set of output symbols (alphabet)</li>
<li><strong>states</strong> (<em>seq of any</em>) &#8211; a set of states representing state space</li>
<li><strong>transitions</strong> (<em>ConditionalProbDistI</em>) &#8211; transition probabilities; Pr(s_i | s_j) is the
probability of transition from state i given the model is in
state_j</li>
<li><strong>outputs</strong> (<em>ConditionalProbDistI</em>) &#8211; output probabilities; Pr(o_k | s_i) is the probability
of emitting symbol k when entering state i</li>
<li><strong>priors</strong> (<em>ProbDistI</em>) &#8211; initial state distribution; Pr(s_i) is the probability
of starting in state i</li>
<li><strong>transform</strong> (<em>function or HiddenMarkovModelTaggerTransform</em>) &#8211; an optional function for transforming training
instances, defaults to the identity function.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="nltk.tag.hmm.HiddenMarkovModelTagger.best_path">
<tt class="descname">best_path</tt><big>(</big><em>unlabeled_sequence</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/hmm.html#HiddenMarkovModelTagger.best_path"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.hmm.HiddenMarkovModelTagger.best_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the state sequence of the optimal (most probable) path through
the HMM. Uses the Viterbi algorithm to calculate this part by dynamic
programming.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">the state sequence</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">sequence of any</td>
</tr>
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>unlabeled_sequence</strong> (<em>list</em>) &#8211; the sequence of unlabeled symbols</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.tag.hmm.HiddenMarkovModelTagger.best_path_simple">
<tt class="descname">best_path_simple</tt><big>(</big><em>unlabeled_sequence</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/hmm.html#HiddenMarkovModelTagger.best_path_simple"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.hmm.HiddenMarkovModelTagger.best_path_simple" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the state sequence of the optimal (most probable) path through
the HMM. Uses the Viterbi algorithm to calculate this part by dynamic
programming.  This uses a simple, direct method, and is included for
teaching purposes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">the state sequence</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">sequence of any</td>
</tr>
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>unlabeled_sequence</strong> (<em>list</em>) &#8211; the sequence of unlabeled symbols</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.tag.hmm.HiddenMarkovModelTagger.entropy">
<tt class="descname">entropy</tt><big>(</big><em>unlabeled_sequence</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/hmm.html#HiddenMarkovModelTagger.entropy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.hmm.HiddenMarkovModelTagger.entropy" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the entropy over labellings of the given sequence. This is
given by:</p>
<div class="highlight-python"><pre>H(O) = - sum_S Pr(S | O) log Pr(S | O)</pre>
</div>
<p>where the summation ranges over all state sequences, S. Let
<em>Z = Pr(O) = sum_S Pr(S, O)}</em> where the summation ranges over all state
sequences and O is the observation sequence. As such the entropy can
be re-expressed as:</p>
<div class="highlight-python"><pre>H = - sum_S Pr(S | O) log [ Pr(S, O) / Z ]
= log Z - sum_S Pr(S | O) log Pr(S, 0)
= log Z - sum_S Pr(S | O) [ log Pr(S_0) + sum_t Pr(S_t | S_{t-1}) + sum_t Pr(O_t | S_t) ]</pre>
</div>
<p>The order of summation for the log terms can be flipped, allowing
dynamic programming to be used to calculate the entropy. Specifically,
we use the forward and backward probabilities (alpha, beta) giving:</p>
<div class="highlight-python"><pre>H = log Z - sum_s0 alpha_0(s0) beta_0(s0) / Z * log Pr(s0)
+ sum_t,si,sj alpha_t(si) Pr(sj | si) Pr(O_t+1 | sj) beta_t(sj) / Z * log Pr(sj | si)
+ sum_t,st alpha_t(st) beta_t(st) / Z * log Pr(O_t | st)</pre>
</div>
<p>This simply uses alpha and beta to find the probabilities of partial
sequences, constrained to include the given state(s) at some point in
time.</p>
</dd></dl>

<dl class="method">
<dt id="nltk.tag.hmm.HiddenMarkovModelTagger.log_probability">
<tt class="descname">log_probability</tt><big>(</big><em>sequence</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/hmm.html#HiddenMarkovModelTagger.log_probability"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.hmm.HiddenMarkovModelTagger.log_probability" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the log-probability of the given symbol sequence. If the
sequence is labelled, then returns the joint log-probability of the
symbol, state sequence. Otherwise, uses the forward algorithm to find
the log-probability over all label sequences.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">the log-probability of the sequence</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">float</td>
</tr>
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>sequence</strong> (<em>Token</em>) &#8211; the sequence of symbols which must contain the TEXT
property, and optionally the TAG property</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.tag.hmm.HiddenMarkovModelTagger.point_entropy">
<tt class="descname">point_entropy</tt><big>(</big><em>unlabeled_sequence</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/hmm.html#HiddenMarkovModelTagger.point_entropy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.hmm.HiddenMarkovModelTagger.point_entropy" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the pointwise entropy over the possible states at each
position in the chain, given the observation sequence.</p>
</dd></dl>

<dl class="method">
<dt id="nltk.tag.hmm.HiddenMarkovModelTagger.probability">
<tt class="descname">probability</tt><big>(</big><em>sequence</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/hmm.html#HiddenMarkovModelTagger.probability"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.hmm.HiddenMarkovModelTagger.probability" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the probability of the given symbol sequence. If the sequence
is labelled, then returns the joint probability of the symbol, state
sequence. Otherwise, uses the forward algorithm to find the
probability over all label sequences.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">the probability of the sequence</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">float</td>
</tr>
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>sequence</strong> (<em>Token</em>) &#8211; the sequence of symbols which must contain the TEXT
property, and optionally the TAG property</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.tag.hmm.HiddenMarkovModelTagger.random_sample">
<tt class="descname">random_sample</tt><big>(</big><em>rng</em>, <em>length</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/hmm.html#HiddenMarkovModelTagger.random_sample"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.hmm.HiddenMarkovModelTagger.random_sample" title="Permalink to this definition">¶</a></dt>
<dd><p>Randomly sample the HMM to generate a sentence of a given length. This
samples the prior distribution then the observation distribution and
transition distribution for each subsequent observation and state.
This will mostly generate unintelligible garbage, but can provide some
amusement.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">the randomly created state/observation sequence,
generated according to the HMM&#8217;s probability
distributions. The SUBTOKENS have TEXT and TAG
properties containing the observation and state
respectively.</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">list</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>rng</strong> (<em>Random (or any object with a random() method)</em>) &#8211; random number generator</li>
<li><strong>length</strong> (<em>int</em>) &#8211; desired output length</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.tag.hmm.HiddenMarkovModelTagger.tag">
<tt class="descname">tag</tt><big>(</big><em>unlabeled_sequence</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/hmm.html#HiddenMarkovModelTagger.tag"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.hmm.HiddenMarkovModelTagger.tag" title="Permalink to this definition">¶</a></dt>
<dd><p>Tags the sequence with the highest probability state sequence. This
uses the best_path method to find the Viterbi path.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a labelled sequence of symbols</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">list</td>
</tr>
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>unlabeled_sequence</strong> (<em>list</em>) &#8211; the sequence of unlabeled symbols</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.tag.hmm.HiddenMarkovModelTagger.test">
<tt class="descname">test</tt><big>(</big><em>test_sequence</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/hmm.html#HiddenMarkovModelTagger.test"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.hmm.HiddenMarkovModelTagger.test" title="Permalink to this definition">¶</a></dt>
<dd><p>Tests the HiddenMarkovModelTagger instance.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>test_sequence</strong> (<em>list(list)</em>) &#8211; a sequence of labeled test instances</li>
<li><strong>verbose</strong> (<em>bool</em>) &#8211; boolean flag indicating whether training should be
verbose or include printed output</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="nltk.tag.hmm.HiddenMarkovModelTagger.train">
<em class="property">classmethod </em><tt class="descname">train</tt><big>(</big><em>labeled_sequence</em>, <em>test_sequence=None</em>, <em>unlabeled_sequence=None</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/hmm.html#HiddenMarkovModelTagger.train"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.hmm.HiddenMarkovModelTagger.train" title="Permalink to this definition">¶</a></dt>
<dd><p>Train a new HiddenMarkovModelTagger using the given labeled and
unlabeled training instances. Testing will be performed if test
instances are provided.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">a hidden markov model tagger</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">HiddenMarkovModelTagger</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>labeled_sequence</strong> (<em>list(list)</em>) &#8211; a sequence of labeled training instances,
i.e. a list of sentences represented as tuples</li>
<li><strong>test_sequence</strong> (<em>list(list)</em>) &#8211; a sequence of labeled test instances</li>
<li><strong>unlabeled_sequence</strong> (<em>list(list)</em>) &#8211; a sequence of unlabeled training instances,
i.e. a list of sentences represented as words</li>
<li><strong>transform</strong> (<em>function</em>) &#8211; an optional function for transforming training
instances, defaults to the identity function, see <tt class="docutils literal"><span class="pre">transform()</span></tt></li>
<li><strong>estimator</strong> (<em>class or function</em>) &#8211; an optional function or class that maps a
condition&#8217;s frequency distribution to its probability
distribution, defaults to a Lidstone distribution with gamma = 0.1</li>
<li><strong>verbose</strong> (<em>bool</em>) &#8211; boolean flag indicating whether training should be
verbose or include printed output</li>
<li><strong>max_iterations</strong> (<em>int</em>) &#8211; number of Baum-Welch interations to perform</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.tag.hmm.HiddenMarkovModelTaggerTransform">
<em class="property">class </em><tt class="descclassname">nltk.tag.hmm.</tt><tt class="descname">HiddenMarkovModelTaggerTransform</tt><a class="reference internal" href="../_modules/nltk/tag/hmm.html#HiddenMarkovModelTaggerTransform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.hmm.HiddenMarkovModelTaggerTransform" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.tag.api.HiddenMarkovModelTaggerTransformI" title="nltk.tag.api.HiddenMarkovModelTaggerTransformI"><tt class="xref py py-class docutils literal"><span class="pre">nltk.tag.api.HiddenMarkovModelTaggerTransformI</span></tt></a></p>
<p>An abstract subclass of HiddenMarkovModelTaggerTransformI.</p>
</dd></dl>

<dl class="class">
<dt id="nltk.tag.hmm.HiddenMarkovModelTrainer">
<em class="property">class </em><tt class="descclassname">nltk.tag.hmm.</tt><tt class="descname">HiddenMarkovModelTrainer</tt><big>(</big><em>states=None</em>, <em>symbols=None</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/hmm.html#HiddenMarkovModelTrainer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.hmm.HiddenMarkovModelTrainer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Algorithms for learning HMM parameters from training data. These include
both supervised learning (MLE) and unsupervised learning (Baum-Welch).</p>
<p>Creates an HMM trainer to induce an HMM with the given states and
output symbol alphabet. A supervised and unsupervised training
method may be used. If either of the states or symbols are not given,
these may be derived from supervised training.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>states</strong> (<em>sequence of any</em>) &#8211; the set of state labels</li>
<li><strong>symbols</strong> (<em>sequence of any</em>) &#8211; the set of observation symbols</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="nltk.tag.hmm.HiddenMarkovModelTrainer.train">
<tt class="descname">train</tt><big>(</big><em>labelled_sequences=None</em>, <em>unlabeled_sequences=None</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/hmm.html#HiddenMarkovModelTrainer.train"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.hmm.HiddenMarkovModelTrainer.train" title="Permalink to this definition">¶</a></dt>
<dd><p>Trains the HMM using both (or either of) supervised and unsupervised
techniques.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">the trained model</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">HiddenMarkovModelTagger</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>labelled_sequences</strong> (<em>list</em>) &#8211; the supervised training data, a set of
labelled sequences of observations</li>
<li><strong>unlabeled_sequences</strong> (<em>list</em>) &#8211; the unsupervised training data, a set of
sequences of observations</li>
<li><strong>kwargs</strong> &#8211; additional arguments to pass to the training methods</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.tag.hmm.HiddenMarkovModelTrainer.train_supervised">
<tt class="descname">train_supervised</tt><big>(</big><em>labelled_sequences</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/hmm.html#HiddenMarkovModelTrainer.train_supervised"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.hmm.HiddenMarkovModelTrainer.train_supervised" title="Permalink to this definition">¶</a></dt>
<dd><p>Supervised training maximising the joint probability of the symbol and
state sequences. This is done via collecting frequencies of
transitions between states, symbol observations while within each
state and which states start a sentence. These frequency distributions
are then normalised into probability estimates, which can be
smoothed if desired.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">the trained model</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">HiddenMarkovModelTagger</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>labelled_sequences</strong> (<em>list</em>) &#8211; the training data, a set of
labelled sequences of observations</li>
<li><strong>kwargs</strong> &#8211; may include an &#8216;estimator&#8217; parameter, a function taking
a FreqDist and a number of bins and returning a CProbDistI;
otherwise a MLE estimate is used</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.tag.hmm.HiddenMarkovModelTrainer.train_unsupervised">
<tt class="descname">train_unsupervised</tt><big>(</big><em>unlabeled_sequences</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/hmm.html#HiddenMarkovModelTrainer.train_unsupervised"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.hmm.HiddenMarkovModelTrainer.train_unsupervised" title="Permalink to this definition">¶</a></dt>
<dd><p>Trains the HMM using the Baum-Welch algorithm to maximise the
probability of the data sequence. This is a variant of the EM
algorithm, and is unsupervised in that it doesn&#8217;t need the state
sequences for the symbols. The code is based on &#8216;A Tutorial on Hidden
Markov Models and Selected Applications in Speech Recognition&#8217;,
Lawrence Rabiner, IEEE, 1989.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">the trained model</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">HiddenMarkovModelTagger</td>
</tr>
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>unlabeled_sequences</strong> (<em>list</em>) &#8211; the training data, a set of
sequences of observations</td>
</tr>
</tbody>
</table>
<p>kwargs may include following parameters:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>model</strong> &#8211; a HiddenMarkovModelTagger instance used to begin
the Baum-Welch algorithm</li>
<li><strong>max_iterations</strong> &#8211; the maximum number of EM iterations</li>
<li><strong>convergence_logprob</strong> &#8211; the maximum change in log probability to
allow convergence</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.tag.hmm.IdentityTransform">
<em class="property">class </em><tt class="descclassname">nltk.tag.hmm.</tt><tt class="descname">IdentityTransform</tt><a class="reference internal" href="../_modules/nltk/tag/hmm.html#IdentityTransform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.hmm.IdentityTransform" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.tag.hmm.HiddenMarkovModelTaggerTransform" title="nltk.tag.hmm.HiddenMarkovModelTaggerTransform"><tt class="xref py py-class docutils literal"><span class="pre">nltk.tag.hmm.HiddenMarkovModelTaggerTransform</span></tt></a></p>
<p>A subclass of HiddenMarkovModelTaggerTransform that implements
transform() as the identity function, i.e. symbols passed to
transform() are returned unmodified.</p>
<dl class="method">
<dt id="nltk.tag.hmm.IdentityTransform.transform">
<tt class="descname">transform</tt><big>(</big><em>labeled_symbols</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/hmm.html#IdentityTransform.transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.hmm.IdentityTransform.transform" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.tag.hmm.LambdaTransform">
<em class="property">class </em><tt class="descclassname">nltk.tag.hmm.</tt><tt class="descname">LambdaTransform</tt><big>(</big><em>transform</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/hmm.html#LambdaTransform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.hmm.LambdaTransform" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.tag.hmm.HiddenMarkovModelTaggerTransform" title="nltk.tag.hmm.HiddenMarkovModelTaggerTransform"><tt class="xref py py-class docutils literal"><span class="pre">nltk.tag.hmm.HiddenMarkovModelTaggerTransform</span></tt></a></p>
<p>A subclass of HiddenMarkovModelTaggerTransform that is backed by an
arbitrary user-defined function, instance method, or lambda function.</p>
<dl class="method">
<dt id="nltk.tag.hmm.LambdaTransform.transform">
<tt class="descname">transform</tt><big>(</big><em>labeled_symbols</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/hmm.html#LambdaTransform.transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.hmm.LambdaTransform.transform" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="nltk.tag.hmm.demo">
<tt class="descclassname">nltk.tag.hmm.</tt><tt class="descname">demo</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/tag/hmm.html#demo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.hmm.demo" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="nltk.tag.hmm.demo_bw">
<tt class="descclassname">nltk.tag.hmm.</tt><tt class="descname">demo_bw</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/tag/hmm.html#demo_bw"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.hmm.demo_bw" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="nltk.tag.hmm.demo_pos">
<tt class="descclassname">nltk.tag.hmm.</tt><tt class="descname">demo_pos</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/tag/hmm.html#demo_pos"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.hmm.demo_pos" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="nltk.tag.hmm.demo_pos_bw">
<tt class="descclassname">nltk.tag.hmm.</tt><tt class="descname">demo_pos_bw</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/tag/hmm.html#demo_pos_bw"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.hmm.demo_pos_bw" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="nltk.tag.hmm.load_pos">
<tt class="descclassname">nltk.tag.hmm.</tt><tt class="descname">load_pos</tt><big>(</big><em>num_sents</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/hmm.html#load_pos"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.hmm.load_pos" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-nltk.tag.hunpos">
<span id="hunpos-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">hunpos</span></tt> Module<a class="headerlink" href="#module-nltk.tag.hunpos" title="Permalink to this headline">¶</a></h2>
<p>A module for interfacing with the HunPos open-source POS-tagger.</p>
<dl class="class">
<dt id="nltk.tag.hunpos.HunposTagger">
<em class="property">class </em><tt class="descclassname">nltk.tag.hunpos.</tt><tt class="descname">HunposTagger</tt><big>(</big><em>path_to_model</em>, <em>path_to_bin=None</em>, <em>encoding='ISO-8859-1'</em>, <em>verbose=False</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/hunpos.html#HunposTagger"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.hunpos.HunposTagger" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.tag.api.TaggerI" title="nltk.tag.api.TaggerI"><tt class="xref py py-class docutils literal"><span class="pre">nltk.tag.api.TaggerI</span></tt></a></p>
<dl class="docutils">
<dt>A class for pos tagging with HunPos. The input is the paths to:</dt>
<dd><ul class="first last simple">
<li>a model trained on training data</li>
<li>(optionally) the path to the hunpos-tag binary</li>
<li>(optionally) the encoding of the training data (default: ISO-8859-1)</li>
</ul>
</dd>
</dl>
<p>Example:</p>
<p>This class communicates with the hunpos-tag binary via pipes. When the
tagger object is no longer needed, the close() method should be called to
free system resources. The class supports the context manager interface; if
used in a with statement, the close() method is invoked automatically:</p>
<dl class="method">
<dt id="nltk.tag.hunpos.HunposTagger.close">
<tt class="descname">close</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/tag/hunpos.html#HunposTagger.close"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.hunpos.HunposTagger.close" title="Permalink to this definition">¶</a></dt>
<dd><p>Closes the pipe to the hunpos executable.</p>
</dd></dl>

<dl class="method">
<dt id="nltk.tag.hunpos.HunposTagger.tag">
<tt class="descname">tag</tt><big>(</big><em>tokens</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/hunpos.html#HunposTagger.tag"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.hunpos.HunposTagger.tag" title="Permalink to this definition">¶</a></dt>
<dd><p>Tags a single sentence: a list of words.
The tokens should not contain any newline characters.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-nltk.tag.senna">
<span id="senna-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">senna</span></tt> Module<a class="headerlink" href="#module-nltk.tag.senna" title="Permalink to this headline">¶</a></h2>
<p>A module for interfacing with the SENNA pipeline.</p>
<dl class="class">
<dt id="nltk.tag.senna.CHKTagger">
<em class="property">class </em><tt class="descclassname">nltk.tag.senna.</tt><tt class="descname">CHKTagger</tt><big>(</big><em>path</em>, <em>encoding='utf-8'</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/senna.html#CHKTagger"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.senna.CHKTagger" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.tag.senna.SennaTagger" title="nltk.tag.senna.SennaTagger"><tt class="xref py py-class docutils literal"><span class="pre">nltk.tag.senna.SennaTagger</span></tt></a></p>
<p>A chunker.</p>
<p>The input is:
- path to the directory that contains SENNA executables.
- (optionally) the encoding of the input data (default:utf-8)</p>
<p>Example:</p>
<dl class="method">
<dt id="nltk.tag.senna.CHKTagger.batch_tag">
<tt class="descname">batch_tag</tt><big>(</big><em>sentences</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/senna.html#CHKTagger.batch_tag"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.senna.CHKTagger.batch_tag" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies the tag method over a list of sentences. This method will return
for each sentence a list of tuples of (word, tag).</p>
</dd></dl>

</dd></dl>

<dl class="exception">
<dt id="nltk.tag.senna.Error">
<em class="property">exception </em><tt class="descclassname">nltk.tag.senna.</tt><tt class="descname">Error</tt><a class="reference internal" href="../_modules/nltk/tag/senna.html#Error"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.senna.Error" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">exceptions.Exception</span></tt></p>
<p>Basic error handling class to be extended by the module specific
exceptions</p>
</dd></dl>

<dl class="exception">
<dt id="nltk.tag.senna.ExecutableNotFound">
<em class="property">exception </em><tt class="descclassname">nltk.tag.senna.</tt><tt class="descname">ExecutableNotFound</tt><a class="reference internal" href="../_modules/nltk/tag/senna.html#ExecutableNotFound"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.senna.ExecutableNotFound" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.tag.senna.Error" title="nltk.tag.senna.Error"><tt class="xref py py-class docutils literal"><span class="pre">nltk.tag.senna.Error</span></tt></a></p>
<p>Raised if the senna executable does not exist</p>
</dd></dl>

<dl class="class">
<dt id="nltk.tag.senna.NERTagger">
<em class="property">class </em><tt class="descclassname">nltk.tag.senna.</tt><tt class="descname">NERTagger</tt><big>(</big><em>path</em>, <em>encoding='utf-8'</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/senna.html#NERTagger"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.senna.NERTagger" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.tag.senna.SennaTagger" title="nltk.tag.senna.SennaTagger"><tt class="xref py py-class docutils literal"><span class="pre">nltk.tag.senna.SennaTagger</span></tt></a></p>
<p>A named entity extractor.</p>
<p>The input is:
- path to the directory that contains SENNA executables.
- (optionally) the encoding of the input data (default:utf-8)</p>
<p>Example:</p>
<dl class="method">
<dt id="nltk.tag.senna.NERTagger.batch_tag">
<tt class="descname">batch_tag</tt><big>(</big><em>sentences</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/senna.html#NERTagger.batch_tag"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.senna.NERTagger.batch_tag" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies the tag method over a list of sentences. This method will return
for each sentence a list of tuples of (word, tag).</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.tag.senna.POSTagger">
<em class="property">class </em><tt class="descclassname">nltk.tag.senna.</tt><tt class="descname">POSTagger</tt><big>(</big><em>path</em>, <em>encoding='utf-8'</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/senna.html#POSTagger"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.senna.POSTagger" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.tag.senna.SennaTagger" title="nltk.tag.senna.SennaTagger"><tt class="xref py py-class docutils literal"><span class="pre">nltk.tag.senna.SennaTagger</span></tt></a></p>
<p>A Part of Speech tagger.</p>
<p>The input is:
- path to the directory that contains SENNA executables.
- (optionally) the encoding of the input data (default:utf-8)</p>
<p>Example:</p>
<dl class="method">
<dt id="nltk.tag.senna.POSTagger.batch_tag">
<tt class="descname">batch_tag</tt><big>(</big><em>sentences</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/senna.html#POSTagger.batch_tag"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.senna.POSTagger.batch_tag" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies the tag method over a list of sentences. This method will return
for each sentence a list of tuples of (word, tag).</p>
</dd></dl>

</dd></dl>

<dl class="exception">
<dt id="nltk.tag.senna.RunFailure">
<em class="property">exception </em><tt class="descclassname">nltk.tag.senna.</tt><tt class="descname">RunFailure</tt><a class="reference internal" href="../_modules/nltk/tag/senna.html#RunFailure"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.senna.RunFailure" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.tag.senna.Error" title="nltk.tag.senna.Error"><tt class="xref py py-class docutils literal"><span class="pre">nltk.tag.senna.Error</span></tt></a></p>
<p>Raised if the pipeline fails to execute</p>
</dd></dl>

<dl class="class">
<dt id="nltk.tag.senna.SennaTagger">
<em class="property">class </em><tt class="descclassname">nltk.tag.senna.</tt><tt class="descname">SennaTagger</tt><big>(</big><em>senna_path</em>, <em>operations</em>, <em>encoding='utf-8'</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/senna.html#SennaTagger"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.senna.SennaTagger" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.tag.api.TaggerI" title="nltk.tag.api.TaggerI"><tt class="xref py py-class docutils literal"><span class="pre">nltk.tag.api.TaggerI</span></tt></a></p>
<p>A general interface of the SENNA pipeline that supports any of the
operations specified in SUPPORTED_OPERATIONS.</p>
<p>Applying multiple operations at once has the speed advantage. For example,
senna v2.0 will calculate the POS tags in case you are extracting the named
entities. Applying both of the operations will cost only the time of
extracting the named entities.</p>
<p>SENNA pipeline has a fixed maximum size of the sentences that it can read.
By default it is 1024 token/sentence. If you have larger sentences, changing
the MAX_SENTENCE_SIZE value in SENNA_main.c should be considered and your
system specific binary should be rebuilt. Otherwise this could introduce
misalignment errors.</p>
<p>The input is:
- path to the directory that contains SENNA executables.
- List of the operations needed to be performed.
- (optionally) the encoding of the input data (default:utf-8)</p>
<p>Example:</p>
<dl class="attribute">
<dt id="nltk.tag.senna.SennaTagger.SUPPORTED_OPERATIONS">
<tt class="descname">SUPPORTED_OPERATIONS</tt><em class="property"> = ['pos', 'chk', 'ner']</em><a class="headerlink" href="#nltk.tag.senna.SennaTagger.SUPPORTED_OPERATIONS" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nltk.tag.senna.SennaTagger.batch_tag">
<tt class="descname">batch_tag</tt><big>(</big><em>sentences</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/senna.html#SennaTagger.batch_tag"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.senna.SennaTagger.batch_tag" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies the tag method over a list of sentences. This method will return a
list of dictionaries. Every dictionary will contain a word with its
calculated annotations/tags.</p>
</dd></dl>

<dl class="attribute">
<dt id="nltk.tag.senna.SennaTagger.executable">
<tt class="descname">executable</tt><a class="reference internal" href="../_modules/nltk/tag/senna.html#SennaTagger.executable"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.senna.SennaTagger.executable" title="Permalink to this definition">¶</a></dt>
<dd><p>A property that determines the system specific binary that should be
used in the pipeline. In case, the system is not known the senna binary will
be used.</p>
</dd></dl>

<dl class="method">
<dt id="nltk.tag.senna.SennaTagger.tag">
<tt class="descname">tag</tt><big>(</big><em>tokens</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/senna.html#SennaTagger.tag"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.senna.SennaTagger.tag" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies the specified operation(s) on a list of tokens.</p>
</dd></dl>

</dd></dl>

<dl class="exception">
<dt id="nltk.tag.senna.SentenceMisalignment">
<em class="property">exception </em><tt class="descclassname">nltk.tag.senna.</tt><tt class="descname">SentenceMisalignment</tt><a class="reference internal" href="../_modules/nltk/tag/senna.html#SentenceMisalignment"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.senna.SentenceMisalignment" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.tag.senna.Error" title="nltk.tag.senna.Error"><tt class="xref py py-class docutils literal"><span class="pre">nltk.tag.senna.Error</span></tt></a></p>
<p>Raised if the new sentence is shorter than the original one or the number
of sentences in the result is less than the input.</p>
</dd></dl>

</div>
<div class="section" id="module-nltk.tag.sequential">
<span id="sequential-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">sequential</span></tt> Module<a class="headerlink" href="#module-nltk.tag.sequential" title="Permalink to this headline">¶</a></h2>
<p>Classes for tagging sentences sequentially, left to right.  The
abstract base class SequentialBackoffTagger serves as the base
class for all the taggers in this module.  Tagging of individual words
is performed by the method <tt class="docutils literal"><span class="pre">choose_tag()</span></tt>, which is defined by
subclasses of SequentialBackoffTagger.  If a tagger is unable to
determine a tag for the specified token, then its backoff tagger is
consulted instead.  Any SequentialBackoffTagger may serve as a
backoff tagger for any other SequentialBackoffTagger.</p>
<dl class="class">
<dt id="nltk.tag.sequential.AffixTagger">
<em class="property">class </em><tt class="descclassname">nltk.tag.sequential.</tt><tt class="descname">AffixTagger</tt><big>(</big><em>train=None</em>, <em>model=None</em>, <em>affix_length=-3</em>, <em>min_stem_length=2</em>, <em>backoff=None</em>, <em>cutoff=0</em>, <em>verbose=False</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/sequential.html#AffixTagger"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.sequential.AffixTagger" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.tag.sequential.ContextTagger" title="nltk.tag.sequential.ContextTagger"><tt class="xref py py-class docutils literal"><span class="pre">nltk.tag.sequential.ContextTagger</span></tt></a>, <tt class="xref py py-class docutils literal"><span class="pre">yaml.YAMLObject</span></tt></p>
<p>A tagger that chooses a token&#8217;s tag based on a leading or trailing
substring of its word string.  (It is important to note that these
substrings are not necessarily &#8220;true&#8221; morphological affixes).  In
particular, a fixed-length substring of the word is looked up in a
table, and the corresponding tag is returned.  Affix taggers are
typically constructed by training them on a tagged corpus.</p>
<p>Construct a new affix tagger.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>affix_length</strong> &#8211; The length of the affixes that should be
considered during training and tagging.  Use negative
numbers for suffixes.</li>
<li><strong>min_stem_length</strong> &#8211; Any words whose length is less than
min_stem_length+abs(affix_length) will be assigned a
tag of None by this tagger.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="nltk.tag.sequential.AffixTagger.context">
<tt class="descname">context</tt><big>(</big><em>tokens</em>, <em>index</em>, <em>history</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/sequential.html#AffixTagger.context"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.sequential.AffixTagger.context" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nltk.tag.sequential.AffixTagger.yaml_tag">
<tt class="descname">yaml_tag</tt><em class="property"> = '!nltk.AffixTagger'</em><a class="headerlink" href="#nltk.tag.sequential.AffixTagger.yaml_tag" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.tag.sequential.BigramTagger">
<em class="property">class </em><tt class="descclassname">nltk.tag.sequential.</tt><tt class="descname">BigramTagger</tt><big>(</big><em>train</em>, <em>model=None</em>, <em>backoff=None</em>, <em>cutoff=0</em>, <em>verbose=False</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/sequential.html#BigramTagger"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.sequential.BigramTagger" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.tag.sequential.NgramTagger" title="nltk.tag.sequential.NgramTagger"><tt class="xref py py-class docutils literal"><span class="pre">nltk.tag.sequential.NgramTagger</span></tt></a></p>
<p>A tagger that chooses a token&#8217;s tag based its word string and on
the preceding words&#8217; tag.  In particular, a tuple consisting
of the previous tag and the word is looked up in a table, and
the corresponding tag is returned.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>train</strong> (<em>list(list(tuple(str, str)))</em>) &#8211; The corpus of training data, a list of tagged sentences</li>
<li><strong>model</strong> (<em>dict</em>) &#8211; The tagger model</li>
<li><strong>backoff</strong> (<em>TaggerI</em>) &#8211; Another tagger which this tagger will consult when it is
unable to tag a word</li>
<li><strong>cutoff</strong> (<em>int</em>) &#8211; The number of instances of training data the tagger must see
in order not to use the backoff tagger</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="nltk.tag.sequential.BigramTagger.yaml_tag">
<tt class="descname">yaml_tag</tt><em class="property"> = '!nltk.BigramTagger'</em><a class="headerlink" href="#nltk.tag.sequential.BigramTagger.yaml_tag" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.tag.sequential.ClassifierBasedPOSTagger">
<em class="property">class </em><tt class="descclassname">nltk.tag.sequential.</tt><tt class="descname">ClassifierBasedPOSTagger</tt><big>(</big><em>feature_detector=None</em>, <em>train=None</em>, <em>classifier_builder=&lt;function train at 0x3734cf8&gt;</em>, <em>classifier=None</em>, <em>backoff=None</em>, <em>cutoff_prob=None</em>, <em>verbose=False</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/sequential.html#ClassifierBasedPOSTagger"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.sequential.ClassifierBasedPOSTagger" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.tag.sequential.ClassifierBasedTagger" title="nltk.tag.sequential.ClassifierBasedTagger"><tt class="xref py py-class docutils literal"><span class="pre">nltk.tag.sequential.ClassifierBasedTagger</span></tt></a></p>
<p>A classifier based part of speech tagger.</p>
<dl class="method">
<dt id="nltk.tag.sequential.ClassifierBasedPOSTagger.feature_detector">
<tt class="descname">feature_detector</tt><big>(</big><em>tokens</em>, <em>index</em>, <em>history</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/sequential.html#ClassifierBasedPOSTagger.feature_detector"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.sequential.ClassifierBasedPOSTagger.feature_detector" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.tag.sequential.ClassifierBasedTagger">
<em class="property">class </em><tt class="descclassname">nltk.tag.sequential.</tt><tt class="descname">ClassifierBasedTagger</tt><big>(</big><em>feature_detector=None</em>, <em>train=None</em>, <em>classifier_builder=&lt;function train at 0x3734cf8&gt;</em>, <em>classifier=None</em>, <em>backoff=None</em>, <em>cutoff_prob=None</em>, <em>verbose=False</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/sequential.html#ClassifierBasedTagger"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.sequential.ClassifierBasedTagger" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.tag.sequential.SequentialBackoffTagger" title="nltk.tag.sequential.SequentialBackoffTagger"><tt class="xref py py-class docutils literal"><span class="pre">nltk.tag.sequential.SequentialBackoffTagger</span></tt></a>, <a class="reference internal" href="#nltk.tag.api.FeaturesetTaggerI" title="nltk.tag.api.FeaturesetTaggerI"><tt class="xref py py-class docutils literal"><span class="pre">nltk.tag.api.FeaturesetTaggerI</span></tt></a></p>
<p>A sequential tagger that uses a classifier to choose the tag for
each token in a sentence.  The featureset input for the classifier
is generated by a feature detector function:</p>
<div class="highlight-python"><pre>feature_detector(tokens, index, history) -&gt; featureset</pre>
</div>
<p>Where tokens is the list of unlabeled tokens in the sentence;
index is the index of the token for which feature detection
should be performed; and history is list of the tags for all
tokens before index.</p>
<p>Construct a new classifier-based sequential tagger.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>feature_detector</strong> &#8211; A function used to generate the
featureset input for the classifier::
feature_detector(tokens, index, history) -&gt; featureset</li>
<li><strong>train</strong> &#8211; A tagged corpus consisting of a list of tagged
sentences, where each sentence is a list of (word, tag) tuples.</li>
<li><strong>backoff</strong> &#8211; A backoff tagger, to be used by the new tagger
if it encounters an unknown context.</li>
<li><strong>classifier_builder</strong> &#8211; A function used to train a new
classifier based on the data in <em>train</em>.  It should take
one argument, a list of labeled featuresets (i.e.,
(featureset, label) tuples).</li>
<li><strong>classifier</strong> &#8211; The classifier that should be used by the
tagger.  This is only useful if you want to manually
construct the classifier; normally, you would use <em>train</em>
instead.</li>
<li><strong>backoff</strong> &#8211; A backoff tagger, used if this tagger is
unable to determine a tag for a given token.</li>
<li><strong>cutoff_prob</strong> &#8211; If specified, then this tagger will fall
back on its backoff tagger if the probability of the most
likely tag is less than <em>cutoff_prob</em>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="nltk.tag.sequential.ClassifierBasedTagger.choose_tag">
<tt class="descname">choose_tag</tt><big>(</big><em>tokens</em>, <em>index</em>, <em>history</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/sequential.html#ClassifierBasedTagger.choose_tag"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.sequential.ClassifierBasedTagger.choose_tag" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nltk.tag.sequential.ClassifierBasedTagger.classifier">
<tt class="descname">classifier</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/tag/sequential.html#ClassifierBasedTagger.classifier"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.sequential.ClassifierBasedTagger.classifier" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the classifier that this tagger uses to choose a tag
for each word in a sentence.  The input for this classifier is
generated using this tagger&#8217;s feature detector.
See <tt class="docutils literal"><span class="pre">feature_detector()</span></tt></p>
</dd></dl>

<dl class="method">
<dt id="nltk.tag.sequential.ClassifierBasedTagger.feature_detector">
<tt class="descname">feature_detector</tt><big>(</big><em>tokens</em>, <em>index</em>, <em>history</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/sequential.html#ClassifierBasedTagger.feature_detector"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.sequential.ClassifierBasedTagger.feature_detector" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the feature detector that this tagger uses to generate
featuresets for its classifier.  The feature detector is a
function with the signature:</p>
<div class="highlight-python"><pre>feature_detector(tokens, index, history) -&gt; featureset</pre>
</div>
<p>See <tt class="docutils literal"><span class="pre">classifier()</span></tt></p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.tag.sequential.ContextTagger">
<em class="property">class </em><tt class="descclassname">nltk.tag.sequential.</tt><tt class="descname">ContextTagger</tt><big>(</big><em>context_to_tag</em>, <em>backoff=None</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/sequential.html#ContextTagger"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.sequential.ContextTagger" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.tag.sequential.SequentialBackoffTagger" title="nltk.tag.sequential.SequentialBackoffTagger"><tt class="xref py py-class docutils literal"><span class="pre">nltk.tag.sequential.SequentialBackoffTagger</span></tt></a></p>
<p>An abstract base class for sequential backoff taggers that choose
a tag for a token based on the value of its &#8220;context&#8221;.  Different
subclasses are used to define different contexts.</p>
<p>A ContextTagger chooses the tag for a token by calculating the
token&#8217;s context, and looking up the corresponding tag in a table.
This table can be constructed manually; or it can be automatically
constructed based on a training corpus, using the <tt class="docutils literal"><span class="pre">_train()</span></tt>
factory method.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><strong>_context_to_tag</strong> &#8211; Dictionary mapping contexts to tags.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="nltk.tag.sequential.ContextTagger.choose_tag">
<tt class="descname">choose_tag</tt><big>(</big><em>tokens</em>, <em>index</em>, <em>history</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/sequential.html#ContextTagger.choose_tag"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.sequential.ContextTagger.choose_tag" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nltk.tag.sequential.ContextTagger.context">
<tt class="descname">context</tt><big>(</big><em>tokens</em>, <em>index</em>, <em>history</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/sequential.html#ContextTagger.context"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.sequential.ContextTagger.context" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">the context that should be used to look up the tag
for the specified token; or None if the specified token
should not be handled by this tagger.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">(hashable)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.tag.sequential.ContextTagger.size">
<tt class="descname">size</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/tag/sequential.html#ContextTagger.size"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.sequential.ContextTagger.size" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The number of entries in the table used by this</td>
</tr>
</tbody>
</table>
<p>tagger to map from contexts to tags.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.tag.sequential.DefaultTagger">
<em class="property">class </em><tt class="descclassname">nltk.tag.sequential.</tt><tt class="descname">DefaultTagger</tt><big>(</big><em>tag</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/sequential.html#DefaultTagger"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.sequential.DefaultTagger" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.tag.sequential.SequentialBackoffTagger" title="nltk.tag.sequential.SequentialBackoffTagger"><tt class="xref py py-class docutils literal"><span class="pre">nltk.tag.sequential.SequentialBackoffTagger</span></tt></a>, <tt class="xref py py-class docutils literal"><span class="pre">yaml.YAMLObject</span></tt></p>
<p>A tagger that assigns the same tag to every token.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">nltk.tag.sequential</span> <span class="kn">import</span> <span class="n">DefaultTagger</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">default_tagger</span> <span class="o">=</span> <span class="n">DefaultTagger</span><span class="p">(</span><span class="s">&#39;NN&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">default_tagger</span><span class="o">.</span><span class="n">tag</span><span class="p">(</span><span class="s">&#39;This is a test&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">())</span>
<span class="go">[(&#39;This&#39;, &#39;NN&#39;), (&#39;is&#39;, &#39;NN&#39;), (&#39;a&#39;, &#39;NN&#39;), (&#39;test&#39;, &#39;NN&#39;)]</span>
</pre></div>
</div>
<p>This tagger is recommended as a backoff tagger, in cases where
a more powerful tagger is unable to assign a tag to the word
(e.g. because the word was not seen during training).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>tag</strong> (<em>str</em>) &#8211; The tag to assign to each token</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="nltk.tag.sequential.DefaultTagger.choose_tag">
<tt class="descname">choose_tag</tt><big>(</big><em>tokens</em>, <em>index</em>, <em>history</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/sequential.html#DefaultTagger.choose_tag"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.sequential.DefaultTagger.choose_tag" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nltk.tag.sequential.DefaultTagger.yaml_tag">
<tt class="descname">yaml_tag</tt><em class="property"> = '!nltk.DefaultTagger'</em><a class="headerlink" href="#nltk.tag.sequential.DefaultTagger.yaml_tag" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.tag.sequential.NgramTagger">
<em class="property">class </em><tt class="descclassname">nltk.tag.sequential.</tt><tt class="descname">NgramTagger</tt><big>(</big><em>n</em>, <em>train=None</em>, <em>model=None</em>, <em>backoff=None</em>, <em>cutoff=0</em>, <em>verbose=False</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/sequential.html#NgramTagger"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.sequential.NgramTagger" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.tag.sequential.ContextTagger" title="nltk.tag.sequential.ContextTagger"><tt class="xref py py-class docutils literal"><span class="pre">nltk.tag.sequential.ContextTagger</span></tt></a>, <tt class="xref py py-class docutils literal"><span class="pre">yaml.YAMLObject</span></tt></p>
<p>A tagger that chooses a token&#8217;s tag based on its word string and
on the preceding n word&#8217;s tags.  In particular, a tuple
(tags[i-n:i-1], words[i]) is looked up in a table, and the
corresponding tag is returned.  N-gram taggers are typically
trained on a tagged corpus.</p>
<p>Train a new NgramTagger using the given training data or
the supplied model.  In particular, construct a new tagger
whose table maps from each context (tag[i-n:i-1], word[i])
to the most frequent tag for that context.  But exclude any
contexts that are already tagged perfectly by the backoff
tagger.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>train</strong> &#8211; A tagged corpus consisting of a list of tagged
sentences, where each sentence is a list of (word, tag) tuples.</li>
<li><strong>backoff</strong> &#8211; A backoff tagger, to be used by the new
tagger if it encounters an unknown context.</li>
<li><strong>cutoff</strong> &#8211; If the most likely tag for a context occurs
fewer than <em>cutoff</em> times, then exclude it from the
context-to-tag table for the new tagger.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="nltk.tag.sequential.NgramTagger.context">
<tt class="descname">context</tt><big>(</big><em>tokens</em>, <em>index</em>, <em>history</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/sequential.html#NgramTagger.context"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.sequential.NgramTagger.context" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nltk.tag.sequential.NgramTagger.yaml_tag">
<tt class="descname">yaml_tag</tt><em class="property"> = '!nltk.NgramTagger'</em><a class="headerlink" href="#nltk.tag.sequential.NgramTagger.yaml_tag" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.tag.sequential.RegexpTagger">
<em class="property">class </em><tt class="descclassname">nltk.tag.sequential.</tt><tt class="descname">RegexpTagger</tt><big>(</big><em>regexps</em>, <em>backoff=None</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/sequential.html#RegexpTagger"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.sequential.RegexpTagger" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.tag.sequential.SequentialBackoffTagger" title="nltk.tag.sequential.SequentialBackoffTagger"><tt class="xref py py-class docutils literal"><span class="pre">nltk.tag.sequential.SequentialBackoffTagger</span></tt></a>, <tt class="xref py py-class docutils literal"><span class="pre">yaml.YAMLObject</span></tt></p>
<p>Regular Expression Tagger</p>
<p>The RegexpTagger assigns tags to tokens by comparing their
word strings to a series of regular expressions.  The following tagger
uses word suffixes to make guesses about the correct Brown Corpus part
of speech tag:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">nltk.corpus</span> <span class="kn">import</span> <span class="n">brown</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">nltk.tag.sequential</span> <span class="kn">import</span> <span class="n">RegexpTagger</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">test_sent</span> <span class="o">=</span> <span class="n">brown</span><span class="o">.</span><span class="n">sents</span><span class="p">(</span><span class="n">categories</span><span class="o">=</span><span class="s">&#39;news&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">regexp_tagger</span> <span class="o">=</span> <span class="n">RegexpTagger</span><span class="p">(</span>
<span class="gp">... </span>    <span class="p">[(</span><span class="s">r&#39;^-?[0-9]+(.[0-9]+)?$&#39;</span><span class="p">,</span> <span class="s">&#39;CD&#39;</span><span class="p">),</span>   <span class="c"># cardinal numbers</span>
<span class="gp">... </span>     <span class="p">(</span><span class="s">r&#39;(The|the|A|a|An|an)$&#39;</span><span class="p">,</span> <span class="s">&#39;AT&#39;</span><span class="p">),</span>   <span class="c"># articles</span>
<span class="gp">... </span>     <span class="p">(</span><span class="s">r&#39;.*able$&#39;</span><span class="p">,</span> <span class="s">&#39;JJ&#39;</span><span class="p">),</span>                <span class="c"># adjectives</span>
<span class="gp">... </span>     <span class="p">(</span><span class="s">r&#39;.*ness$&#39;</span><span class="p">,</span> <span class="s">&#39;NN&#39;</span><span class="p">),</span>                <span class="c"># nouns formed from adjectives</span>
<span class="gp">... </span>     <span class="p">(</span><span class="s">r&#39;.*ly$&#39;</span><span class="p">,</span> <span class="s">&#39;RB&#39;</span><span class="p">),</span>                  <span class="c"># adverbs</span>
<span class="gp">... </span>     <span class="p">(</span><span class="s">r&#39;.*s$&#39;</span><span class="p">,</span> <span class="s">&#39;NNS&#39;</span><span class="p">),</span>                  <span class="c"># plural nouns</span>
<span class="gp">... </span>     <span class="p">(</span><span class="s">r&#39;.*ing$&#39;</span><span class="p">,</span> <span class="s">&#39;VBG&#39;</span><span class="p">),</span>                <span class="c"># gerunds</span>
<span class="gp">... </span>     <span class="p">(</span><span class="s">r&#39;.*ed$&#39;</span><span class="p">,</span> <span class="s">&#39;VBD&#39;</span><span class="p">),</span>                 <span class="c"># past tense verbs</span>
<span class="gp">... </span>     <span class="p">(</span><span class="s">r&#39;.*&#39;</span><span class="p">,</span> <span class="s">&#39;NN&#39;</span><span class="p">)</span>                      <span class="c"># nouns (default)</span>
<span class="gp">... </span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">regexp_tagger</span><span class="o">.</span><span class="n">tag</span><span class="p">(</span><span class="n">test_sent</span><span class="p">)</span>
<span class="go">[(&#39;The&#39;, &#39;AT&#39;), (&#39;Fulton&#39;, &#39;NN&#39;), (&#39;County&#39;, &#39;NN&#39;), (&#39;Grand&#39;, &#39;NN&#39;), (&#39;Jury&#39;, &#39;NN&#39;),</span>
<span class="go">(&#39;said&#39;, &#39;NN&#39;), (&#39;Friday&#39;, &#39;NN&#39;), (&#39;an&#39;, &#39;AT&#39;), (&#39;investigation&#39;, &#39;NN&#39;), (&#39;of&#39;, &#39;NN&#39;),</span>
<span class="go">(&quot;Atlanta&#39;s&quot;, &#39;NNS&#39;), (&#39;recent&#39;, &#39;NN&#39;), (&#39;primary&#39;, &#39;NN&#39;), (&#39;election&#39;, &#39;NN&#39;),</span>
<span class="go">(&#39;produced&#39;, &#39;VBD&#39;), (&#39;``&#39;, &#39;NN&#39;), (&#39;no&#39;, &#39;NN&#39;), (&#39;evidence&#39;, &#39;NN&#39;), (&quot;&#39;&#39;&quot;, &#39;NN&#39;),</span>
<span class="go">(&#39;that&#39;, &#39;NN&#39;), (&#39;any&#39;, &#39;NN&#39;), (&#39;irregularities&#39;, &#39;NNS&#39;), (&#39;took&#39;, &#39;NN&#39;),</span>
<span class="go">(&#39;place&#39;, &#39;NN&#39;), (&#39;.&#39;, &#39;NN&#39;)]</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>regexps</strong> (<em>list(tuple(str, str))</em>) &#8211; A list of <tt class="docutils literal"><span class="pre">(regexp,</span> <span class="pre">tag)</span></tt> pairs, each of
which indicates that a word matching <tt class="docutils literal"><span class="pre">regexp</span></tt> should
be tagged with <tt class="docutils literal"><span class="pre">tag</span></tt>.  The pairs will be evalutated in
order.  If none of the regexps match a word, then the
optional backoff tagger is invoked, else it is
assigned the tag None.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="nltk.tag.sequential.RegexpTagger.choose_tag">
<tt class="descname">choose_tag</tt><big>(</big><em>tokens</em>, <em>index</em>, <em>history</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/sequential.html#RegexpTagger.choose_tag"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.sequential.RegexpTagger.choose_tag" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nltk.tag.sequential.RegexpTagger.yaml_tag">
<tt class="descname">yaml_tag</tt><em class="property"> = '!nltk.RegexpTagger'</em><a class="headerlink" href="#nltk.tag.sequential.RegexpTagger.yaml_tag" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.tag.sequential.SequentialBackoffTagger">
<em class="property">class </em><tt class="descclassname">nltk.tag.sequential.</tt><tt class="descname">SequentialBackoffTagger</tt><big>(</big><em>backoff=None</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/sequential.html#SequentialBackoffTagger"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.sequential.SequentialBackoffTagger" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.tag.api.TaggerI" title="nltk.tag.api.TaggerI"><tt class="xref py py-class docutils literal"><span class="pre">nltk.tag.api.TaggerI</span></tt></a></p>
<p>An abstract base class for taggers that tags words sequentially,
left to right.  Tagging of individual words is performed by the
<tt class="docutils literal"><span class="pre">choose_tag()</span></tt> method, which should be defined by subclasses.  If
a tagger is unable to determine a tag for the specified token,
then its backoff tagger is consulted.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><strong>_taggers</strong> &#8211; A list of all the taggers that should be tried to
tag a token (i.e., self and its backoff taggers).</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="nltk.tag.sequential.SequentialBackoffTagger.backoff">
<tt class="descname">backoff</tt><a class="reference internal" href="../_modules/nltk/tag/sequential.html#SequentialBackoffTagger.backoff"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.sequential.SequentialBackoffTagger.backoff" title="Permalink to this definition">¶</a></dt>
<dd><p>The backoff tagger for this tagger.</p>
</dd></dl>

<dl class="method">
<dt id="nltk.tag.sequential.SequentialBackoffTagger.choose_tag">
<tt class="descname">choose_tag</tt><big>(</big><em>tokens</em>, <em>index</em>, <em>history</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/sequential.html#SequentialBackoffTagger.choose_tag"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.sequential.SequentialBackoffTagger.choose_tag" title="Permalink to this definition">¶</a></dt>
<dd><p>Decide which tag should be used for the specified token, and
return that tag.  If this tagger is unable to determine a tag
for the specified token, return None &#8211; do not consult
the backoff tagger.  This method should be overridden by
subclasses of SequentialBackoffTagger.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">str</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>tokens</strong> (<em>list</em>) &#8211; The list of words that are being tagged.</li>
<li><strong>index</strong> (<em>int</em>) &#8211; The index of the word whose tag should be
returned.</li>
<li><strong>history</strong> (<em>list(str)</em>) &#8211; A list of the tags for all words before <em>index</em>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.tag.sequential.SequentialBackoffTagger.tag">
<tt class="descname">tag</tt><big>(</big><em>tokens</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/sequential.html#SequentialBackoffTagger.tag"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.sequential.SequentialBackoffTagger.tag" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nltk.tag.sequential.SequentialBackoffTagger.tag_one">
<tt class="descname">tag_one</tt><big>(</big><em>tokens</em>, <em>index</em>, <em>history</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/sequential.html#SequentialBackoffTagger.tag_one"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.sequential.SequentialBackoffTagger.tag_one" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine an appropriate tag for the specified token, and
return that tag.  If this tagger is unable to determine a tag
for the specified token, then its backoff tagger is consulted.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">str</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>tokens</strong> (<em>list</em>) &#8211; The list of words that are being tagged.</li>
<li><strong>index</strong> (<em>int</em>) &#8211; The index of the word whose tag should be
returned.</li>
<li><strong>history</strong> (<em>list(str)</em>) &#8211; A list of the tags for all words before <em>index</em>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.tag.sequential.TrigramTagger">
<em class="property">class </em><tt class="descclassname">nltk.tag.sequential.</tt><tt class="descname">TrigramTagger</tt><big>(</big><em>train=None</em>, <em>model=None</em>, <em>backoff=None</em>, <em>cutoff=0</em>, <em>verbose=False</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/sequential.html#TrigramTagger"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.sequential.TrigramTagger" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.tag.sequential.NgramTagger" title="nltk.tag.sequential.NgramTagger"><tt class="xref py py-class docutils literal"><span class="pre">nltk.tag.sequential.NgramTagger</span></tt></a></p>
<p>A tagger that chooses a token&#8217;s tag based its word string and on
the preceding two words&#8217; tags.  In particular, a tuple consisting
of the previous two tags and the word is looked up in a table, and
the corresponding tag is returned.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>train</strong> (<em>list(list(tuple(str, str)))</em>) &#8211; The corpus of training data, a list of tagged sentences</li>
<li><strong>model</strong> (<em>dict</em>) &#8211; The tagger model</li>
<li><strong>backoff</strong> (<em>TaggerI</em>) &#8211; Another tagger which this tagger will consult when it is
unable to tag a word</li>
<li><strong>cutoff</strong> (<em>int</em>) &#8211; The number of instances of training data the tagger must see
in order not to use the backoff tagger</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="nltk.tag.sequential.TrigramTagger.yaml_tag">
<tt class="descname">yaml_tag</tt><em class="property"> = '!nltk.TrigramTagger'</em><a class="headerlink" href="#nltk.tag.sequential.TrigramTagger.yaml_tag" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.tag.sequential.UnigramTagger">
<em class="property">class </em><tt class="descclassname">nltk.tag.sequential.</tt><tt class="descname">UnigramTagger</tt><big>(</big><em>train=None</em>, <em>model=None</em>, <em>backoff=None</em>, <em>cutoff=0</em>, <em>verbose=False</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/sequential.html#UnigramTagger"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.sequential.UnigramTagger" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.tag.sequential.NgramTagger" title="nltk.tag.sequential.NgramTagger"><tt class="xref py py-class docutils literal"><span class="pre">nltk.tag.sequential.NgramTagger</span></tt></a></p>
<p>Unigram Tagger</p>
<p>The UnigramTagger finds the most likely tag for each word in a training
corpus, and then uses that information to assign tags to new tokens.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">nltk.corpus</span> <span class="kn">import</span> <span class="n">brown</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">nltk.tag.sequential</span> <span class="kn">import</span> <span class="n">UnigramTagger</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">test_sent</span> <span class="o">=</span> <span class="n">brown</span><span class="o">.</span><span class="n">sents</span><span class="p">(</span><span class="n">categories</span><span class="o">=</span><span class="s">&#39;news&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">unigram_tagger</span> <span class="o">=</span> <span class="n">UnigramTagger</span><span class="p">(</span><span class="n">brown</span><span class="o">.</span><span class="n">tagged_sents</span><span class="p">(</span><span class="n">categories</span><span class="o">=</span><span class="s">&#39;news&#39;</span><span class="p">)[:</span><span class="mi">500</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">unigram_tagger</span><span class="o">.</span><span class="n">tag</span><span class="p">(</span><span class="n">test_sent</span><span class="p">)</span>
<span class="go">[(&#39;The&#39;, &#39;AT&#39;), (&#39;Fulton&#39;, &#39;NP-TL&#39;), (&#39;County&#39;, &#39;NN-TL&#39;), (&#39;Grand&#39;, &#39;JJ-TL&#39;),</span>
<span class="go">(&#39;Jury&#39;, &#39;NN-TL&#39;), (&#39;said&#39;, &#39;VBD&#39;), (&#39;Friday&#39;, &#39;NR&#39;), (&#39;an&#39;, &#39;AT&#39;),</span>
<span class="go">(&#39;investigation&#39;, &#39;NN&#39;), (&#39;of&#39;, &#39;IN&#39;), (&quot;Atlanta&#39;s&quot;, &#39;NP$&#39;), (&#39;recent&#39;, &#39;JJ&#39;),</span>
<span class="go">(&#39;primary&#39;, &#39;NN&#39;), (&#39;election&#39;, &#39;NN&#39;), (&#39;produced&#39;, &#39;VBD&#39;), (&#39;``&#39;, &#39;``&#39;),</span>
<span class="go">(&#39;no&#39;, &#39;AT&#39;), (&#39;evidence&#39;, &#39;NN&#39;), (&quot;&#39;&#39;&quot;, &quot;&#39;&#39;&quot;), (&#39;that&#39;, &#39;CS&#39;), (&#39;any&#39;, &#39;DTI&#39;),</span>
<span class="go">(&#39;irregularities&#39;, &#39;NNS&#39;), (&#39;took&#39;, &#39;VBD&#39;), (&#39;place&#39;, &#39;NN&#39;), (&#39;.&#39;, &#39;.&#39;)]</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>train</strong> (<em>list(list(tuple(str, str)))</em>) &#8211; The corpus of training data, a list of tagged sentences</li>
<li><strong>model</strong> (<em>dict</em>) &#8211; The tagger model</li>
<li><strong>backoff</strong> (<em>TaggerI</em>) &#8211; Another tagger which this tagger will consult when it is
unable to tag a word</li>
<li><strong>cutoff</strong> (<em>int</em>) &#8211; The number of instances of training data the tagger must see
in order not to use the backoff tagger</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="nltk.tag.sequential.UnigramTagger.context">
<tt class="descname">context</tt><big>(</big><em>tokens</em>, <em>index</em>, <em>history</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/sequential.html#UnigramTagger.context"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.sequential.UnigramTagger.context" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nltk.tag.sequential.UnigramTagger.yaml_tag">
<tt class="descname">yaml_tag</tt><em class="property"> = '!nltk.UnigramTagger'</em><a class="headerlink" href="#nltk.tag.sequential.UnigramTagger.yaml_tag" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="module-nltk.tag.simplify">
<span id="simplify-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">simplify</span></tt> Module<a class="headerlink" href="#module-nltk.tag.simplify" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="nltk.tag.simplify.simplify_alpino_tag">
<tt class="descclassname">nltk.tag.simplify.</tt><tt class="descname">simplify_alpino_tag</tt><big>(</big><em>tag</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/simplify.html#simplify_alpino_tag"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.simplify.simplify_alpino_tag" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="nltk.tag.simplify.simplify_brown_tag">
<tt class="descclassname">nltk.tag.simplify.</tt><tt class="descname">simplify_brown_tag</tt><big>(</big><em>tag</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/simplify.html#simplify_brown_tag"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.simplify.simplify_brown_tag" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="nltk.tag.simplify.simplify_indian_tag">
<tt class="descclassname">nltk.tag.simplify.</tt><tt class="descname">simplify_indian_tag</tt><big>(</big><em>tag</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/simplify.html#simplify_indian_tag"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.simplify.simplify_indian_tag" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="nltk.tag.simplify.simplify_tag">
<tt class="descclassname">nltk.tag.simplify.</tt><tt class="descname">simplify_tag</tt><big>(</big><em>tag</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/simplify.html#simplify_tag"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.simplify.simplify_tag" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="nltk.tag.simplify.simplify_wsj_tag">
<tt class="descclassname">nltk.tag.simplify.</tt><tt class="descname">simplify_wsj_tag</tt><big>(</big><em>tag</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/simplify.html#simplify_wsj_tag"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.simplify.simplify_wsj_tag" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-nltk.tag.stanford">
<span id="stanford-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">stanford</span></tt> Module<a class="headerlink" href="#module-nltk.tag.stanford" title="Permalink to this headline">¶</a></h2>
<p>A module for interfacing with the Stanford taggers.</p>
<dl class="class">
<dt id="nltk.tag.stanford.NERTagger">
<em class="property">class </em><tt class="descclassname">nltk.tag.stanford.</tt><tt class="descname">NERTagger</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/stanford.html#NERTagger"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.stanford.NERTagger" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.tag.stanford.StanfordTagger" title="nltk.tag.stanford.StanfordTagger"><tt class="xref py py-class docutils literal"><span class="pre">nltk.tag.stanford.StanfordTagger</span></tt></a></p>
<p>A class for ner tagging with Stanford Tagger. The input is the paths to:</p>
<ul class="simple">
<li>a model trained on training data</li>
<li>(optionally) the path to the stanford tagger jar file. If not specified here,
then this jar file must be specified in the CLASSPATH envinroment variable.</li>
<li>(optionally) the encoding of the training data (default: ASCII)</li>
</ul>
<p>Example:</p>
<dl class="method">
<dt id="nltk.tag.stanford.NERTagger.parse_output">
<tt class="descname">parse_output</tt><big>(</big><em>text</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/stanford.html#NERTagger.parse_output"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.stanford.NERTagger.parse_output" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.tag.stanford.POSTagger">
<em class="property">class </em><tt class="descclassname">nltk.tag.stanford.</tt><tt class="descname">POSTagger</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/stanford.html#POSTagger"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.stanford.POSTagger" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.tag.stanford.StanfordTagger" title="nltk.tag.stanford.StanfordTagger"><tt class="xref py py-class docutils literal"><span class="pre">nltk.tag.stanford.StanfordTagger</span></tt></a></p>
<dl class="docutils">
<dt>A class for pos tagging with Stanford Tagger. The input is the paths to:</dt>
<dd><ul class="first last simple">
<li>a model trained on training data</li>
<li>(optionally) the path to the stanford tagger jar file. If not specified here,
then this jar file must be specified in the CLASSPATH envinroment variable.</li>
<li>(optionally) the encoding of the training data (default: ASCII)</li>
</ul>
</dd>
</dl>
<p>Example:</p>
</dd></dl>

<dl class="class">
<dt id="nltk.tag.stanford.StanfordTagger">
<em class="property">class </em><tt class="descclassname">nltk.tag.stanford.</tt><tt class="descname">StanfordTagger</tt><big>(</big><em>path_to_model</em>, <em>path_to_jar=None</em>, <em>encoding=None</em>, <em>verbose=False</em>, <em>java_options='-mx1000m'</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/stanford.html#StanfordTagger"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.stanford.StanfordTagger" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.tag.api.TaggerI" title="nltk.tag.api.TaggerI"><tt class="xref py py-class docutils literal"><span class="pre">nltk.tag.api.TaggerI</span></tt></a></p>
<p>An interface to Stanford taggers. Subclasses must define:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">_cmd</span></tt> property: A property that returns the command that will be
executed.</li>
<li><tt class="docutils literal"><span class="pre">_SEPARATOR</span></tt>: Class constant that represents that character that
is used to separate the tokens from their tags.</li>
<li><tt class="docutils literal"><span class="pre">_JAR</span></tt> file: Class constant that represents the jar file name.</li>
</ul>
<dl class="method">
<dt id="nltk.tag.stanford.StanfordTagger.batch_tag">
<tt class="descname">batch_tag</tt><big>(</big><em>sentences</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/stanford.html#StanfordTagger.batch_tag"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.stanford.StanfordTagger.batch_tag" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nltk.tag.stanford.StanfordTagger.parse_output">
<tt class="descname">parse_output</tt><big>(</big><em>text</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/stanford.html#StanfordTagger.parse_output"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.stanford.StanfordTagger.parse_output" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nltk.tag.stanford.StanfordTagger.tag">
<tt class="descname">tag</tt><big>(</big><em>tokens</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/stanford.html#StanfordTagger.tag"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.stanford.StanfordTagger.tag" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="module-nltk.tag.tnt">
<span id="tnt-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">tnt</span></tt> Module<a class="headerlink" href="#module-nltk.tag.tnt" title="Permalink to this headline">¶</a></h2>
<p>Implementation of &#8216;TnT - A Statisical Part of Speech Tagger&#8217;
by Thorsten Brants</p>
<p><a class="reference external" href="http://acl.ldc.upenn.edu/A/A00/A00-1031.pdf">http://acl.ldc.upenn.edu/A/A00/A00-1031.pdf</a></p>
<dl class="class">
<dt id="nltk.tag.tnt.TnT">
<em class="property">class </em><tt class="descclassname">nltk.tag.tnt.</tt><tt class="descname">TnT</tt><big>(</big><em>unk=None</em>, <em>Trained=False</em>, <em>N=1000</em>, <em>C=False</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/tnt.html#TnT"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.tnt.TnT" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.tag.api.TaggerI" title="nltk.tag.api.TaggerI"><tt class="xref py py-class docutils literal"><span class="pre">nltk.tag.api.TaggerI</span></tt></a></p>
<p>TnT - Statistical POS tagger</p>
<p>IMPORTANT NOTES:</p>
<ul class="simple">
<li>DOES NOT AUTOMATICALLY DEAL WITH UNSEEN WORDS<ul>
<li>It is possible to provide an untrained POS tagger to
create tags for unknown words, see __init__ function</li>
</ul>
</li>
<li>SHOULD BE USED WITH SENTENCE-DELIMITED INPUT<ul>
<li>Due to the nature of this tagger, it works best when
trained over sentence delimited input.</li>
<li>However it still produces good results if the training
data and testing data are separated on all punctuation eg: [,.?!]</li>
<li>Input for training is expected to be a list of sentences
where each sentence is a list of (word, tag) tuples</li>
<li>Input for tag function is a single sentence
Input for tagdata function is a list of sentences
Output is of a similar form</li>
</ul>
</li>
<li>Function provided to process text that is unsegmented<ul>
<li>Please see basic_sent_chop()</li>
</ul>
</li>
</ul>
<p>TnT uses a second order Markov model to produce tags for
a sequence of input, specifically:</p>
<blockquote>
<div>argmax [Proj(P(t_i|t_i-1,t_i-2)P(w_i|t_i))] P(t_T+1 | t_T)</div></blockquote>
<p>IE: the maximum projection of a set of probabilities</p>
<p>The set of possible tags for a given word is derived
from the training data. It is the set of all tags
that exact word has been assigned.</p>
<p>The probability of a tag for a given word is the linear
interpolation of 3 markov models; a zero-order, first-order,
and a second order model.</p>
<blockquote>
<div><dl class="docutils">
<dt>P(t_i| t_i-1, t_i-2) = l1*P(t_i) + l2*P(t_i| t_i-1) +</dt>
<dd>l3*P(t_i| t_i-1, t_i-2)</dd>
</dl>
</div></blockquote>
<p>A beam search is used to limit the memory usage of the algorithm.
The degree of the beam can be changed using N in the initialization.
N represents the maximum number of possible solutions to maintain
while tagging.</p>
<p>It is possible to differentiate the tags which are assigned to
capitalized words. However this does not result in a significant
gain in the accuracy of the results.</p>
<dl class="method">
<dt id="nltk.tag.tnt.TnT.tag">
<tt class="descname">tag</tt><big>(</big><em>data</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/tnt.html#TnT.tag"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.tnt.TnT.tag" title="Permalink to this definition">¶</a></dt>
<dd><p>Tags a single sentence</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>data</strong> (<em>[string,]</em>) &#8211; list of words</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">[(word, tag),]</td>
</tr>
</tbody>
</table>
<p>Calls recursive function &#8216;_tagword&#8217;
to produce a list of tags</p>
<p>Associates the sequence of returned tags
with the correct words in the input sequence</p>
<p>returns a list of (word, tag) tuples</p>
</dd></dl>

<dl class="method">
<dt id="nltk.tag.tnt.TnT.tagdata">
<tt class="descname">tagdata</tt><big>(</big><em>data</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/tnt.html#TnT.tagdata"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.tnt.TnT.tagdata" title="Permalink to this definition">¶</a></dt>
<dd><p>Tags each sentence in a list of sentences</p>
<p>:param <a class="reference external" href="data:list">data:list</a> of list of words
:type data: [[string,],]
:return: list of list of (word, tag) tuples</p>
<p>Invokes tag(sent) function for each sentence
compiles the results into a list of tagged sentences
each tagged sentence is a list of (word, tag) tuples</p>
</dd></dl>

<dl class="method">
<dt id="nltk.tag.tnt.TnT.train">
<tt class="descname">train</tt><big>(</big><em>data</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/tnt.html#TnT.train"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.tnt.TnT.train" title="Permalink to this definition">¶</a></dt>
<dd><p>Uses a set of tagged data to train the tagger.
If an unknown word tagger is specified,
it is trained on the same data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>data</strong> (<em>tuple(str)</em>) &#8211; List of lists of (word, tag) tuples</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="nltk.tag.tnt.basic_sent_chop">
<tt class="descclassname">nltk.tag.tnt.</tt><tt class="descname">basic_sent_chop</tt><big>(</big><em>data</em>, <em>raw=True</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/tnt.html#basic_sent_chop"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.tnt.basic_sent_chop" title="Permalink to this definition">¶</a></dt>
<dd><p>Basic method for tokenizing input into sentences
for this tagger:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<em>str or tuple(str, str)</em>) &#8211; list of tokens (words or (word, tag) tuples)</li>
<li><strong>raw</strong> (<em>bool</em>) &#8211; boolean flag marking the input data
as a list of words or a list of tagged words</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">list of sentences
sentences are a list of tokens
tokens are the same as the input</p>
</td>
</tr>
</tbody>
</table>
<p>Function takes a list of tokens and separates the tokens into lists
where each list represents a sentence fragment
This function can separate both tagged and raw sequences into
basic sentences.</p>
<p>Sentence markers are the set of [,.!?]</p>
<p>This is a simple method which enhances the performance of the TnT
tagger. Better sentence tokenization will further enhance the results.</p>
</dd></dl>

<dl class="function">
<dt id="nltk.tag.tnt.demo">
<tt class="descclassname">nltk.tag.tnt.</tt><tt class="descname">demo</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/tag/tnt.html#demo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.tnt.demo" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="nltk.tag.tnt.demo2">
<tt class="descclassname">nltk.tag.tnt.</tt><tt class="descname">demo2</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/tag/tnt.html#demo2"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.tnt.demo2" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="nltk.tag.tnt.demo3">
<tt class="descclassname">nltk.tag.tnt.</tt><tt class="descname">demo3</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/tag/tnt.html#demo3"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.tnt.demo3" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-nltk.tag.util">
<span id="util-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">util</span></tt> Module<a class="headerlink" href="#module-nltk.tag.util" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="nltk.tag.util.str2tuple">
<tt class="descclassname">nltk.tag.util.</tt><tt class="descname">str2tuple</tt><big>(</big><em>s</em>, <em>sep='/'</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/util.html#str2tuple"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.util.str2tuple" title="Permalink to this definition">¶</a></dt>
<dd><p>Given the string representation of a tagged token, return the
corresponding tuple representation.  The rightmost occurrence of
<em>sep</em> in <em>s</em> will be used to divide <em>s</em> into a word string and
a tag string.  If <em>sep</em> does not occur in <em>s</em>, return (s, None).</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">nltk.tag.util</span> <span class="kn">import</span> <span class="n">str2tuple</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">str2tuple</span><span class="p">(</span><span class="s">&#39;fly/NN&#39;</span><span class="p">)</span>
<span class="go">(&#39;fly&#39;, &#39;NN&#39;)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>s</strong> (<em>str</em>) &#8211; The string representation of a tagged token.</li>
<li><strong>sep</strong> (<em>str</em>) &#8211; The separator string used to separate word strings
from tags.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="nltk.tag.util.tuple2str">
<tt class="descclassname">nltk.tag.util.</tt><tt class="descname">tuple2str</tt><big>(</big><em>tagged_token</em>, <em>sep='/'</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/util.html#tuple2str"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.util.tuple2str" title="Permalink to this definition">¶</a></dt>
<dd><p>Given the tuple representation of a tagged token, return the
corresponding string representation.  This representation is
formed by concatenating the token&#8217;s word string, followed by the
separator, followed by the token&#8217;s tag.  (If the tag is None,
then just return the bare word string.)</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">nltk.tag.util</span> <span class="kn">import</span> <span class="n">tuple2str</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tagged_token</span> <span class="o">=</span> <span class="p">(</span><span class="s">&#39;fly&#39;</span><span class="p">,</span> <span class="s">&#39;NN&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tuple2str</span><span class="p">(</span><span class="n">tagged_token</span><span class="p">)</span>
<span class="go">&#39;fly/NN&#39;</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>tagged_token</strong> (<em>tuple(str, str)</em>) &#8211; The tuple representation of a tagged token.</li>
<li><strong>sep</strong> (<em>str</em>) &#8211; The separator string used to separate word strings
from tags.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="nltk.tag.util.untag">
<tt class="descclassname">nltk.tag.util.</tt><tt class="descname">untag</tt><big>(</big><em>tagged_sentence</em><big>)</big><a class="reference internal" href="../_modules/nltk/tag/util.html#untag"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.util.untag" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a tagged sentence, return an untagged version of that
sentence.  I.e., return a list containing the first element
of each tuple in <em>tagged_sentence</em>.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">nltk.tag.util</span> <span class="kn">import</span> <span class="n">untag</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">untag</span><span class="p">([(</span><span class="s">&#39;John&#39;</span><span class="p">,</span> <span class="s">&#39;NNP&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;saw&#39;</span><span class="p">,</span> <span class="s">&#39;VBD&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;Mary&#39;</span><span class="p">,</span> <span class="s">&#39;NNP&#39;</span><span class="p">)])</span>
<span class="go">[&#39;John&#39;, &#39;saw&#39;, &#39;Mary&#39;]</span>
</pre></div>
</div>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
        </div>
        <div class="sidebar">
          <h3>Table Of Contents</h3>
          <ul>
<li class="toctree-l1"><a class="reference internal" href="../news.html">NLTK News</a></li>
<li class="toctree-l1"><a class="reference internal" href="../install.html">Installing NLTK</a></li>
<li class="toctree-l1"><a class="reference internal" href="../data.html">Installing NLTK Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="nltk.html">nltk Package</a></li>
</ul>

          <h3 style="margin-top: 1.5em;">Search</h3>
          <form class="search" action="../search.html" method="get">
            <input type="text" name="q" />
            <input type="submit" value="Go" />
            <input type="hidden" name="check_keywords" value="yes" />
            <input type="hidden" name="area" value="default" />
          </form>
          <p class="searchtip" style="font-size: 90%">
            Enter search terms or a module, class or function name.
          </p>
        </div>
        <div class="clearer"></div>
      </div>
    </div>

    <div class="footer-wrapper">
      <div class="footer">
        <div class="left">
          <a href="nltk.stem.html" title="stem Package"
             >previous</a> |
          <a href="nltk.test.html" title="test Package"
             >next</a> |
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |
          <a href="../genindex.html" title="General Index"
             >index</a>
            <br/>
            <a href="../_sources/api/nltk.tag.txt"
               rel="nofollow">Show Source</a>
        </div>

        <div class="right">
          
    <div class="footer">
        &copy; Copyright 2012, NLTK Project.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.2.
    </div>
        </div>
        <div class="clearer"></div>
      </div>
    </div>

  </body>
</html>