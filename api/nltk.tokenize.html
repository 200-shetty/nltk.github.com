

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>tokenize Package &mdash; NLTK 2.0 documentation</title>
    
    <link rel="stylesheet" href="../_static/agogo.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="NLTK 2.0 documentation" href="../index.html" />
    <link rel="up" title="nltk Package" href="nltk.html" />
    <link rel="prev" title="test Package" href="nltk.test.html" /> 
  </head>
  <body>
    <div class="header-wrapper">
      <div class="header">
        <div class="headertitle"><a
          href="../index.html">NLTK 2.0 documentation</a></div>
        <div class="rel">
          <a href="nltk.test.html" title="test Package"
             accesskey="P">previous</a> |
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a>
        </div>
       </div>
    </div>

    <div class="content-wrapper">
      <div class="content">
        <div class="document">
            
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="tokenize-package">
<h1>tokenize Package<a class="headerlink" href="#tokenize-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="id1">
<h2><tt class="xref py py-mod docutils literal"><span class="pre">tokenize</span></tt> Package<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<span class="target" id="module-nltk.tokenize"></span><p>NLTK Tokenizer Package</p>
<p>Tokenizers divide strings into lists of substrings.  For example,
tokenizers can be used to find the list of sentences or words in a
string.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">nltk.tokenize</span> <span class="kn">import</span> <span class="n">word_tokenize</span><span class="p">,</span> <span class="n">wordpunct_tokenize</span><span class="p">,</span> <span class="n">sent_tokenize</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="s">&#39;&#39;&#39;Good muffins cost $3.88</span><span class="se">\n</span><span class="s">in New York.  Please buy me</span>
<span class="gp">... </span><span class="s">two of them.</span><span class="se">\n\n</span><span class="s">Thanks.&#39;&#39;&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">wordpunct_tokenize</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">[&#39;Good&#39;, &#39;muffins&#39;, &#39;cost&#39;, &#39;$&#39;, &#39;3&#39;, &#39;.&#39;, &#39;88&#39;, &#39;in&#39;, &#39;New&#39;, &#39;York&#39;, &#39;.&#39;,</span>
<span class="go">&#39;Please&#39;, &#39;buy&#39;, &#39;me&#39;, &#39;two&#39;, &#39;of&#39;, &#39;them&#39;, &#39;.&#39;, &#39;Thanks&#39;, &#39;.&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sent_tokenize</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">[&#39;Good muffins cost $3.88\nin New York.&#39;, &#39;Please buy me\ntwo of them.&#39;, &#39;Thanks.&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">word_tokenize</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">sent_tokenize</span><span class="p">(</span><span class="n">s</span><span class="p">)]</span>
<span class="go">[[&#39;Good&#39;, &#39;muffins&#39;, &#39;cost&#39;, &#39;$&#39;, &#39;3.88&#39;, &#39;in&#39;, &#39;New&#39;, &#39;York&#39;, &#39;.&#39;],</span>
<span class="go">[&#39;Please&#39;, &#39;buy&#39;, &#39;me&#39;, &#39;two&#39;, &#39;of&#39;, &#39;them&#39;, &#39;.&#39;], [&#39;Thanks&#39;, &#39;.&#39;]]</span>
</pre></div>
</div>
<p>Caution: only use <tt class="docutils literal"><span class="pre">word_tokenize()</span></tt> on individual sentences.</p>
<p>Caution: when tokenizing a Unicode string, make sure you are not
using an encoded version of the string (it may be necessary to
decode it first, e.g. with <tt class="docutils literal"><span class="pre">s.decode(&quot;utf8&quot;)</span></tt>.</p>
<p>NLTK tokenizers can produce token-spans, represented as tuples of integers
having the same semantics as string slices, to support efficient comparison
of tokenizers.  (These methods are implemented as generators.)</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">nltk.tokenize</span> <span class="kn">import</span> <span class="n">WhitespaceTokenizer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">WhitespaceTokenizer</span><span class="p">()</span><span class="o">.</span><span class="n">span_tokenize</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
<span class="go">[(0, 4), (5, 12), (13, 17), (18, 23), (24, 26), (27, 30), (31, 36), (38, 44),</span>
<span class="go">(45, 48), (49, 51), (52, 55), (56, 58), (59, 64), (66, 73)]</span>
</pre></div>
</div>
<p>There are numerous ways to tokenize text.  If you need more control over
tokenization, see the other methods provided in this package.</p>
<p>For further information, please see Chapter 3 of the NLTK book.</p>
<dl class="function">
<dt id="nltk.tokenize.sent_tokenize">
<tt class="descclassname">nltk.tokenize.</tt><tt class="descname">sent_tokenize</tt><big>(</big><em>text</em><big>)</big><a class="reference internal" href="../_modules/nltk/tokenize.html#sent_tokenize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.sent_tokenize" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a sentence-tokenized copy of <em>text</em>,
using NLTK&#8217;s recommended sentence tokenizer
(currently <a class="reference internal" href="#nltk.tokenize.punkt.PunktSentenceTokenizer" title="nltk.tokenize.punkt.PunktSentenceTokenizer"><tt class="xref py py-class docutils literal"><span class="pre">PunktSentenceTokenizer</span></tt></a>).</p>
</dd></dl>

<dl class="function">
<dt id="nltk.tokenize.word_tokenize">
<tt class="descclassname">nltk.tokenize.</tt><tt class="descname">word_tokenize</tt><big>(</big><em>text</em><big>)</big><a class="reference internal" href="../_modules/nltk/tokenize.html#word_tokenize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.word_tokenize" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a tokenized copy of <em>text</em>,
using NLTK&#8217;s recommended word tokenizer
(currently <a class="reference internal" href="#nltk.tokenize.treebank.TreebankWordTokenizer" title="nltk.tokenize.treebank.TreebankWordTokenizer"><tt class="xref py py-class docutils literal"><span class="pre">TreebankWordTokenizer</span></tt></a>).
This tokenizer is designed to work on a sentence at a time.</p>
</dd></dl>

</div>
<div class="section" id="module-nltk.tokenize.api">
<span id="api-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">api</span></tt> Module<a class="headerlink" href="#module-nltk.tokenize.api" title="Permalink to this headline">¶</a></h2>
<p>Tokenizer Interface</p>
<dl class="class">
<dt id="nltk.tokenize.api.StringTokenizer">
<em class="property">class </em><tt class="descclassname">nltk.tokenize.api.</tt><tt class="descname">StringTokenizer</tt><a class="reference internal" href="../_modules/nltk/tokenize/api.html#StringTokenizer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.api.StringTokenizer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.tokenize.api.TokenizerI" title="nltk.tokenize.api.TokenizerI"><tt class="xref py py-class docutils literal"><span class="pre">nltk.tokenize.api.TokenizerI</span></tt></a></p>
<p>A tokenizer that divides a string into substrings by splitting
on the specified string (defined in subclasses).</p>
<dl class="method">
<dt id="nltk.tokenize.api.StringTokenizer.span_tokenize">
<tt class="descname">span_tokenize</tt><big>(</big><em>s</em><big>)</big><a class="reference internal" href="../_modules/nltk/tokenize/api.html#StringTokenizer.span_tokenize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.api.StringTokenizer.span_tokenize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nltk.tokenize.api.StringTokenizer.tokenize">
<tt class="descname">tokenize</tt><big>(</big><em>s</em><big>)</big><a class="reference internal" href="../_modules/nltk/tokenize/api.html#StringTokenizer.tokenize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.api.StringTokenizer.tokenize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.tokenize.api.TokenizerI">
<em class="property">class </em><tt class="descclassname">nltk.tokenize.api.</tt><tt class="descname">TokenizerI</tt><a class="reference internal" href="../_modules/nltk/tokenize/api.html#TokenizerI"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.api.TokenizerI" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>A processing interface for tokenizing a string.
Subclasses must define <tt class="docutils literal"><span class="pre">tokenize()</span></tt> or <tt class="docutils literal"><span class="pre">batch_tokenize()</span></tt> (or both).</p>
<dl class="method">
<dt id="nltk.tokenize.api.TokenizerI.batch_span_tokenize">
<tt class="descname">batch_span_tokenize</tt><big>(</big><em>strings</em><big>)</big><a class="reference internal" href="../_modules/nltk/tokenize/api.html#TokenizerI.batch_span_tokenize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.api.TokenizerI.batch_span_tokenize" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply <tt class="docutils literal"><span class="pre">self.span_tokenize()</span></tt> to each element of <tt class="docutils literal"><span class="pre">strings</span></tt>.  I.e.:</p>
<blockquote>
<div>return [self.span_tokenize(s) for s in strings]</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">iter(list(tuple(int, int)))</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.tokenize.api.TokenizerI.batch_tokenize">
<tt class="descname">batch_tokenize</tt><big>(</big><em>strings</em><big>)</big><a class="reference internal" href="../_modules/nltk/tokenize/api.html#TokenizerI.batch_tokenize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.api.TokenizerI.batch_tokenize" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply <tt class="docutils literal"><span class="pre">self.tokenize()</span></tt> to each element of <tt class="docutils literal"><span class="pre">strings</span></tt>.  I.e.:</p>
<blockquote>
<div>return [self.tokenize(s) for s in strings]</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">list(list(str))</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.tokenize.api.TokenizerI.span_tokenize">
<tt class="descname">span_tokenize</tt><big>(</big><em>s</em><big>)</big><a class="reference internal" href="../_modules/nltk/tokenize/api.html#TokenizerI.span_tokenize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.api.TokenizerI.span_tokenize" title="Permalink to this definition">¶</a></dt>
<dd><p>Identify the tokens using integer offsets <tt class="docutils literal"><span class="pre">(start_i,</span> <span class="pre">end_i)</span></tt>,
where <tt class="docutils literal"><span class="pre">s[start_i:end_i]</span></tt> is the corresponding token.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">iter(tuple(int, int))</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.tokenize.api.TokenizerI.tokenize">
<tt class="descname">tokenize</tt><big>(</big><em>s</em><big>)</big><a class="reference internal" href="../_modules/nltk/tokenize/api.html#TokenizerI.tokenize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.api.TokenizerI.tokenize" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a tokenized copy of <em>s</em>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">list of str</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-nltk.tokenize.punkt">
<span id="punkt-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">punkt</span></tt> Module<a class="headerlink" href="#module-nltk.tokenize.punkt" title="Permalink to this headline">¶</a></h2>
<p>Punkt Sentence Tokenizer</p>
<p>This tokenizer divides a text into a list of sentences,
by using an unsupervised algorithm to build a model for abbreviation
words, collocations, and words that start sentences.  It must be
trained on a large collection of plaintext in the taret language
before it can be used.</p>
<p>The NLTK data package includes a pre-trained Punkt tokenizer for
English.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">nltk.data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">text</span> <span class="o">=</span> <span class="s">&#39;&#39;&#39;</span>
<span class="gp">... </span><span class="s">Punkt knows that the periods in Mr. Smith and Johann S. Bach</span>
<span class="gp">... </span><span class="s">do not mark sentence boundaries.  And sometimes sentences</span>
<span class="gp">... </span><span class="s">can start with non-capitalized words.  i is a good variable</span>
<span class="gp">... </span><span class="s">name.</span>
<span class="gp">... </span><span class="s">&#39;&#39;&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sent_detector</span> <span class="o">=</span> <span class="n">nltk</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s">&#39;tokenizers/punkt/english.pickle&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">-----</span><span class="se">\n</span><span class="s">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">sent_detector</span><span class="o">.</span><span class="n">tokenize</span><span class="p">(</span><span class="n">text</span><span class="o">.</span><span class="n">strip</span><span class="p">()))</span>
<span class="go">Punkt knows that the periods in Mr. Smith and Johann S. Bach</span>
<span class="go">do not mark sentence boundaries.</span>
<span class="go">-----</span>
<span class="go">And sometimes sentences</span>
<span class="go">can start with non-capitalized words.</span>
<span class="go">-----</span>
<span class="go">i is a good variable</span>
<span class="go">name.</span>
</pre></div>
</div>
<p>(Note that whitespace from the original text, including newlines, is
retained in the output.)</p>
<p>Punctuation following sentences can be included with the realign_boundaries
flag:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">text</span> <span class="o">=</span> <span class="s">&#39;&#39;&#39;</span>
<span class="gp">... </span><span class="s">(How does it deal with this parenthesis?)  &quot;It should be part of the</span>
<span class="gp">... </span><span class="s">previous sentence.&quot;</span>
<span class="gp">... </span><span class="s">&#39;&#39;&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">-----</span><span class="se">\n</span><span class="s">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">sent_detector</span><span class="o">.</span><span class="n">tokenize</span><span class="p">(</span><span class="n">text</span><span class="o">.</span><span class="n">strip</span><span class="p">(),</span> <span class="n">realign_boundaries</span><span class="o">=</span><span class="bp">True</span><span class="p">))</span>
<span class="go">(How does it deal with this parenthesis?)</span>
<span class="go">-----</span>
<span class="go">&quot;It should be part of the</span>
<span class="go">previous sentence.&quot;</span>
</pre></div>
</div>
<p>However, Punkt is designed to learn parameters (a list of abbreviations, etc.)
unsupervised from a corpus similar to the target domain. The pre-packaged models
may therefore be unsuitable: use <tt class="docutils literal"><span class="pre">PunktSentenceTokenizer(text)</span></tt> to learn
parameters from the given text.</p>
<p><a class="reference internal" href="#nltk.tokenize.punkt.PunktTrainer" title="nltk.tokenize.punkt.PunktTrainer"><tt class="xref py py-class docutils literal"><span class="pre">PunktTrainer</span></tt></a> learns parameters such as a list of abbreviations
(without supervision) from portions of text. Using a <tt class="docutils literal"><span class="pre">PunktTrainer</span></tt> directly
allows for incremental training and modification of the hyper-parameters used
to decide what is considered an abbreviation, etc.</p>
<p><a class="reference internal" href="#nltk.tokenize.punkt.PunktWordTokenizer" title="nltk.tokenize.punkt.PunktWordTokenizer"><tt class="xref py py-class docutils literal"><span class="pre">PunktWordTokenizer</span></tt></a> uses a regular expression to divide a text into tokens,
leaving all periods attached to words, but separating off other punctuation:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">nltk.tokenize.punkt</span> <span class="kn">import</span> <span class="n">PunktWordTokenizer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="s">&quot;Good muffins cost $3.88</span><span class="se">\n</span><span class="s">in New York.  Please buy me</span><span class="se">\n</span><span class="s">two of them.</span><span class="se">\n\n</span><span class="s">Thanks.&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PunktWordTokenizer</span><span class="p">()</span><span class="o">.</span><span class="n">tokenize</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">[&#39;Good&#39;, &#39;muffins&#39;, &#39;cost&#39;, &#39;$3.88&#39;, &#39;in&#39;, &#39;New&#39;, &#39;York.&#39;, &#39;Please&#39;,</span>
<span class="go">&#39;buy&#39;, &#39;me&#39;, &#39;two&#39;, &#39;of&#39;, &#39;them.&#39;, &#39;Thanks.&#39;]</span>
</pre></div>
</div>
<p>The algorithm for this tokenizer is described in:</p>
<div class="highlight-python"><pre>Kiss, Tibor and Strunk, Jan (2006): Unsupervised Multilingual Sentence
  Boundary Detection.  Computational Linguistics 32: 485-525.</pre>
</div>
<dl class="class">
<dt id="nltk.tokenize.punkt.PunktBaseClass">
<em class="property">class </em><tt class="descclassname">nltk.tokenize.punkt.</tt><tt class="descname">PunktBaseClass</tt><big>(</big><em>lang_vars=&lt;nltk.tokenize.punkt.PunktLanguageVars object at 0x4da7910&gt;</em>, <em>token_cls=&lt;class 'nltk.tokenize.punkt.PunktToken'&gt;</em>, <em>params=&lt;nltk.tokenize.punkt.PunktParameters object at 0x4da7950&gt;</em><big>)</big><a class="reference internal" href="../_modules/nltk/tokenize/punkt.html#PunktBaseClass"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.punkt.PunktBaseClass" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Includes common components of PunktTrainer and PunktSentenceTokenizer.</p>
</dd></dl>

<dl class="class">
<dt id="nltk.tokenize.punkt.PunktLanguageVars">
<em class="property">class </em><tt class="descclassname">nltk.tokenize.punkt.</tt><tt class="descname">PunktLanguageVars</tt><a class="reference internal" href="../_modules/nltk/tokenize/punkt.html#PunktLanguageVars"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.punkt.PunktLanguageVars" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Stores variables, mostly regular expressions, which may be
language-dependent for correct application of the algorithm.
An extension of this class may modify its properties to suit
a language other than English; an instance can then be passed
as an argument to PunktSentenceTokenizer and PunktTrainer
constructors.</p>
<dl class="attribute">
<dt id="nltk.tokenize.punkt.PunktLanguageVars.internal_punctuation">
<tt class="descname">internal_punctuation</tt><em class="property"> = ',:;'</em><a class="headerlink" href="#nltk.tokenize.punkt.PunktLanguageVars.internal_punctuation" title="Permalink to this definition">¶</a></dt>
<dd><p>sentence internal punctuation, which indicates an abbreviation if
preceded by a period-final token.</p>
</dd></dl>

<dl class="method">
<dt id="nltk.tokenize.punkt.PunktLanguageVars.period_context_re">
<tt class="descname">period_context_re</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/tokenize/punkt.html#PunktLanguageVars.period_context_re"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.punkt.PunktLanguageVars.period_context_re" title="Permalink to this definition">¶</a></dt>
<dd><p>Compiles and returns a regular expression to find contexts
including possible sentence boundaries.</p>
</dd></dl>

<dl class="attribute">
<dt id="nltk.tokenize.punkt.PunktLanguageVars.re_boundary_realignment">
<tt class="descname">re_boundary_realignment</tt><em class="property"> = &lt;_sre.SRE_Pattern object at 0x4d832b8&gt;</em><a class="headerlink" href="#nltk.tokenize.punkt.PunktLanguageVars.re_boundary_realignment" title="Permalink to this definition">¶</a></dt>
<dd><p>Used to realign punctuation that should be included in a sentence
although it follows the period (or ?, !).</p>
</dd></dl>

<dl class="attribute">
<dt id="nltk.tokenize.punkt.PunktLanguageVars.sent_end_chars">
<tt class="descname">sent_end_chars</tt><em class="property"> = ('.', '?', '!')</em><a class="headerlink" href="#nltk.tokenize.punkt.PunktLanguageVars.sent_end_chars" title="Permalink to this definition">¶</a></dt>
<dd><p>Characters which are candidates for sentence boundaries</p>
</dd></dl>

<dl class="method">
<dt id="nltk.tokenize.punkt.PunktLanguageVars.word_tokenize">
<tt class="descname">word_tokenize</tt><big>(</big><em>s</em><big>)</big><a class="reference internal" href="../_modules/nltk/tokenize/punkt.html#PunktLanguageVars.word_tokenize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.punkt.PunktLanguageVars.word_tokenize" title="Permalink to this definition">¶</a></dt>
<dd><p>Tokenize a string to split off punctuation other than periods</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.tokenize.punkt.PunktParameters">
<em class="property">class </em><tt class="descclassname">nltk.tokenize.punkt.</tt><tt class="descname">PunktParameters</tt><a class="reference internal" href="../_modules/nltk/tokenize/punkt.html#PunktParameters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.punkt.PunktParameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Stores data used to perform sentence boundary detection with Punkt.</p>
<dl class="attribute">
<dt id="nltk.tokenize.punkt.PunktParameters.abbrev_types">
<tt class="descname">abbrev_types</tt><em class="property"> = None</em><a class="headerlink" href="#nltk.tokenize.punkt.PunktParameters.abbrev_types" title="Permalink to this definition">¶</a></dt>
<dd><p>A set of word types for known abbreviations.</p>
</dd></dl>

<dl class="method">
<dt id="nltk.tokenize.punkt.PunktParameters.add_ortho_context">
<tt class="descname">add_ortho_context</tt><big>(</big><em>typ</em>, <em>flag</em><big>)</big><a class="reference internal" href="../_modules/nltk/tokenize/punkt.html#PunktParameters.add_ortho_context"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.punkt.PunktParameters.add_ortho_context" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nltk.tokenize.punkt.PunktParameters.clear_abbrevs">
<tt class="descname">clear_abbrevs</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/tokenize/punkt.html#PunktParameters.clear_abbrevs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.punkt.PunktParameters.clear_abbrevs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nltk.tokenize.punkt.PunktParameters.clear_collocations">
<tt class="descname">clear_collocations</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/tokenize/punkt.html#PunktParameters.clear_collocations"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.punkt.PunktParameters.clear_collocations" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nltk.tokenize.punkt.PunktParameters.clear_ortho_context">
<tt class="descname">clear_ortho_context</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/tokenize/punkt.html#PunktParameters.clear_ortho_context"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.punkt.PunktParameters.clear_ortho_context" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nltk.tokenize.punkt.PunktParameters.clear_sent_starters">
<tt class="descname">clear_sent_starters</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/tokenize/punkt.html#PunktParameters.clear_sent_starters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.punkt.PunktParameters.clear_sent_starters" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nltk.tokenize.punkt.PunktParameters.collocations">
<tt class="descname">collocations</tt><em class="property"> = None</em><a class="headerlink" href="#nltk.tokenize.punkt.PunktParameters.collocations" title="Permalink to this definition">¶</a></dt>
<dd><p>A set of word type tuples for known common collocations
where the first word ends in a period.  E.g., (&#8216;S.&#8217;, &#8216;Bach&#8217;)
is a common collocation in a text that discusses &#8216;Johann
S. Bach&#8217;.  These count as negative evidence for sentence
boundaries.</p>
</dd></dl>

<dl class="attribute">
<dt id="nltk.tokenize.punkt.PunktParameters.ortho_context">
<tt class="descname">ortho_context</tt><em class="property"> = None</em><a class="headerlink" href="#nltk.tokenize.punkt.PunktParameters.ortho_context" title="Permalink to this definition">¶</a></dt>
<dd><p>A dictionary mapping word types to the set of orthographic
contexts that word type appears in.  Contexts are represented
by adding orthographic context flags: ...</p>
</dd></dl>

<dl class="attribute">
<dt id="nltk.tokenize.punkt.PunktParameters.sent_starters">
<tt class="descname">sent_starters</tt><em class="property"> = None</em><a class="headerlink" href="#nltk.tokenize.punkt.PunktParameters.sent_starters" title="Permalink to this definition">¶</a></dt>
<dd><p>A set of word types for words that often appear at the
beginning of sentences.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.tokenize.punkt.PunktSentenceTokenizer">
<em class="property">class </em><tt class="descclassname">nltk.tokenize.punkt.</tt><tt class="descname">PunktSentenceTokenizer</tt><big>(</big><em>train_text=None</em>, <em>verbose=False</em>, <em>lang_vars=&lt;nltk.tokenize.punkt.PunktLanguageVars object at 0x4da7a90&gt;</em>, <em>token_cls=&lt;class 'nltk.tokenize.punkt.PunktToken'&gt;</em><big>)</big><a class="reference internal" href="../_modules/nltk/tokenize/punkt.html#PunktSentenceTokenizer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.punkt.PunktSentenceTokenizer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.tokenize.punkt.PunktBaseClass" title="nltk.tokenize.punkt.PunktBaseClass"><tt class="xref py py-class docutils literal"><span class="pre">nltk.tokenize.punkt.PunktBaseClass</span></tt></a>, <a class="reference internal" href="#nltk.tokenize.api.TokenizerI" title="nltk.tokenize.api.TokenizerI"><tt class="xref py py-class docutils literal"><span class="pre">nltk.tokenize.api.TokenizerI</span></tt></a></p>
<p>A sentence tokenizer which uses an unsupervised algorithm to build
a model for abbreviation words, collocations, and words that start
sentences; and then uses that model to find sentence boundaries.
This approach has been shown to work well for many European
languages.</p>
<dl class="attribute">
<dt id="nltk.tokenize.punkt.PunktSentenceTokenizer.PUNCTUATION">
<tt class="descname">PUNCTUATION</tt><em class="property"> = (';', ':', ',', '.', '!', '?')</em><a class="headerlink" href="#nltk.tokenize.punkt.PunktSentenceTokenizer.PUNCTUATION" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nltk.tokenize.punkt.PunktSentenceTokenizer.debug_decisions">
<tt class="descname">debug_decisions</tt><big>(</big><em>text</em><big>)</big><a class="reference internal" href="../_modules/nltk/tokenize/punkt.html#PunktSentenceTokenizer.debug_decisions"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.punkt.PunktSentenceTokenizer.debug_decisions" title="Permalink to this definition">¶</a></dt>
<dd><p>Classifies candidate periods as sentence breaks, yielding a dict for
each that may be used to understand why the decision was made.</p>
<p>See format_debug_decision() to help make this output readable.</p>
</dd></dl>

<dl class="method">
<dt id="nltk.tokenize.punkt.PunktSentenceTokenizer.dump">
<tt class="descname">dump</tt><big>(</big><em>tokens</em><big>)</big><a class="reference internal" href="../_modules/nltk/tokenize/punkt.html#PunktSentenceTokenizer.dump"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.punkt.PunktSentenceTokenizer.dump" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nltk.tokenize.punkt.PunktSentenceTokenizer.sentences_from_text">
<tt class="descname">sentences_from_text</tt><big>(</big><em>text</em>, <em>realign_boundaries=False</em><big>)</big><a class="reference internal" href="../_modules/nltk/tokenize/punkt.html#PunktSentenceTokenizer.sentences_from_text"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.punkt.PunktSentenceTokenizer.sentences_from_text" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a text, generates the sentences in that text by only
testing candidate sentence breaks. If realign_boundaries is
True, includes in the sentence closing punctuation that
follows the period.</p>
</dd></dl>

<dl class="method">
<dt id="nltk.tokenize.punkt.PunktSentenceTokenizer.sentences_from_text_legacy">
<tt class="descname">sentences_from_text_legacy</tt><big>(</big><em>text</em><big>)</big><a class="reference internal" href="../_modules/nltk/tokenize/punkt.html#PunktSentenceTokenizer.sentences_from_text_legacy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.punkt.PunktSentenceTokenizer.sentences_from_text_legacy" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a text, generates the sentences in that text. Annotates all
tokens, rather than just those with possible sentence breaks. Should
produce the same results as <tt class="docutils literal"><span class="pre">sentences_from_text</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="nltk.tokenize.punkt.PunktSentenceTokenizer.sentences_from_tokens">
<tt class="descname">sentences_from_tokens</tt><big>(</big><em>tokens</em><big>)</big><a class="reference internal" href="../_modules/nltk/tokenize/punkt.html#PunktSentenceTokenizer.sentences_from_tokens"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.punkt.PunktSentenceTokenizer.sentences_from_tokens" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a sequence of tokens, generates lists of tokens, each list
corresponding to a sentence.</p>
</dd></dl>

<dl class="method">
<dt id="nltk.tokenize.punkt.PunktSentenceTokenizer.span_tokenize">
<tt class="descname">span_tokenize</tt><big>(</big><em>text</em><big>)</big><a class="reference internal" href="../_modules/nltk/tokenize/punkt.html#PunktSentenceTokenizer.span_tokenize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.punkt.PunktSentenceTokenizer.span_tokenize" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a text, returns a list of the (start, end) spans of sentences
in the text.</p>
</dd></dl>

<dl class="method">
<dt id="nltk.tokenize.punkt.PunktSentenceTokenizer.text_contains_sentbreak">
<tt class="descname">text_contains_sentbreak</tt><big>(</big><em>text</em><big>)</big><a class="reference internal" href="../_modules/nltk/tokenize/punkt.html#PunktSentenceTokenizer.text_contains_sentbreak"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.punkt.PunktSentenceTokenizer.text_contains_sentbreak" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if the given text includes a sentence break.</p>
</dd></dl>

<dl class="method">
<dt id="nltk.tokenize.punkt.PunktSentenceTokenizer.tokenize">
<tt class="descname">tokenize</tt><big>(</big><em>text</em>, <em>realign_boundaries=False</em><big>)</big><a class="reference internal" href="../_modules/nltk/tokenize/punkt.html#PunktSentenceTokenizer.tokenize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.punkt.PunktSentenceTokenizer.tokenize" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a text, returns a list of the sentences in that text.</p>
</dd></dl>

<dl class="method">
<dt id="nltk.tokenize.punkt.PunktSentenceTokenizer.train">
<tt class="descname">train</tt><big>(</big><em>train_text</em>, <em>verbose=False</em><big>)</big><a class="reference internal" href="../_modules/nltk/tokenize/punkt.html#PunktSentenceTokenizer.train"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.punkt.PunktSentenceTokenizer.train" title="Permalink to this definition">¶</a></dt>
<dd><p>Derives parameters from a given training text, or uses the parameters
given. Repeated calls to this method destroy previous parameters. For
incremental training, instantiate a separate PunktTrainer instance.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.tokenize.punkt.PunktToken">
<em class="property">class </em><tt class="descclassname">nltk.tokenize.punkt.</tt><tt class="descname">PunktToken</tt><big>(</big><em>tok</em>, <em>**params</em><big>)</big><a class="reference internal" href="../_modules/nltk/tokenize/punkt.html#PunktToken"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.punkt.PunktToken" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Stores a token of text with annotations produced during
sentence boundary detection.</p>
<dl class="attribute">
<dt id="nltk.tokenize.punkt.PunktToken.abbr">
<tt class="descname">abbr</tt><a class="headerlink" href="#nltk.tokenize.punkt.PunktToken.abbr" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nltk.tokenize.punkt.PunktToken.ellipsis">
<tt class="descname">ellipsis</tt><a class="headerlink" href="#nltk.tokenize.punkt.PunktToken.ellipsis" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nltk.tokenize.punkt.PunktToken.first_case">
<tt class="descname">first_case</tt><a class="reference internal" href="../_modules/nltk/tokenize/punkt.html#PunktToken.first_case"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.punkt.PunktToken.first_case" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nltk.tokenize.punkt.PunktToken.first_lower">
<tt class="descname">first_lower</tt><a class="reference internal" href="../_modules/nltk/tokenize/punkt.html#PunktToken.first_lower"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.punkt.PunktToken.first_lower" title="Permalink to this definition">¶</a></dt>
<dd><p>True if the token&#8217;s first character is lowercase.</p>
</dd></dl>

<dl class="attribute">
<dt id="nltk.tokenize.punkt.PunktToken.first_upper">
<tt class="descname">first_upper</tt><a class="reference internal" href="../_modules/nltk/tokenize/punkt.html#PunktToken.first_upper"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.punkt.PunktToken.first_upper" title="Permalink to this definition">¶</a></dt>
<dd><p>True if the token&#8217;s first character is uppercase.</p>
</dd></dl>

<dl class="attribute">
<dt id="nltk.tokenize.punkt.PunktToken.is_alpha">
<tt class="descname">is_alpha</tt><a class="reference internal" href="../_modules/nltk/tokenize/punkt.html#PunktToken.is_alpha"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.punkt.PunktToken.is_alpha" title="Permalink to this definition">¶</a></dt>
<dd><p>True if the token text is all alphabetic.</p>
</dd></dl>

<dl class="attribute">
<dt id="nltk.tokenize.punkt.PunktToken.is_ellipsis">
<tt class="descname">is_ellipsis</tt><a class="reference internal" href="../_modules/nltk/tokenize/punkt.html#PunktToken.is_ellipsis"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.punkt.PunktToken.is_ellipsis" title="Permalink to this definition">¶</a></dt>
<dd><p>True if the token text is that of an ellipsis.</p>
</dd></dl>

<dl class="attribute">
<dt id="nltk.tokenize.punkt.PunktToken.is_initial">
<tt class="descname">is_initial</tt><a class="reference internal" href="../_modules/nltk/tokenize/punkt.html#PunktToken.is_initial"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.punkt.PunktToken.is_initial" title="Permalink to this definition">¶</a></dt>
<dd><p>True if the token text is that of an initial.</p>
</dd></dl>

<dl class="attribute">
<dt id="nltk.tokenize.punkt.PunktToken.is_non_punct">
<tt class="descname">is_non_punct</tt><a class="reference internal" href="../_modules/nltk/tokenize/punkt.html#PunktToken.is_non_punct"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.punkt.PunktToken.is_non_punct" title="Permalink to this definition">¶</a></dt>
<dd><p>True if the token is either a number or is alphabetic.</p>
</dd></dl>

<dl class="attribute">
<dt id="nltk.tokenize.punkt.PunktToken.is_number">
<tt class="descname">is_number</tt><a class="reference internal" href="../_modules/nltk/tokenize/punkt.html#PunktToken.is_number"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.punkt.PunktToken.is_number" title="Permalink to this definition">¶</a></dt>
<dd><p>True if the token text is that of a number.</p>
</dd></dl>

<dl class="attribute">
<dt id="nltk.tokenize.punkt.PunktToken.linestart">
<tt class="descname">linestart</tt><a class="headerlink" href="#nltk.tokenize.punkt.PunktToken.linestart" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nltk.tokenize.punkt.PunktToken.parastart">
<tt class="descname">parastart</tt><a class="headerlink" href="#nltk.tokenize.punkt.PunktToken.parastart" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nltk.tokenize.punkt.PunktToken.period_final">
<tt class="descname">period_final</tt><a class="headerlink" href="#nltk.tokenize.punkt.PunktToken.period_final" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nltk.tokenize.punkt.PunktToken.sentbreak">
<tt class="descname">sentbreak</tt><a class="headerlink" href="#nltk.tokenize.punkt.PunktToken.sentbreak" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nltk.tokenize.punkt.PunktToken.tok">
<tt class="descname">tok</tt><a class="headerlink" href="#nltk.tokenize.punkt.PunktToken.tok" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nltk.tokenize.punkt.PunktToken.type">
<tt class="descname">type</tt><a class="headerlink" href="#nltk.tokenize.punkt.PunktToken.type" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nltk.tokenize.punkt.PunktToken.type_no_period">
<tt class="descname">type_no_period</tt><a class="reference internal" href="../_modules/nltk/tokenize/punkt.html#PunktToken.type_no_period"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.punkt.PunktToken.type_no_period" title="Permalink to this definition">¶</a></dt>
<dd><p>The type with its final period removed if it has one.</p>
</dd></dl>

<dl class="attribute">
<dt id="nltk.tokenize.punkt.PunktToken.type_no_sentperiod">
<tt class="descname">type_no_sentperiod</tt><a class="reference internal" href="../_modules/nltk/tokenize/punkt.html#PunktToken.type_no_sentperiod"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.punkt.PunktToken.type_no_sentperiod" title="Permalink to this definition">¶</a></dt>
<dd><p>The type with its final period removed if it is marked as a
sentence break.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.tokenize.punkt.PunktTrainer">
<em class="property">class </em><tt class="descclassname">nltk.tokenize.punkt.</tt><tt class="descname">PunktTrainer</tt><big>(</big><em>train_text=None</em>, <em>verbose=False</em>, <em>lang_vars=&lt;nltk.tokenize.punkt.PunktLanguageVars object at 0x4da79d0&gt;</em>, <em>token_cls=&lt;class 'nltk.tokenize.punkt.PunktToken'&gt;</em><big>)</big><a class="reference internal" href="../_modules/nltk/tokenize/punkt.html#PunktTrainer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.punkt.PunktTrainer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.tokenize.punkt.PunktBaseClass" title="nltk.tokenize.punkt.PunktBaseClass"><tt class="xref py py-class docutils literal"><span class="pre">nltk.tokenize.punkt.PunktBaseClass</span></tt></a></p>
<p>Learns parameters used in Punkt sentence boundary detection.</p>
<dl class="attribute">
<dt id="nltk.tokenize.punkt.PunktTrainer.ABBREV">
<tt class="descname">ABBREV</tt><em class="property"> = 0.29999999999999999</em><a class="headerlink" href="#nltk.tokenize.punkt.PunktTrainer.ABBREV" title="Permalink to this definition">¶</a></dt>
<dd><p>cut-off value whether a &#8216;token&#8217; is an abbreviation</p>
</dd></dl>

<dl class="attribute">
<dt id="nltk.tokenize.punkt.PunktTrainer.ABBREV_BACKOFF">
<tt class="descname">ABBREV_BACKOFF</tt><em class="property"> = 5</em><a class="headerlink" href="#nltk.tokenize.punkt.PunktTrainer.ABBREV_BACKOFF" title="Permalink to this definition">¶</a></dt>
<dd><p>upper cut-off for Mikheev&#8217;s(2002) abbreviation detection algorithm</p>
</dd></dl>

<dl class="attribute">
<dt id="nltk.tokenize.punkt.PunktTrainer.COLLOCATION">
<tt class="descname">COLLOCATION</tt><em class="property"> = 7.8799999999999999</em><a class="headerlink" href="#nltk.tokenize.punkt.PunktTrainer.COLLOCATION" title="Permalink to this definition">¶</a></dt>
<dd><p>minimal log-likelihood value that two tokens need to be considered
as a collocation</p>
</dd></dl>

<dl class="attribute">
<dt id="nltk.tokenize.punkt.PunktTrainer.IGNORE_ABBREV_PENALTY">
<tt class="descname">IGNORE_ABBREV_PENALTY</tt><em class="property"> = False</em><a class="headerlink" href="#nltk.tokenize.punkt.PunktTrainer.IGNORE_ABBREV_PENALTY" title="Permalink to this definition">¶</a></dt>
<dd><p>allows the disabling of the abbreviation penalty heuristic, which
exponentially disadvantages words that are found at times without a
final period.</p>
</dd></dl>

<dl class="attribute">
<dt id="nltk.tokenize.punkt.PunktTrainer.INCLUDE_ABBREV_COLLOCS">
<tt class="descname">INCLUDE_ABBREV_COLLOCS</tt><em class="property"> = False</em><a class="headerlink" href="#nltk.tokenize.punkt.PunktTrainer.INCLUDE_ABBREV_COLLOCS" title="Permalink to this definition">¶</a></dt>
<dd><p>this includes as potential collocations all word pairs where the first
word is an abbreviation. Such collocations override the orthographic
heuristic, but not the sentence starter heuristic. This is overridden by
INCLUDE_ALL_COLLOCS, and if both are false, only collocations with initials
and ordinals are considered.</p>
</dd></dl>

<dl class="attribute">
<dt id="nltk.tokenize.punkt.PunktTrainer.INCLUDE_ALL_COLLOCS">
<tt class="descname">INCLUDE_ALL_COLLOCS</tt><em class="property"> = False</em><a class="headerlink" href="#nltk.tokenize.punkt.PunktTrainer.INCLUDE_ALL_COLLOCS" title="Permalink to this definition">¶</a></dt>
<dd><p>this includes as potential collocations all word pairs where the first
word ends in a period. It may be useful in corpora where there is a lot
of variation that makes abbreviations like Mr difficult to identify.</p>
</dd></dl>

<dl class="attribute">
<dt id="nltk.tokenize.punkt.PunktTrainer.MIN_COLLOC_FREQ">
<tt class="descname">MIN_COLLOC_FREQ</tt><em class="property"> = 1</em><a class="headerlink" href="#nltk.tokenize.punkt.PunktTrainer.MIN_COLLOC_FREQ" title="Permalink to this definition">¶</a></dt>
<dd><p>this sets a minimum bound on the number of times a bigram needs to
appear before it can be considered a collocation, in addition to log
likelihood statistics. This is useful when INCLUDE_ALL_COLLOCS is True.</p>
</dd></dl>

<dl class="attribute">
<dt id="nltk.tokenize.punkt.PunktTrainer.SENT_STARTER">
<tt class="descname">SENT_STARTER</tt><em class="property"> = 30</em><a class="headerlink" href="#nltk.tokenize.punkt.PunktTrainer.SENT_STARTER" title="Permalink to this definition">¶</a></dt>
<dd><p>minimal log-likelihood value that a token requires to be considered
as a frequent sentence starter</p>
</dd></dl>

<dl class="method">
<dt id="nltk.tokenize.punkt.PunktTrainer.finalize_training">
<tt class="descname">finalize_training</tt><big>(</big><em>verbose=False</em><big>)</big><a class="reference internal" href="../_modules/nltk/tokenize/punkt.html#PunktTrainer.finalize_training"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.punkt.PunktTrainer.finalize_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Uses data that has been gathered in training to determine likely
collocations and sentence starters.</p>
</dd></dl>

<dl class="method">
<dt id="nltk.tokenize.punkt.PunktTrainer.find_abbrev_types">
<tt class="descname">find_abbrev_types</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/tokenize/punkt.html#PunktTrainer.find_abbrev_types"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.punkt.PunktTrainer.find_abbrev_types" title="Permalink to this definition">¶</a></dt>
<dd><p>Recalculates abbreviations given type frequencies, despite no prior
determination of abbreviations.
This fails to include abbreviations otherwise found as &#8220;rare&#8221;.</p>
</dd></dl>

<dl class="method">
<dt id="nltk.tokenize.punkt.PunktTrainer.freq_threshold">
<tt class="descname">freq_threshold</tt><big>(</big><em>ortho_thresh=2</em>, <em>type_thresh=2</em>, <em>colloc_thres=2</em>, <em>sentstart_thresh=2</em><big>)</big><a class="reference internal" href="../_modules/nltk/tokenize/punkt.html#PunktTrainer.freq_threshold"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.punkt.PunktTrainer.freq_threshold" title="Permalink to this definition">¶</a></dt>
<dd><p>Allows memory use to be reduced after much training by removing data
about rare tokens that are unlikely to have a statistical effect with
further training. Entries occurring above the given thresholds will be
retained.</p>
</dd></dl>

<dl class="method">
<dt id="nltk.tokenize.punkt.PunktTrainer.get_params">
<tt class="descname">get_params</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/nltk/tokenize/punkt.html#PunktTrainer.get_params"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.punkt.PunktTrainer.get_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates and returns parameters for sentence boundary detection as
derived from training.</p>
</dd></dl>

<dl class="method">
<dt id="nltk.tokenize.punkt.PunktTrainer.train">
<tt class="descname">train</tt><big>(</big><em>text</em>, <em>verbose=False</em>, <em>finalize=True</em><big>)</big><a class="reference internal" href="../_modules/nltk/tokenize/punkt.html#PunktTrainer.train"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.punkt.PunktTrainer.train" title="Permalink to this definition">¶</a></dt>
<dd><p>Collects training data from a given text. If finalize is True, it
will determine all the parameters for sentence boundary detection. If
not, this will be delayed until get_params() or finalize_training() is
called. If verbose is True, abbreviations found will be listed.</p>
</dd></dl>

<dl class="method">
<dt id="nltk.tokenize.punkt.PunktTrainer.train_tokens">
<tt class="descname">train_tokens</tt><big>(</big><em>tokens</em>, <em>verbose=False</em>, <em>finalize=True</em><big>)</big><a class="reference internal" href="../_modules/nltk/tokenize/punkt.html#PunktTrainer.train_tokens"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.punkt.PunktTrainer.train_tokens" title="Permalink to this definition">¶</a></dt>
<dd><p>Collects training data from a given list of tokens.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.tokenize.punkt.PunktWordTokenizer">
<em class="property">class </em><tt class="descclassname">nltk.tokenize.punkt.</tt><tt class="descname">PunktWordTokenizer</tt><big>(</big><em>lang_vars=&lt;nltk.tokenize.punkt.PunktLanguageVars object at 0x4da77d0&gt;</em><big>)</big><a class="reference internal" href="../_modules/nltk/tokenize/punkt.html#PunktWordTokenizer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.punkt.PunktWordTokenizer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.tokenize.api.TokenizerI" title="nltk.tokenize.api.TokenizerI"><tt class="xref py py-class docutils literal"><span class="pre">nltk.tokenize.api.TokenizerI</span></tt></a></p>
<dl class="method">
<dt id="nltk.tokenize.punkt.PunktWordTokenizer.tokenize">
<tt class="descname">tokenize</tt><big>(</big><em>text</em><big>)</big><a class="reference internal" href="../_modules/nltk/tokenize/punkt.html#PunktWordTokenizer.tokenize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.punkt.PunktWordTokenizer.tokenize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="nltk.tokenize.punkt.demo">
<tt class="descclassname">nltk.tokenize.punkt.</tt><tt class="descname">demo</tt><big>(</big><em>text</em>, <em>tok_cls=&lt;class 'nltk.tokenize.punkt.PunktSentenceTokenizer'&gt;</em>, <em>train_cls=&lt;class 'nltk.tokenize.punkt.PunktTrainer'&gt;</em><big>)</big><a class="reference internal" href="../_modules/nltk/tokenize/punkt.html#demo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.punkt.demo" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds a punkt model and applies it to the same text</p>
</dd></dl>

<dl class="function">
<dt id="nltk.tokenize.punkt.format_debug_decision">
<tt class="descclassname">nltk.tokenize.punkt.</tt><tt class="descname">format_debug_decision</tt><big>(</big><em>d</em><big>)</big><a class="reference internal" href="../_modules/nltk/tokenize/punkt.html#format_debug_decision"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.punkt.format_debug_decision" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-nltk.tokenize.regexp">
<span id="regexp-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">regexp</span></tt> Module<a class="headerlink" href="#module-nltk.tokenize.regexp" title="Permalink to this headline">¶</a></h2>
<p>Regular-Expression Tokenizers</p>
<p>A <tt class="docutils literal"><span class="pre">RegexpTokenizer</span></tt> splits a string into substrings using a regular expression.
For example, the following tokenizer forms tokens out of alphabetic sequences,
money expressions, and any other non-whitespace sequences:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">nltk.tokenize</span> <span class="kn">import</span> <span class="n">RegexpTokenizer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="s">&quot;Good muffins cost $3.88</span><span class="se">\n</span><span class="s">in New York.  Please buy me</span><span class="se">\n</span><span class="s">two of them.</span><span class="se">\n\n</span><span class="s">Thanks.&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tokenizer</span> <span class="o">=</span> <span class="n">RegexpTokenizer</span><span class="p">(</span><span class="s">&#39;\w+|\$[\d\.]+|\S+&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tokenizer</span><span class="o">.</span><span class="n">tokenize</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">[&#39;Good&#39;, &#39;muffins&#39;, &#39;cost&#39;, &#39;$3.88&#39;, &#39;in&#39;, &#39;New&#39;, &#39;York&#39;, &#39;.&#39;,</span>
<span class="go">&#39;Please&#39;, &#39;buy&#39;, &#39;me&#39;, &#39;two&#39;, &#39;of&#39;, &#39;them&#39;, &#39;.&#39;, &#39;Thanks&#39;, &#39;.&#39;]</span>
</pre></div>
</div>
<p>A <tt class="docutils literal"><span class="pre">RegexpTokenizer</span></tt> can use its regexp to match delimiters instead:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">tokenizer</span> <span class="o">=</span> <span class="n">RegexpTokenizer</span><span class="p">(</span><span class="s">&#39;\s+&#39;</span><span class="p">,</span> <span class="n">gaps</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tokenizer</span><span class="o">.</span><span class="n">tokenize</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">[&#39;Good&#39;, &#39;muffins&#39;, &#39;cost&#39;, &#39;$3.88&#39;, &#39;in&#39;, &#39;New&#39;, &#39;York.&#39;,</span>
<span class="go">&#39;Please&#39;, &#39;buy&#39;, &#39;me&#39;, &#39;two&#39;, &#39;of&#39;, &#39;them.&#39;, &#39;Thanks.&#39;]</span>
</pre></div>
</div>
<p>Note that empty tokens are not returned when the delimiter appears at
the start or end of the string.</p>
<p>The material between the tokens is discarded.  For example,
the following tokenizer selects just the capitalized words:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">capword_tokenizer</span> <span class="o">=</span> <span class="n">RegexpTokenizer</span><span class="p">(</span><span class="s">&#39;[A-Z]\w+&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">capword_tokenizer</span><span class="o">.</span><span class="n">tokenize</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">[&#39;Good&#39;, &#39;New&#39;, &#39;York&#39;, &#39;Please&#39;, &#39;Thanks&#39;]</span>
</pre></div>
</div>
<p>This module contains several subclasses of <tt class="docutils literal"><span class="pre">RegexpTokenizer</span></tt>
that use pre-defined regular expressions.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">nltk.tokenize</span> <span class="kn">import</span> <span class="n">BlanklineTokenizer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Uses &#39;\s*\n\s*\n\s*&#39;:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">BlanklineTokenizer</span><span class="p">()</span><span class="o">.</span><span class="n">tokenize</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">[&#39;Good muffins cost $3.88\nin New York.  Please buy me\ntwo of them.&#39;,</span>
<span class="go">&#39;Thanks.&#39;]</span>
</pre></div>
</div>
<p>All of the regular expression tokenizers are also available as functions:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">nltk.tokenize</span> <span class="kn">import</span> <span class="n">regexp_tokenize</span><span class="p">,</span> <span class="n">wordpunct_tokenize</span><span class="p">,</span> <span class="n">blankline_tokenize</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">regexp_tokenize</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">pattern</span><span class="o">=</span><span class="s">&#39;\w+|\$[\d\.]+|\S+&#39;</span><span class="p">)</span>
<span class="go">[&#39;Good&#39;, &#39;muffins&#39;, &#39;cost&#39;, &#39;$3.88&#39;, &#39;in&#39;, &#39;New&#39;, &#39;York&#39;, &#39;.&#39;,</span>
<span class="go">&#39;Please&#39;, &#39;buy&#39;, &#39;me&#39;, &#39;two&#39;, &#39;of&#39;, &#39;them&#39;, &#39;.&#39;, &#39;Thanks&#39;, &#39;.&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">wordpunct_tokenize</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">[&#39;Good&#39;, &#39;muffins&#39;, &#39;cost&#39;, &#39;$&#39;, &#39;3&#39;, &#39;.&#39;, &#39;88&#39;, &#39;in&#39;, &#39;New&#39;, &#39;York&#39;,</span>
<span class="go"> &#39;.&#39;, &#39;Please&#39;, &#39;buy&#39;, &#39;me&#39;, &#39;two&#39;, &#39;of&#39;, &#39;them&#39;, &#39;.&#39;, &#39;Thanks&#39;, &#39;.&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">blankline_tokenize</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">[&#39;Good muffins cost $3.88\nin New York.  Please buy me\ntwo of them.&#39;, &#39;Thanks.&#39;]</span>
</pre></div>
</div>
<p>Caution: The function <tt class="docutils literal"><span class="pre">regexp_tokenize()</span></tt> takes the text as its
first argument, and the regular expression pattern as its second
argument.  This differs from the conventions used by Python&#8217;s
<tt class="docutils literal"><span class="pre">re</span></tt> functions, where the pattern is always the first argument.
(This is for consistency with the other NLTK tokenizers.)</p>
<dl class="class">
<dt id="nltk.tokenize.regexp.BlanklineTokenizer">
<em class="property">class </em><tt class="descclassname">nltk.tokenize.regexp.</tt><tt class="descname">BlanklineTokenizer</tt><a class="reference internal" href="../_modules/nltk/tokenize/regexp.html#BlanklineTokenizer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.regexp.BlanklineTokenizer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.tokenize.regexp.RegexpTokenizer" title="nltk.tokenize.regexp.RegexpTokenizer"><tt class="xref py py-class docutils literal"><span class="pre">nltk.tokenize.regexp.RegexpTokenizer</span></tt></a></p>
<p>Tokenize a string, treating any sequence of blank lines as a delimiter.
Blank lines are defined as lines containing no characters, except for
space or tab characters.</p>
</dd></dl>

<dl class="class">
<dt id="nltk.tokenize.regexp.RegexpTokenizer">
<em class="property">class </em><tt class="descclassname">nltk.tokenize.regexp.</tt><tt class="descname">RegexpTokenizer</tt><big>(</big><em>pattern</em>, <em>gaps=False</em>, <em>discard_empty=True</em>, <em>flags=56</em><big>)</big><a class="reference internal" href="../_modules/nltk/tokenize/regexp.html#RegexpTokenizer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.regexp.RegexpTokenizer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.tokenize.api.TokenizerI" title="nltk.tokenize.api.TokenizerI"><tt class="xref py py-class docutils literal"><span class="pre">nltk.tokenize.api.TokenizerI</span></tt></a></p>
<p>A tokenizer that splits a string using a regular expression, which
matches either the tokens or the separators between tokens.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">tokenizer</span> <span class="o">=</span> <span class="n">RegexpTokenizer</span><span class="p">(</span><span class="s">&#39;\w+|\$[\d\.]+|\S+&#39;</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>pattern</strong> (<em>str</em>) &#8211; The pattern used to build this tokenizer.
(This pattern may safely contain grouping parentheses.)</li>
<li><strong>gaps</strong> (<em>bool</em>) &#8211; True if this tokenizer&#8217;s pattern should be used
to find separators between tokens; False if this
tokenizer&#8217;s pattern should be used to find the tokens
themselves.</li>
<li><strong>discard_empty</strong> (<em>bool</em>) &#8211; True if any empty tokens <cite>&#8216;&#8217;</cite>
generated by the tokenizer should be discarded.  Empty
tokens can only be generated if <cite>_gaps == True</cite>.</li>
<li><strong>flags</strong> (<em>int</em>) &#8211; The regexp flags used to compile this
tokenizer&#8217;s pattern.  By default, the following flags are
used: <cite>re.UNICODE | re.MULTILINE | re.DOTALL</cite>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="nltk.tokenize.regexp.RegexpTokenizer.span_tokenize">
<tt class="descname">span_tokenize</tt><big>(</big><em>text</em><big>)</big><a class="reference internal" href="../_modules/nltk/tokenize/regexp.html#RegexpTokenizer.span_tokenize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.regexp.RegexpTokenizer.span_tokenize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nltk.tokenize.regexp.RegexpTokenizer.tokenize">
<tt class="descname">tokenize</tt><big>(</big><em>text</em><big>)</big><a class="reference internal" href="../_modules/nltk/tokenize/regexp.html#RegexpTokenizer.tokenize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.regexp.RegexpTokenizer.tokenize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.tokenize.regexp.WhitespaceTokenizer">
<em class="property">class </em><tt class="descclassname">nltk.tokenize.regexp.</tt><tt class="descname">WhitespaceTokenizer</tt><a class="reference internal" href="../_modules/nltk/tokenize/regexp.html#WhitespaceTokenizer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.regexp.WhitespaceTokenizer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.tokenize.regexp.RegexpTokenizer" title="nltk.tokenize.regexp.RegexpTokenizer"><tt class="xref py py-class docutils literal"><span class="pre">nltk.tokenize.regexp.RegexpTokenizer</span></tt></a></p>
<p>Tokenize a string on whitespace (space, tab, newline).
In general, users should use the string <tt class="docutils literal"><span class="pre">split()</span></tt> method instead.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">nltk.tokenize</span> <span class="kn">import</span> <span class="n">WhitespaceTokenizer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="s">&quot;Good muffins cost $3.88</span><span class="se">\n</span><span class="s">in New York.  Please buy me</span><span class="se">\n</span><span class="s">two of them.</span><span class="se">\n\n</span><span class="s">Thanks.&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">WhitespaceTokenizer</span><span class="p">()</span><span class="o">.</span><span class="n">tokenize</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">[&#39;Good&#39;, &#39;muffins&#39;, &#39;cost&#39;, &#39;$3.88&#39;, &#39;in&#39;, &#39;New&#39;, &#39;York.&#39;,</span>
<span class="go">&#39;Please&#39;, &#39;buy&#39;, &#39;me&#39;, &#39;two&#39;, &#39;of&#39;, &#39;them.&#39;, &#39;Thanks.&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nltk.tokenize.regexp.WordPunctTokenizer">
<em class="property">class </em><tt class="descclassname">nltk.tokenize.regexp.</tt><tt class="descname">WordPunctTokenizer</tt><a class="reference internal" href="../_modules/nltk/tokenize/regexp.html#WordPunctTokenizer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.regexp.WordPunctTokenizer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.tokenize.regexp.RegexpTokenizer" title="nltk.tokenize.regexp.RegexpTokenizer"><tt class="xref py py-class docutils literal"><span class="pre">nltk.tokenize.regexp.RegexpTokenizer</span></tt></a></p>
<p>Tokenize a text into a sequence of alphabetic and
non-alphabetic characters, using the regexp <tt class="docutils literal"><span class="pre">\w+|[^\w\s]+</span></tt>.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">nltk.tokenize</span> <span class="kn">import</span> <span class="n">WordPunctTokenizer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="s">&quot;Good muffins cost $3.88</span><span class="se">\n</span><span class="s">in New York.  Please buy me</span><span class="se">\n</span><span class="s">two of them.</span><span class="se">\n\n</span><span class="s">Thanks.&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">WordPunctTokenizer</span><span class="p">()</span><span class="o">.</span><span class="n">tokenize</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">[&#39;Good&#39;, &#39;muffins&#39;, &#39;cost&#39;, &#39;$&#39;, &#39;3&#39;, &#39;.&#39;, &#39;88&#39;, &#39;in&#39;, &#39;New&#39;, &#39;York&#39;,</span>
<span class="go">&#39;.&#39;, &#39;Please&#39;, &#39;buy&#39;, &#39;me&#39;, &#39;two&#39;, &#39;of&#39;, &#39;them&#39;, &#39;.&#39;, &#39;Thanks&#39;, &#39;.&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="nltk.tokenize.regexp.regexp_tokenize">
<tt class="descclassname">nltk.tokenize.regexp.</tt><tt class="descname">regexp_tokenize</tt><big>(</big><em>text</em>, <em>pattern</em>, <em>gaps=False</em>, <em>discard_empty=True</em>, <em>flags=56</em><big>)</big><a class="reference internal" href="../_modules/nltk/tokenize/regexp.html#regexp_tokenize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.regexp.regexp_tokenize" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a tokenized copy of <em>text</em>.  See <a class="reference internal" href="#nltk.tokenize.regexp.RegexpTokenizer" title="nltk.tokenize.regexp.RegexpTokenizer"><tt class="xref py py-class docutils literal"><span class="pre">RegexpTokenizer</span></tt></a>
for descriptions of the arguments.</p>
</dd></dl>

</div>
<div class="section" id="module-nltk.tokenize.sexpr">
<span id="sexpr-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">sexpr</span></tt> Module<a class="headerlink" href="#module-nltk.tokenize.sexpr" title="Permalink to this headline">¶</a></h2>
<p>S-Expression Tokenizer</p>
<p><tt class="docutils literal"><span class="pre">SExprTokenizer</span></tt> is used to find parenthesized expressions in a
string.  In particular, it divides a string into a sequence of
substrings that are either parenthesized expressions (including any
nested parenthesized expressions), or other whitespace-separated
tokens.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">nltk.tokenize</span> <span class="kn">import</span> <span class="n">SExprTokenizer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">SExprTokenizer</span><span class="p">()</span><span class="o">.</span><span class="n">tokenize</span><span class="p">(</span><span class="s">&#39;(a b (c d)) e f (g)&#39;</span><span class="p">)</span>
<span class="go">[&#39;(a b (c d))&#39;, &#39;e&#39;, &#39;f&#39;, &#39;(g)&#39;]</span>
</pre></div>
</div>
<p>By default, <cite>SExprTokenizer</cite> will raise a <tt class="docutils literal"><span class="pre">ValueError</span></tt> exception if
used to tokenize an expression with non-matching parentheses:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">SExprTokenizer</span><span class="p">()</span><span class="o">.</span><span class="n">tokenize</span><span class="p">(</span><span class="s">&#39;c) d) e (f (g&#39;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  <span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">Un-matched close paren at char 1</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">strict</span></tt> argument can be set to False to allow for
non-matching parentheses.  Any unmatched close parentheses will be
listed as their own s-expression; and the last partial sexpr with
unmatched open parentheses will be listed as its own sexpr:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">SExprTokenizer</span><span class="p">(</span><span class="n">strict</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span><span class="o">.</span><span class="n">tokenize</span><span class="p">(</span><span class="s">&#39;c) d) e (f (g&#39;</span><span class="p">)</span>
<span class="go">[&#39;c&#39;, &#39;)&#39;, &#39;d&#39;, &#39;)&#39;, &#39;e&#39;, &#39;(f (g&#39;]</span>
</pre></div>
</div>
<p>The characters used for open and close parentheses may be customized
using the <tt class="docutils literal"><span class="pre">parens</span></tt> argument to the <cite>SExprTokenizer</cite> constructor:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">SExprTokenizer</span><span class="p">(</span><span class="n">parens</span><span class="o">=</span><span class="s">&#39;{}&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">tokenize</span><span class="p">(</span><span class="s">&#39;{a b {c d}} e f {g}&#39;</span><span class="p">)</span>
<span class="go">[&#39;{a b {c d}}&#39;, &#39;e&#39;, &#39;f&#39;, &#39;{g}&#39;]</span>
</pre></div>
</div>
<p>The s-expression tokenizer is also available as a function:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">nltk.tokenize</span> <span class="kn">import</span> <span class="n">sexpr_tokenize</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sexpr_tokenize</span><span class="p">(</span><span class="s">&#39;(a b (c d)) e f (g)&#39;</span><span class="p">)</span>
<span class="go">[&#39;(a b (c d))&#39;, &#39;e&#39;, &#39;f&#39;, &#39;(g)&#39;]</span>
</pre></div>
</div>
<dl class="class">
<dt id="nltk.tokenize.sexpr.SExprTokenizer">
<em class="property">class </em><tt class="descclassname">nltk.tokenize.sexpr.</tt><tt class="descname">SExprTokenizer</tt><big>(</big><em>parens='()'</em>, <em>strict=True</em><big>)</big><a class="reference internal" href="../_modules/nltk/tokenize/sexpr.html#SExprTokenizer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.sexpr.SExprTokenizer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.tokenize.api.TokenizerI" title="nltk.tokenize.api.TokenizerI"><tt class="xref py py-class docutils literal"><span class="pre">nltk.tokenize.api.TokenizerI</span></tt></a></p>
<p>A tokenizer that divides strings into s-expressions.
An s-expresion can be either:</p>
<blockquote>
<div><ul class="simple">
<li>a parenthesized expression, including any nested parenthesized
expressions, or</li>
<li>a sequence of non-whitespace non-parenthesis characters.</li>
</ul>
</div></blockquote>
<p>For example, the string <tt class="docutils literal"><span class="pre">(a</span> <span class="pre">(b</span> <span class="pre">c))</span> <span class="pre">d</span> <span class="pre">e</span> <span class="pre">(f)</span></tt> consists of four
s-expressions: <tt class="docutils literal"><span class="pre">(a</span> <span class="pre">(b</span> <span class="pre">c))</span></tt>, <tt class="docutils literal"><span class="pre">d</span></tt>, <tt class="docutils literal"><span class="pre">e</span></tt>, and <tt class="docutils literal"><span class="pre">(f)</span></tt>.</p>
<p>By default, the characters <tt class="docutils literal"><span class="pre">(</span></tt> and <tt class="docutils literal"><span class="pre">)</span></tt> are treated as open and
close parentheses, but alternative strings may be specified.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>parens</strong> (<em>str or list</em>) &#8211; A two-element sequence specifying the open and close parentheses
that should be used to find sexprs.  This will typically be either a
two-character string, or a list of two strings.</li>
<li><strong>strict</strong> &#8211; If true, then raise an exception when tokenizing an ill-formed sexpr.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="nltk.tokenize.sexpr.SExprTokenizer.tokenize">
<tt class="descname">tokenize</tt><big>(</big><em>text</em><big>)</big><a class="reference internal" href="../_modules/nltk/tokenize/sexpr.html#SExprTokenizer.tokenize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.sexpr.SExprTokenizer.tokenize" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of s-expressions extracted from <em>text</em>.
For example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">SExprTokenizer</span><span class="p">()</span><span class="o">.</span><span class="n">tokenize</span><span class="p">(</span><span class="s">&#39;(a b (c d)) e f (g)&#39;</span><span class="p">)</span>
<span class="go">[&#39;(a b (c d))&#39;, &#39;e&#39;, &#39;f&#39;, &#39;(g)&#39;]</span>
</pre></div>
</div>
<p>All parentheses are assumed to mark s-expressions.
(No special processing is done to exclude parentheses that occur
inside strings, or following backslash characters.)</p>
<p>If the given expression contains non-matching parentheses,
then the behavior of the tokenizer depends on the <tt class="docutils literal"><span class="pre">strict</span></tt>
parameter to the constructor.  If <tt class="docutils literal"><span class="pre">strict</span></tt> is <tt class="docutils literal"><span class="pre">True</span></tt>, then
raise a <tt class="docutils literal"><span class="pre">ValueError</span></tt>.  If <tt class="docutils literal"><span class="pre">strict</span></tt> is <tt class="docutils literal"><span class="pre">False</span></tt>, then any
unmatched close parentheses will be listed as their own
s-expression; and the last partial s-expression with unmatched open
parentheses will be listed as its own s-expression:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">SExprTokenizer</span><span class="p">(</span><span class="n">strict</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span><span class="o">.</span><span class="n">tokenize</span><span class="p">(</span><span class="s">&#39;c) d) e (f (g&#39;</span><span class="p">)</span>
<span class="go">[&#39;c&#39;, &#39;)&#39;, &#39;d&#39;, &#39;)&#39;, &#39;e&#39;, &#39;(f (g&#39;]</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>text</strong> (<em>str or iter(str)</em>) &#8211; the string to be tokenized</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">iter(str)</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-nltk.tokenize.simple">
<span id="simple-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">simple</span></tt> Module<a class="headerlink" href="#module-nltk.tokenize.simple" title="Permalink to this headline">¶</a></h2>
<p>Simple Tokenizers</p>
<p>These tokenizers divide strings into substrings using the string
<tt class="docutils literal"><span class="pre">split()</span></tt> method.
When tokenizing using a particular delimiter string, use
the string <tt class="docutils literal"><span class="pre">split()</span></tt> method directly, as this is more efficient.</p>
<p>The simple tokenizers are <em>not</em> available as separate functions;
instead, you should just use the string <tt class="docutils literal"><span class="pre">split()</span></tt> method directly:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="s">&quot;Good muffins cost $3.88</span><span class="se">\n</span><span class="s">in New York.  Please buy me</span><span class="se">\n</span><span class="s">two of them.</span><span class="se">\n\n</span><span class="s">Thanks.&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
<span class="go">[&#39;Good&#39;, &#39;muffins&#39;, &#39;cost&#39;, &#39;$3.88&#39;, &#39;in&#39;, &#39;New&#39;, &#39;York.&#39;,</span>
<span class="go">&#39;Please&#39;, &#39;buy&#39;, &#39;me&#39;, &#39;two&#39;, &#39;of&#39;, &#39;them.&#39;, &#39;Thanks.&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39; &#39;</span><span class="p">)</span>
<span class="go">[&#39;Good&#39;, &#39;muffins&#39;, &#39;cost&#39;, &#39;$3.88\nin&#39;, &#39;New&#39;, &#39;York.&#39;, &#39;&#39;,</span>
<span class="go">&#39;Please&#39;, &#39;buy&#39;, &#39;me\ntwo&#39;, &#39;of&#39;, &#39;them.\n\nThanks.&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">)</span>
<span class="go">[&#39;Good muffins cost $3.88&#39;, &#39;in New York.  Please buy me&#39;,</span>
<span class="go">&#39;two of them.&#39;, &#39;&#39;, &#39;Thanks.&#39;]</span>
</pre></div>
</div>
<p>The simple tokenizers are mainly useful because they follow the
standard <tt class="docutils literal"><span class="pre">TokenizerI</span></tt> interface, and so can be used with any code
that expects a tokenizer.  For example, these tokenizers can be used
to specify the tokenization conventions when building a <cite>CorpusReader</cite>.</p>
<dl class="class">
<dt id="nltk.tokenize.simple.CharTokenizer">
<em class="property">class </em><tt class="descclassname">nltk.tokenize.simple.</tt><tt class="descname">CharTokenizer</tt><a class="reference internal" href="../_modules/nltk/tokenize/simple.html#CharTokenizer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.simple.CharTokenizer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.tokenize.api.StringTokenizer" title="nltk.tokenize.api.StringTokenizer"><tt class="xref py py-class docutils literal"><span class="pre">nltk.tokenize.api.StringTokenizer</span></tt></a></p>
<p>Tokenize a string into individual characters.  If this functionality
is ever required directly, use <tt class="docutils literal"><span class="pre">for</span> <span class="pre">char</span> <span class="pre">in</span> <span class="pre">string</span></tt>.</p>
<dl class="method">
<dt id="nltk.tokenize.simple.CharTokenizer.span_tokenize">
<tt class="descname">span_tokenize</tt><big>(</big><em>s</em><big>)</big><a class="reference internal" href="../_modules/nltk/tokenize/simple.html#CharTokenizer.span_tokenize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.simple.CharTokenizer.span_tokenize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nltk.tokenize.simple.CharTokenizer.tokenize">
<tt class="descname">tokenize</tt><big>(</big><em>s</em><big>)</big><a class="reference internal" href="../_modules/nltk/tokenize/simple.html#CharTokenizer.tokenize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.simple.CharTokenizer.tokenize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.tokenize.simple.LineTokenizer">
<em class="property">class </em><tt class="descclassname">nltk.tokenize.simple.</tt><tt class="descname">LineTokenizer</tt><big>(</big><em>blanklines='discard'</em><big>)</big><a class="reference internal" href="../_modules/nltk/tokenize/simple.html#LineTokenizer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.simple.LineTokenizer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.tokenize.api.TokenizerI" title="nltk.tokenize.api.TokenizerI"><tt class="xref py py-class docutils literal"><span class="pre">nltk.tokenize.api.TokenizerI</span></tt></a></p>
<p>Tokenize a string into its lines, optionally discarding blank lines.
This is similar to <tt class="docutils literal"><span class="pre">s.split('\n')</span></tt>.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">nltk.tokenize</span> <span class="kn">import</span> <span class="n">LineTokenizer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="s">&quot;Good muffins cost $3.88</span><span class="se">\n</span><span class="s">in New York.  Please buy me</span><span class="se">\n</span><span class="s">two of them.</span><span class="se">\n\n</span><span class="s">Thanks.&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">LineTokenizer</span><span class="p">(</span><span class="n">blanklines</span><span class="o">=</span><span class="s">&#39;keep&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">tokenize</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">[&#39;Good muffins cost $3.88&#39;, &#39;in New York.  Please buy me&#39;,</span>
<span class="go">&#39;two of them.&#39;, &#39;&#39;, &#39;Thanks.&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># same as [l for l in s.split(&#39;\n&#39;) if l.strip()]:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">LineTokenizer</span><span class="p">(</span><span class="n">blanklines</span><span class="o">=</span><span class="s">&#39;discard&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">tokenize</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">[&#39;Good muffins cost $3.88&#39;, &#39;in New York.  Please buy me&#39;,</span>
<span class="go">&#39;two of them.&#39;, &#39;Thanks.&#39;]</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>blanklines</strong> &#8211; <p>Indicates how blank lines should be handled.  Valid values are:</p>
<ul>
<li><dl class="first docutils">
<dt><tt class="docutils literal"><span class="pre">discard</span></tt>: strip blank lines out of the token list before returning it.</dt>
<dd>A line is considered blank if it contains only whitespace characters.</dd>
</dl>
</li>
<li><tt class="docutils literal"><span class="pre">keep</span></tt>: leave all blank lines in the token list.</li>
<li><dl class="first docutils">
<dt><tt class="docutils literal"><span class="pre">discard-eof</span></tt>: if the string ends with a newline, then do not generate</dt>
<dd>a corresponding token <tt class="docutils literal"><span class="pre">''</span></tt> after that newline.</dd>
</dl>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="nltk.tokenize.simple.LineTokenizer.span_tokenize">
<tt class="descname">span_tokenize</tt><big>(</big><em>s</em><big>)</big><a class="reference internal" href="../_modules/nltk/tokenize/simple.html#LineTokenizer.span_tokenize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.simple.LineTokenizer.span_tokenize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nltk.tokenize.simple.LineTokenizer.tokenize">
<tt class="descname">tokenize</tt><big>(</big><em>s</em><big>)</big><a class="reference internal" href="../_modules/nltk/tokenize/simple.html#LineTokenizer.tokenize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.simple.LineTokenizer.tokenize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.tokenize.simple.SpaceTokenizer">
<em class="property">class </em><tt class="descclassname">nltk.tokenize.simple.</tt><tt class="descname">SpaceTokenizer</tt><a class="reference internal" href="../_modules/nltk/tokenize/simple.html#SpaceTokenizer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.simple.SpaceTokenizer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.tokenize.api.StringTokenizer" title="nltk.tokenize.api.StringTokenizer"><tt class="xref py py-class docutils literal"><span class="pre">nltk.tokenize.api.StringTokenizer</span></tt></a></p>
<p>Tokenize a string using the space character as a delimiter,
which is the same as <tt class="docutils literal"><span class="pre">s.split('</span> <span class="pre">')</span></tt>.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">nltk.tokenize</span> <span class="kn">import</span> <span class="n">SpaceTokenizer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="s">&quot;Good muffins cost $3.88</span><span class="se">\n</span><span class="s">in New York.  Please buy me</span><span class="se">\n</span><span class="s">two of them.</span><span class="se">\n\n</span><span class="s">Thanks.&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">SpaceTokenizer</span><span class="p">()</span><span class="o">.</span><span class="n">tokenize</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">[&#39;Good&#39;, &#39;muffins&#39;, &#39;cost&#39;, &#39;$3.88\nin&#39;, &#39;New&#39;, &#39;York.&#39;, &#39;&#39;,</span>
<span class="go">&#39;Please&#39;, &#39;buy&#39;, &#39;me\ntwo&#39;, &#39;of&#39;, &#39;them.\n\nThanks.&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nltk.tokenize.simple.TabTokenizer">
<em class="property">class </em><tt class="descclassname">nltk.tokenize.simple.</tt><tt class="descname">TabTokenizer</tt><a class="reference internal" href="../_modules/nltk/tokenize/simple.html#TabTokenizer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.simple.TabTokenizer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.tokenize.api.StringTokenizer" title="nltk.tokenize.api.StringTokenizer"><tt class="xref py py-class docutils literal"><span class="pre">nltk.tokenize.api.StringTokenizer</span></tt></a></p>
<p>Tokenize a string use the tab character as a delimiter,
the same as <tt class="docutils literal"><span class="pre">s.split('\t')</span></tt>.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">nltk.tokenize</span> <span class="kn">import</span> <span class="n">TabTokenizer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">TabTokenizer</span><span class="p">()</span><span class="o">.</span><span class="n">tokenize</span><span class="p">(</span><span class="s">&#39;a</span><span class="se">\t</span><span class="s">b c</span><span class="se">\n\t</span><span class="s"> d&#39;</span><span class="p">)</span>
<span class="go">[&#39;a&#39;, &#39;b c\n&#39;, &#39; d&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="nltk.tokenize.simple.line_tokenize">
<tt class="descclassname">nltk.tokenize.simple.</tt><tt class="descname">line_tokenize</tt><big>(</big><em>text</em>, <em>blanklines='discard'</em><big>)</big><a class="reference internal" href="../_modules/nltk/tokenize/simple.html#line_tokenize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.simple.line_tokenize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-nltk.tokenize.texttiling">
<span id="texttiling-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">texttiling</span></tt> Module<a class="headerlink" href="#module-nltk.tokenize.texttiling" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="nltk.tokenize.texttiling.TextTilingTokenizer">
<em class="property">class </em><tt class="descclassname">nltk.tokenize.texttiling.</tt><tt class="descname">TextTilingTokenizer</tt><big>(</big><em>w=20, k=10, similarity_method=0, stopwords=None, smoothing_method=[0], smoothing_width=2, smoothing_rounds=1, cutoff_policy=1, demo_mode=False</em><big>)</big><a class="reference internal" href="../_modules/nltk/tokenize/texttiling.html#TextTilingTokenizer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.texttiling.TextTilingTokenizer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.tokenize.api.TokenizerI" title="nltk.tokenize.api.TokenizerI"><tt class="xref py py-class docutils literal"><span class="pre">nltk.tokenize.api.TokenizerI</span></tt></a></p>
<p>Tokenize a document into topical sections using the TextTiling algorithm.
This algorithm detects subtopic shifts based on the analysis of lexical
co-occurrence patterns.</p>
<p>The process starts by tokenizing the text into pseudosentences of
a fixed size w. Then, depending on the method used, similarity
scores are assigned at sentence gaps. The algorithm proceeds by
detecting the peak differences between these scores and marking
them as boundaries. The boundaries are normalized to the closest
paragraph break and the segmented text is returned.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>w</strong> (<em>int</em>) &#8211; Pseudosentence size</li>
<li><strong>k</strong> (<em>int</em>) &#8211; Size (in sentences) of the block used in the block comparison method</li>
<li><strong>similarity_method</strong> (<em>constant</em>) &#8211; The method used for determining similarity scores:
<cite>BLOCK_COMPARISON</cite> (default) or <cite>VOCABULARY_INTRODUCTION</cite>.</li>
<li><strong>stopwords</strong> (<em>list(str)</em>) &#8211; A list of stopwords that are filtered out (defaults to NLTK&#8217;s stopwords corpus)</li>
<li><strong>smoothing_method</strong> (<em>constant</em>) &#8211; The method used for smoothing the score plot:
<cite>DEFAULT_SMOOTHING</cite> (default)</li>
<li><strong>smoothing_width</strong> (<em>int</em>) &#8211; The width of the window used by the smoothing method</li>
<li><strong>smoothing_rounds</strong> (<em>int</em>) &#8211; The number of smoothing passes</li>
<li><strong>cutoff_policy</strong> (<em>constant</em>) &#8211; The policy used to determine the number of boundaries:
<cite>HC</cite> (default) or <cite>LC</cite></li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="nltk.tokenize.texttiling.TextTilingTokenizer.tokenize">
<tt class="descname">tokenize</tt><big>(</big><em>text</em><big>)</big><a class="reference internal" href="../_modules/nltk/tokenize/texttiling.html#TextTilingTokenizer.tokenize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.texttiling.TextTilingTokenizer.tokenize" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a tokenized copy of <em>text</em>, where each &#8220;token&#8221; represents
a separate topic.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.tokenize.texttiling.TokenSequence">
<em class="property">class </em><tt class="descclassname">nltk.tokenize.texttiling.</tt><tt class="descname">TokenSequence</tt><big>(</big><em>index</em>, <em>wrdindex_list</em>, <em>original_length=None</em><big>)</big><a class="reference internal" href="../_modules/nltk/tokenize/texttiling.html#TokenSequence"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.texttiling.TokenSequence" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>A token list with its original length and its index</p>
</dd></dl>

<dl class="class">
<dt id="nltk.tokenize.texttiling.TokenTableField">
<em class="property">class </em><tt class="descclassname">nltk.tokenize.texttiling.</tt><tt class="descname">TokenTableField</tt><big>(</big><em>first_pos</em>, <em>ts_occurences</em>, <em>total_count=1</em>, <em>par_count=1</em>, <em>last_par=0</em>, <em>last_tok_seq=None</em><big>)</big><a class="reference internal" href="../_modules/nltk/tokenize/texttiling.html#TokenTableField"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.texttiling.TokenTableField" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>A field in the token table holding parameters for each token,
used later in the process</p>
</dd></dl>

<dl class="function">
<dt id="nltk.tokenize.texttiling.demo">
<tt class="descclassname">nltk.tokenize.texttiling.</tt><tt class="descname">demo</tt><big>(</big><em>text=None</em><big>)</big><a class="reference internal" href="../_modules/nltk/tokenize/texttiling.html#demo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.texttiling.demo" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="nltk.tokenize.texttiling.smooth">
<tt class="descclassname">nltk.tokenize.texttiling.</tt><tt class="descname">smooth</tt><big>(</big><em>x</em>, <em>window_len=11</em>, <em>window='flat'</em><big>)</big><a class="reference internal" href="../_modules/nltk/tokenize/texttiling.html#smooth"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.texttiling.smooth" title="Permalink to this definition">¶</a></dt>
<dd><p>smooth the data using a window with requested size.</p>
<p>This method is based on the convolution of a scaled window with the signal.
The signal is prepared by introducing reflected copies of the signal
(with the window size) in both ends so that transient parts are minimized
in the beginning and end part of the output signal.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>x</strong> &#8211; the input signal</li>
<li><strong>window_len</strong> &#8211; the dimension of the smoothing window; should be an odd integer</li>
<li><strong>window</strong> &#8211; the type of window from &#8216;flat&#8217;, &#8216;hanning&#8217;, &#8216;hamming&#8217;, &#8216;bartlett&#8217;, &#8216;blackman&#8217;
flat window will produce a moving average smoothing.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the smoothed signal</p>
</td>
</tr>
</tbody>
</table>
<p>example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">t</span><span class="o">=</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mf">0.1</span><span class="p">)</span>
<span class="n">x</span><span class="o">=</span><span class="n">sin</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">+</span><span class="n">randn</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">))</span><span class="o">*</span><span class="mf">0.1</span>
<span class="n">y</span><span class="o">=</span><span class="n">smooth</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">See also:</th><td class="field-body">numpy.hanning, numpy.hamming, numpy.bartlett, numpy.blackman, numpy.convolve,
scipy.signal.lfilter</td>
</tr>
</tbody>
</table>
<p>TODO: the window parameter could be the window itself if an array instead of a string</p>
</dd></dl>

</div>
<div class="section" id="module-nltk.tokenize.treebank">
<span id="treebank-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">treebank</span></tt> Module<a class="headerlink" href="#module-nltk.tokenize.treebank" title="Permalink to this headline">¶</a></h2>
<p>Penn Treebank Tokenizer</p>
<p>The Treebank tokenizer uses regular expressions to tokenize text as in Penn Treebank.
This implementation is a port of the tokenizer sed script written by Robert McIntyre
and available at <a class="reference external" href="http://www.cis.upenn.edu/~treebank/tokenizer.sed">http://www.cis.upenn.edu/~treebank/tokenizer.sed</a>.</p>
<dl class="class">
<dt id="nltk.tokenize.treebank.TreebankWordTokenizer">
<em class="property">class </em><tt class="descclassname">nltk.tokenize.treebank.</tt><tt class="descname">TreebankWordTokenizer</tt><a class="reference internal" href="../_modules/nltk/tokenize/treebank.html#TreebankWordTokenizer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.treebank.TreebankWordTokenizer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.tokenize.api.TokenizerI" title="nltk.tokenize.api.TokenizerI"><tt class="xref py py-class docutils literal"><span class="pre">nltk.tokenize.api.TokenizerI</span></tt></a></p>
<p>The Treebank tokenizer uses regular expressions to tokenize text as in Penn Treebank.
This is the method that is invoked by <tt class="docutils literal"><span class="pre">word_tokenize()</span></tt>.  It assumes that the
text has already been segmented into sentences, e.g. using <tt class="docutils literal"><span class="pre">sent_tokenize()</span></tt>.</p>
<p>This tokenizer performs the following steps:</p>
<ul>
<li><p class="first">split standard contractions, e.g. <tt class="docutils literal"><span class="pre">don't</span></tt> -&gt; <tt class="docutils literal"><span class="pre">do</span> <span class="pre">n't</span></tt> and <tt class="docutils literal"><span class="pre">they'll</span></tt> -&gt; <tt class="docutils literal"><span class="pre">they</span> <span class="pre">'ll</span></tt></p>
</li>
<li><p class="first">treat most punctuation characters as separate tokens</p>
</li>
<li><p class="first">split off commas and single quotes, when followed by whitespace</p>
</li>
<li><p class="first">separate periods that appear at the end of line</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">nltk.tokenize</span> <span class="kn">import</span> <span class="n">TreebankWordTokenizer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="s">&#39;&#39;&#39;Good muffins cost $3.88</span><span class="se">\n</span><span class="s">in New York.  Please buy me</span><span class="se">\n</span><span class="s">two of them.</span><span class="se">\n\n</span><span class="s">Thanks.&#39;&#39;&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">TreebankWordTokenizer</span><span class="p">()</span><span class="o">.</span><span class="n">tokenize</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">[&#39;Good&#39;, &#39;muffins&#39;, &#39;cost&#39;, &#39;$&#39;, &#39;3.88&#39;, &#39;in&#39;, &#39;New&#39;, &#39;York.&#39;,</span>
<span class="go">&#39;Please&#39;, &#39;buy&#39;, &#39;me&#39;, &#39;two&#39;, &#39;of&#39;, &#39;them&#39;, &#39;.&#39;, &#39;Thanks&#39;, &#39;.&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="s">&quot;They&#39;ll save and invest more.&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">TreebankWordTokenizer</span><span class="p">()</span><span class="o">.</span><span class="n">tokenize</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">[&#39;They&#39;, &quot;&#39;ll&quot;, &#39;save&#39;, &#39;and&#39;, &#39;invest&#39;, &#39;more&#39;, &#39;.&#39;]</span>
</pre></div>
</div>
</li>
</ul>
<p>NB. this tokenizer assumes that the text is presented as one sentence per line,
where each line is delimited with a newline character.
The only periods to be treated as separate tokens are those appearing
at the end of a line.</p>
<dl class="attribute">
<dt id="nltk.tokenize.treebank.TreebankWordTokenizer.CONTRACTIONS2">
<tt class="descname">CONTRACTIONS2</tt><em class="property"> = [&lt;_sre.SRE_Pattern object at 0x5147f08&gt;, &lt;_sre.SRE_Pattern object at 0x5150f60&gt;, &lt;_sre.SRE_Pattern object at 0x4da90c0&gt;, &lt;_sre.SRE_Pattern object at 0x4da9150&gt;, &lt;_sre.SRE_Pattern object at 0x4da91e0&gt;, &lt;_sre.SRE_Pattern object at 0x4da9270&gt;, &lt;_sre.SRE_Pattern object at 0x4da9300&gt;, &lt;_sre.SRE_Pattern object at 0x4da9390&gt;]</em><a class="headerlink" href="#nltk.tokenize.treebank.TreebankWordTokenizer.CONTRACTIONS2" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nltk.tokenize.treebank.TreebankWordTokenizer.CONTRACTIONS3">
<tt class="descname">CONTRACTIONS3</tt><em class="property"> = [&lt;_sre.SRE_Pattern object at 0x4da9420&gt;, &lt;_sre.SRE_Pattern object at 0x4da94b0&gt;]</em><a class="headerlink" href="#nltk.tokenize.treebank.TreebankWordTokenizer.CONTRACTIONS3" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nltk.tokenize.treebank.TreebankWordTokenizer.CONTRACTIONS4">
<tt class="descname">CONTRACTIONS4</tt><em class="property"> = [&lt;_sre.SRE_Pattern object at 0x53574c8&gt;, &lt;_sre.SRE_Pattern object at 0x4e6dcb0&gt;]</em><a class="headerlink" href="#nltk.tokenize.treebank.TreebankWordTokenizer.CONTRACTIONS4" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nltk.tokenize.treebank.TreebankWordTokenizer.tokenize">
<tt class="descname">tokenize</tt><big>(</big><em>text</em><big>)</big><a class="reference internal" href="../_modules/nltk/tokenize/treebank.html#TreebankWordTokenizer.tokenize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.treebank.TreebankWordTokenizer.tokenize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="module-nltk.tokenize.util">
<span id="util-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">util</span></tt> Module<a class="headerlink" href="#module-nltk.tokenize.util" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="nltk.tokenize.util.regexp_span_tokenize">
<tt class="descclassname">nltk.tokenize.util.</tt><tt class="descname">regexp_span_tokenize</tt><big>(</big><em>s</em>, <em>regexp</em><big>)</big><a class="reference internal" href="../_modules/nltk/tokenize/util.html#regexp_span_tokenize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.util.regexp_span_tokenize" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the offsets of the tokens in <em>s</em>, as a sequence of <tt class="docutils literal"><span class="pre">(start,</span> <span class="pre">end)</span></tt>
tuples, by splitting the string at each successive match of <em>regexp</em>.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">nltk.tokenize</span> <span class="kn">import</span> <span class="n">WhitespaceTokenizer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="s">&#39;&#39;&#39;Good muffins cost $3.88</span><span class="se">\n</span><span class="s">in New York.  Please buy me</span>
<span class="gp">... </span><span class="s">two of them.</span><span class="se">\n\n</span><span class="s">Thanks.&#39;&#39;&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">WhitespaceTokenizer</span><span class="p">()</span><span class="o">.</span><span class="n">span_tokenize</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
<span class="go">[(0, 4), (5, 12), (13, 17), (18, 23), (24, 26), (27, 30), (31, 36),</span>
<span class="go">(38, 44), (45, 48), (49, 51), (52, 55), (56, 58), (59, 64), (66, 73)]</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>s</strong> (<em>str</em>) &#8211; the string to be tokenized</li>
<li><strong>regexp</strong> (<em>str</em>) &#8211; regular expression that matches token separators</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">iter(tuple(int, int))</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="nltk.tokenize.util.spans_to_relative">
<tt class="descclassname">nltk.tokenize.util.</tt><tt class="descname">spans_to_relative</tt><big>(</big><em>spans</em><big>)</big><a class="reference internal" href="../_modules/nltk/tokenize/util.html#spans_to_relative"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.util.spans_to_relative" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a sequence of relative spans, given a sequence of spans.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">nltk.tokenize</span> <span class="kn">import</span> <span class="n">WhitespaceTokenizer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">nltk.tokenize.util</span> <span class="kn">import</span> <span class="n">spans_to_relative</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="s">&#39;&#39;&#39;Good muffins cost $3.88</span><span class="se">\n</span><span class="s">in New York.  Please buy me</span>
<span class="gp">... </span><span class="s">two of them.</span><span class="se">\n\n</span><span class="s">Thanks.&#39;&#39;&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">spans_to_relative</span><span class="p">(</span><span class="n">WhitespaceTokenizer</span><span class="p">()</span><span class="o">.</span><span class="n">span_tokenize</span><span class="p">(</span><span class="n">s</span><span class="p">)))</span>
<span class="go">[(0, 4), (1, 7), (1, 4), (1, 5), (1, 2), (1, 3), (1, 5), (2, 6),</span>
<span class="go">(1, 3), (1, 2), (1, 3), (1, 2), (1, 5), (2, 7)]</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>spans</strong> (<em>iter(tuple(int, int))</em>) &#8211; a sequence of (start, end) offsets of the tokens</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">iter(tuple(int, int))</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="nltk.tokenize.util.string_span_tokenize">
<tt class="descclassname">nltk.tokenize.util.</tt><tt class="descname">string_span_tokenize</tt><big>(</big><em>s</em>, <em>sep</em><big>)</big><a class="reference internal" href="../_modules/nltk/tokenize/util.html#string_span_tokenize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.util.string_span_tokenize" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the offsets of the tokens in <em>s</em>, as a sequence of <tt class="docutils literal"><span class="pre">(start,</span> <span class="pre">end)</span></tt>
tuples, by splitting the string at each occurrence of <em>sep</em>.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">nltk.tokenize.util</span> <span class="kn">import</span> <span class="n">string_span_tokenize</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="s">&#39;&#39;&#39;Good muffins cost $3.88</span><span class="se">\n</span><span class="s">in New York.  Please buy me</span>
<span class="gp">... </span><span class="s">two of them.</span><span class="se">\n\n</span><span class="s">Thanks.&#39;&#39;&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">string_span_tokenize</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot; &quot;</span><span class="p">))</span>
<span class="go">[(0, 4), (5, 12), (13, 17), (18, 26), (27, 30), (31, 36), (37, 37),</span>
<span class="go">(38, 44), (45, 48), (49, 55), (56, 58), (59, 73)]</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>s</strong> (<em>str</em>) &#8211; the string to be tokenized</li>
<li><strong>sep</strong> (<em>str</em>) &#8211; the token separator</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">iter(tuple(int, int))</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
        </div>
        <div class="sidebar">
          <h3>Table Of Contents</h3>
          <ul>
<li class="toctree-l1"><a class="reference internal" href="../news.html">NLTK News</a></li>
<li class="toctree-l1"><a class="reference internal" href="../install.html">Installing NLTK</a></li>
<li class="toctree-l1"><a class="reference internal" href="../data.html">Installing NLTK Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="nltk.html">nltk Package</a></li>
</ul>

          <h3 style="margin-top: 1.5em;">Search</h3>
          <form class="search" action="../search.html" method="get">
            <input type="text" name="q" />
            <input type="submit" value="Go" />
            <input type="hidden" name="check_keywords" value="yes" />
            <input type="hidden" name="area" value="default" />
          </form>
          <p class="searchtip" style="font-size: 90%">
            Enter search terms or a module, class or function name.
          </p>
        </div>
        <div class="clearer"></div>
      </div>
    </div>

    <div class="footer-wrapper">
      <div class="footer">
        <div class="left">
          <a href="nltk.test.html" title="test Package"
             >previous</a> |
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |
          <a href="../genindex.html" title="General Index"
             >index</a>
            <br/>
            <a href="../_sources/api/nltk.tokenize.txt"
               rel="nofollow">Show Source</a>
        </div>

        <div class="right">
          
    <div class="footer">
        &copy; Copyright 2012, NLTK Project.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
        </div>
        <div class="clearer"></div>
      </div>
    </div>

  </body>
</html>