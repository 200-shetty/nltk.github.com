<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>nltk.tokenize package &mdash; NLTK 3.0 documentation</title>
    
    <link rel="stylesheet" href="../_static/agogo.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '3.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="NLTK 3.0 documentation" href="../index.html" />
    <link rel="up" title="nltk Package" href="nltk.html" />
    <link rel="prev" title="nltk.test.unit.align package" href="nltk.test.unit.align.html" /> 
  </head>
  <body role="document">
    <div class="header-wrapper" role="banner">
      <div class="header">
        <div class="headertitle"><a
          href="../index.html">NLTK 3.0 documentation</a></div>
        <div class="rel" role="navigation" aria-label="related navigation">
          <a href="nltk.test.unit.align.html" title="nltk.test.unit.align package"
             accesskey="P">previous</a> |
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a>
        </div>
       </div>
    </div>

    <div class="content-wrapper">
      <div class="content">
        <div class="document">
            
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="nltk-tokenize-package">
<h1>nltk.tokenize package<a class="headerlink" href="#nltk-tokenize-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-nltk.tokenize.api">
<span id="nltk-tokenize-api-module"></span><h2>nltk.tokenize.api module<a class="headerlink" href="#module-nltk.tokenize.api" title="Permalink to this headline">¶</a></h2>
<p>Tokenizer Interface</p>
<dl class="class">
<dt id="nltk.tokenize.api.StringTokenizer">
<em class="property">class </em><code class="descclassname">nltk.tokenize.api.</code><code class="descname">StringTokenizer</code><a class="reference internal" href="../_modules/nltk/tokenize/api.html#StringTokenizer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.api.StringTokenizer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.tokenize.api.TokenizerI" title="nltk.tokenize.api.TokenizerI"><code class="xref py py-class docutils literal"><span class="pre">nltk.tokenize.api.TokenizerI</span></code></a></p>
<p>A tokenizer that divides a string into substrings by splitting
on the specified string (defined in subclasses).</p>
<dl class="method">
<dt id="nltk.tokenize.api.StringTokenizer.span_tokenize">
<code class="descname">span_tokenize</code><span class="sig-paren">(</span><em>s</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tokenize/api.html#StringTokenizer.span_tokenize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.api.StringTokenizer.span_tokenize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nltk.tokenize.api.StringTokenizer.tokenize">
<code class="descname">tokenize</code><span class="sig-paren">(</span><em>s</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tokenize/api.html#StringTokenizer.tokenize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.api.StringTokenizer.tokenize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.tokenize.api.TokenizerI">
<em class="property">class </em><code class="descclassname">nltk.tokenize.api.</code><code class="descname">TokenizerI</code><a class="reference internal" href="../_modules/nltk/tokenize/api.html#TokenizerI"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.api.TokenizerI" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>A processing interface for tokenizing a string.
Subclasses must define <code class="docutils literal"><span class="pre">tokenize()</span></code> or <code class="docutils literal"><span class="pre">tokenize_sents()</span></code> (or both).</p>
<dl class="method">
<dt id="nltk.tokenize.api.TokenizerI.span_tokenize">
<code class="descname">span_tokenize</code><span class="sig-paren">(</span><em>s</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tokenize/api.html#TokenizerI.span_tokenize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.api.TokenizerI.span_tokenize" title="Permalink to this definition">¶</a></dt>
<dd><p>Identify the tokens using integer offsets <code class="docutils literal"><span class="pre">(start_i,</span> <span class="pre">end_i)</span></code>,
where <code class="docutils literal"><span class="pre">s[start_i:end_i]</span></code> is the corresponding token.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">iter(tuple(int, int))</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.tokenize.api.TokenizerI.span_tokenize_sents">
<code class="descname">span_tokenize_sents</code><span class="sig-paren">(</span><em>strings</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tokenize/api.html#TokenizerI.span_tokenize_sents"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.api.TokenizerI.span_tokenize_sents" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply <code class="docutils literal"><span class="pre">self.span_tokenize()</span></code> to each element of <code class="docutils literal"><span class="pre">strings</span></code>.  I.e.:</p>
<blockquote>
<div>return [self.span_tokenize(s) for s in strings]</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">iter(list(tuple(int, int)))</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.tokenize.api.TokenizerI.tokenize">
<code class="descname">tokenize</code><span class="sig-paren">(</span><em>s</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tokenize/api.html#TokenizerI.tokenize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.api.TokenizerI.tokenize" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a tokenized copy of <em>s</em>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">list of str</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nltk.tokenize.api.TokenizerI.tokenize_sents">
<code class="descname">tokenize_sents</code><span class="sig-paren">(</span><em>strings</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tokenize/api.html#TokenizerI.tokenize_sents"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.api.TokenizerI.tokenize_sents" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply <code class="docutils literal"><span class="pre">self.tokenize()</span></code> to each element of <code class="docutils literal"><span class="pre">strings</span></code>.  I.e.:</p>
<blockquote>
<div>return [self.tokenize(s) for s in strings]</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">list(list(str))</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-nltk.tokenize.casual">
<span id="nltk-tokenize-casual-module"></span><h2>nltk.tokenize.casual module<a class="headerlink" href="#module-nltk.tokenize.casual" title="Permalink to this headline">¶</a></h2>
<p>Twitter-aware tokenizer, designed to be flexible and easy to adapt to new
domains and tasks. The basic logic is this:</p>
<ol class="arabic simple">
<li>The tuple regex_strings defines a list of regular expression
strings.</li>
<li>The regex_strings strings are put, in order, into a compiled
regular expression object called word_re.</li>
<li>The tokenization is done by word_re.findall(s), where s is the
user-supplied string, inside the tokenize() method of the class
Tokenizer.</li>
<li>When instantiating Tokenizer objects, there is a single option:
preserve_case.  By default, it is set to True. If it is set to
False, then the tokenizer will downcase everything except for
emoticons.</li>
</ol>
<dl class="class">
<dt id="nltk.tokenize.casual.TweetTokenizer">
<em class="property">class </em><code class="descclassname">nltk.tokenize.casual.</code><code class="descname">TweetTokenizer</code><span class="sig-paren">(</span><em>preserve_case=True</em>, <em>reduce_len=False</em>, <em>strip_handles=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tokenize/casual.html#TweetTokenizer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.casual.TweetTokenizer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Tokenizer for tweets.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">nltk.tokenize</span> <span class="kn">import</span> <span class="n">TweetTokenizer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tknzr</span> <span class="o">=</span> <span class="n">TweetTokenizer</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s0</span> <span class="o">=</span> <span class="s">&quot;This is a cooool #dummysmiley: :-) :-P &lt;3 and some arrows &lt; &gt; -&gt; &lt;--&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tknzr</span><span class="o">.</span><span class="n">tokenize</span><span class="p">(</span><span class="n">s0</span><span class="p">)</span>
<span class="go">[&#39;This&#39;, &#39;is&#39;, &#39;a&#39;, &#39;cooool&#39;, &#39;#dummysmiley&#39;, &#39;:&#39;, &#39;:-)&#39;, &#39;:-P&#39;, &#39;&lt;3&#39;, &#39;and&#39;, &#39;some&#39;, &#39;arrows&#39;, &#39;&lt;&#39;, &#39;&gt;&#39;, &#39;-&gt;&#39;, &#39;&lt;--&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s1</span> <span class="o">=</span> <span class="s">&quot;@Joyster2012 @CathStaincliffe Good for you, girl!! Best wishes :-)&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tknzr</span><span class="o">.</span><span class="n">tokenize</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span>
<span class="go">[&#39;@Joyster2012&#39;, &#39;@CathStaincliffe&#39;, &#39;Good&#39;, &#39;for&#39;, &#39;you&#39;, &#39;,&#39;, &#39;girl&#39;, &#39;!&#39;, &#39;!&#39;, &#39;Best&#39;, &#39;wishes&#39;, &#39;:-)&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s2</span> <span class="o">=</span> <span class="s">&quot;3Points for #DreamTeam Gooo BAILEY! :) #PBB737Gold @PBBabscbn&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tknzr</span><span class="o">.</span><span class="n">tokenize</span><span class="p">(</span><span class="n">s2</span><span class="p">)</span>
<span class="go">[&#39;3Points&#39;, &#39;for&#39;, &#39;#DreamTeam&#39;, &#39;Gooo&#39;, &#39;BAILEY&#39;, &#39;!&#39;, &#39;:)&#39;, &#39;#PBB737Gold&#39;, &#39;@PBBabscbn&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s3</span> <span class="o">=</span> <span class="s">&quot;@Insanomania They do... Their mentality doesn&#39;t :(&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tknzr</span><span class="o">.</span><span class="n">tokenize</span><span class="p">(</span><span class="n">s3</span><span class="p">)</span>
<span class="go">[&#39;@Insanomania&#39;, &#39;They&#39;, &#39;do&#39;, &#39;...&#39;, &#39;Their&#39;, &#39;mentality&#39;, &quot;doesn&#39;t&quot;, &#39;:(&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s4</span> <span class="o">=</span> <span class="s">&quot;RT @facugambande: Ya por arrancar a grabar !!! #TirenTirenTiren vamoo !!&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tknzr</span><span class="o">.</span><span class="n">tokenize</span><span class="p">(</span><span class="n">s4</span><span class="p">)</span>
<span class="go">[&#39;RT&#39;, &#39;@facugambande&#39;, &#39;:&#39;, &#39;Ya&#39;, &#39;por&#39;, &#39;arrancar&#39;, &#39;a&#39;, &#39;grabar&#39;, &#39;!&#39;, &#39;!&#39;, &#39;!&#39;, &#39;#TirenTirenTiren&#39;, &#39;vamoo&#39;, &#39;!&#39;, &#39;!&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tknzr</span> <span class="o">=</span> <span class="n">TweetTokenizer</span><span class="p">(</span><span class="n">reduce_len</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s5</span> <span class="o">=</span> <span class="s">&quot;@crushinghes the summer holidays are great but I&#39;m so bored already :(&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tknzr</span><span class="o">.</span><span class="n">tokenize</span><span class="p">(</span><span class="n">s5</span><span class="p">)</span>
<span class="go">[&#39;@crushinghes&#39;, &#39;the&#39;, &#39;summer&#39;, &#39;holidays&#39;, &#39;are&#39;, &#39;great&#39;, &#39;but&#39;, &quot;I&#39;m&quot;, &#39;so&#39;, &#39;bored&#39;, &#39;already&#39;, &#39;:(&#39;]</span>
</pre></div>
</div>
<p>Examples using <cite>strip_handles</cite> and <cite>reduce_len parameters</cite>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">tknzr</span> <span class="o">=</span> <span class="n">TweetTokenizer</span><span class="p">(</span><span class="n">strip_handles</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">reduce_len</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s6</span> <span class="o">=</span> <span class="s">&#39;@remy: This is waaaaayyyy too much for you!!!!!!&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tknzr</span><span class="o">.</span><span class="n">tokenize</span><span class="p">(</span><span class="n">s6</span><span class="p">)</span>
<span class="go">[&#39;:&#39;, &#39;This&#39;, &#39;is&#39;, &#39;waaayyy&#39;, &#39;too&#39;, &#39;much&#39;, &#39;for&#39;, &#39;you&#39;, &#39;!&#39;, &#39;!&#39;, &#39;!&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s7</span> <span class="o">=</span> <span class="s">&#39;@_willy65: No place for @chuck tonight. Sorry.&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tknzr</span><span class="o">.</span><span class="n">tokenize</span><span class="p">(</span><span class="n">s7</span><span class="p">)</span>
<span class="go">[&#39;:&#39;, &#39;No&#39;, &#39;place&#39;, &#39;for&#39;, &#39;tonight&#39;, &#39;.&#39;, &#39;Sorry&#39;, &#39;.&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s8</span> <span class="o">=</span> <span class="s">&#39;@mar_tin is a great developer. Contact him at mar_tin@email.com&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tknzr</span><span class="o">.</span><span class="n">tokenize</span><span class="p">(</span><span class="n">s8</span><span class="p">)</span>
<span class="go">[&#39;is&#39;, &#39;a&#39;, &#39;great&#39;, &#39;developer&#39;, &#39;.&#39;, &#39;Contact&#39;, &#39;him&#39;, &#39;at&#39;, &#39;mar_tin&#39;, &#39;@email&#39;, &#39;.&#39;, &#39;com&#39;]</span>
</pre></div>
</div>
<dl class="method">
<dt id="nltk.tokenize.casual.TweetTokenizer.tokenize">
<code class="descname">tokenize</code><span class="sig-paren">(</span><em>text</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tokenize/casual.html#TweetTokenizer.tokenize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.casual.TweetTokenizer.tokenize" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>text</strong> &#8211; str</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">list(str)</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a tokenized list of strings; concatenating this list returns        the original string if <cite>preserve_case=False</cite></td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="nltk.tokenize.casual.casual_tokenize">
<code class="descclassname">nltk.tokenize.casual.</code><code class="descname">casual_tokenize</code><span class="sig-paren">(</span><em>text</em>, <em>preserve_case=True</em>, <em>reduce_len=False</em>, <em>strip_handles=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tokenize/casual.html#casual_tokenize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.casual.casual_tokenize" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience function for wrapping the tokenizer.</p>
</dd></dl>

<dl class="function">
<dt id="nltk.tokenize.casual.reduce_lengthening">
<code class="descclassname">nltk.tokenize.casual.</code><code class="descname">reduce_lengthening</code><span class="sig-paren">(</span><em>text</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tokenize/casual.html#reduce_lengthening"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.casual.reduce_lengthening" title="Permalink to this definition">¶</a></dt>
<dd><p>Replace repeated character sequences of length 3 or greater with sequences
of length 3.</p>
</dd></dl>

<dl class="function">
<dt id="nltk.tokenize.casual.remove_handles">
<code class="descclassname">nltk.tokenize.casual.</code><code class="descname">remove_handles</code><span class="sig-paren">(</span><em>text</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tokenize/casual.html#remove_handles"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.casual.remove_handles" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove Twitter username handles from text.</p>
</dd></dl>

</div>
<div class="section" id="module-nltk.tokenize.punkt">
<span id="nltk-tokenize-punkt-module"></span><h2>nltk.tokenize.punkt module<a class="headerlink" href="#module-nltk.tokenize.punkt" title="Permalink to this headline">¶</a></h2>
<p>Punkt Sentence Tokenizer</p>
<p>This tokenizer divides a text into a list of sentences,
by using an unsupervised algorithm to build a model for abbreviation
words, collocations, and words that start sentences.  It must be
trained on a large collection of plaintext in the target language
before it can be used.</p>
<p>The NLTK data package includes a pre-trained Punkt tokenizer for
English.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">nltk.data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">text</span> <span class="o">=</span> <span class="s">&#39;&#39;&#39;</span>
<span class="gp">... </span><span class="s">Punkt knows that the periods in Mr. Smith and Johann S. Bach</span>
<span class="gp">... </span><span class="s">do not mark sentence boundaries.  And sometimes sentences</span>
<span class="gp">... </span><span class="s">can start with non-capitalized words.  i is a good variable</span>
<span class="gp">... </span><span class="s">name.</span>
<span class="gp">... </span><span class="s">&#39;&#39;&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sent_detector</span> <span class="o">=</span> <span class="n">nltk</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s">&#39;tokenizers/punkt/english.pickle&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">-----</span><span class="se">\n</span><span class="s">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">sent_detector</span><span class="o">.</span><span class="n">tokenize</span><span class="p">(</span><span class="n">text</span><span class="o">.</span><span class="n">strip</span><span class="p">())))</span>
<span class="go">Punkt knows that the periods in Mr. Smith and Johann S. Bach</span>
<span class="go">do not mark sentence boundaries.</span>
<span class="go">-----</span>
<span class="go">And sometimes sentences</span>
<span class="go">can start with non-capitalized words.</span>
<span class="go">-----</span>
<span class="go">i is a good variable</span>
<span class="go">name.</span>
</pre></div>
</div>
<p>(Note that whitespace from the original text, including newlines, is
retained in the output.)</p>
<p>Punctuation following sentences is also included by default
(from NLTK 3.0 onwards). It can be excluded with the realign_boundaries
flag.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">text</span> <span class="o">=</span> <span class="s">&#39;&#39;&#39;</span>
<span class="gp">... </span><span class="s">(How does it deal with this parenthesis?)  &quot;It should be part of the</span>
<span class="gp">... </span><span class="s">previous sentence.&quot; &quot;(And the same with this one.)&quot; (&#39;And this one!&#39;)</span>
<span class="gp">... </span><span class="s">&quot;(&#39;(And (this)) &#39;?)&quot; [(and this. )]</span>
<span class="gp">... </span><span class="s">&#39;&#39;&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">-----</span><span class="se">\n</span><span class="s">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">sent_detector</span><span class="o">.</span><span class="n">tokenize</span><span class="p">(</span><span class="n">text</span><span class="o">.</span><span class="n">strip</span><span class="p">())))</span>
<span class="go">(How does it deal with this parenthesis?)</span>
<span class="go">-----</span>
<span class="go">&quot;It should be part of the</span>
<span class="go">previous sentence.&quot;</span>
<span class="go">-----</span>
<span class="go">&quot;(And the same with this one.)&quot;</span>
<span class="go">-----</span>
<span class="go">(&#39;And this one!&#39;)</span>
<span class="go">-----</span>
<span class="go">&quot;(&#39;(And (this)) &#39;?)&quot;</span>
<span class="go">-----</span>
<span class="go">[(and this. )]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">-----</span><span class="se">\n</span><span class="s">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">sent_detector</span><span class="o">.</span><span class="n">tokenize</span><span class="p">(</span><span class="n">text</span><span class="o">.</span><span class="n">strip</span><span class="p">(),</span> <span class="n">realign_boundaries</span><span class="o">=</span><span class="bp">False</span><span class="p">)))</span>
<span class="go">(How does it deal with this parenthesis?</span>
<span class="go">-----</span>
<span class="go">)  &quot;It should be part of the</span>
<span class="go">previous sentence.</span>
<span class="go">-----</span>
<span class="go">&quot; &quot;(And the same with this one.</span>
<span class="go">-----</span>
<span class="go">)&quot; (&#39;And this one!</span>
<span class="go">-----</span>
<span class="go">&#39;)</span>
<span class="go">&quot;(&#39;(And (this)) &#39;?</span>
<span class="go">-----</span>
<span class="go">)&quot; [(and this.</span>
<span class="go">-----</span>
<span class="go">)]</span>
</pre></div>
</div>
<p>However, Punkt is designed to learn parameters (a list of abbreviations, etc.)
unsupervised from a corpus similar to the target domain. The pre-packaged models
may therefore be unsuitable: use <code class="docutils literal"><span class="pre">PunktSentenceTokenizer(text)</span></code> to learn
parameters from the given text.</p>
<p><a class="reference internal" href="#nltk.tokenize.punkt.PunktTrainer" title="nltk.tokenize.punkt.PunktTrainer"><code class="xref py py-class docutils literal"><span class="pre">PunktTrainer</span></code></a> learns parameters such as a list of abbreviations
(without supervision) from portions of text. Using a <code class="docutils literal"><span class="pre">PunktTrainer</span></code> directly
allows for incremental training and modification of the hyper-parameters used
to decide what is considered an abbreviation, etc.</p>
<p>The algorithm for this tokenizer is described in:</p>
<div class="highlight-python"><div class="highlight"><pre>Kiss, Tibor and Strunk, Jan (2006): Unsupervised Multilingual Sentence
  Boundary Detection.  Computational Linguistics 32: 485-525.
</pre></div>
</div>
<dl class="class">
<dt id="nltk.tokenize.punkt.PunktBaseClass">
<em class="property">class </em><code class="descclassname">nltk.tokenize.punkt.</code><code class="descname">PunktBaseClass</code><span class="sig-paren">(</span><em>lang_vars=&lt;nltk.tokenize.punkt.PunktLanguageVars object&gt;</em>, <em>token_cls=&lt;class 'nltk.tokenize.punkt.PunktToken'&gt;</em>, <em>params=&lt;nltk.tokenize.punkt.PunktParameters object&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tokenize/punkt.html#PunktBaseClass"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.punkt.PunktBaseClass" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Includes common components of PunktTrainer and PunktSentenceTokenizer.</p>
</dd></dl>

<dl class="class">
<dt id="nltk.tokenize.punkt.PunktLanguageVars">
<em class="property">class </em><code class="descclassname">nltk.tokenize.punkt.</code><code class="descname">PunktLanguageVars</code><a class="reference internal" href="../_modules/nltk/tokenize/punkt.html#PunktLanguageVars"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.punkt.PunktLanguageVars" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Stores variables, mostly regular expressions, which may be
language-dependent for correct application of the algorithm.
An extension of this class may modify its properties to suit
a language other than English; an instance can then be passed
as an argument to PunktSentenceTokenizer and PunktTrainer
constructors.</p>
<dl class="attribute">
<dt id="nltk.tokenize.punkt.PunktLanguageVars.internal_punctuation">
<code class="descname">internal_punctuation</code><em class="property"> = ',:;'</em><a class="headerlink" href="#nltk.tokenize.punkt.PunktLanguageVars.internal_punctuation" title="Permalink to this definition">¶</a></dt>
<dd><p>sentence internal punctuation, which indicates an abbreviation if
preceded by a period-final token.</p>
</dd></dl>

<dl class="method">
<dt id="nltk.tokenize.punkt.PunktLanguageVars.period_context_re">
<code class="descname">period_context_re</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tokenize/punkt.html#PunktLanguageVars.period_context_re"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.punkt.PunktLanguageVars.period_context_re" title="Permalink to this definition">¶</a></dt>
<dd><p>Compiles and returns a regular expression to find contexts
including possible sentence boundaries.</p>
</dd></dl>

<dl class="attribute">
<dt id="nltk.tokenize.punkt.PunktLanguageVars.re_boundary_realignment">
<code class="descname">re_boundary_realignment</code><em class="property"> = re.compile('[&quot;\\\')\\]}]+?(?:\\s+|(?=--)|$)', re.MULTILINE)</em><a class="headerlink" href="#nltk.tokenize.punkt.PunktLanguageVars.re_boundary_realignment" title="Permalink to this definition">¶</a></dt>
<dd><p>Used to realign punctuation that should be included in a sentence
although it follows the period (or ?, !).</p>
</dd></dl>

<dl class="attribute">
<dt id="nltk.tokenize.punkt.PunktLanguageVars.sent_end_chars">
<code class="descname">sent_end_chars</code><em class="property"> = ('.', '?', '!')</em><a class="headerlink" href="#nltk.tokenize.punkt.PunktLanguageVars.sent_end_chars" title="Permalink to this definition">¶</a></dt>
<dd><p>Characters which are candidates for sentence boundaries</p>
</dd></dl>

<dl class="method">
<dt id="nltk.tokenize.punkt.PunktLanguageVars.word_tokenize">
<code class="descname">word_tokenize</code><span class="sig-paren">(</span><em>s</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tokenize/punkt.html#PunktLanguageVars.word_tokenize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.punkt.PunktLanguageVars.word_tokenize" title="Permalink to this definition">¶</a></dt>
<dd><p>Tokenize a string to split off punctuation other than periods</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.tokenize.punkt.PunktParameters">
<em class="property">class </em><code class="descclassname">nltk.tokenize.punkt.</code><code class="descname">PunktParameters</code><a class="reference internal" href="../_modules/nltk/tokenize/punkt.html#PunktParameters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.punkt.PunktParameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Stores data used to perform sentence boundary detection with Punkt.</p>
<dl class="attribute">
<dt id="nltk.tokenize.punkt.PunktParameters.abbrev_types">
<code class="descname">abbrev_types</code><em class="property"> = None</em><a class="headerlink" href="#nltk.tokenize.punkt.PunktParameters.abbrev_types" title="Permalink to this definition">¶</a></dt>
<dd><p>A set of word types for known abbreviations.</p>
</dd></dl>

<dl class="method">
<dt id="nltk.tokenize.punkt.PunktParameters.add_ortho_context">
<code class="descname">add_ortho_context</code><span class="sig-paren">(</span><em>typ</em>, <em>flag</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tokenize/punkt.html#PunktParameters.add_ortho_context"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.punkt.PunktParameters.add_ortho_context" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nltk.tokenize.punkt.PunktParameters.clear_abbrevs">
<code class="descname">clear_abbrevs</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tokenize/punkt.html#PunktParameters.clear_abbrevs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.punkt.PunktParameters.clear_abbrevs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nltk.tokenize.punkt.PunktParameters.clear_collocations">
<code class="descname">clear_collocations</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tokenize/punkt.html#PunktParameters.clear_collocations"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.punkt.PunktParameters.clear_collocations" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nltk.tokenize.punkt.PunktParameters.clear_ortho_context">
<code class="descname">clear_ortho_context</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tokenize/punkt.html#PunktParameters.clear_ortho_context"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.punkt.PunktParameters.clear_ortho_context" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nltk.tokenize.punkt.PunktParameters.clear_sent_starters">
<code class="descname">clear_sent_starters</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tokenize/punkt.html#PunktParameters.clear_sent_starters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.punkt.PunktParameters.clear_sent_starters" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nltk.tokenize.punkt.PunktParameters.collocations">
<code class="descname">collocations</code><em class="property"> = None</em><a class="headerlink" href="#nltk.tokenize.punkt.PunktParameters.collocations" title="Permalink to this definition">¶</a></dt>
<dd><p>A set of word type tuples for known common collocations
where the first word ends in a period.  E.g., (&#8216;S.&#8217;, &#8216;Bach&#8217;)
is a common collocation in a text that discusses &#8216;Johann
S. Bach&#8217;.  These count as negative evidence for sentence
boundaries.</p>
</dd></dl>

<dl class="attribute">
<dt id="nltk.tokenize.punkt.PunktParameters.ortho_context">
<code class="descname">ortho_context</code><em class="property"> = None</em><a class="headerlink" href="#nltk.tokenize.punkt.PunktParameters.ortho_context" title="Permalink to this definition">¶</a></dt>
<dd><p>A dictionary mapping word types to the set of orthographic
contexts that word type appears in.  Contexts are represented
by adding orthographic context flags: ...</p>
</dd></dl>

<dl class="attribute">
<dt id="nltk.tokenize.punkt.PunktParameters.sent_starters">
<code class="descname">sent_starters</code><em class="property"> = None</em><a class="headerlink" href="#nltk.tokenize.punkt.PunktParameters.sent_starters" title="Permalink to this definition">¶</a></dt>
<dd><p>A set of word types for words that often appear at the
beginning of sentences.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.tokenize.punkt.PunktSentenceTokenizer">
<em class="property">class </em><code class="descclassname">nltk.tokenize.punkt.</code><code class="descname">PunktSentenceTokenizer</code><span class="sig-paren">(</span><em>train_text=None</em>, <em>verbose=False</em>, <em>lang_vars=&lt;nltk.tokenize.punkt.PunktLanguageVars object&gt;</em>, <em>token_cls=&lt;class 'nltk.tokenize.punkt.PunktToken'&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tokenize/punkt.html#PunktSentenceTokenizer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.punkt.PunktSentenceTokenizer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.tokenize.punkt.PunktBaseClass" title="nltk.tokenize.punkt.PunktBaseClass"><code class="xref py py-class docutils literal"><span class="pre">nltk.tokenize.punkt.PunktBaseClass</span></code></a>, <a class="reference internal" href="#nltk.tokenize.api.TokenizerI" title="nltk.tokenize.api.TokenizerI"><code class="xref py py-class docutils literal"><span class="pre">nltk.tokenize.api.TokenizerI</span></code></a></p>
<p>A sentence tokenizer which uses an unsupervised algorithm to build
a model for abbreviation words, collocations, and words that start
sentences; and then uses that model to find sentence boundaries.
This approach has been shown to work well for many European
languages.</p>
<dl class="attribute">
<dt id="nltk.tokenize.punkt.PunktSentenceTokenizer.PUNCTUATION">
<code class="descname">PUNCTUATION</code><em class="property"> = (';', ':', ',', '.', '!', '?')</em><a class="headerlink" href="#nltk.tokenize.punkt.PunktSentenceTokenizer.PUNCTUATION" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nltk.tokenize.punkt.PunktSentenceTokenizer.debug_decisions">
<code class="descname">debug_decisions</code><span class="sig-paren">(</span><em>text</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tokenize/punkt.html#PunktSentenceTokenizer.debug_decisions"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.punkt.PunktSentenceTokenizer.debug_decisions" title="Permalink to this definition">¶</a></dt>
<dd><p>Classifies candidate periods as sentence breaks, yielding a dict for
each that may be used to understand why the decision was made.</p>
<p>See format_debug_decision() to help make this output readable.</p>
</dd></dl>

<dl class="method">
<dt id="nltk.tokenize.punkt.PunktSentenceTokenizer.dump">
<code class="descname">dump</code><span class="sig-paren">(</span><em>tokens</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tokenize/punkt.html#PunktSentenceTokenizer.dump"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.punkt.PunktSentenceTokenizer.dump" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nltk.tokenize.punkt.PunktSentenceTokenizer.sentences_from_text">
<code class="descname">sentences_from_text</code><span class="sig-paren">(</span><em>text</em>, <em>realign_boundaries=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tokenize/punkt.html#PunktSentenceTokenizer.sentences_from_text"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.punkt.PunktSentenceTokenizer.sentences_from_text" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a text, generates the sentences in that text by only
testing candidate sentence breaks. If realign_boundaries is
True, includes in the sentence closing punctuation that
follows the period.</p>
</dd></dl>

<dl class="method">
<dt id="nltk.tokenize.punkt.PunktSentenceTokenizer.sentences_from_text_legacy">
<code class="descname">sentences_from_text_legacy</code><span class="sig-paren">(</span><em>text</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tokenize/punkt.html#PunktSentenceTokenizer.sentences_from_text_legacy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.punkt.PunktSentenceTokenizer.sentences_from_text_legacy" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a text, generates the sentences in that text. Annotates all
tokens, rather than just those with possible sentence breaks. Should
produce the same results as <code class="docutils literal"><span class="pre">sentences_from_text</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="nltk.tokenize.punkt.PunktSentenceTokenizer.sentences_from_tokens">
<code class="descname">sentences_from_tokens</code><span class="sig-paren">(</span><em>tokens</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tokenize/punkt.html#PunktSentenceTokenizer.sentences_from_tokens"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.punkt.PunktSentenceTokenizer.sentences_from_tokens" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a sequence of tokens, generates lists of tokens, each list
corresponding to a sentence.</p>
</dd></dl>

<dl class="method">
<dt id="nltk.tokenize.punkt.PunktSentenceTokenizer.span_tokenize">
<code class="descname">span_tokenize</code><span class="sig-paren">(</span><em>text</em>, <em>realign_boundaries=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tokenize/punkt.html#PunktSentenceTokenizer.span_tokenize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.punkt.PunktSentenceTokenizer.span_tokenize" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a text, returns a list of the (start, end) spans of sentences
in the text.</p>
</dd></dl>

<dl class="method">
<dt id="nltk.tokenize.punkt.PunktSentenceTokenizer.text_contains_sentbreak">
<code class="descname">text_contains_sentbreak</code><span class="sig-paren">(</span><em>text</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tokenize/punkt.html#PunktSentenceTokenizer.text_contains_sentbreak"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.punkt.PunktSentenceTokenizer.text_contains_sentbreak" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if the given text includes a sentence break.</p>
</dd></dl>

<dl class="method">
<dt id="nltk.tokenize.punkt.PunktSentenceTokenizer.tokenize">
<code class="descname">tokenize</code><span class="sig-paren">(</span><em>text</em>, <em>realign_boundaries=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tokenize/punkt.html#PunktSentenceTokenizer.tokenize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.punkt.PunktSentenceTokenizer.tokenize" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a text, returns a list of the sentences in that text.</p>
</dd></dl>

<dl class="method">
<dt id="nltk.tokenize.punkt.PunktSentenceTokenizer.train">
<code class="descname">train</code><span class="sig-paren">(</span><em>train_text</em>, <em>verbose=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tokenize/punkt.html#PunktSentenceTokenizer.train"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.punkt.PunktSentenceTokenizer.train" title="Permalink to this definition">¶</a></dt>
<dd><p>Derives parameters from a given training text, or uses the parameters
given. Repeated calls to this method destroy previous parameters. For
incremental training, instantiate a separate PunktTrainer instance.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.tokenize.punkt.PunktToken">
<em class="property">class </em><code class="descclassname">nltk.tokenize.punkt.</code><code class="descname">PunktToken</code><span class="sig-paren">(</span><em>tok</em>, <em>**params</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tokenize/punkt.html#PunktToken"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.punkt.PunktToken" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Stores a token of text with annotations produced during
sentence boundary detection.</p>
<dl class="attribute">
<dt id="nltk.tokenize.punkt.PunktToken.abbr">
<code class="descname">abbr</code><a class="headerlink" href="#nltk.tokenize.punkt.PunktToken.abbr" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nltk.tokenize.punkt.PunktToken.ellipsis">
<code class="descname">ellipsis</code><a class="headerlink" href="#nltk.tokenize.punkt.PunktToken.ellipsis" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nltk.tokenize.punkt.PunktToken.first_case">
<code class="descname">first_case</code><a class="headerlink" href="#nltk.tokenize.punkt.PunktToken.first_case" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nltk.tokenize.punkt.PunktToken.first_lower">
<code class="descname">first_lower</code><a class="headerlink" href="#nltk.tokenize.punkt.PunktToken.first_lower" title="Permalink to this definition">¶</a></dt>
<dd><p>True if the token&#8217;s first character is lowercase.</p>
</dd></dl>

<dl class="attribute">
<dt id="nltk.tokenize.punkt.PunktToken.first_upper">
<code class="descname">first_upper</code><a class="headerlink" href="#nltk.tokenize.punkt.PunktToken.first_upper" title="Permalink to this definition">¶</a></dt>
<dd><p>True if the token&#8217;s first character is uppercase.</p>
</dd></dl>

<dl class="attribute">
<dt id="nltk.tokenize.punkt.PunktToken.is_alpha">
<code class="descname">is_alpha</code><a class="headerlink" href="#nltk.tokenize.punkt.PunktToken.is_alpha" title="Permalink to this definition">¶</a></dt>
<dd><p>True if the token text is all alphabetic.</p>
</dd></dl>

<dl class="attribute">
<dt id="nltk.tokenize.punkt.PunktToken.is_ellipsis">
<code class="descname">is_ellipsis</code><a class="headerlink" href="#nltk.tokenize.punkt.PunktToken.is_ellipsis" title="Permalink to this definition">¶</a></dt>
<dd><p>True if the token text is that of an ellipsis.</p>
</dd></dl>

<dl class="attribute">
<dt id="nltk.tokenize.punkt.PunktToken.is_initial">
<code class="descname">is_initial</code><a class="headerlink" href="#nltk.tokenize.punkt.PunktToken.is_initial" title="Permalink to this definition">¶</a></dt>
<dd><p>True if the token text is that of an initial.</p>
</dd></dl>

<dl class="attribute">
<dt id="nltk.tokenize.punkt.PunktToken.is_non_punct">
<code class="descname">is_non_punct</code><a class="headerlink" href="#nltk.tokenize.punkt.PunktToken.is_non_punct" title="Permalink to this definition">¶</a></dt>
<dd><p>True if the token is either a number or is alphabetic.</p>
</dd></dl>

<dl class="attribute">
<dt id="nltk.tokenize.punkt.PunktToken.is_number">
<code class="descname">is_number</code><a class="headerlink" href="#nltk.tokenize.punkt.PunktToken.is_number" title="Permalink to this definition">¶</a></dt>
<dd><p>True if the token text is that of a number.</p>
</dd></dl>

<dl class="attribute">
<dt id="nltk.tokenize.punkt.PunktToken.linestart">
<code class="descname">linestart</code><a class="headerlink" href="#nltk.tokenize.punkt.PunktToken.linestart" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nltk.tokenize.punkt.PunktToken.parastart">
<code class="descname">parastart</code><a class="headerlink" href="#nltk.tokenize.punkt.PunktToken.parastart" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nltk.tokenize.punkt.PunktToken.period_final">
<code class="descname">period_final</code><a class="headerlink" href="#nltk.tokenize.punkt.PunktToken.period_final" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nltk.tokenize.punkt.PunktToken.sentbreak">
<code class="descname">sentbreak</code><a class="headerlink" href="#nltk.tokenize.punkt.PunktToken.sentbreak" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nltk.tokenize.punkt.PunktToken.tok">
<code class="descname">tok</code><a class="headerlink" href="#nltk.tokenize.punkt.PunktToken.tok" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nltk.tokenize.punkt.PunktToken.type">
<code class="descname">type</code><a class="headerlink" href="#nltk.tokenize.punkt.PunktToken.type" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nltk.tokenize.punkt.PunktToken.type_no_period">
<code class="descname">type_no_period</code><a class="headerlink" href="#nltk.tokenize.punkt.PunktToken.type_no_period" title="Permalink to this definition">¶</a></dt>
<dd><p>The type with its final period removed if it has one.</p>
</dd></dl>

<dl class="attribute">
<dt id="nltk.tokenize.punkt.PunktToken.type_no_sentperiod">
<code class="descname">type_no_sentperiod</code><a class="headerlink" href="#nltk.tokenize.punkt.PunktToken.type_no_sentperiod" title="Permalink to this definition">¶</a></dt>
<dd><p>The type with its final period removed if it is marked as a
sentence break.</p>
</dd></dl>

<dl class="method">
<dt id="nltk.tokenize.punkt.PunktToken.unicode_repr">
<code class="descname">unicode_repr</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nltk.tokenize.punkt.PunktToken.unicode_repr" title="Permalink to this definition">¶</a></dt>
<dd><p>A string representation of the token that can reproduce it
with eval(), which lists all the token&#8217;s non-default
annotations.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.tokenize.punkt.PunktTrainer">
<em class="property">class </em><code class="descclassname">nltk.tokenize.punkt.</code><code class="descname">PunktTrainer</code><span class="sig-paren">(</span><em>train_text=None</em>, <em>verbose=False</em>, <em>lang_vars=&lt;nltk.tokenize.punkt.PunktLanguageVars object&gt;</em>, <em>token_cls=&lt;class 'nltk.tokenize.punkt.PunktToken'&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tokenize/punkt.html#PunktTrainer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.punkt.PunktTrainer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.tokenize.punkt.PunktBaseClass" title="nltk.tokenize.punkt.PunktBaseClass"><code class="xref py py-class docutils literal"><span class="pre">nltk.tokenize.punkt.PunktBaseClass</span></code></a></p>
<p>Learns parameters used in Punkt sentence boundary detection.</p>
<dl class="attribute">
<dt id="nltk.tokenize.punkt.PunktTrainer.ABBREV">
<code class="descname">ABBREV</code><em class="property"> = 0.3</em><a class="headerlink" href="#nltk.tokenize.punkt.PunktTrainer.ABBREV" title="Permalink to this definition">¶</a></dt>
<dd><p>cut-off value whether a &#8216;token&#8217; is an abbreviation</p>
</dd></dl>

<dl class="attribute">
<dt id="nltk.tokenize.punkt.PunktTrainer.ABBREV_BACKOFF">
<code class="descname">ABBREV_BACKOFF</code><em class="property"> = 5</em><a class="headerlink" href="#nltk.tokenize.punkt.PunktTrainer.ABBREV_BACKOFF" title="Permalink to this definition">¶</a></dt>
<dd><p>upper cut-off for Mikheev&#8217;s(2002) abbreviation detection algorithm</p>
</dd></dl>

<dl class="attribute">
<dt id="nltk.tokenize.punkt.PunktTrainer.COLLOCATION">
<code class="descname">COLLOCATION</code><em class="property"> = 7.88</em><a class="headerlink" href="#nltk.tokenize.punkt.PunktTrainer.COLLOCATION" title="Permalink to this definition">¶</a></dt>
<dd><p>minimal log-likelihood value that two tokens need to be considered
as a collocation</p>
</dd></dl>

<dl class="attribute">
<dt id="nltk.tokenize.punkt.PunktTrainer.IGNORE_ABBREV_PENALTY">
<code class="descname">IGNORE_ABBREV_PENALTY</code><em class="property"> = False</em><a class="headerlink" href="#nltk.tokenize.punkt.PunktTrainer.IGNORE_ABBREV_PENALTY" title="Permalink to this definition">¶</a></dt>
<dd><p>allows the disabling of the abbreviation penalty heuristic, which
exponentially disadvantages words that are found at times without a
final period.</p>
</dd></dl>

<dl class="attribute">
<dt id="nltk.tokenize.punkt.PunktTrainer.INCLUDE_ABBREV_COLLOCS">
<code class="descname">INCLUDE_ABBREV_COLLOCS</code><em class="property"> = False</em><a class="headerlink" href="#nltk.tokenize.punkt.PunktTrainer.INCLUDE_ABBREV_COLLOCS" title="Permalink to this definition">¶</a></dt>
<dd><p>this includes as potential collocations all word pairs where the first
word is an abbreviation. Such collocations override the orthographic
heuristic, but not the sentence starter heuristic. This is overridden by
INCLUDE_ALL_COLLOCS, and if both are false, only collocations with initials
and ordinals are considered.</p>
</dd></dl>

<dl class="attribute">
<dt id="nltk.tokenize.punkt.PunktTrainer.INCLUDE_ALL_COLLOCS">
<code class="descname">INCLUDE_ALL_COLLOCS</code><em class="property"> = False</em><a class="headerlink" href="#nltk.tokenize.punkt.PunktTrainer.INCLUDE_ALL_COLLOCS" title="Permalink to this definition">¶</a></dt>
<dd><p>this includes as potential collocations all word pairs where the first
word ends in a period. It may be useful in corpora where there is a lot
of variation that makes abbreviations like Mr difficult to identify.</p>
</dd></dl>

<dl class="attribute">
<dt id="nltk.tokenize.punkt.PunktTrainer.MIN_COLLOC_FREQ">
<code class="descname">MIN_COLLOC_FREQ</code><em class="property"> = 1</em><a class="headerlink" href="#nltk.tokenize.punkt.PunktTrainer.MIN_COLLOC_FREQ" title="Permalink to this definition">¶</a></dt>
<dd><p>this sets a minimum bound on the number of times a bigram needs to
appear before it can be considered a collocation, in addition to log
likelihood statistics. This is useful when INCLUDE_ALL_COLLOCS is True.</p>
</dd></dl>

<dl class="attribute">
<dt id="nltk.tokenize.punkt.PunktTrainer.SENT_STARTER">
<code class="descname">SENT_STARTER</code><em class="property"> = 30</em><a class="headerlink" href="#nltk.tokenize.punkt.PunktTrainer.SENT_STARTER" title="Permalink to this definition">¶</a></dt>
<dd><p>minimal log-likelihood value that a token requires to be considered
as a frequent sentence starter</p>
</dd></dl>

<dl class="method">
<dt id="nltk.tokenize.punkt.PunktTrainer.finalize_training">
<code class="descname">finalize_training</code><span class="sig-paren">(</span><em>verbose=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tokenize/punkt.html#PunktTrainer.finalize_training"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.punkt.PunktTrainer.finalize_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Uses data that has been gathered in training to determine likely
collocations and sentence starters.</p>
</dd></dl>

<dl class="method">
<dt id="nltk.tokenize.punkt.PunktTrainer.find_abbrev_types">
<code class="descname">find_abbrev_types</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tokenize/punkt.html#PunktTrainer.find_abbrev_types"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.punkt.PunktTrainer.find_abbrev_types" title="Permalink to this definition">¶</a></dt>
<dd><p>Recalculates abbreviations given type frequencies, despite no prior
determination of abbreviations.
This fails to include abbreviations otherwise found as &#8220;rare&#8221;.</p>
</dd></dl>

<dl class="method">
<dt id="nltk.tokenize.punkt.PunktTrainer.freq_threshold">
<code class="descname">freq_threshold</code><span class="sig-paren">(</span><em>ortho_thresh=2</em>, <em>type_thresh=2</em>, <em>colloc_thres=2</em>, <em>sentstart_thresh=2</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tokenize/punkt.html#PunktTrainer.freq_threshold"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.punkt.PunktTrainer.freq_threshold" title="Permalink to this definition">¶</a></dt>
<dd><p>Allows memory use to be reduced after much training by removing data
about rare tokens that are unlikely to have a statistical effect with
further training. Entries occurring above the given thresholds will be
retained.</p>
</dd></dl>

<dl class="method">
<dt id="nltk.tokenize.punkt.PunktTrainer.get_params">
<code class="descname">get_params</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tokenize/punkt.html#PunktTrainer.get_params"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.punkt.PunktTrainer.get_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates and returns parameters for sentence boundary detection as
derived from training.</p>
</dd></dl>

<dl class="method">
<dt id="nltk.tokenize.punkt.PunktTrainer.train">
<code class="descname">train</code><span class="sig-paren">(</span><em>text</em>, <em>verbose=False</em>, <em>finalize=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tokenize/punkt.html#PunktTrainer.train"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.punkt.PunktTrainer.train" title="Permalink to this definition">¶</a></dt>
<dd><p>Collects training data from a given text. If finalize is True, it
will determine all the parameters for sentence boundary detection. If
not, this will be delayed until get_params() or finalize_training() is
called. If verbose is True, abbreviations found will be listed.</p>
</dd></dl>

<dl class="method">
<dt id="nltk.tokenize.punkt.PunktTrainer.train_tokens">
<code class="descname">train_tokens</code><span class="sig-paren">(</span><em>tokens</em>, <em>verbose=False</em>, <em>finalize=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tokenize/punkt.html#PunktTrainer.train_tokens"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.punkt.PunktTrainer.train_tokens" title="Permalink to this definition">¶</a></dt>
<dd><p>Collects training data from a given list of tokens.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="nltk.tokenize.punkt.demo">
<code class="descclassname">nltk.tokenize.punkt.</code><code class="descname">demo</code><span class="sig-paren">(</span><em>text</em>, <em>tok_cls=&lt;class 'nltk.tokenize.punkt.PunktSentenceTokenizer'&gt;</em>, <em>train_cls=&lt;class 'nltk.tokenize.punkt.PunktTrainer'&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tokenize/punkt.html#demo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.punkt.demo" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds a punkt model and applies it to the same text</p>
</dd></dl>

<dl class="function">
<dt id="nltk.tokenize.punkt.format_debug_decision">
<code class="descclassname">nltk.tokenize.punkt.</code><code class="descname">format_debug_decision</code><span class="sig-paren">(</span><em>d</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tokenize/punkt.html#format_debug_decision"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.punkt.format_debug_decision" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-nltk.tokenize.regexp">
<span id="nltk-tokenize-regexp-module"></span><h2>nltk.tokenize.regexp module<a class="headerlink" href="#module-nltk.tokenize.regexp" title="Permalink to this headline">¶</a></h2>
<p>Regular-Expression Tokenizers</p>
<p>A <code class="docutils literal"><span class="pre">RegexpTokenizer</span></code> splits a string into substrings using a regular expression.
For example, the following tokenizer forms tokens out of alphabetic sequences,
money expressions, and any other non-whitespace sequences:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">nltk.tokenize</span> <span class="kn">import</span> <span class="n">RegexpTokenizer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="s">&quot;Good muffins cost $3.88</span><span class="se">\n</span><span class="s">in New York.  Please buy me</span><span class="se">\n</span><span class="s">two of them.</span><span class="se">\n\n</span><span class="s">Thanks.&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tokenizer</span> <span class="o">=</span> <span class="n">RegexpTokenizer</span><span class="p">(</span><span class="s">&#39;\w+|\$[\d\.]+|\S+&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tokenizer</span><span class="o">.</span><span class="n">tokenize</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">[&#39;Good&#39;, &#39;muffins&#39;, &#39;cost&#39;, &#39;$3.88&#39;, &#39;in&#39;, &#39;New&#39;, &#39;York&#39;, &#39;.&#39;,</span>
<span class="go">&#39;Please&#39;, &#39;buy&#39;, &#39;me&#39;, &#39;two&#39;, &#39;of&#39;, &#39;them&#39;, &#39;.&#39;, &#39;Thanks&#39;, &#39;.&#39;]</span>
</pre></div>
</div>
<p>A <code class="docutils literal"><span class="pre">RegexpTokenizer</span></code> can use its regexp to match delimiters instead:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">tokenizer</span> <span class="o">=</span> <span class="n">RegexpTokenizer</span><span class="p">(</span><span class="s">&#39;\s+&#39;</span><span class="p">,</span> <span class="n">gaps</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tokenizer</span><span class="o">.</span><span class="n">tokenize</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">[&#39;Good&#39;, &#39;muffins&#39;, &#39;cost&#39;, &#39;$3.88&#39;, &#39;in&#39;, &#39;New&#39;, &#39;York.&#39;,</span>
<span class="go">&#39;Please&#39;, &#39;buy&#39;, &#39;me&#39;, &#39;two&#39;, &#39;of&#39;, &#39;them.&#39;, &#39;Thanks.&#39;]</span>
</pre></div>
</div>
<p>Note that empty tokens are not returned when the delimiter appears at
the start or end of the string.</p>
<p>The material between the tokens is discarded.  For example,
the following tokenizer selects just the capitalized words:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">capword_tokenizer</span> <span class="o">=</span> <span class="n">RegexpTokenizer</span><span class="p">(</span><span class="s">&#39;[A-Z]\w+&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">capword_tokenizer</span><span class="o">.</span><span class="n">tokenize</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">[&#39;Good&#39;, &#39;New&#39;, &#39;York&#39;, &#39;Please&#39;, &#39;Thanks&#39;]</span>
</pre></div>
</div>
<p>This module contains several subclasses of <code class="docutils literal"><span class="pre">RegexpTokenizer</span></code>
that use pre-defined regular expressions.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">nltk.tokenize</span> <span class="kn">import</span> <span class="n">BlanklineTokenizer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Uses &#39;\s*\n\s*\n\s*&#39;:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">BlanklineTokenizer</span><span class="p">()</span><span class="o">.</span><span class="n">tokenize</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">[&#39;Good muffins cost $3.88\nin New York.  Please buy me\ntwo of them.&#39;,</span>
<span class="go">&#39;Thanks.&#39;]</span>
</pre></div>
</div>
<p>All of the regular expression tokenizers are also available as functions:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">nltk.tokenize</span> <span class="kn">import</span> <span class="n">regexp_tokenize</span><span class="p">,</span> <span class="n">wordpunct_tokenize</span><span class="p">,</span> <span class="n">blankline_tokenize</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">regexp_tokenize</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">pattern</span><span class="o">=</span><span class="s">&#39;\w+|\$[\d\.]+|\S+&#39;</span><span class="p">)</span>
<span class="go">[&#39;Good&#39;, &#39;muffins&#39;, &#39;cost&#39;, &#39;$3.88&#39;, &#39;in&#39;, &#39;New&#39;, &#39;York&#39;, &#39;.&#39;,</span>
<span class="go">&#39;Please&#39;, &#39;buy&#39;, &#39;me&#39;, &#39;two&#39;, &#39;of&#39;, &#39;them&#39;, &#39;.&#39;, &#39;Thanks&#39;, &#39;.&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">wordpunct_tokenize</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">[&#39;Good&#39;, &#39;muffins&#39;, &#39;cost&#39;, &#39;$&#39;, &#39;3&#39;, &#39;.&#39;, &#39;88&#39;, &#39;in&#39;, &#39;New&#39;, &#39;York&#39;,</span>
<span class="go"> &#39;.&#39;, &#39;Please&#39;, &#39;buy&#39;, &#39;me&#39;, &#39;two&#39;, &#39;of&#39;, &#39;them&#39;, &#39;.&#39;, &#39;Thanks&#39;, &#39;.&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">blankline_tokenize</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">[&#39;Good muffins cost $3.88\nin New York.  Please buy me\ntwo of them.&#39;, &#39;Thanks.&#39;]</span>
</pre></div>
</div>
<p>Caution: The function <code class="docutils literal"><span class="pre">regexp_tokenize()</span></code> takes the text as its
first argument, and the regular expression pattern as its second
argument.  This differs from the conventions used by Python&#8217;s
<code class="docutils literal"><span class="pre">re</span></code> functions, where the pattern is always the first argument.
(This is for consistency with the other NLTK tokenizers.)</p>
<dl class="class">
<dt id="nltk.tokenize.regexp.BlanklineTokenizer">
<em class="property">class </em><code class="descclassname">nltk.tokenize.regexp.</code><code class="descname">BlanklineTokenizer</code><a class="reference internal" href="../_modules/nltk/tokenize/regexp.html#BlanklineTokenizer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.regexp.BlanklineTokenizer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.tokenize.regexp.RegexpTokenizer" title="nltk.tokenize.regexp.RegexpTokenizer"><code class="xref py py-class docutils literal"><span class="pre">nltk.tokenize.regexp.RegexpTokenizer</span></code></a></p>
<p>Tokenize a string, treating any sequence of blank lines as a delimiter.
Blank lines are defined as lines containing no characters, except for
space or tab characters.</p>
</dd></dl>

<dl class="class">
<dt id="nltk.tokenize.regexp.RegexpTokenizer">
<em class="property">class </em><code class="descclassname">nltk.tokenize.regexp.</code><code class="descname">RegexpTokenizer</code><span class="sig-paren">(</span><em>pattern</em>, <em>gaps=False</em>, <em>discard_empty=True</em>, <em>flags=56</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tokenize/regexp.html#RegexpTokenizer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.regexp.RegexpTokenizer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.tokenize.api.TokenizerI" title="nltk.tokenize.api.TokenizerI"><code class="xref py py-class docutils literal"><span class="pre">nltk.tokenize.api.TokenizerI</span></code></a></p>
<p>A tokenizer that splits a string using a regular expression, which
matches either the tokens or the separators between tokens.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">tokenizer</span> <span class="o">=</span> <span class="n">RegexpTokenizer</span><span class="p">(</span><span class="s">&#39;\w+|\$[\d\.]+|\S+&#39;</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>pattern</strong> (<a class="reference internal" href="nltk.sem.html#nltk.sem.logic.AnyType.str" title="nltk.sem.logic.AnyType.str"><em>str</em></a>) &#8211; The pattern used to build this tokenizer.
(This pattern may safely contain capturing parentheses.)</li>
<li><strong>gaps</strong> (<em>bool</em>) &#8211; True if this tokenizer&#8217;s pattern should be used
to find separators between tokens; False if this
tokenizer&#8217;s pattern should be used to find the tokens
themselves.</li>
<li><strong>discard_empty</strong> (<em>bool</em>) &#8211; True if any empty tokens <cite>&#8216;&#8217;</cite>
generated by the tokenizer should be discarded.  Empty
tokens can only be generated if <cite>_gaps == True</cite>.</li>
<li><strong>flags</strong> (<em>int</em>) &#8211; The regexp flags used to compile this
tokenizer&#8217;s pattern.  By default, the following flags are
used: <cite>re.UNICODE | re.MULTILINE | re.DOTALL</cite>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="nltk.tokenize.regexp.RegexpTokenizer.span_tokenize">
<code class="descname">span_tokenize</code><span class="sig-paren">(</span><em>text</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tokenize/regexp.html#RegexpTokenizer.span_tokenize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.regexp.RegexpTokenizer.span_tokenize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nltk.tokenize.regexp.RegexpTokenizer.tokenize">
<code class="descname">tokenize</code><span class="sig-paren">(</span><em>text</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tokenize/regexp.html#RegexpTokenizer.tokenize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.regexp.RegexpTokenizer.tokenize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nltk.tokenize.regexp.RegexpTokenizer.unicode_repr">
<code class="descname">unicode_repr</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nltk.tokenize.regexp.RegexpTokenizer.unicode_repr" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.tokenize.regexp.WhitespaceTokenizer">
<em class="property">class </em><code class="descclassname">nltk.tokenize.regexp.</code><code class="descname">WhitespaceTokenizer</code><a class="reference internal" href="../_modules/nltk/tokenize/regexp.html#WhitespaceTokenizer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.regexp.WhitespaceTokenizer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.tokenize.regexp.RegexpTokenizer" title="nltk.tokenize.regexp.RegexpTokenizer"><code class="xref py py-class docutils literal"><span class="pre">nltk.tokenize.regexp.RegexpTokenizer</span></code></a></p>
<p>Tokenize a string on whitespace (space, tab, newline).
In general, users should use the string <code class="docutils literal"><span class="pre">split()</span></code> method instead.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">nltk.tokenize</span> <span class="kn">import</span> <span class="n">WhitespaceTokenizer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="s">&quot;Good muffins cost $3.88</span><span class="se">\n</span><span class="s">in New York.  Please buy me</span><span class="se">\n</span><span class="s">two of them.</span><span class="se">\n\n</span><span class="s">Thanks.&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">WhitespaceTokenizer</span><span class="p">()</span><span class="o">.</span><span class="n">tokenize</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">[&#39;Good&#39;, &#39;muffins&#39;, &#39;cost&#39;, &#39;$3.88&#39;, &#39;in&#39;, &#39;New&#39;, &#39;York.&#39;,</span>
<span class="go">&#39;Please&#39;, &#39;buy&#39;, &#39;me&#39;, &#39;two&#39;, &#39;of&#39;, &#39;them.&#39;, &#39;Thanks.&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nltk.tokenize.regexp.WordPunctTokenizer">
<em class="property">class </em><code class="descclassname">nltk.tokenize.regexp.</code><code class="descname">WordPunctTokenizer</code><a class="reference internal" href="../_modules/nltk/tokenize/regexp.html#WordPunctTokenizer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.regexp.WordPunctTokenizer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.tokenize.regexp.RegexpTokenizer" title="nltk.tokenize.regexp.RegexpTokenizer"><code class="xref py py-class docutils literal"><span class="pre">nltk.tokenize.regexp.RegexpTokenizer</span></code></a></p>
<p>Tokenize a text into a sequence of alphabetic and
non-alphabetic characters, using the regexp <code class="docutils literal"><span class="pre">\w+|[^\w\s]+</span></code>.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">nltk.tokenize</span> <span class="kn">import</span> <span class="n">WordPunctTokenizer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="s">&quot;Good muffins cost $3.88</span><span class="se">\n</span><span class="s">in New York.  Please buy me</span><span class="se">\n</span><span class="s">two of them.</span><span class="se">\n\n</span><span class="s">Thanks.&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">WordPunctTokenizer</span><span class="p">()</span><span class="o">.</span><span class="n">tokenize</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">[&#39;Good&#39;, &#39;muffins&#39;, &#39;cost&#39;, &#39;$&#39;, &#39;3&#39;, &#39;.&#39;, &#39;88&#39;, &#39;in&#39;, &#39;New&#39;, &#39;York&#39;,</span>
<span class="go">&#39;.&#39;, &#39;Please&#39;, &#39;buy&#39;, &#39;me&#39;, &#39;two&#39;, &#39;of&#39;, &#39;them&#39;, &#39;.&#39;, &#39;Thanks&#39;, &#39;.&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="nltk.tokenize.regexp.regexp_tokenize">
<code class="descclassname">nltk.tokenize.regexp.</code><code class="descname">regexp_tokenize</code><span class="sig-paren">(</span><em>text</em>, <em>pattern</em>, <em>gaps=False</em>, <em>discard_empty=True</em>, <em>flags=56</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tokenize/regexp.html#regexp_tokenize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.regexp.regexp_tokenize" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a tokenized copy of <em>text</em>.  See <a class="reference internal" href="#nltk.tokenize.regexp.RegexpTokenizer" title="nltk.tokenize.regexp.RegexpTokenizer"><code class="xref py py-class docutils literal"><span class="pre">RegexpTokenizer</span></code></a>
for descriptions of the arguments.</p>
</dd></dl>

</div>
<div class="section" id="module-nltk.tokenize.sexpr">
<span id="nltk-tokenize-sexpr-module"></span><h2>nltk.tokenize.sexpr module<a class="headerlink" href="#module-nltk.tokenize.sexpr" title="Permalink to this headline">¶</a></h2>
<p>S-Expression Tokenizer</p>
<p><code class="docutils literal"><span class="pre">SExprTokenizer</span></code> is used to find parenthesized expressions in a
string.  In particular, it divides a string into a sequence of
substrings that are either parenthesized expressions (including any
nested parenthesized expressions), or other whitespace-separated
tokens.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">nltk.tokenize</span> <span class="kn">import</span> <span class="n">SExprTokenizer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">SExprTokenizer</span><span class="p">()</span><span class="o">.</span><span class="n">tokenize</span><span class="p">(</span><span class="s">&#39;(a b (c d)) e f (g)&#39;</span><span class="p">)</span>
<span class="go">[&#39;(a b (c d))&#39;, &#39;e&#39;, &#39;f&#39;, &#39;(g)&#39;]</span>
</pre></div>
</div>
<p>By default, <cite>SExprTokenizer</cite> will raise a <code class="docutils literal"><span class="pre">ValueError</span></code> exception if
used to tokenize an expression with non-matching parentheses:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">SExprTokenizer</span><span class="p">()</span><span class="o">.</span><span class="n">tokenize</span><span class="p">(</span><span class="s">&#39;c) d) e (f (g&#39;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  <span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">Un-matched close paren at char 1</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">strict</span></code> argument can be set to False to allow for
non-matching parentheses.  Any unmatched close parentheses will be
listed as their own s-expression; and the last partial sexpr with
unmatched open parentheses will be listed as its own sexpr:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">SExprTokenizer</span><span class="p">(</span><span class="n">strict</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span><span class="o">.</span><span class="n">tokenize</span><span class="p">(</span><span class="s">&#39;c) d) e (f (g&#39;</span><span class="p">)</span>
<span class="go">[&#39;c&#39;, &#39;)&#39;, &#39;d&#39;, &#39;)&#39;, &#39;e&#39;, &#39;(f (g&#39;]</span>
</pre></div>
</div>
<p>The characters used for open and close parentheses may be customized
using the <code class="docutils literal"><span class="pre">parens</span></code> argument to the <cite>SExprTokenizer</cite> constructor:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">SExprTokenizer</span><span class="p">(</span><span class="n">parens</span><span class="o">=</span><span class="s">&#39;{}&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">tokenize</span><span class="p">(</span><span class="s">&#39;{a b {c d}} e f {g}&#39;</span><span class="p">)</span>
<span class="go">[&#39;{a b {c d}}&#39;, &#39;e&#39;, &#39;f&#39;, &#39;{g}&#39;]</span>
</pre></div>
</div>
<p>The s-expression tokenizer is also available as a function:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">nltk.tokenize</span> <span class="kn">import</span> <span class="n">sexpr_tokenize</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sexpr_tokenize</span><span class="p">(</span><span class="s">&#39;(a b (c d)) e f (g)&#39;</span><span class="p">)</span>
<span class="go">[&#39;(a b (c d))&#39;, &#39;e&#39;, &#39;f&#39;, &#39;(g)&#39;]</span>
</pre></div>
</div>
<dl class="class">
<dt id="nltk.tokenize.sexpr.SExprTokenizer">
<em class="property">class </em><code class="descclassname">nltk.tokenize.sexpr.</code><code class="descname">SExprTokenizer</code><span class="sig-paren">(</span><em>parens='()'</em>, <em>strict=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tokenize/sexpr.html#SExprTokenizer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.sexpr.SExprTokenizer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.tokenize.api.TokenizerI" title="nltk.tokenize.api.TokenizerI"><code class="xref py py-class docutils literal"><span class="pre">nltk.tokenize.api.TokenizerI</span></code></a></p>
<p>A tokenizer that divides strings into s-expressions.
An s-expresion can be either:</p>
<blockquote>
<div><ul class="simple">
<li>a parenthesized expression, including any nested parenthesized
expressions, or</li>
<li>a sequence of non-whitespace non-parenthesis characters.</li>
</ul>
</div></blockquote>
<p>For example, the string <code class="docutils literal"><span class="pre">(a</span> <span class="pre">(b</span> <span class="pre">c))</span> <span class="pre">d</span> <span class="pre">e</span> <span class="pre">(f)</span></code> consists of four
s-expressions: <code class="docutils literal"><span class="pre">(a</span> <span class="pre">(b</span> <span class="pre">c))</span></code>, <code class="docutils literal"><span class="pre">d</span></code>, <code class="docutils literal"><span class="pre">e</span></code>, and <code class="docutils literal"><span class="pre">(f)</span></code>.</p>
<p>By default, the characters <code class="docutils literal"><span class="pre">(</span></code> and <code class="docutils literal"><span class="pre">)</span></code> are treated as open and
close parentheses, but alternative strings may be specified.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>parens</strong> (<em>str or list</em>) &#8211; A two-element sequence specifying the open and close parentheses
that should be used to find sexprs.  This will typically be either a
two-character string, or a list of two strings.</li>
<li><strong>strict</strong> &#8211; If true, then raise an exception when tokenizing an ill-formed sexpr.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="nltk.tokenize.sexpr.SExprTokenizer.tokenize">
<code class="descname">tokenize</code><span class="sig-paren">(</span><em>text</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tokenize/sexpr.html#SExprTokenizer.tokenize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.sexpr.SExprTokenizer.tokenize" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of s-expressions extracted from <em>text</em>.
For example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">SExprTokenizer</span><span class="p">()</span><span class="o">.</span><span class="n">tokenize</span><span class="p">(</span><span class="s">&#39;(a b (c d)) e f (g)&#39;</span><span class="p">)</span>
<span class="go">[&#39;(a b (c d))&#39;, &#39;e&#39;, &#39;f&#39;, &#39;(g)&#39;]</span>
</pre></div>
</div>
<p>All parentheses are assumed to mark s-expressions.
(No special processing is done to exclude parentheses that occur
inside strings, or following backslash characters.)</p>
<p>If the given expression contains non-matching parentheses,
then the behavior of the tokenizer depends on the <code class="docutils literal"><span class="pre">strict</span></code>
parameter to the constructor.  If <code class="docutils literal"><span class="pre">strict</span></code> is <code class="docutils literal"><span class="pre">True</span></code>, then
raise a <code class="docutils literal"><span class="pre">ValueError</span></code>.  If <code class="docutils literal"><span class="pre">strict</span></code> is <code class="docutils literal"><span class="pre">False</span></code>, then any
unmatched close parentheses will be listed as their own
s-expression; and the last partial s-expression with unmatched open
parentheses will be listed as its own s-expression:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">SExprTokenizer</span><span class="p">(</span><span class="n">strict</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span><span class="o">.</span><span class="n">tokenize</span><span class="p">(</span><span class="s">&#39;c) d) e (f (g&#39;</span><span class="p">)</span>
<span class="go">[&#39;c&#39;, &#39;)&#39;, &#39;d&#39;, &#39;)&#39;, &#39;e&#39;, &#39;(f (g&#39;]</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>text</strong> (<em>str or iter(str)</em>) &#8211; the string to be tokenized</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">iter(str)</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-nltk.tokenize.simple">
<span id="nltk-tokenize-simple-module"></span><h2>nltk.tokenize.simple module<a class="headerlink" href="#module-nltk.tokenize.simple" title="Permalink to this headline">¶</a></h2>
<p>Simple Tokenizers</p>
<p>These tokenizers divide strings into substrings using the string
<code class="docutils literal"><span class="pre">split()</span></code> method.
When tokenizing using a particular delimiter string, use
the string <code class="docutils literal"><span class="pre">split()</span></code> method directly, as this is more efficient.</p>
<p>The simple tokenizers are <em>not</em> available as separate functions;
instead, you should just use the string <code class="docutils literal"><span class="pre">split()</span></code> method directly:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="s">&quot;Good muffins cost $3.88</span><span class="se">\n</span><span class="s">in New York.  Please buy me</span><span class="se">\n</span><span class="s">two of them.</span><span class="se">\n\n</span><span class="s">Thanks.&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
<span class="go">[&#39;Good&#39;, &#39;muffins&#39;, &#39;cost&#39;, &#39;$3.88&#39;, &#39;in&#39;, &#39;New&#39;, &#39;York.&#39;,</span>
<span class="go">&#39;Please&#39;, &#39;buy&#39;, &#39;me&#39;, &#39;two&#39;, &#39;of&#39;, &#39;them.&#39;, &#39;Thanks.&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39; &#39;</span><span class="p">)</span>
<span class="go">[&#39;Good&#39;, &#39;muffins&#39;, &#39;cost&#39;, &#39;$3.88\nin&#39;, &#39;New&#39;, &#39;York.&#39;, &#39;&#39;,</span>
<span class="go">&#39;Please&#39;, &#39;buy&#39;, &#39;me\ntwo&#39;, &#39;of&#39;, &#39;them.\n\nThanks.&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">)</span>
<span class="go">[&#39;Good muffins cost $3.88&#39;, &#39;in New York.  Please buy me&#39;,</span>
<span class="go">&#39;two of them.&#39;, &#39;&#39;, &#39;Thanks.&#39;]</span>
</pre></div>
</div>
<p>The simple tokenizers are mainly useful because they follow the
standard <code class="docutils literal"><span class="pre">TokenizerI</span></code> interface, and so can be used with any code
that expects a tokenizer.  For example, these tokenizers can be used
to specify the tokenization conventions when building a <cite>CorpusReader</cite>.</p>
<dl class="class">
<dt id="nltk.tokenize.simple.CharTokenizer">
<em class="property">class </em><code class="descclassname">nltk.tokenize.simple.</code><code class="descname">CharTokenizer</code><a class="reference internal" href="../_modules/nltk/tokenize/simple.html#CharTokenizer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.simple.CharTokenizer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.tokenize.api.StringTokenizer" title="nltk.tokenize.api.StringTokenizer"><code class="xref py py-class docutils literal"><span class="pre">nltk.tokenize.api.StringTokenizer</span></code></a></p>
<p>Tokenize a string into individual characters.  If this functionality
is ever required directly, use <code class="docutils literal"><span class="pre">for</span> <span class="pre">char</span> <span class="pre">in</span> <span class="pre">string</span></code>.</p>
<dl class="method">
<dt id="nltk.tokenize.simple.CharTokenizer.span_tokenize">
<code class="descname">span_tokenize</code><span class="sig-paren">(</span><em>s</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tokenize/simple.html#CharTokenizer.span_tokenize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.simple.CharTokenizer.span_tokenize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nltk.tokenize.simple.CharTokenizer.tokenize">
<code class="descname">tokenize</code><span class="sig-paren">(</span><em>s</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tokenize/simple.html#CharTokenizer.tokenize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.simple.CharTokenizer.tokenize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.tokenize.simple.LineTokenizer">
<em class="property">class </em><code class="descclassname">nltk.tokenize.simple.</code><code class="descname">LineTokenizer</code><span class="sig-paren">(</span><em>blanklines='discard'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tokenize/simple.html#LineTokenizer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.simple.LineTokenizer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.tokenize.api.TokenizerI" title="nltk.tokenize.api.TokenizerI"><code class="xref py py-class docutils literal"><span class="pre">nltk.tokenize.api.TokenizerI</span></code></a></p>
<p>Tokenize a string into its lines, optionally discarding blank lines.
This is similar to <code class="docutils literal"><span class="pre">s.split('\n')</span></code>.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">nltk.tokenize</span> <span class="kn">import</span> <span class="n">LineTokenizer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="s">&quot;Good muffins cost $3.88</span><span class="se">\n</span><span class="s">in New York.  Please buy me</span><span class="se">\n</span><span class="s">two of them.</span><span class="se">\n\n</span><span class="s">Thanks.&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">LineTokenizer</span><span class="p">(</span><span class="n">blanklines</span><span class="o">=</span><span class="s">&#39;keep&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">tokenize</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">[&#39;Good muffins cost $3.88&#39;, &#39;in New York.  Please buy me&#39;,</span>
<span class="go">&#39;two of them.&#39;, &#39;&#39;, &#39;Thanks.&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># same as [l for l in s.split(&#39;\n&#39;) if l.strip()]:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">LineTokenizer</span><span class="p">(</span><span class="n">blanklines</span><span class="o">=</span><span class="s">&#39;discard&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">tokenize</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">[&#39;Good muffins cost $3.88&#39;, &#39;in New York.  Please buy me&#39;,</span>
<span class="go">&#39;two of them.&#39;, &#39;Thanks.&#39;]</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>blanklines</strong> &#8211; <p>Indicates how blank lines should be handled.  Valid values are:</p>
<ul>
<li><dl class="first docutils">
<dt><code class="docutils literal"><span class="pre">discard</span></code>: strip blank lines out of the token list before returning it.</dt>
<dd>A line is considered blank if it contains only whitespace characters.</dd>
</dl>
</li>
<li><code class="docutils literal"><span class="pre">keep</span></code>: leave all blank lines in the token list.</li>
<li><dl class="first docutils">
<dt><code class="docutils literal"><span class="pre">discard-eof</span></code>: if the string ends with a newline, then do not generate</dt>
<dd>a corresponding token <code class="docutils literal"><span class="pre">''</span></code> after that newline.</dd>
</dl>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="nltk.tokenize.simple.LineTokenizer.span_tokenize">
<code class="descname">span_tokenize</code><span class="sig-paren">(</span><em>s</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tokenize/simple.html#LineTokenizer.span_tokenize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.simple.LineTokenizer.span_tokenize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nltk.tokenize.simple.LineTokenizer.tokenize">
<code class="descname">tokenize</code><span class="sig-paren">(</span><em>s</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tokenize/simple.html#LineTokenizer.tokenize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.simple.LineTokenizer.tokenize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.tokenize.simple.SpaceTokenizer">
<em class="property">class </em><code class="descclassname">nltk.tokenize.simple.</code><code class="descname">SpaceTokenizer</code><a class="reference internal" href="../_modules/nltk/tokenize/simple.html#SpaceTokenizer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.simple.SpaceTokenizer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.tokenize.api.StringTokenizer" title="nltk.tokenize.api.StringTokenizer"><code class="xref py py-class docutils literal"><span class="pre">nltk.tokenize.api.StringTokenizer</span></code></a></p>
<p>Tokenize a string using the space character as a delimiter,
which is the same as <code class="docutils literal"><span class="pre">s.split('</span> <span class="pre">')</span></code>.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">nltk.tokenize</span> <span class="kn">import</span> <span class="n">SpaceTokenizer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="s">&quot;Good muffins cost $3.88</span><span class="se">\n</span><span class="s">in New York.  Please buy me</span><span class="se">\n</span><span class="s">two of them.</span><span class="se">\n\n</span><span class="s">Thanks.&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">SpaceTokenizer</span><span class="p">()</span><span class="o">.</span><span class="n">tokenize</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">[&#39;Good&#39;, &#39;muffins&#39;, &#39;cost&#39;, &#39;$3.88\nin&#39;, &#39;New&#39;, &#39;York.&#39;, &#39;&#39;,</span>
<span class="go">&#39;Please&#39;, &#39;buy&#39;, &#39;me\ntwo&#39;, &#39;of&#39;, &#39;them.\n\nThanks.&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nltk.tokenize.simple.TabTokenizer">
<em class="property">class </em><code class="descclassname">nltk.tokenize.simple.</code><code class="descname">TabTokenizer</code><a class="reference internal" href="../_modules/nltk/tokenize/simple.html#TabTokenizer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.simple.TabTokenizer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.tokenize.api.StringTokenizer" title="nltk.tokenize.api.StringTokenizer"><code class="xref py py-class docutils literal"><span class="pre">nltk.tokenize.api.StringTokenizer</span></code></a></p>
<p>Tokenize a string use the tab character as a delimiter,
the same as <code class="docutils literal"><span class="pre">s.split('\t')</span></code>.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">nltk.tokenize</span> <span class="kn">import</span> <span class="n">TabTokenizer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">TabTokenizer</span><span class="p">()</span><span class="o">.</span><span class="n">tokenize</span><span class="p">(</span><span class="s">&#39;a</span><span class="se">\t</span><span class="s">b c</span><span class="se">\n\t</span><span class="s"> d&#39;</span><span class="p">)</span>
<span class="go">[&#39;a&#39;, &#39;b c\n&#39;, &#39; d&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="nltk.tokenize.simple.line_tokenize">
<code class="descclassname">nltk.tokenize.simple.</code><code class="descname">line_tokenize</code><span class="sig-paren">(</span><em>text</em>, <em>blanklines='discard'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tokenize/simple.html#line_tokenize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.simple.line_tokenize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-nltk.tokenize.stanford">
<span id="nltk-tokenize-stanford-module"></span><h2>nltk.tokenize.stanford module<a class="headerlink" href="#module-nltk.tokenize.stanford" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="nltk.tokenize.stanford.StanfordTokenizer">
<em class="property">class </em><code class="descclassname">nltk.tokenize.stanford.</code><code class="descname">StanfordTokenizer</code><span class="sig-paren">(</span><em>path_to_jar=None</em>, <em>encoding='utf8'</em>, <em>options=None</em>, <em>verbose=False</em>, <em>java_options='-mx1000m'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tokenize/stanford.html#StanfordTokenizer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.stanford.StanfordTokenizer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.tokenize.api.TokenizerI" title="nltk.tokenize.api.TokenizerI"><code class="xref py py-class docutils literal"><span class="pre">nltk.tokenize.api.TokenizerI</span></code></a></p>
<p>Interface to the Stanford Tokenizer</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">nltk.tokenize</span> <span class="kn">import</span> <span class="n">StanfordTokenizer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="s">&quot;Good muffins cost $3.88</span><span class="se">\n</span><span class="s">in New York.  Please buy me</span><span class="se">\n</span><span class="s">two of them.</span><span class="se">\n</span><span class="s">Thanks.&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">StanfordTokenizer</span><span class="p">()</span><span class="o">.</span><span class="n">tokenize</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">[&#39;Good&#39;, &#39;muffins&#39;, &#39;cost&#39;, &#39;$&#39;, &#39;3.88&#39;, &#39;in&#39;, &#39;New&#39;, &#39;York&#39;, &#39;.&#39;, &#39;Please&#39;, &#39;buy&#39;, &#39;me&#39;, &#39;two&#39;, &#39;of&#39;, &#39;them&#39;, &#39;.&#39;, &#39;Thanks&#39;, &#39;.&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="s">&quot;The colour of the wall is blue.&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">StanfordTokenizer</span><span class="p">(</span><span class="n">options</span><span class="o">=</span><span class="p">{</span><span class="s">&quot;americanize&quot;</span><span class="p">:</span> <span class="bp">True</span><span class="p">})</span><span class="o">.</span><span class="n">tokenize</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">[&#39;The&#39;, &#39;color&#39;, &#39;of&#39;, &#39;the&#39;, &#39;wall&#39;, &#39;is&#39;, &#39;blue&#39;, &#39;.&#39;]</span>
</pre></div>
</div>
<dl class="method">
<dt id="nltk.tokenize.stanford.StanfordTokenizer.tokenize">
<code class="descname">tokenize</code><span class="sig-paren">(</span><em>s</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tokenize/stanford.html#StanfordTokenizer.tokenize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.stanford.StanfordTokenizer.tokenize" title="Permalink to this definition">¶</a></dt>
<dd><p>Use stanford tokenizer&#8217;s PTBTokenizer to tokenize multiple sentences.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="nltk.tokenize.stanford.setup_module">
<code class="descclassname">nltk.tokenize.stanford.</code><code class="descname">setup_module</code><span class="sig-paren">(</span><em>module</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tokenize/stanford.html#setup_module"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.stanford.setup_module" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-nltk.tokenize.texttiling">
<span id="nltk-tokenize-texttiling-module"></span><h2>nltk.tokenize.texttiling module<a class="headerlink" href="#module-nltk.tokenize.texttiling" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="nltk.tokenize.texttiling.TextTilingTokenizer">
<em class="property">class </em><code class="descclassname">nltk.tokenize.texttiling.</code><code class="descname">TextTilingTokenizer</code><span class="sig-paren">(</span><em>w=20, k=10, similarity_method=0, stopwords=None, smoothing_method=[0], smoothing_width=2, smoothing_rounds=1, cutoff_policy=1, demo_mode=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tokenize/texttiling.html#TextTilingTokenizer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.texttiling.TextTilingTokenizer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.tokenize.api.TokenizerI" title="nltk.tokenize.api.TokenizerI"><code class="xref py py-class docutils literal"><span class="pre">nltk.tokenize.api.TokenizerI</span></code></a></p>
<p>Tokenize a document into topical sections using the TextTiling algorithm.
This algorithm detects subtopic shifts based on the analysis of lexical
co-occurrence patterns.</p>
<p>The process starts by tokenizing the text into pseudosentences of
a fixed size w. Then, depending on the method used, similarity
scores are assigned at sentence gaps. The algorithm proceeds by
detecting the peak differences between these scores and marking
them as boundaries. The boundaries are normalized to the closest
paragraph break and the segmented text is returned.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>w</strong> (<em>int</em>) &#8211; Pseudosentence size</li>
<li><strong>k</strong> (<em>int</em>) &#8211; Size (in sentences) of the block used in the block comparison method</li>
<li><strong>similarity_method</strong> (<em>constant</em>) &#8211; The method used for determining similarity scores:
<cite>BLOCK_COMPARISON</cite> (default) or <cite>VOCABULARY_INTRODUCTION</cite>.</li>
<li><strong>stopwords</strong> (<em>list(str)</em>) &#8211; A list of stopwords that are filtered out (defaults to NLTK&#8217;s stopwords corpus)</li>
<li><strong>smoothing_method</strong> (<em>constant</em>) &#8211; The method used for smoothing the score plot:
<cite>DEFAULT_SMOOTHING</cite> (default)</li>
<li><strong>smoothing_width</strong> (<em>int</em>) &#8211; The width of the window used by the smoothing method</li>
<li><strong>smoothing_rounds</strong> (<em>int</em>) &#8211; The number of smoothing passes</li>
<li><strong>cutoff_policy</strong> (<em>constant</em>) &#8211; The policy used to determine the number of boundaries:
<cite>HC</cite> (default) or <cite>LC</cite></li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">nltk.corpus</span> <span class="kn">import</span> <span class="n">brown</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tt</span> <span class="o">=</span> <span class="n">TextTilingTokenizer</span><span class="p">(</span><span class="n">demo_mode</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">text</span> <span class="o">=</span> <span class="n">brown</span><span class="o">.</span><span class="n">raw</span><span class="p">()[:</span><span class="mi">10000</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="p">,</span> <span class="n">ss</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">tt</span><span class="o">.</span><span class="n">tokenize</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">[0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0,</span>
<span class="go"> 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0,</span>
<span class="go"> 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0]</span>
</pre></div>
</div>
<dl class="method">
<dt id="nltk.tokenize.texttiling.TextTilingTokenizer.tokenize">
<code class="descname">tokenize</code><span class="sig-paren">(</span><em>text</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tokenize/texttiling.html#TextTilingTokenizer.tokenize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.texttiling.TextTilingTokenizer.tokenize" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a tokenized copy of <em>text</em>, where each &#8220;token&#8221; represents
a separate topic.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.tokenize.texttiling.TokenSequence">
<em class="property">class </em><code class="descclassname">nltk.tokenize.texttiling.</code><code class="descname">TokenSequence</code><span class="sig-paren">(</span><em>index</em>, <em>wrdindex_list</em>, <em>original_length=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tokenize/texttiling.html#TokenSequence"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.texttiling.TokenSequence" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>A token list with its original length and its index</p>
</dd></dl>

<dl class="class">
<dt id="nltk.tokenize.texttiling.TokenTableField">
<em class="property">class </em><code class="descclassname">nltk.tokenize.texttiling.</code><code class="descname">TokenTableField</code><span class="sig-paren">(</span><em>first_pos</em>, <em>ts_occurences</em>, <em>total_count=1</em>, <em>par_count=1</em>, <em>last_par=0</em>, <em>last_tok_seq=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tokenize/texttiling.html#TokenTableField"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.texttiling.TokenTableField" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>A field in the token table holding parameters for each token,
used later in the process</p>
</dd></dl>

<dl class="function">
<dt id="nltk.tokenize.texttiling.demo">
<code class="descclassname">nltk.tokenize.texttiling.</code><code class="descname">demo</code><span class="sig-paren">(</span><em>text=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tokenize/texttiling.html#demo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.texttiling.demo" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="nltk.tokenize.texttiling.smooth">
<code class="descclassname">nltk.tokenize.texttiling.</code><code class="descname">smooth</code><span class="sig-paren">(</span><em>x</em>, <em>window_len=11</em>, <em>window='flat'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tokenize/texttiling.html#smooth"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.texttiling.smooth" title="Permalink to this definition">¶</a></dt>
<dd><p>smooth the data using a window with requested size.</p>
<p>This method is based on the convolution of a scaled window with the signal.
The signal is prepared by introducing reflected copies of the signal
(with the window size) in both ends so that transient parts are minimized
in the beginning and end part of the output signal.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>x</strong> &#8211; the input signal</li>
<li><strong>window_len</strong> &#8211; the dimension of the smoothing window; should be an odd integer</li>
<li><strong>window</strong> &#8211; the type of window from &#8216;flat&#8217;, &#8216;hanning&#8217;, &#8216;hamming&#8217;, &#8216;bartlett&#8217;, &#8216;blackman&#8217;
flat window will produce a moving average smoothing.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the smoothed signal</p>
</td>
</tr>
</tbody>
</table>
<p>example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">t</span><span class="o">=</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mf">0.1</span><span class="p">)</span>
<span class="n">x</span><span class="o">=</span><span class="n">sin</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">+</span><span class="n">randn</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">))</span><span class="o">*</span><span class="mf">0.1</span>
<span class="n">y</span><span class="o">=</span><span class="n">smooth</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">See also:</th><td class="field-body">numpy.hanning, numpy.hamming, numpy.bartlett, numpy.blackman, numpy.convolve,
scipy.signal.lfilter</td>
</tr>
</tbody>
</table>
<p>TODO: the window parameter could be the window itself if an array instead of a string</p>
</dd></dl>

</div>
<div class="section" id="module-nltk.tokenize.treebank">
<span id="nltk-tokenize-treebank-module"></span><h2>nltk.tokenize.treebank module<a class="headerlink" href="#module-nltk.tokenize.treebank" title="Permalink to this headline">¶</a></h2>
<p>Penn Treebank Tokenizer</p>
<p>The Treebank tokenizer uses regular expressions to tokenize text as in Penn Treebank.
This implementation is a port of the tokenizer sed script written by Robert McIntyre
and available at <a class="reference external" href="http://www.cis.upenn.edu/~treebank/tokenizer.sed">http://www.cis.upenn.edu/~treebank/tokenizer.sed</a>.</p>
<dl class="class">
<dt id="nltk.tokenize.treebank.TreebankWordTokenizer">
<em class="property">class </em><code class="descclassname">nltk.tokenize.treebank.</code><code class="descname">TreebankWordTokenizer</code><a class="reference internal" href="../_modules/nltk/tokenize/treebank.html#TreebankWordTokenizer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.treebank.TreebankWordTokenizer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.tokenize.api.TokenizerI" title="nltk.tokenize.api.TokenizerI"><code class="xref py py-class docutils literal"><span class="pre">nltk.tokenize.api.TokenizerI</span></code></a></p>
<p>The Treebank tokenizer uses regular expressions to tokenize text as in Penn Treebank.
This is the method that is invoked by <code class="docutils literal"><span class="pre">word_tokenize()</span></code>.  It assumes that the
text has already been segmented into sentences, e.g. using <code class="docutils literal"><span class="pre">sent_tokenize()</span></code>.</p>
<p>This tokenizer performs the following steps:</p>
<ul>
<li><p class="first">split standard contractions, e.g. <code class="docutils literal"><span class="pre">don't</span></code> -&gt; <code class="docutils literal"><span class="pre">do</span> <span class="pre">n't</span></code> and <code class="docutils literal"><span class="pre">they'll</span></code> -&gt; <code class="docutils literal"><span class="pre">they</span> <span class="pre">'ll</span></code></p>
</li>
<li><p class="first">treat most punctuation characters as separate tokens</p>
</li>
<li><p class="first">split off commas and single quotes, when followed by whitespace</p>
</li>
<li><p class="first">separate periods that appear at the end of line</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">nltk.tokenize</span> <span class="kn">import</span> <span class="n">TreebankWordTokenizer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="s">&#39;&#39;&#39;Good muffins cost $3.88</span><span class="se">\n</span><span class="s">in New York.  Please buy me</span><span class="se">\n</span><span class="s">two of them.</span><span class="se">\n</span><span class="s">Thanks.&#39;&#39;&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">TreebankWordTokenizer</span><span class="p">()</span><span class="o">.</span><span class="n">tokenize</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">[&#39;Good&#39;, &#39;muffins&#39;, &#39;cost&#39;, &#39;$&#39;, &#39;3.88&#39;, &#39;in&#39;, &#39;New&#39;, &#39;York.&#39;, &#39;Please&#39;, &#39;buy&#39;, &#39;me&#39;, &#39;two&#39;, &#39;of&#39;, &#39;them.&#39;, &#39;Thanks&#39;, &#39;.&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="s">&quot;They&#39;ll save and invest more.&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">TreebankWordTokenizer</span><span class="p">()</span><span class="o">.</span><span class="n">tokenize</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">[&#39;They&#39;, &quot;&#39;ll&quot;, &#39;save&#39;, &#39;and&#39;, &#39;invest&#39;, &#39;more&#39;, &#39;.&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="s">&quot;hi, my name can&#39;t hello,&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">TreebankWordTokenizer</span><span class="p">()</span><span class="o">.</span><span class="n">tokenize</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">[&#39;hi&#39;, &#39;,&#39;, &#39;my&#39;, &#39;name&#39;, &#39;ca&#39;, &quot;n&#39;t&quot;, &#39;hello&#39;, &#39;,&#39;]</span>
</pre></div>
</div>
</li>
</ul>
<dl class="attribute">
<dt id="nltk.tokenize.treebank.TreebankWordTokenizer.CONTRACTIONS2">
<code class="descname">CONTRACTIONS2</code><em class="property"> = [re.compile('(?i)\\b(can)(not)\\b', re.IGNORECASE), re.compile(&quot;(?i)\\b(d)('ye)\\b&quot;, re.IGNORECASE), re.compile('(?i)\\b(gim)(me)\\b', re.IGNORECASE), re.compile('(?i)\\b(gon)(na)\\b', re.IGNORECASE), re.compile('(?i)\\b(got)(ta)\\b', re.IGNORECASE), re.compile('(?i)\\b(lem)(me)\\b', re.IGNORECASE), re.compile(&quot;(?i)\\b(mor)('n)\\b&quot;, re.IGNORECASE), re.compile('(?i)\\b(wan)(na) ', re.IGNORECASE)]</em><a class="headerlink" href="#nltk.tokenize.treebank.TreebankWordTokenizer.CONTRACTIONS2" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nltk.tokenize.treebank.TreebankWordTokenizer.CONTRACTIONS3">
<code class="descname">CONTRACTIONS3</code><em class="property"> = [re.compile(&quot;(?i) ('t)(is)\\b&quot;, re.IGNORECASE), re.compile(&quot;(?i) ('t)(was)\\b&quot;, re.IGNORECASE)]</em><a class="headerlink" href="#nltk.tokenize.treebank.TreebankWordTokenizer.CONTRACTIONS3" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nltk.tokenize.treebank.TreebankWordTokenizer.CONTRACTIONS4">
<code class="descname">CONTRACTIONS4</code><em class="property"> = [re.compile('(?i)\\b(whad)(dd)(ya)\\b', re.IGNORECASE), re.compile('(?i)\\b(wha)(t)(cha)\\b', re.IGNORECASE)]</em><a class="headerlink" href="#nltk.tokenize.treebank.TreebankWordTokenizer.CONTRACTIONS4" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nltk.tokenize.treebank.TreebankWordTokenizer.tokenize">
<code class="descname">tokenize</code><span class="sig-paren">(</span><em>text</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tokenize/treebank.html#TreebankWordTokenizer.tokenize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.treebank.TreebankWordTokenizer.tokenize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="module-nltk.tokenize.util">
<span id="nltk-tokenize-util-module"></span><h2>nltk.tokenize.util module<a class="headerlink" href="#module-nltk.tokenize.util" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="nltk.tokenize.util.regexp_span_tokenize">
<code class="descclassname">nltk.tokenize.util.</code><code class="descname">regexp_span_tokenize</code><span class="sig-paren">(</span><em>s</em>, <em>regexp</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tokenize/util.html#regexp_span_tokenize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.util.regexp_span_tokenize" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the offsets of the tokens in <em>s</em>, as a sequence of <code class="docutils literal"><span class="pre">(start,</span> <span class="pre">end)</span></code>
tuples, by splitting the string at each successive match of <em>regexp</em>.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">nltk.tokenize</span> <span class="kn">import</span> <span class="n">WhitespaceTokenizer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="s">&#39;&#39;&#39;Good muffins cost $3.88</span><span class="se">\n</span><span class="s">in New York.  Please buy me</span>
<span class="gp">... </span><span class="s">two of them.</span><span class="se">\n\n</span><span class="s">Thanks.&#39;&#39;&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">WhitespaceTokenizer</span><span class="p">()</span><span class="o">.</span><span class="n">span_tokenize</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
<span class="go">[(0, 4), (5, 12), (13, 17), (18, 23), (24, 26), (27, 30), (31, 36),</span>
<span class="go">(38, 44), (45, 48), (49, 51), (52, 55), (56, 58), (59, 64), (66, 73)]</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>s</strong> (<a class="reference internal" href="nltk.sem.html#nltk.sem.logic.AnyType.str" title="nltk.sem.logic.AnyType.str"><em>str</em></a>) &#8211; the string to be tokenized</li>
<li><strong>regexp</strong> (<a class="reference internal" href="nltk.sem.html#nltk.sem.logic.AnyType.str" title="nltk.sem.logic.AnyType.str"><em>str</em></a>) &#8211; regular expression that matches token separators</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">iter(tuple(int, int))</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="nltk.tokenize.util.spans_to_relative">
<code class="descclassname">nltk.tokenize.util.</code><code class="descname">spans_to_relative</code><span class="sig-paren">(</span><em>spans</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tokenize/util.html#spans_to_relative"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.util.spans_to_relative" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a sequence of relative spans, given a sequence of spans.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">nltk.tokenize</span> <span class="kn">import</span> <span class="n">WhitespaceTokenizer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">nltk.tokenize.util</span> <span class="kn">import</span> <span class="n">spans_to_relative</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="s">&#39;&#39;&#39;Good muffins cost $3.88</span><span class="se">\n</span><span class="s">in New York.  Please buy me</span>
<span class="gp">... </span><span class="s">two of them.</span><span class="se">\n\n</span><span class="s">Thanks.&#39;&#39;&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">spans_to_relative</span><span class="p">(</span><span class="n">WhitespaceTokenizer</span><span class="p">()</span><span class="o">.</span><span class="n">span_tokenize</span><span class="p">(</span><span class="n">s</span><span class="p">)))</span>
<span class="go">[(0, 4), (1, 7), (1, 4), (1, 5), (1, 2), (1, 3), (1, 5), (2, 6),</span>
<span class="go">(1, 3), (1, 2), (1, 3), (1, 2), (1, 5), (2, 7)]</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>spans</strong> (<em>iter(tuple(int, int))</em>) &#8211; a sequence of (start, end) offsets of the tokens</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">iter(tuple(int, int))</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="nltk.tokenize.util.string_span_tokenize">
<code class="descclassname">nltk.tokenize.util.</code><code class="descname">string_span_tokenize</code><span class="sig-paren">(</span><em>s</em>, <em>sep</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tokenize/util.html#string_span_tokenize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.util.string_span_tokenize" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the offsets of the tokens in <em>s</em>, as a sequence of <code class="docutils literal"><span class="pre">(start,</span> <span class="pre">end)</span></code>
tuples, by splitting the string at each occurrence of <em>sep</em>.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">nltk.tokenize.util</span> <span class="kn">import</span> <span class="n">string_span_tokenize</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="s">&#39;&#39;&#39;Good muffins cost $3.88</span><span class="se">\n</span><span class="s">in New York.  Please buy me</span>
<span class="gp">... </span><span class="s">two of them.</span><span class="se">\n\n</span><span class="s">Thanks.&#39;&#39;&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">string_span_tokenize</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot; &quot;</span><span class="p">))</span>
<span class="go">[(0, 4), (5, 12), (13, 17), (18, 26), (27, 30), (31, 36), (37, 37),</span>
<span class="go">(38, 44), (45, 48), (49, 55), (56, 58), (59, 73)]</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>s</strong> (<a class="reference internal" href="nltk.sem.html#nltk.sem.logic.AnyType.str" title="nltk.sem.logic.AnyType.str"><em>str</em></a>) &#8211; the string to be tokenized</li>
<li><strong>sep</strong> (<a class="reference internal" href="nltk.sem.html#nltk.sem.logic.AnyType.str" title="nltk.sem.logic.AnyType.str"><em>str</em></a>) &#8211; the token separator</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">iter(tuple(int, int))</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-nltk.tokenize">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-nltk.tokenize" title="Permalink to this headline">¶</a></h2>
<p>NLTK Tokenizer Package</p>
<p>Tokenizers divide strings into lists of substrings.  For example,
tokenizers can be used to find the words and punctuation in a string:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">nltk.tokenize</span> <span class="kn">import</span> <span class="n">word_tokenize</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="s">&#39;&#39;&#39;Good muffins cost $3.88</span><span class="se">\n</span><span class="s">in New York.  Please buy me</span>
<span class="gp">... </span><span class="s">two of them.</span><span class="se">\n\n</span><span class="s">Thanks.&#39;&#39;&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">word_tokenize</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">[&#39;Good&#39;, &#39;muffins&#39;, &#39;cost&#39;, &#39;$&#39;, &#39;3.88&#39;, &#39;in&#39;, &#39;New&#39;, &#39;York&#39;, &#39;.&#39;,</span>
<span class="go">&#39;Please&#39;, &#39;buy&#39;, &#39;me&#39;, &#39;two&#39;, &#39;of&#39;, &#39;them&#39;, &#39;.&#39;, &#39;Thanks&#39;, &#39;.&#39;]</span>
</pre></div>
</div>
<p>This particular tokenizer requires the Punkt sentence tokenization
models to be installed. NLTK also provides a simpler,
regular-expression based tokenizer, which splits text on whitespace
and punctuation:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">nltk.tokenize</span> <span class="kn">import</span> <span class="n">wordpunct_tokenize</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">wordpunct_tokenize</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">[&#39;Good&#39;, &#39;muffins&#39;, &#39;cost&#39;, &#39;$&#39;, &#39;3&#39;, &#39;.&#39;, &#39;88&#39;, &#39;in&#39;, &#39;New&#39;, &#39;York&#39;, &#39;.&#39;,</span>
<span class="go">&#39;Please&#39;, &#39;buy&#39;, &#39;me&#39;, &#39;two&#39;, &#39;of&#39;, &#39;them&#39;, &#39;.&#39;, &#39;Thanks&#39;, &#39;.&#39;]</span>
</pre></div>
</div>
<p>We can also operate at the level of sentences, using the sentence
tokenizer directly as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">nltk.tokenize</span> <span class="kn">import</span> <span class="n">sent_tokenize</span><span class="p">,</span> <span class="n">word_tokenize</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sent_tokenize</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">[&#39;Good muffins cost $3.88\nin New York.&#39;, &#39;Please buy me\ntwo of them.&#39;, &#39;Thanks.&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">word_tokenize</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">sent_tokenize</span><span class="p">(</span><span class="n">s</span><span class="p">)]</span>
<span class="go">[[&#39;Good&#39;, &#39;muffins&#39;, &#39;cost&#39;, &#39;$&#39;, &#39;3.88&#39;, &#39;in&#39;, &#39;New&#39;, &#39;York&#39;, &#39;.&#39;],</span>
<span class="go">[&#39;Please&#39;, &#39;buy&#39;, &#39;me&#39;, &#39;two&#39;, &#39;of&#39;, &#39;them&#39;, &#39;.&#39;], [&#39;Thanks&#39;, &#39;.&#39;]]</span>
</pre></div>
</div>
<p>Caution: when tokenizing a Unicode string, make sure you are not
using an encoded version of the string (it may be necessary to
decode it first, e.g. with <code class="docutils literal"><span class="pre">s.decode(&quot;utf8&quot;)</span></code>.</p>
<p>NLTK tokenizers can produce token-spans, represented as tuples of integers
having the same semantics as string slices, to support efficient comparison
of tokenizers.  (These methods are implemented as generators.)</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">nltk.tokenize</span> <span class="kn">import</span> <span class="n">WhitespaceTokenizer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">WhitespaceTokenizer</span><span class="p">()</span><span class="o">.</span><span class="n">span_tokenize</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
<span class="go">[(0, 4), (5, 12), (13, 17), (18, 23), (24, 26), (27, 30), (31, 36), (38, 44),</span>
<span class="go">(45, 48), (49, 51), (52, 55), (56, 58), (59, 64), (66, 73)]</span>
</pre></div>
</div>
<p>There are numerous ways to tokenize text.  If you need more control over
tokenization, see the other methods provided in this package.</p>
<p>For further information, please see Chapter 3 of the NLTK book.</p>
<dl class="function">
<dt id="nltk.tokenize.sent_tokenize">
<code class="descclassname">nltk.tokenize.</code><code class="descname">sent_tokenize</code><span class="sig-paren">(</span><em>text</em>, <em>language='english'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tokenize.html#sent_tokenize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.sent_tokenize" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a sentence-tokenized copy of <em>text</em>,
using NLTK&#8217;s recommended sentence tokenizer
(currently <a class="reference internal" href="#nltk.tokenize.punkt.PunktSentenceTokenizer" title="nltk.tokenize.punkt.PunktSentenceTokenizer"><code class="xref py py-class docutils literal"><span class="pre">PunktSentenceTokenizer</span></code></a>
for the specified language).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>text</strong> &#8211; text to split into sentences</li>
<li><strong>language</strong> &#8211; the model name in the Punkt corpus</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="nltk.tokenize.word_tokenize">
<code class="descclassname">nltk.tokenize.</code><code class="descname">word_tokenize</code><span class="sig-paren">(</span><em>text</em>, <em>language='english'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tokenize.html#word_tokenize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tokenize.word_tokenize" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a tokenized copy of <em>text</em>,
using NLTK&#8217;s recommended word tokenizer
(currently <a class="reference internal" href="#nltk.tokenize.treebank.TreebankWordTokenizer" title="nltk.tokenize.treebank.TreebankWordTokenizer"><code class="xref py py-class docutils literal"><span class="pre">TreebankWordTokenizer</span></code></a>
along with <a class="reference internal" href="#nltk.tokenize.punkt.PunktSentenceTokenizer" title="nltk.tokenize.punkt.PunktSentenceTokenizer"><code class="xref py py-class docutils literal"><span class="pre">PunktSentenceTokenizer</span></code></a>
for the specified language).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>text</strong> &#8211; text to split into sentences</li>
<li><strong>language</strong> &#8211; the model name in the Punkt corpus</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
        </div>
        <div class="sidebar">
          <h3>Table Of Contents</h3>
          <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../news.html">NLTK News</a></li>
<li class="toctree-l1"><a class="reference internal" href="../install.html">Installing NLTK</a></li>
<li class="toctree-l1"><a class="reference internal" href="../data.html">Installing NLTK Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contribute.html">Contribute to NLTK</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/nltk/nltk/wiki/FAQ">FAQ</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/nltk/nltk/wiki">Wiki</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="nltk.html">API</a></li>
<li class="toctree-l1"><a class="reference external" href="http://www.nltk.org/howto">HOWTO</a></li>
</ul>

          <div role="search">
            <h3 style="margin-top: 1.5em;">Search</h3>
            <form class="search" action="../search.html" method="get">
                <input type="text" name="q" />
                <input type="submit" value="Go" />
                <input type="hidden" name="check_keywords" value="yes" />
                <input type="hidden" name="area" value="default" />
            </form>
            <p class="searchtip" style="font-size: 90%">
                Enter search terms or a module, class or function name.
            </p>
          </div>
        </div>
        <div class="clearer"></div>
      </div>
    </div>

    <div class="footer-wrapper">
      <div class="footer">
        <div class="left">
          <div role="navigation" aria-label="related navigaton">
            <a href="nltk.test.unit.align.html" title="nltk.test.unit.align package"
              >previous</a> |
            <a href="../py-modindex.html" title="Python Module Index"
              >modules</a> |
            <a href="../genindex.html" title="General Index"
              >index</a>
          </div>
          <div role="note" aria-label="source link">
              <br/>
              <a href="../_sources/api/nltk.tokenize.txt"
                rel="nofollow">Show Source</a>
          </div>
        </div>

        <div class="right">
          
    <div class="footer" role="contentinfo">
        &copy; Copyright 2015, NLTK Project.
      Last updated on Sep 05, 2015.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.1.
    </div>
        </div>
        <div class="clearer"></div>
      </div>
    </div>

  </body>
</html>